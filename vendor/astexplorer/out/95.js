(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{"./node_modules/meriyah/dist/meriyah.umd.js":function(module,exports,__webpack_require__){eval("(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n  const errorMessages = {\r\n      [0]: 'Unexpected token',\r\n      [28]: \"Unexpected token: '%0'\",\r\n      [1]: 'Octal escape sequences are not allowed in strict mode',\r\n      [2]: 'Octal escape sequences are not allowed in template strings',\r\n      [3]: 'Unexpected token `#`',\r\n      [4]: 'Illegal Unicode escape sequence',\r\n      [5]: 'Invalid code point %0',\r\n      [6]: 'Invalid hexadecimal escape sequence',\r\n      [8]: 'Octal literals are not allowed in strict mode',\r\n      [7]: 'Decimal integer literals with a leading zero are forbidden in strict mode',\r\n      [9]: 'Expected number in radix %0',\r\n      [145]: 'Invalid left-hand side assignment to a destructible right-hand side',\r\n      [10]: 'Non-number found after exponent indicator',\r\n      [11]: 'Invalid BigIntLiteral',\r\n      [12]: 'No identifiers allowed directly after numeric literal',\r\n      [13]: 'Escapes \\\\8 or \\\\9 are not syntactically valid escapes',\r\n      [14]: 'Unterminated string literal',\r\n      [15]: 'Unterminated template literal',\r\n      [16]: 'Multiline comment was not closed properly',\r\n      [17]: 'The identifier contained dynamic unicode escape that was not closed',\r\n      [18]: \"Illegal character '%0'\",\r\n      [19]: 'Missing hexadecimal digits',\r\n      [20]: 'Invalid implicit octal',\r\n      [21]: 'Invalid line break in string literal',\r\n      [22]: 'Only unicode escapes are legal in identifier names',\r\n      [23]: \"Expected '%0'\",\r\n      [24]: 'Invalid left-hand side in assignment',\r\n      [25]: 'Invalid left-hand side in async arrow',\r\n      [26]: 'Calls to super must be in the \"constructor\" method of a class expression or class declaration that has a superclass',\r\n      [27]: 'Member access on super must be in a method',\r\n      [29]: 'Await expression not allowed in formal parameter',\r\n      [30]: 'Yield expression not allowed in formal parameter',\r\n      [92]: \"Unexpected token: 'escaped keyword'\",\r\n      [31]: 'Unary expressions as the left operand of an exponentation expression must be disambiguated with parentheses',\r\n      [119]: 'Async functions can only be declared at the top level or inside a block',\r\n      [32]: 'Unterminated regular expression',\r\n      [33]: 'Unexpected regular expression flag',\r\n      [34]: \"Duplicate regular expression flag '%0'\",\r\n      [35]: '%0 functions must have exactly %1 argument%2',\r\n      [36]: 'Setter function argument must not be a rest parameter',\r\n      [37]: '%0 declaration must have a name in this context',\r\n      [38]: 'Function name may not contain any reserved words or be eval or arguments in strict mode',\r\n      [39]: 'The rest operator is missing an argument',\r\n      [40]: 'A getter cannot be a generator',\r\n      [41]: 'A computed property name must be followed by a colon or paren',\r\n      [130]: 'Object literal keys that are strings or numbers must be a method or have a colon',\r\n      [43]: 'Found `* async x(){}` but this should be `async * x(){}`',\r\n      [42]: 'Getters and setters can not be generators',\r\n      [44]: \"'%0' can not be generator method\",\r\n      [45]: \"No line break is allowed after '=>'\",\r\n      [46]: 'The left-hand side of the arrow can only be destructed through assignment',\r\n      [47]: 'The binding declaration is not destructible',\r\n      [48]: 'Async arrow can not be followed by new expression',\r\n      [49]: \"Classes may not have a static property named 'prototype'\",\r\n      [50]: 'Class constructor may not be a %0',\r\n      [51]: 'Duplicate constructor method in class',\r\n      [52]: 'Invalid increment/decrement operand',\r\n      [53]: 'Invalid use of `new` keyword on an increment/decrement expression',\r\n      [54]: '`=>` is an invalid assignment target',\r\n      [55]: 'Rest element may not have a trailing comma',\r\n      [56]: 'Missing initializer in %0 declaration',\r\n      [57]: \"'for-%0' loop head declarations can not have an initializer\",\r\n      [58]: 'Invalid left-hand side in for-%0 loop: Must have a single binding',\r\n      [59]: 'Invalid shorthand property initializer',\r\n      [60]: 'Property name __proto__ appears more than once in object literal',\r\n      [61]: 'Let is disallowed as a lexically bound name',\r\n      [62]: \"Invalid use of '%0' inside new expression\",\r\n      [63]: \"Illegal 'use strict' directive in function with non-simple parameter list\",\r\n      [64]: 'Identifier \"let\" disallowed as left-hand side expression in strict mode',\r\n      [65]: 'Illegal continue statement',\r\n      [66]: 'Illegal break statement',\r\n      [67]: 'Cannot have `let[...]` as a var name in strict mode',\r\n      [68]: 'Invalid destructuring assignment target',\r\n      [69]: 'Rest parameter may not have a default initializer',\r\n      [70]: 'The rest argument must the be last parameter',\r\n      [71]: 'Invalid rest argument',\r\n      [73]: 'In strict mode code, functions can only be declared at top level or inside a block',\r\n      [74]: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement',\r\n      [75]: 'Without web compability enabled functions can not be declared at top level, inside a block, or as the body of an if statement',\r\n      [76]: \"Class declaration can't appear in single-statement context\",\r\n      [77]: 'Invalid left-hand side in for-%0',\r\n      [78]: 'Invalid assignment in for-%0',\r\n      [79]: 'for await (... of ...) is only valid in async functions and async generators',\r\n      [80]: 'The first token after the template expression should be a continuation of the template',\r\n      [82]: '`let` declaration not allowed here and `let` cannot be a regular var name in strict mode',\r\n      [81]: '`let \\n [` is a restricted production at the start of a statement',\r\n      [83]: 'Catch clause requires exactly one parameter, not more (and no trailing comma)',\r\n      [84]: 'Catch clause parameter does not support default values',\r\n      [85]: 'Missing catch or finally after try',\r\n      [86]: 'More than one default clause in switch statement',\r\n      [87]: 'Illegal newline after throw',\r\n      [88]: 'Strict mode code may not include a with statement',\r\n      [89]: 'Illegal return statement',\r\n      [90]: 'The left hand side of the for-header binding declaration is not destructible',\r\n      [91]: 'new.target only allowed within functions',\r\n      [92]: \"'Unexpected token: 'escaped keyword'\",\r\n      [93]: \"'#' not followed by identifier\",\r\n      [99]: 'Invalid keyword',\r\n      [98]: \"Can not use 'let' as a class name\",\r\n      [97]: \"'A lexical declaration can't define a 'let' binding\",\r\n      [96]: 'Can not use `let` as variable name in strict mode',\r\n      [94]: \"'%0' may not be used as an identifier in this context\",\r\n      [95]: 'Await is only valid in async functions',\r\n      [100]: 'The %0 keyword can only be used with the module goal',\r\n      [101]: 'Unicode codepoint must not be greater than 0x10FFFF',\r\n      [102]: '%0 source must be string',\r\n      [103]: 'Only a identifier can be used to indicate alias',\r\n      [104]: \"Only '*' or '{...}' can be imported after default\",\r\n      [105]: 'Trailing decorator may be followed by method',\r\n      [106]: \"Decorators can't be used with a constructor\",\r\n      [107]: \"'%0' may not be used as an identifier in this context\",\r\n      [108]: 'HTML comments are only allowed with web compability (Annex B)',\r\n      [109]: \"The identifier 'let' must not be in expression position in strict mode\",\r\n      [110]: 'Cannot assign to `eval` and `arguments` in strict mode',\r\n      [111]: \"The left-hand side of a for-of loop may not start with 'let'\",\r\n      [112]: 'Block body arrows can not be immediately invoked without a group',\r\n      [113]: 'Block body arrows can not be immediately accessed without a group',\r\n      [114]: 'Unexpected strict mode reserved word',\r\n      [115]: 'Unexpected eval or arguments in strict mode',\r\n      [116]: 'Decorators must not be followed by a semicolon',\r\n      [117]: 'Calling delete on expression not allowed in strict mode',\r\n      [118]: 'Pattern can not have a tail',\r\n      [120]: 'Can not have a `yield` expression on the left side of a ternary',\r\n      [121]: 'An arrow function can not have a postfix update operator',\r\n      [122]: 'Invalid object literal key character after generator star',\r\n      [123]: 'Private fields can not be deleted',\r\n      [125]: 'Classes may not have a field called constructor',\r\n      [124]: 'Classes may not have a private element named constructor',\r\n      [126]: 'A class field initializer may not contain arguments',\r\n      [127]: 'Generators can only be declared at the top level or inside a block',\r\n      [128]: 'Async methods are a restricted production and cannot have a newline following it',\r\n      [129]: 'Unexpected character after object literal property name',\r\n      [131]: 'Invalid key token',\r\n      [132]: \"Label '%0' has already been declared\",\r\n      [133]: 'continue statement must be nested within an iteration statement',\r\n      [134]: \"Undefined label '%0'\",\r\n      [135]: 'Trailing comma is disallowed inside import(...) arguments',\r\n      [136]: 'import() requires exactly one argument',\r\n      [137]: 'Cannot use new with import(...)',\r\n      [138]: '... is not allowed in import()',\r\n      [139]: \"Expected '=>'\",\r\n      [140]: \"Duplicate binding '%0'\",\r\n      [141]: \"Cannot export a duplicate name '%0'\",\r\n      [144]: 'Duplicate %0 for-binding',\r\n      [142]: \"Exported binding '%0' needs to refer to a top-level declared variable\",\r\n      [143]: 'Unexpected private field',\r\n      [147]: 'Numeric separators are not allowed at the end of numeric literals',\r\n      [146]: 'Only one underscore is allowed as numeric separator',\r\n      [148]: 'JSX value should be either an expression or a quoted JSX text',\r\n      [149]: 'Expected corresponding JSX closing tag for %0',\r\n      [150]: 'Adjacent JSX elements must be wrapped in an enclosing tag',\r\n      [151]: \"JSX attributes must only be assigned a non-empty 'expression'\",\r\n      [152]: \"'%0' has already been declared\",\r\n      [153]: \"'%0' shadowed a catch clause binding\",\r\n      [154]: 'Dot property must be an identifier',\r\n      [155]: 'Encountered invalid input after spread/rest argument',\r\n      [156]: 'Catch without try',\r\n      [157]: 'Finally without try',\r\n      [158]: 'Expected corresponding closing tag for JSX fragment',\r\n      [159]: 'Coalescing and logical operators used together in the same expression must be disambiguated with parentheses',\r\n      [160]: 'Invalid tagged template on optional chain',\r\n      [161]: 'Invalid optional chain from super property',\r\n      [162]: 'Invalid optional chain from new expression',\r\n      [163]: 'Cannot use \"import.meta\" outside a module'\r\n  };\r\n  class ParseError extends SyntaxError {\r\n      constructor(startindex, line, column, type, ...params) {\r\n          const message = '[' + line + ':' + column + ']: ' + errorMessages[type].replace(/%(\\d+)/g, (_, i) => params[i]);\r\n          super(`${message}`);\r\n          this.index = startindex;\r\n          this.line = line;\r\n          this.column = column;\r\n          this.description = message;\r\n          this.loc = {\r\n              line,\r\n              column\r\n          };\r\n      }\r\n  }\r\n  function report(parser, type, ...params) {\r\n      throw new ParseError(parser.index, parser.line, parser.column, type, ...params);\r\n  }\r\n  function reportScopeError(scope) {\r\n      throw new ParseError(scope.index, scope.line, scope.column, scope.type, scope.params);\r\n  }\r\n  function reportMessageAt(index, line, column, type, ...params) {\r\n      throw new ParseError(index, line, column, type, ...params);\r\n  }\r\n  function reportScannerError(index, line, column, type) {\r\n      throw new ParseError(index, line, column, type);\r\n  }\n\n  const unicodeLookup = ((compressed, lookup) => {\r\n      const result = new Uint32Array(104448);\r\n      let index = 0;\r\n      let subIndex = 0;\r\n      while (index < 3540) {\r\n          const inst = compressed[index++];\r\n          if (inst < 0) {\r\n              subIndex -= inst;\r\n          }\r\n          else {\r\n              let code = compressed[index++];\r\n              if (inst & 2)\r\n                  code = lookup[code];\r\n              if (inst & 1) {\r\n                  result.fill(code, subIndex, subIndex += compressed[index++]);\r\n              }\r\n              else {\r\n                  result[subIndex++] = code;\r\n              }\r\n          }\r\n      }\r\n      return result;\r\n  })([-1, 2, 24, 2, 25, 2, 5, -1, 0, 77595648, 3, 44, 2, 3, 0, 14, 2, 57, 2, 58, 3, 0, 3, 0, 3168796671, 0, 4294956992, 2, 1, 2, 0, 2, 59, 3, 0, 4, 0, 4294966523, 3, 0, 4, 2, 16, 2, 60, 2, 0, 0, 4294836735, 0, 3221225471, 0, 4294901942, 2, 61, 0, 134152192, 3, 0, 2, 0, 4294951935, 3, 0, 2, 0, 2683305983, 0, 2684354047, 2, 17, 2, 0, 0, 4294961151, 3, 0, 2, 2, 19, 2, 0, 0, 608174079, 2, 0, 2, 131, 2, 6, 2, 56, -1, 2, 37, 0, 4294443263, 2, 1, 3, 0, 3, 0, 4294901711, 2, 39, 0, 4089839103, 0, 2961209759, 0, 1342439375, 0, 4294543342, 0, 3547201023, 0, 1577204103, 0, 4194240, 0, 4294688750, 2, 2, 0, 80831, 0, 4261478351, 0, 4294549486, 2, 2, 0, 2967484831, 0, 196559, 0, 3594373100, 0, 3288319768, 0, 8469959, 2, 194, 2, 3, 0, 3825204735, 0, 123747807, 0, 65487, 0, 4294828015, 0, 4092591615, 0, 1080049119, 0, 458703, 2, 3, 2, 0, 0, 2163244511, 0, 4227923919, 0, 4236247022, 2, 66, 0, 4284449919, 0, 851904, 2, 4, 2, 11, 0, 67076095, -1, 2, 67, 0, 1073741743, 0, 4093591391, -1, 0, 50331649, 0, 3265266687, 2, 32, 0, 4294844415, 0, 4278190047, 2, 18, 2, 129, -1, 3, 0, 2, 2, 21, 2, 0, 2, 9, 2, 0, 2, 14, 2, 15, 3, 0, 10, 2, 69, 2, 0, 2, 70, 2, 71, 2, 72, 2, 0, 2, 73, 2, 0, 2, 10, 0, 261632, 2, 23, 3, 0, 2, 2, 12, 2, 4, 3, 0, 18, 2, 74, 2, 5, 3, 0, 2, 2, 75, 0, 2088959, 2, 27, 2, 8, 0, 909311, 3, 0, 2, 0, 814743551, 2, 41, 0, 67057664, 3, 0, 2, 2, 40, 2, 0, 2, 28, 2, 0, 2, 29, 2, 7, 0, 268374015, 2, 26, 2, 49, 2, 0, 2, 76, 0, 134153215, -1, 2, 6, 2, 0, 2, 7, 0, 2684354559, 0, 67044351, 0, 3221160064, 0, 1, -1, 3, 0, 2, 2, 42, 0, 1046528, 3, 0, 3, 2, 8, 2, 0, 2, 51, 0, 4294960127, 2, 9, 2, 38, 2, 10, 0, 4294377472, 2, 11, 3, 0, 7, 0, 4227858431, 3, 0, 8, 2, 12, 2, 0, 2, 78, 2, 9, 2, 0, 2, 79, 2, 80, 2, 81, -1, 2, 124, 0, 1048577, 2, 82, 2, 13, -1, 2, 13, 0, 131042, 2, 83, 2, 84, 2, 85, 2, 0, 2, 33, -83, 2, 0, 2, 53, 2, 7, 3, 0, 4, 0, 1046559, 2, 0, 2, 14, 2, 0, 0, 2147516671, 2, 20, 3, 86, 2, 2, 0, -16, 2, 87, 0, 524222462, 2, 4, 2, 0, 0, 4269801471, 2, 4, 2, 0, 2, 15, 2, 77, 2, 16, 3, 0, 2, 2, 47, 2, 0, -1, 2, 17, -16, 3, 0, 206, -2, 3, 0, 655, 2, 18, 3, 0, 36, 2, 68, -1, 2, 17, 2, 9, 3, 0, 8, 2, 89, 2, 121, 2, 0, 0, 3220242431, 3, 0, 3, 2, 19, 2, 90, 2, 91, 3, 0, 2, 2, 92, 2, 0, 2, 93, 2, 94, 2, 0, 0, 4351, 2, 0, 2, 8, 3, 0, 2, 0, 67043391, 0, 3909091327, 2, 0, 2, 22, 2, 8, 2, 18, 3, 0, 2, 0, 67076097, 2, 7, 2, 0, 2, 20, 0, 67059711, 0, 4236247039, 3, 0, 2, 0, 939524103, 0, 8191999, 2, 97, 2, 98, 2, 15, 2, 21, 3, 0, 3, 0, 67057663, 3, 0, 349, 2, 99, 2, 100, 2, 6, -264, 3, 0, 11, 2, 22, 3, 0, 2, 2, 31, -1, 0, 3774349439, 2, 101, 2, 102, 3, 0, 2, 2, 19, 2, 103, 3, 0, 10, 2, 9, 2, 17, 2, 0, 2, 45, 2, 0, 2, 30, 2, 104, 2, 23, 0, 1638399, 2, 172, 2, 105, 3, 0, 3, 2, 18, 2, 24, 2, 25, 2, 5, 2, 26, 2, 0, 2, 7, 2, 106, -1, 2, 107, 2, 108, 2, 109, -1, 3, 0, 3, 2, 11, -2, 2, 0, 2, 27, -3, 2, 150, -4, 2, 18, 2, 0, 2, 35, 0, 1, 2, 0, 2, 62, 2, 28, 2, 11, 2, 9, 2, 0, 2, 110, -1, 3, 0, 4, 2, 9, 2, 21, 2, 111, 2, 6, 2, 0, 2, 112, 2, 0, 2, 48, -4, 3, 0, 9, 2, 20, 2, 29, 2, 30, -4, 2, 113, 2, 114, 2, 29, 2, 20, 2, 7, -2, 2, 115, 2, 29, 2, 31, -2, 2, 0, 2, 116, -2, 0, 4277137519, 0, 2269118463, -1, 3, 18, 2, -1, 2, 32, 2, 36, 2, 0, 3, 29, 2, 2, 34, 2, 19, -3, 3, 0, 2, 2, 33, -1, 2, 0, 2, 34, 2, 0, 2, 34, 2, 0, 2, 46, -10, 2, 0, 0, 203775, -2, 2, 18, 2, 43, 2, 35, -2, 2, 17, 2, 117, 2, 20, 3, 0, 2, 2, 36, 0, 2147549120, 2, 0, 2, 11, 2, 17, 2, 135, 2, 0, 2, 37, 2, 52, 0, 5242879, 3, 0, 2, 0, 402644511, -1, 2, 120, 0, 1090519039, -2, 2, 122, 2, 38, 2, 0, 0, 67045375, 2, 39, 0, 4226678271, 0, 3766565279, 0, 2039759, -4, 3, 0, 2, 0, 3288270847, 0, 3, 3, 0, 2, 0, 67043519, -5, 2, 0, 0, 4282384383, 0, 1056964609, -1, 3, 0, 2, 0, 67043345, -1, 2, 0, 2, 40, 2, 41, -1, 2, 10, 2, 42, -6, 2, 0, 2, 11, -3, 3, 0, 2, 0, 2147484671, 2, 125, 0, 4190109695, 2, 50, -2, 2, 126, 0, 4244635647, 0, 27, 2, 0, 2, 7, 2, 43, 2, 0, 2, 63, -1, 2, 0, 2, 40, -8, 2, 54, 2, 44, 0, 67043329, 2, 127, 2, 45, 0, 8388351, -2, 2, 128, 0, 3028287487, 2, 46, 2, 130, 0, 33259519, 2, 41, -9, 2, 20, -5, 2, 64, -2, 3, 0, 28, 2, 31, -3, 3, 0, 3, 2, 47, 3, 0, 6, 2, 48, -85, 3, 0, 33, 2, 47, -126, 3, 0, 18, 2, 36, -269, 3, 0, 17, 2, 40, 2, 7, 2, 41, -2, 2, 17, 2, 49, 2, 0, 2, 20, 2, 50, 2, 132, 2, 23, -21, 3, 0, 2, -4, 3, 0, 2, 0, 4294936575, 2, 0, 0, 4294934783, -2, 0, 196635, 3, 0, 191, 2, 51, 3, 0, 38, 2, 29, -1, 2, 33, -279, 3, 0, 8, 2, 7, -1, 2, 133, 2, 52, 3, 0, 11, 2, 6, -72, 3, 0, 3, 2, 134, 0, 1677656575, -166, 0, 4161266656, 0, 4071, 0, 15360, -4, 0, 28, -13, 3, 0, 2, 2, 37, 2, 0, 2, 136, 2, 137, 2, 55, 2, 0, 2, 138, 2, 139, 2, 140, 3, 0, 10, 2, 141, 2, 142, 2, 15, 3, 37, 2, 3, 53, 2, 3, 54, 2, 0, 4294954999, 2, 0, -16, 2, 0, 2, 88, 2, 0, 0, 2105343, 0, 4160749584, 0, 65534, -42, 0, 4194303871, 0, 2011, -6, 2, 0, 0, 1073684479, 0, 17407, -11, 2, 0, 2, 31, -40, 3, 0, 6, 0, 8323103, -1, 3, 0, 2, 2, 42, -37, 2, 55, 2, 144, 2, 145, 2, 146, 2, 147, 2, 148, -105, 2, 24, -32, 3, 0, 1334, 2, 9, -1, 3, 0, 129, 2, 27, 3, 0, 6, 2, 9, 3, 0, 180, 2, 149, 3, 0, 233, 0, 1, -96, 3, 0, 16, 2, 9, -47, 3, 0, 154, 2, 56, -22381, 3, 0, 7, 2, 23, -6130, 3, 5, 2, -1, 0, 69207040, 3, 44, 2, 3, 0, 14, 2, 57, 2, 58, -3, 0, 3168731136, 0, 4294956864, 2, 1, 2, 0, 2, 59, 3, 0, 4, 0, 4294966275, 3, 0, 4, 2, 16, 2, 60, 2, 0, 2, 33, -1, 2, 17, 2, 61, -1, 2, 0, 2, 56, 0, 4294885376, 3, 0, 2, 0, 3145727, 0, 2617294944, 0, 4294770688, 2, 23, 2, 62, 3, 0, 2, 0, 131135, 2, 95, 0, 70256639, 0, 71303167, 0, 272, 2, 40, 2, 56, -1, 2, 37, 2, 30, -1, 2, 96, 2, 63, 0, 4278255616, 0, 4294836227, 0, 4294549473, 0, 600178175, 0, 2952806400, 0, 268632067, 0, 4294543328, 0, 57540095, 0, 1577058304, 0, 1835008, 0, 4294688736, 2, 65, 2, 64, 0, 33554435, 2, 123, 2, 65, 2, 151, 0, 131075, 0, 3594373096, 0, 67094296, 2, 64, -1, 0, 4294828000, 0, 603979263, 2, 160, 0, 3, 0, 4294828001, 0, 602930687, 2, 183, 0, 393219, 0, 4294828016, 0, 671088639, 0, 2154840064, 0, 4227858435, 0, 4236247008, 2, 66, 2, 36, -1, 2, 4, 0, 917503, 2, 36, -1, 2, 67, 0, 537788335, 0, 4026531935, -1, 0, 1, -1, 2, 32, 2, 68, 0, 7936, -3, 2, 0, 0, 2147485695, 0, 1010761728, 0, 4292984930, 0, 16387, 2, 0, 2, 14, 2, 15, 3, 0, 10, 2, 69, 2, 0, 2, 70, 2, 71, 2, 72, 2, 0, 2, 73, 2, 0, 2, 11, -1, 2, 23, 3, 0, 2, 2, 12, 2, 4, 3, 0, 18, 2, 74, 2, 5, 3, 0, 2, 2, 75, 0, 253951, 3, 19, 2, 0, 122879, 2, 0, 2, 8, 0, 276824064, -2, 3, 0, 2, 2, 40, 2, 0, 0, 4294903295, 2, 0, 2, 29, 2, 7, -1, 2, 17, 2, 49, 2, 0, 2, 76, 2, 41, -1, 2, 20, 2, 0, 2, 27, -2, 0, 128, -2, 2, 77, 2, 8, 0, 4064, -1, 2, 119, 0, 4227907585, 2, 0, 2, 118, 2, 0, 2, 48, 2, 173, 2, 9, 2, 38, 2, 10, -1, 0, 74440192, 3, 0, 6, -2, 3, 0, 8, 2, 12, 2, 0, 2, 78, 2, 9, 2, 0, 2, 79, 2, 80, 2, 81, -3, 2, 82, 2, 13, -3, 2, 83, 2, 84, 2, 85, 2, 0, 2, 33, -83, 2, 0, 2, 53, 2, 7, 3, 0, 4, 0, 817183, 2, 0, 2, 14, 2, 0, 0, 33023, 2, 20, 3, 86, 2, -17, 2, 87, 0, 524157950, 2, 4, 2, 0, 2, 88, 2, 4, 2, 0, 2, 15, 2, 77, 2, 16, 3, 0, 2, 2, 47, 2, 0, -1, 2, 17, -16, 3, 0, 206, -2, 3, 0, 655, 2, 18, 3, 0, 36, 2, 68, -1, 2, 17, 2, 9, 3, 0, 8, 2, 89, 0, 3072, 2, 0, 0, 2147516415, 2, 9, 3, 0, 2, 2, 23, 2, 90, 2, 91, 3, 0, 2, 2, 92, 2, 0, 2, 93, 2, 94, 0, 4294965179, 0, 7, 2, 0, 2, 8, 2, 91, 2, 8, -1, 0, 1761345536, 2, 95, 0, 4294901823, 2, 36, 2, 18, 2, 96, 2, 34, 2, 166, 0, 2080440287, 2, 0, 2, 33, 2, 143, 0, 3296722943, 2, 0, 0, 1046675455, 0, 939524101, 0, 1837055, 2, 97, 2, 98, 2, 15, 2, 21, 3, 0, 3, 0, 7, 3, 0, 349, 2, 99, 2, 100, 2, 6, -264, 3, 0, 11, 2, 22, 3, 0, 2, 2, 31, -1, 0, 2700607615, 2, 101, 2, 102, 3, 0, 2, 2, 19, 2, 103, 3, 0, 10, 2, 9, 2, 17, 2, 0, 2, 45, 2, 0, 2, 30, 2, 104, -3, 2, 105, 3, 0, 3, 2, 18, -1, 3, 5, 2, 2, 26, 2, 0, 2, 7, 2, 106, -1, 2, 107, 2, 108, 2, 109, -1, 3, 0, 3, 2, 11, -2, 2, 0, 2, 27, -8, 2, 18, 2, 0, 2, 35, -1, 2, 0, 2, 62, 2, 28, 2, 29, 2, 9, 2, 0, 2, 110, -1, 3, 0, 4, 2, 9, 2, 17, 2, 111, 2, 6, 2, 0, 2, 112, 2, 0, 2, 48, -4, 3, 0, 9, 2, 20, 2, 29, 2, 30, -4, 2, 113, 2, 114, 2, 29, 2, 20, 2, 7, -2, 2, 115, 2, 29, 2, 31, -2, 2, 0, 2, 116, -2, 0, 4277075969, 2, 29, -1, 3, 18, 2, -1, 2, 32, 2, 117, 2, 0, 3, 29, 2, 2, 34, 2, 19, -3, 3, 0, 2, 2, 33, -1, 2, 0, 2, 34, 2, 0, 2, 34, 2, 0, 2, 48, -10, 2, 0, 0, 197631, -2, 2, 18, 2, 43, 2, 118, -2, 2, 17, 2, 117, 2, 20, 2, 119, 2, 51, -2, 2, 119, 2, 23, 2, 17, 2, 33, 2, 119, 2, 36, 0, 4294901904, 0, 4718591, 2, 119, 2, 34, 0, 335544350, -1, 2, 120, 2, 121, -2, 2, 122, 2, 38, 2, 7, -1, 2, 123, 2, 65, 0, 3758161920, 0, 3, -4, 2, 0, 2, 27, 0, 2147485568, 0, 3, 2, 0, 2, 23, 0, 176, -5, 2, 0, 2, 47, 2, 186, -1, 2, 0, 2, 23, 2, 197, -1, 2, 0, 0, 16779263, -2, 2, 11, -7, 2, 0, 2, 121, -3, 3, 0, 2, 2, 124, 2, 125, 0, 2147549183, 0, 2, -2, 2, 126, 2, 35, 0, 10, 0, 4294965249, 0, 67633151, 0, 4026597376, 2, 0, 0, 536871935, -1, 2, 0, 2, 40, -8, 2, 54, 2, 47, 0, 1, 2, 127, 2, 23, -3, 2, 128, 2, 35, 2, 129, 2, 130, 0, 16778239, -10, 2, 34, -5, 2, 64, -2, 3, 0, 28, 2, 31, -3, 3, 0, 3, 2, 47, 3, 0, 6, 2, 48, -85, 3, 0, 33, 2, 47, -126, 3, 0, 18, 2, 36, -269, 3, 0, 17, 2, 40, 2, 7, -3, 2, 17, 2, 131, 2, 0, 2, 23, 2, 48, 2, 132, 2, 23, -21, 3, 0, 2, -4, 3, 0, 2, 0, 67583, -1, 2, 103, -2, 0, 11, 3, 0, 191, 2, 51, 3, 0, 38, 2, 29, -1, 2, 33, -279, 3, 0, 8, 2, 7, -1, 2, 133, 2, 52, 3, 0, 11, 2, 6, -72, 3, 0, 3, 2, 134, 2, 135, -187, 3, 0, 2, 2, 37, 2, 0, 2, 136, 2, 137, 2, 55, 2, 0, 2, 138, 2, 139, 2, 140, 3, 0, 10, 2, 141, 2, 142, 2, 15, 3, 37, 2, 3, 53, 2, 3, 54, 2, 2, 143, -73, 2, 0, 0, 1065361407, 0, 16384, -11, 2, 0, 2, 121, -40, 3, 0, 6, 2, 117, -1, 3, 0, 2, 0, 2063, -37, 2, 55, 2, 144, 2, 145, 2, 146, 2, 147, 2, 148, -138, 3, 0, 1334, 2, 9, -1, 3, 0, 129, 2, 27, 3, 0, 6, 2, 9, 3, 0, 180, 2, 149, 3, 0, 233, 0, 1, -96, 3, 0, 16, 2, 9, -47, 3, 0, 154, 2, 56, -28517, 2, 0, 0, 1, -1, 2, 124, 2, 0, 0, 8193, -21, 2, 193, 0, 10255, 0, 4, -11, 2, 64, 2, 171, -1, 0, 71680, -1, 2, 161, 0, 4292900864, 0, 805306431, -5, 2, 150, -1, 2, 157, -1, 0, 6144, -2, 2, 127, -1, 2, 154, -1, 0, 2147532800, 2, 151, 2, 165, 2, 0, 2, 164, 0, 524032, 0, 4, -4, 2, 190, 0, 205128192, 0, 1333757536, 0, 2147483696, 0, 423953, 0, 747766272, 0, 2717763192, 0, 4286578751, 0, 278545, 2, 152, 0, 4294886464, 0, 33292336, 0, 417809, 2, 152, 0, 1327482464, 0, 4278190128, 0, 700594195, 0, 1006647527, 0, 4286497336, 0, 4160749631, 2, 153, 0, 469762560, 0, 4171219488, 0, 8323120, 2, 153, 0, 202375680, 0, 3214918176, 0, 4294508592, 2, 153, -1, 0, 983584, 0, 48, 0, 58720273, 0, 3489923072, 0, 10517376, 0, 4293066815, 0, 1, 0, 2013265920, 2, 177, 2, 0, 0, 2089, 0, 3221225552, 0, 201375904, 2, 0, -2, 0, 256, 0, 122880, 0, 16777216, 2, 150, 0, 4160757760, 2, 0, -6, 2, 167, -11, 0, 3263218176, -1, 0, 49664, 0, 2160197632, 0, 8388802, -1, 0, 12713984, -1, 2, 154, 2, 159, 2, 178, -2, 2, 162, -20, 0, 3758096385, -2, 2, 155, 0, 4292878336, 2, 90, 2, 169, 0, 4294057984, -2, 2, 163, 2, 156, 2, 175, -2, 2, 155, -1, 2, 182, -1, 2, 170, 2, 124, 0, 4026593280, 0, 14, 0, 4292919296, -1, 2, 158, 0, 939588608, -1, 0, 805306368, -1, 2, 124, 0, 1610612736, 2, 156, 2, 157, 2, 4, 2, 0, -2, 2, 158, 2, 159, -3, 0, 267386880, -1, 2, 160, 0, 7168, -1, 0, 65024, 2, 154, 2, 161, 2, 179, -7, 2, 168, -8, 2, 162, -1, 0, 1426112704, 2, 163, -1, 2, 164, 0, 271581216, 0, 2149777408, 2, 23, 2, 161, 2, 124, 0, 851967, 2, 180, -1, 2, 23, 2, 181, -4, 2, 158, -20, 2, 195, 2, 165, -56, 0, 3145728, 2, 185, -4, 2, 166, 2, 124, -4, 0, 32505856, -1, 2, 167, -1, 0, 2147385088, 2, 90, 1, 2155905152, 2, -3, 2, 103, 2, 0, 2, 168, -2, 2, 169, -6, 2, 170, 0, 4026597375, 0, 1, -1, 0, 1, -1, 2, 171, -3, 2, 117, 2, 64, -2, 2, 166, -2, 2, 176, 2, 124, -878, 2, 159, -36, 2, 172, -1, 2, 201, -10, 2, 188, -5, 2, 174, -6, 0, 4294965251, 2, 27, -1, 2, 173, -1, 2, 174, -2, 0, 4227874752, -3, 0, 2146435072, 2, 159, -2, 0, 1006649344, 2, 124, -1, 2, 90, 0, 201375744, -3, 0, 134217720, 2, 90, 0, 4286677377, 0, 32896, -1, 2, 158, -3, 2, 175, -349, 2, 176, 0, 1920, 2, 177, 3, 0, 264, -11, 2, 157, -2, 2, 178, 2, 0, 0, 520617856, 0, 2692743168, 0, 36, -3, 0, 524284, -11, 2, 23, -1, 2, 187, -1, 2, 184, 0, 3221291007, 2, 178, -1, 2, 202, 0, 2158720, -3, 2, 159, 0, 1, -4, 2, 124, 0, 3808625411, 0, 3489628288, 2, 200, 0, 1207959680, 0, 3221274624, 2, 0, -3, 2, 179, 0, 120, 0, 7340032, -2, 2, 180, 2, 4, 2, 23, 2, 163, 3, 0, 4, 2, 159, -1, 2, 181, 2, 177, -1, 0, 8176, 2, 182, 2, 179, 2, 183, -1, 0, 4290773232, 2, 0, -4, 2, 163, 2, 189, 0, 15728640, 2, 177, -1, 2, 161, -1, 0, 4294934512, 3, 0, 4, -9, 2, 90, 2, 170, 2, 184, 3, 0, 4, 0, 704, 0, 1849688064, 2, 185, -1, 2, 124, 0, 4294901887, 2, 0, 0, 130547712, 0, 1879048192, 2, 199, 3, 0, 2, -1, 2, 186, 2, 187, -1, 0, 17829776, 0, 2025848832, 0, 4261477888, -2, 2, 0, -1, 0, 4286580608, -1, 0, 29360128, 2, 192, 0, 16252928, 0, 3791388672, 2, 38, 3, 0, 2, -2, 2, 196, 2, 0, -1, 2, 103, -1, 0, 66584576, -1, 2, 191, 3, 0, 9, 2, 124, -1, 0, 4294755328, 3, 0, 2, -1, 2, 161, 2, 178, 3, 0, 2, 2, 23, 2, 188, 2, 90, -2, 0, 245760, 0, 2147418112, -1, 2, 150, 2, 203, 0, 4227923456, -1, 2, 164, 2, 161, 2, 90, -3, 0, 4292870145, 0, 262144, 2, 124, 3, 0, 2, 0, 1073758848, 2, 189, -1, 0, 4227921920, 2, 190, 0, 68289024, 0, 528402016, 0, 4292927536, 3, 0, 4, -2, 0, 268435456, 2, 91, -2, 2, 191, 3, 0, 5, -1, 2, 192, 2, 163, 2, 0, -2, 0, 4227923936, 2, 62, -1, 2, 155, 2, 95, 2, 0, 2, 154, 2, 158, 3, 0, 6, -1, 2, 177, 3, 0, 3, -2, 0, 2146959360, 0, 9440640, 0, 104857600, 0, 4227923840, 3, 0, 2, 0, 768, 2, 193, 2, 77, -2, 2, 161, -2, 2, 119, -1, 2, 155, 3, 0, 8, 0, 512, 0, 8388608, 2, 194, 2, 172, 2, 187, 0, 4286578944, 3, 0, 2, 0, 1152, 0, 1266679808, 2, 191, 0, 576, 0, 4261707776, 2, 95, 3, 0, 9, 2, 155, 3, 0, 5, 2, 16, -1, 0, 2147221504, -28, 2, 178, 3, 0, 3, -3, 0, 4292902912, -6, 2, 96, 3, 0, 85, -33, 0, 4294934528, 3, 0, 126, -18, 2, 195, 3, 0, 269, -17, 2, 155, 2, 124, 2, 198, 3, 0, 2, 2, 23, 0, 4290822144, -2, 0, 67174336, 0, 520093700, 2, 17, 3, 0, 21, -2, 2, 179, 3, 0, 3, -2, 0, 30720, -1, 0, 32512, 3, 0, 2, 0, 4294770656, -191, 2, 174, -38, 2, 170, 2, 0, 2, 196, 3, 0, 279, -8, 2, 124, 2, 0, 0, 4294508543, 0, 65295, -11, 2, 177, 3, 0, 72, -3, 0, 3758159872, 0, 201391616, 3, 0, 155, -7, 2, 170, -1, 0, 384, -1, 0, 133693440, -3, 2, 196, -2, 2, 26, 3, 0, 4, 2, 169, -2, 2, 90, 2, 155, 3, 0, 4, -2, 2, 164, -1, 2, 150, 0, 335552923, 2, 197, -1, 0, 538974272, 0, 2214592512, 0, 132000, -10, 0, 192, -8, 0, 12288, -21, 0, 134213632, 0, 4294901761, 3, 0, 42, 0, 100663424, 0, 4294965284, 3, 0, 6, -1, 0, 3221282816, 2, 198, 3, 0, 11, -1, 2, 199, 3, 0, 40, -6, 0, 4286578784, 2, 0, -2, 0, 1006694400, 3, 0, 24, 2, 35, -1, 2, 94, 3, 0, 2, 0, 1, 2, 163, 3, 0, 6, 2, 197, 0, 4110942569, 0, 1432950139, 0, 2701658217, 0, 4026532864, 0, 4026532881, 2, 0, 2, 45, 3, 0, 8, -1, 2, 158, -2, 2, 169, 0, 98304, 0, 65537, 2, 170, -5, 0, 4294950912, 2, 0, 2, 118, 0, 65528, 2, 177, 0, 4294770176, 2, 26, 3, 0, 4, -30, 2, 174, 0, 3758153728, -3, 2, 169, -2, 2, 155, 2, 188, 2, 158, -1, 2, 191, -1, 2, 161, 0, 4294754304, 3, 0, 2, -3, 0, 33554432, -2, 2, 200, -3, 2, 169, 0, 4175478784, 2, 201, 0, 4286643712, 0, 4286644216, 2, 0, -4, 2, 202, -1, 2, 165, 0, 4227923967, 3, 0, 32, -1334, 2, 163, 2, 0, -129, 2, 94, -6, 2, 163, -180, 2, 203, -233, 2, 4, 3, 0, 96, -16, 2, 163, 3, 0, 47, -154, 2, 165, 3, 0, 22381, -7, 2, 17, 3, 0, 6128], [4294967295, 4294967291, 4092460543, 4294828031, 4294967294, 134217726, 268435455, 2147483647, 1048575, 1073741823, 3892314111, 134217727, 1061158911, 536805376, 4294910143, 4160749567, 4294901759, 4294901760, 536870911, 262143, 8388607, 4294902783, 4294918143, 65535, 67043328, 2281701374, 4294967232, 2097151, 4294903807, 4194303, 255, 67108863, 4294967039, 511, 524287, 131071, 127, 4292870143, 4294902271, 4294549487, 33554431, 1023, 67047423, 4294901888, 4286578687, 4294770687, 67043583, 32767, 15, 2047999, 67043343, 16777215, 4294902000, 4294934527, 4294966783, 4294967279, 2047, 262083, 20511, 4290772991, 41943039, 493567, 4294959104, 603979775, 65536, 602799615, 805044223, 4294965206, 8191, 1031749119, 4294917631, 2134769663, 4286578493, 4282253311, 4294942719, 33540095, 4294905855, 4294967264, 2868854591, 1608515583, 265232348, 534519807, 2147614720, 1060109444, 4093640016, 17376, 2139062143, 224, 4169138175, 4294909951, 4286578688, 4294967292, 4294965759, 2044, 4292870144, 4294966272, 4294967280, 8289918, 4294934399, 4294901775, 4294965375, 1602223615, 4294967259, 4294443008, 268369920, 4292804608, 486341884, 4294963199, 3087007615, 1073692671, 4128527, 4279238655, 4294902015, 4294966591, 2445279231, 3670015, 3238002687, 31, 63, 4294967288, 4294705151, 4095, 3221208447, 4294549472, 2147483648, 4285526655, 4294966527, 4294705152, 4294966143, 64, 4294966719, 16383, 3774873592, 458752, 536807423, 67043839, 3758096383, 3959414372, 3755993023, 2080374783, 4294835295, 4294967103, 4160749565, 4087, 184024726, 2862017156, 1593309078, 268434431, 268434414, 4294901763, 536870912, 2952790016, 202506752, 139264, 402653184, 4261412864, 4227922944, 49152, 61440, 3758096384, 117440512, 65280, 3233808384, 3221225472, 2097152, 4294965248, 32768, 57152, 67108864, 4293918720, 4290772992, 25165824, 57344, 4227915776, 4278190080, 4227907584, 65520, 4026531840, 4227858432, 4160749568, 3758129152, 4294836224, 63488, 1073741824, 4294967040, 4194304, 251658240, 196608, 4294963200, 64512, 417808, 4227923712, 12582912, 50331648, 65472, 4294967168, 4294966784, 16, 4294917120, 2080374784, 4096, 65408, 524288, 65532]);\n\n  const TokenLookup = [\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      125,\r\n      133,\r\n      125,\r\n      125,\r\n      127,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      125,\r\n      16842797,\r\n      134283267,\r\n      128,\r\n      208897,\r\n      8457012,\r\n      8455748,\r\n      134283267,\r\n      67174411,\r\n      16,\r\n      8457011,\r\n      25233967,\r\n      1073741842,\r\n      25233968,\r\n      67108877,\r\n      8457013,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      21,\r\n      1074790417,\r\n      8456255,\r\n      1077936157,\r\n      8456256,\r\n      22,\r\n      130,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      69271571,\r\n      134,\r\n      20,\r\n      8455494,\r\n      208897,\r\n      129,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      208897,\r\n      208897,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      4096,\r\n      2162700,\r\n      8455237,\r\n      1074790415,\r\n      16842798,\r\n      126\r\n  ];\r\n  function nextToken(parser, context) {\r\n      parser.flags = (parser.flags | 1) ^ 1;\r\n      parser.startPos = parser.index;\r\n      parser.startColumn = parser.column;\r\n      parser.startLine = parser.line;\r\n      parser.token = scanSingleToken(parser, context, 0);\r\n      if (parser.onToken && parser.token !== 1048576)\r\n          parser.onToken(convertTokenType(parser.token), parser.startPos, parser.index);\r\n  }\r\n  function scanSingleToken(parser, context, state) {\r\n      const isStartOfLine = parser.index === 0;\r\n      const source = parser.source;\r\n      while (parser.index < parser.end) {\r\n          parser.tokenPos = parser.index;\r\n          parser.colPos = parser.column;\r\n          parser.linePos = parser.line;\r\n          let char = parser.currentChar;\r\n          if (char <= 0x7e) {\r\n              const token = TokenLookup[char];\r\n              switch (token) {\r\n                  case 67174411:\r\n                  case 16:\r\n                  case 2162700:\r\n                  case 1074790415:\r\n                  case 69271571:\r\n                  case 20:\r\n                  case 21:\r\n                  case 1074790417:\r\n                  case 1073741842:\r\n                  case 16842798:\r\n                  case 130:\r\n                  case 126:\r\n                      advanceChar(parser);\r\n                      return token;\r\n                  case 8456255:\r\n                      let ch = advanceChar(parser);\r\n                      if (parser.index < parser.end) {\r\n                          if (ch === 60) {\r\n                              if (parser.index < parser.end && advanceChar(parser) === 61) {\r\n                                  advanceChar(parser);\r\n                                  return 4194334;\r\n                              }\r\n                              return 8456513;\r\n                          }\r\n                          else if (ch === 61) {\r\n                              advanceChar(parser);\r\n                              return 8455997;\r\n                          }\r\n                          if (ch === 33) {\r\n                              const index = parser.index + 1;\r\n                              if (index + 1 < parser.end &&\r\n                                  source.charCodeAt(index) === 45 &&\r\n                                  source.charCodeAt(index + 1) == 45) {\r\n                                  parser.column += 3;\r\n                                  parser.currentChar = source.charCodeAt((parser.index += 3));\r\n                                  state = skipSingleHTMLComment(parser, source, state, context, 2);\r\n                                  continue;\r\n                              }\r\n                              return 8456255;\r\n                          }\r\n                          if (ch === 47) {\r\n                              if ((context & 16) < 1)\r\n                                  return 8456255;\r\n                              const index = parser.index + 1;\r\n                              if (index < parser.end) {\r\n                                  ch = source.charCodeAt(index);\r\n                                  if (ch === 42 || ch === 47)\r\n                                      break;\r\n                              }\r\n                              advanceChar(parser);\r\n                              return 25;\r\n                          }\r\n                      }\r\n                      return 8456255;\r\n                  case 1077936157: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 1077936157;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 61) {\r\n                          if (advanceChar(parser) === 61) {\r\n                              advanceChar(parser);\r\n                              return 8455993;\r\n                          }\r\n                          return 8455995;\r\n                      }\r\n                      if (ch === 62) {\r\n                          advanceChar(parser);\r\n                          return 10;\r\n                      }\r\n                      return 1077936157;\r\n                  }\r\n                  case 16842797:\r\n                      if (advanceChar(parser) !== 61) {\r\n                          return 16842797;\r\n                      }\r\n                      if (advanceChar(parser) !== 61) {\r\n                          return 8455996;\r\n                      }\r\n                      advanceChar(parser);\r\n                      return 8455994;\r\n                  case 8457012:\r\n                      if (advanceChar(parser) !== 61)\r\n                          return 8457012;\r\n                      advanceChar(parser);\r\n                      return 4194342;\r\n                  case 8457011: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 8457011;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 4194340;\r\n                      }\r\n                      if (ch !== 42)\r\n                          return 8457011;\r\n                      if (advanceChar(parser) !== 61)\r\n                          return 8457270;\r\n                      advanceChar(parser);\r\n                      return 4194337;\r\n                  }\r\n                  case 8455494:\r\n                      if (advanceChar(parser) !== 61)\r\n                          return 8455494;\r\n                      advanceChar(parser);\r\n                      return 4194343;\r\n                  case 25233967: {\r\n                      advanceChar(parser);\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 43) {\r\n                          advanceChar(parser);\r\n                          return 33619995;\r\n                      }\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 4194338;\r\n                      }\r\n                      return 25233967;\r\n                  }\r\n                  case 25233968: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 25233968;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 45) {\r\n                          advanceChar(parser);\r\n                          if ((state & 1 || isStartOfLine) && parser.currentChar === 62) {\r\n                              if ((context & 256) === 0)\r\n                                  report(parser, 108);\r\n                              advanceChar(parser);\r\n                              state = skipSingleHTMLComment(parser, source, state, context, 3);\r\n                              continue;\r\n                          }\r\n                          return 33619996;\r\n                      }\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 4194339;\r\n                      }\r\n                      return 25233968;\r\n                  }\r\n                  case 8457013: {\r\n                      advanceChar(parser);\r\n                      if (parser.index < parser.end) {\r\n                          const ch = parser.currentChar;\r\n                          if (ch === 47) {\r\n                              advanceChar(parser);\r\n                              state = skipSingleLineComment(parser, source, state, 0);\r\n                              continue;\r\n                          }\r\n                          if (ch === 42) {\r\n                              advanceChar(parser);\r\n                              state = skipMultiLineComment(parser, source, state);\r\n                              continue;\r\n                          }\r\n                          if (context & 32768) {\r\n                              return scanRegularExpression(parser, context);\r\n                          }\r\n                          if (ch === 61) {\r\n                              advanceChar(parser);\r\n                              return 4259877;\r\n                          }\r\n                      }\r\n                      return 8457013;\r\n                  }\r\n                  case 8455237: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 8455237;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 124) {\r\n                          advanceChar(parser);\r\n                          return 8979000;\r\n                      }\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 4194344;\r\n                      }\r\n                      return 8455237;\r\n                  }\r\n                  case 8456256: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 8456256;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 8455998;\r\n                      }\r\n                      if (ch !== 62)\r\n                          return 8456256;\r\n                      advanceChar(parser);\r\n                      if (parser.index < parser.end) {\r\n                          const ch = parser.currentChar;\r\n                          if (ch === 62) {\r\n                              if (advanceChar(parser) === 61) {\r\n                                  advanceChar(parser);\r\n                                  return 4194336;\r\n                              }\r\n                              return 8456515;\r\n                          }\r\n                          if (ch === 61) {\r\n                              advanceChar(parser);\r\n                              return 4194335;\r\n                          }\r\n                      }\r\n                      return 8456514;\r\n                  }\r\n                  case 8455748: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 8455748;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 38) {\r\n                          advanceChar(parser);\r\n                          return 8979255;\r\n                      }\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 4194345;\r\n                      }\r\n                      return 8455748;\r\n                  }\r\n                  case 67108877:\r\n                      const next = advanceChar(parser);\r\n                      if (next >= 48 && next <= 57)\r\n                          return scanNumber(parser, context, 64 | 16);\r\n                      if (next === 46) {\r\n                          const index = parser.index + 1;\r\n                          if (index < parser.end && source.charCodeAt(index) === 46) {\r\n                              parser.column += 2;\r\n                              parser.currentChar = source.charCodeAt((parser.index += 2));\r\n                              return 14;\r\n                          }\r\n                      }\r\n                      return 67108877;\r\n                  case 22: {\r\n                      let ch = advanceChar(parser);\r\n                      if ((context & 1) < 1)\r\n                          return 22;\r\n                      if (ch === 63) {\r\n                          advanceChar(parser);\r\n                          return 276889979;\r\n                      }\r\n                      if (ch === 46) {\r\n                          const index = parser.index + 1;\r\n                          if (index < parser.end) {\r\n                              ch = source.charCodeAt(index);\r\n                              if (!(ch >= 48 && ch <= 57)) {\r\n                                  advanceChar(parser);\r\n                                  return 67108988;\r\n                              }\r\n                          }\r\n                      }\r\n                      return 22;\r\n                  }\r\n                  case 4096:\r\n                      return scanIdentifier(parser, context, 1);\r\n                  case 208897:\r\n                      return scanIdentifier(parser, context, 0);\r\n                  case 134283266:\r\n                      return scanNumber(parser, context, 16 | 128);\r\n                  case 134283267:\r\n                      return scanString(parser, context, char);\r\n                  case 129:\r\n                      return scanTemplate(parser, context);\r\n                  case 134:\r\n                      return scanUnicodeIdentifier(parser, context);\r\n                  case 128:\r\n                      return scanPrivateName(parser);\r\n                  case 125:\r\n                      advanceChar(parser);\r\n                      break;\r\n                  case 127:\r\n                      state |= 1 | 4;\r\n                      scanNewLine(parser);\r\n                      break;\r\n                  case 133:\r\n                      consumeLineFeed(parser, state);\r\n                      state = (state & ~4) | 1;\r\n                      break;\r\n              }\r\n          }\r\n          else {\r\n              if ((char ^ 8232) <= 1) {\r\n                  state = (state & ~4) | 1;\r\n                  scanNewLine(parser);\r\n                  continue;\r\n              }\r\n              if ((char & 0xfc00) === 0xd800 || ((unicodeLookup[(char >>> 5) + 34816] >>> char) & 31 & 1) !== 0) {\r\n                  if ((char & 0xfc00) === 0xdc00) {\r\n                      char = ((char & 0x3ff) << 10) | (char & 0x3ff) | 0x10000;\r\n                      if (((unicodeLookup[(char >>> 5) + 0] >>> char) & 31 & 1) === 0) {\r\n                          report(parser, 18, fromCodePoint(char));\r\n                      }\r\n                      parser.index++;\r\n                      parser.currentChar = char;\r\n                  }\r\n                  parser.column++;\r\n                  parser.tokenValue = '';\r\n                  return scanIdentifierSlowCase(parser, context, 0, 0);\r\n              }\r\n              if (isExoticECMAScriptWhitespace(char)) {\r\n                  advanceChar(parser);\r\n                  continue;\r\n              }\r\n              report(parser, 18, fromCodePoint(char));\r\n          }\r\n      }\r\n      return 1048576;\r\n  }\n\n  const CommentTypes = ['SingleLine', 'MultiLine', 'HTMLOpen', 'HTMLClose', 'HashbangComment'];\r\n  function skipHashBang(parser) {\r\n      const source = parser.source;\r\n      if (parser.currentChar === 35 && source.charCodeAt(parser.index + 1) === 33) {\r\n          skipSingleLineComment(parser, source, 0, 4);\r\n      }\r\n  }\r\n  function skipSingleHTMLComment(parser, source, state, context, type) {\r\n      if (context & 2048)\r\n          report(parser, 0);\r\n      return skipSingleLineComment(parser, source, state, type);\r\n  }\r\n  function skipSingleLineComment(parser, source, state, type) {\r\n      const { index } = parser;\r\n      while (parser.index < parser.end) {\r\n          if (CharTypes[parser.currentChar] & 8) {\r\n              const isCR = parser.currentChar === 13;\r\n              scanNewLine(parser);\r\n              if (isCR && parser.index < parser.end && parser.currentChar === 10)\r\n                  parser.currentChar = source.charCodeAt(++parser.index);\r\n              break;\r\n          }\r\n          else if ((parser.currentChar ^ 8232) <= 1) {\r\n              scanNewLine(parser);\r\n              break;\r\n          }\r\n          advanceChar(parser);\r\n      }\r\n      if (parser.onComment)\r\n          parser.onComment(CommentTypes[type & 0xff], source.slice(index, parser.index), index, parser.index);\r\n      return state | 1;\r\n  }\r\n  function skipMultiLineComment(parser, source, state) {\r\n      const { index } = parser;\r\n      while (parser.index < parser.end) {\r\n          if (parser.currentChar < 0x2b) {\r\n              let skippedOneAsterisk = false;\r\n              while (parser.currentChar === 42) {\r\n                  if (!skippedOneAsterisk) {\r\n                      state &= ~4;\r\n                      skippedOneAsterisk = true;\r\n                  }\r\n                  if (advanceChar(parser) === 47) {\r\n                      advanceChar(parser);\r\n                      if (parser.onComment)\r\n                          parser.onComment(CommentTypes[1 & 0xff], source.slice(index, parser.index - 2), index, parser.index);\r\n                      return state;\r\n                  }\r\n              }\r\n              if (skippedOneAsterisk) {\r\n                  continue;\r\n              }\r\n              if (CharTypes[parser.currentChar] & 8) {\r\n                  if (parser.currentChar === 13) {\r\n                      state |= 1 | 4;\r\n                      scanNewLine(parser);\r\n                  }\r\n                  else {\r\n                      consumeLineFeed(parser, state);\r\n                      state = (state & ~4) | 1;\r\n                  }\r\n              }\r\n              else {\r\n                  advanceChar(parser);\r\n              }\r\n          }\r\n          else if ((parser.currentChar ^ 8232) <= 1) {\r\n              state = (state & ~4) | 1;\r\n              scanNewLine(parser);\r\n          }\r\n          else {\r\n              state &= ~4;\r\n              advanceChar(parser);\r\n          }\r\n      }\r\n      report(parser, 16);\r\n  }\n\n  function advanceChar(parser) {\r\n      parser.column++;\r\n      return (parser.currentChar = parser.source.charCodeAt(++parser.index));\r\n  }\r\n  function consumeMultiUnitCodePoint(parser, hi) {\r\n      if ((hi & 0xfc00) !== 55296)\r\n          return 0;\r\n      const lo = parser.source.charCodeAt(parser.index + 1);\r\n      if ((lo & 0xfc00) !== 0xdc00)\r\n          return 0;\r\n      hi = parser.currentChar = 65536 + ((hi & 0x3ff) << 10) + (lo & 0x3ff);\r\n      if (((unicodeLookup[(hi >>> 5) + 0] >>> hi) & 31 & 1) === 0) {\r\n          report(parser, 18, fromCodePoint(hi));\r\n      }\r\n      parser.index++;\r\n      parser.column++;\r\n      return 1;\r\n  }\r\n  function consumeLineFeed(parser, state) {\r\n      parser.currentChar = parser.source.charCodeAt(++parser.index);\r\n      parser.flags |= 1;\r\n      if ((state & 4) === 0) {\r\n          parser.column = 0;\r\n          parser.line++;\r\n      }\r\n  }\r\n  function scanNewLine(parser) {\r\n      parser.flags |= 1;\r\n      parser.currentChar = parser.source.charCodeAt(++parser.index);\r\n      parser.column = 0;\r\n      parser.line++;\r\n  }\r\n  function isExoticECMAScriptWhitespace(ch) {\r\n      return (ch === 160 ||\r\n          ch === 65279 ||\r\n          ch === 133 ||\r\n          ch === 5760 ||\r\n          (ch >= 8192 && ch <= 8203) ||\r\n          ch === 8239 ||\r\n          ch === 8287 ||\r\n          ch === 12288 ||\r\n          ch === 8201 ||\r\n          ch === 65519);\r\n  }\r\n  function fromCodePoint(codePoint) {\r\n      return codePoint <= 65535\r\n          ? String.fromCharCode(codePoint)\r\n          : String.fromCharCode(codePoint >>> 10) + String.fromCharCode(codePoint & 0x3ff);\r\n  }\r\n  function toHex(code) {\r\n      return code < 65 ? code - 48 : (code - 65 + 10) & 0xf;\r\n  }\r\n  function convertTokenType(t) {\r\n      switch (t) {\r\n          case 134283266:\r\n              return 'NumericLiteral';\r\n          case 134283267:\r\n              return 'StringLiteral';\r\n          case 86021:\r\n          case 86022:\r\n              return 'BooleanLiteral';\r\n          case 86023:\r\n              return 'NullLiteral';\r\n          case 65540:\r\n              return 'RegularExpression';\r\n          case 67174408:\r\n          case 67174409:\r\n          case 129:\r\n              return 'TemplateLiteral';\r\n          default:\r\n              if ((t & 143360) === 143360)\r\n                  return 'Identifier';\r\n              if ((t & 4096) === 4096)\r\n                  return 'Keyword';\r\n              return 'Punctuator';\r\n      }\r\n  }\n\n  const CharTypes = [\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      8 | 1024,\r\n      0,\r\n      0,\r\n      8 | 2048,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      8192,\r\n      0,\r\n      1 | 2,\r\n      0,\r\n      0,\r\n      8192,\r\n      0,\r\n      0,\r\n      0,\r\n      256,\r\n      0,\r\n      256 | 32768,\r\n      0,\r\n      0,\r\n      2 | 16 | 128 | 32 | 64,\r\n      2 | 16 | 128 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 512 | 64,\r\n      2 | 16 | 512 | 64,\r\n      0,\r\n      0,\r\n      16384,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1 | 2 | 64,\r\n      1 | 2 | 64,\r\n      1 | 2 | 64,\r\n      1 | 2 | 64,\r\n      1 | 2 | 64,\r\n      1 | 2 | 64,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      0,\r\n      1,\r\n      0,\r\n      0,\r\n      1 | 2 | 4096,\r\n      0,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      16384,\r\n      0,\r\n      0,\r\n      0,\r\n      0\r\n  ];\r\n  const isIdStart = [\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      0,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0\r\n  ];\r\n  const isIdPart = [\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      0,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0\r\n  ];\r\n  function isIdentifierStart(code) {\r\n      return code <= 0x7F\r\n          ? isIdStart[code]\r\n          : (unicodeLookup[(code >>> 5) + 34816] >>> code) & 31 & 1;\r\n  }\r\n  function isIdentifierPart(code) {\r\n      return code <= 0x7F\r\n          ? isIdPart[code]\r\n          : (unicodeLookup[(code >>> 5) + 0] >>> code) & 31 & 1 || (code === 8204 || code === 8205);\r\n  }\n\n  const KeywordDescTable = [\r\n      'end of source',\r\n      'identifier', 'number', 'string', 'regular expression',\r\n      'false', 'true', 'null',\r\n      'template continuation', 'template tail',\r\n      '=>', '(', '{', '.', '...', '}', ')', ';', ',', '[', ']', ':', '?', '\\'', '\"', '</', '/>',\r\n      '++', '--',\r\n      '=', '<<=', '>>=', '>>>=', '**=', '+=', '-=', '*=', '/=', '%=', '^=', '|=',\r\n      '&=',\r\n      'typeof', 'delete', 'void', '!', '~', '+', '-', 'in', 'instanceof', '*', '%', '/', '**', '&&',\r\n      '||', '===', '!==', '==', '!=', '<=', '>=', '<', '>', '<<', '>>', '>>>', '&', '|', '^',\r\n      'var', 'let', 'const',\r\n      'break', 'case', 'catch', 'class', 'continue', 'debugger', 'default', 'do', 'else', 'export',\r\n      'extends', 'finally', 'for', 'function', 'if', 'import', 'new', 'return', 'super', 'switch',\r\n      'this', 'throw', 'try', 'while', 'with',\r\n      'implements', 'interface', 'package', 'private', 'protected', 'public', 'static', 'yield',\r\n      'as', 'async', 'await', 'constructor', 'get', 'set', 'from', 'of',\r\n      'enum', 'eval', 'arguments', 'escaped keyword', 'escaped future reserved keyword', 'reserved if strict', '#',\r\n      'BigIntLiteral', '??', '?.', 'WhiteSpace', 'Illegal', 'LineTerminator', 'PrivateField',\r\n      'Template', '@', 'target', 'meta', 'LineFeed', 'Escaped', 'JSXText'\r\n  ];\r\n  const descKeywordTable = Object.create(null, {\r\n      this: { value: 86110 },\r\n      function: { value: 86103 },\r\n      if: { value: 20568 },\r\n      return: { value: 20571 },\r\n      var: { value: 86087 },\r\n      else: { value: 20562 },\r\n      for: { value: 20566 },\r\n      new: { value: 86106 },\r\n      in: { value: 8738865 },\r\n      typeof: { value: 16863274 },\r\n      while: { value: 20577 },\r\n      case: { value: 20555 },\r\n      break: { value: 20554 },\r\n      try: { value: 20576 },\r\n      catch: { value: 20556 },\r\n      delete: { value: 16863275 },\r\n      throw: { value: 86111 },\r\n      switch: { value: 86109 },\r\n      continue: { value: 20558 },\r\n      default: { value: 20560 },\r\n      instanceof: { value: 8476722 },\r\n      do: { value: 20561 },\r\n      void: { value: 16863276 },\r\n      finally: { value: 20565 },\r\n      async: { value: 143468 },\r\n      await: { value: 209005 },\r\n      class: { value: 86093 },\r\n      const: { value: 86089 },\r\n      constructor: { value: 12398 },\r\n      debugger: { value: 20559 },\r\n      export: { value: 20563 },\r\n      extends: { value: 20564 },\r\n      false: { value: 86021 },\r\n      from: { value: 12401 },\r\n      get: { value: 12399 },\r\n      implements: { value: 36963 },\r\n      import: { value: 86105 },\r\n      interface: { value: 36964 },\r\n      let: { value: 241736 },\r\n      null: { value: 86023 },\r\n      of: { value: 274546 },\r\n      package: { value: 36965 },\r\n      private: { value: 36966 },\r\n      protected: { value: 36967 },\r\n      public: { value: 36968 },\r\n      set: { value: 12400 },\r\n      static: { value: 36969 },\r\n      super: { value: 86108 },\r\n      true: { value: 86022 },\r\n      with: { value: 20578 },\r\n      yield: { value: 241770 },\r\n      enum: { value: 20595 },\r\n      eval: { value: 537079924 },\r\n      as: { value: 12395 },\r\n      arguments: { value: 537079925 },\r\n      target: { value: 143491 },\r\n      meta: { value: 143492 },\r\n  });\n\n  function scanIdentifier(parser, context, isValidAsKeyword) {\r\n      while (isIdPart[advanceChar(parser)]) { }\r\n      parser.tokenValue = parser.source.slice(parser.tokenPos, parser.index);\r\n      return parser.currentChar !== 92 && parser.currentChar < 0x7e\r\n          ? descKeywordTable[parser.tokenValue] || 208897\r\n          : scanIdentifierSlowCase(parser, context, 0, isValidAsKeyword);\r\n  }\r\n  function scanUnicodeIdentifier(parser, context) {\r\n      const cookedChar = scanIdentifierUnicodeEscape(parser);\r\n      if (!isIdentifierPart(cookedChar))\r\n          report(parser, 4);\r\n      parser.tokenValue = fromCodePoint(cookedChar);\r\n      return scanIdentifierSlowCase(parser, context, 1, CharTypes[cookedChar] & 4);\r\n  }\r\n  function scanIdentifierSlowCase(parser, context, hasEscape, isValidAsKeyword) {\r\n      let start = parser.index;\r\n      while (parser.index < parser.end) {\r\n          if (parser.currentChar === 92) {\r\n              parser.tokenValue += parser.source.slice(start, parser.index);\r\n              hasEscape = 1;\r\n              const code = scanIdentifierUnicodeEscape(parser);\r\n              if (!isIdentifierPart(code))\r\n                  report(parser, 4);\r\n              isValidAsKeyword = isValidAsKeyword && CharTypes[code] & 4;\r\n              parser.tokenValue += fromCodePoint(code);\r\n              start = parser.index;\r\n          }\r\n          else if (isIdentifierPart(parser.currentChar) || consumeMultiUnitCodePoint(parser, parser.currentChar)) {\r\n              advanceChar(parser);\r\n          }\r\n          else {\r\n              break;\r\n          }\r\n      }\r\n      if (parser.index <= parser.end) {\r\n          parser.tokenValue += parser.source.slice(start, parser.index);\r\n      }\r\n      const length = parser.tokenValue.length;\r\n      if (isValidAsKeyword && (length >= 2 && length <= 11)) {\r\n          const token = descKeywordTable[parser.tokenValue];\r\n          if (token === void 0)\r\n              return 208897;\r\n          if (!hasEscape)\r\n              return token;\r\n          if (context & 1024) {\r\n              return token === 209005 && (context & (2048 | 4194304)) === 0\r\n                  ? token\r\n                  : token === 36969\r\n                      ? 119\r\n                      : (token & 36864) === 36864\r\n                          ? 119\r\n                          : 118;\r\n          }\r\n          if (context & 1073741824 &&\r\n              (context & 8192) === 0 &&\r\n              (token & 20480) === 20480)\r\n              return token;\r\n          if (token === 241770) {\r\n              return context & 1073741824\r\n                  ? 143480\r\n                  : context & 2097152\r\n                      ? 118\r\n                      : token;\r\n          }\r\n          return token === 143468 && context & 1073741824\r\n              ? 143480\r\n              : (token & 36864) === 36864\r\n                  ? token\r\n                  : token === 209005 && (context & 4194304) === 0\r\n                      ? token\r\n                      : 118;\r\n      }\r\n      return 208897;\r\n  }\r\n  function scanPrivateName(parser) {\r\n      if (!isIdentifierStart(advanceChar(parser)))\r\n          report(parser, 93);\r\n      return 128;\r\n  }\r\n  function scanIdentifierUnicodeEscape(parser) {\r\n      if (parser.source.charCodeAt(parser.index + 1) !== 117) {\r\n          report(parser, 4);\r\n      }\r\n      parser.currentChar = parser.source.charCodeAt((parser.index += 2));\r\n      return scanUnicodeEscape(parser);\r\n  }\r\n  function scanUnicodeEscape(parser) {\r\n      let codePoint = 0;\r\n      const char = parser.currentChar;\r\n      if (char === 123) {\r\n          const begin = parser.index - 2;\r\n          while (CharTypes[advanceChar(parser)] & 64) {\r\n              codePoint = (codePoint << 4) | toHex(parser.currentChar);\r\n              if (codePoint > 1114111)\r\n                  reportScannerError(begin, parser.line, parser.index + 1, 101);\r\n          }\r\n          if (parser.currentChar !== 125) {\r\n              reportScannerError(begin, parser.line, parser.index - 1, 6);\r\n          }\r\n          advanceChar(parser);\r\n          return codePoint;\r\n      }\r\n      if ((CharTypes[char] & 64) === 0)\r\n          report(parser, 6);\r\n      const char2 = parser.source.charCodeAt(parser.index + 1);\r\n      if ((CharTypes[char2] & 64) === 0)\r\n          report(parser, 6);\r\n      const char3 = parser.source.charCodeAt(parser.index + 2);\r\n      if ((CharTypes[char3] & 64) === 0)\r\n          report(parser, 6);\r\n      const char4 = parser.source.charCodeAt(parser.index + 3);\r\n      if ((CharTypes[char4] & 64) === 0)\r\n          report(parser, 6);\r\n      codePoint = (toHex(char) << 12) | (toHex(char2) << 8) | (toHex(char3) << 4) | toHex(char4);\r\n      parser.currentChar = parser.source.charCodeAt((parser.index += 4));\r\n      return codePoint;\r\n  }\n\n  function scanString(parser, context, quote) {\r\n      const { index: start } = parser;\r\n      let ret = '';\r\n      let char = advanceChar(parser);\r\n      let marker = parser.index;\r\n      while ((CharTypes[char] & 8) === 0) {\r\n          if (char === quote) {\r\n              ret += parser.source.slice(marker, parser.index);\r\n              advanceChar(parser);\r\n              if (context & 512)\r\n                  parser.tokenRaw = parser.source.slice(start, parser.index);\r\n              parser.tokenValue = ret;\r\n              return 134283267;\r\n          }\r\n          if ((char & 8) === 8 && char === 92) {\r\n              ret += parser.source.slice(marker, parser.index);\r\n              char = advanceChar(parser);\r\n              if (char > 0x7e) {\r\n                  ret += fromCodePoint(char);\r\n              }\r\n              else {\r\n                  const code = parseEscape(parser, context, char);\r\n                  if (code >= 0)\r\n                      ret += fromCodePoint(code);\r\n                  else\r\n                      handleStringError(parser, code, 0);\r\n              }\r\n              marker = parser.index + 1;\r\n          }\r\n          if (parser.index >= parser.end)\r\n              report(parser, 14);\r\n          char = advanceChar(parser);\r\n      }\r\n      report(parser, 14);\r\n  }\r\n  function parseEscape(parser, context, first) {\r\n      switch (first) {\r\n          case 98:\r\n              return 8;\r\n          case 102:\r\n              return 12;\r\n          case 114:\r\n              return 13;\r\n          case 110:\r\n              return 10;\r\n          case 116:\r\n              return 9;\r\n          case 118:\r\n              return 11;\r\n          case 13: {\r\n              if (parser.index < parser.end) {\r\n                  if (parser.currentChar === 10) {\r\n                      parser.index = parser.index + 1;\r\n                      parser.currentChar = parser.source.charCodeAt(parser.index);\r\n                  }\r\n              }\r\n          }\r\n          case 10:\r\n          case 8232:\r\n          case 8233:\r\n              parser.column = -1;\r\n              parser.line++;\r\n              return -1;\r\n          case 48:\r\n          case 49:\r\n          case 50:\r\n          case 51: {\r\n              let code = first - 48;\r\n              let index = parser.index + 1;\r\n              let column = parser.column + 1;\r\n              if (index < parser.end) {\r\n                  const next = parser.source.charCodeAt(index);\r\n                  if ((CharTypes[next] & 32) === 0) {\r\n                      if ((code !== 0 || CharTypes[next] & 512) && context & 1024)\r\n                          return -2;\r\n                  }\r\n                  else if (context & 1024) {\r\n                      return -2;\r\n                  }\r\n                  else {\r\n                      parser.currentChar = next;\r\n                      code = (code << 3) | (next - 48);\r\n                      index++;\r\n                      column++;\r\n                      if (index < parser.end) {\r\n                          const next = parser.source.charCodeAt(index);\r\n                          if (CharTypes[next] & 32) {\r\n                              parser.currentChar = next;\r\n                              code = (code << 3) | (next - 48);\r\n                              index++;\r\n                              column++;\r\n                          }\r\n                      }\r\n                      parser.flags |= 64;\r\n                      parser.index = index - 1;\r\n                      parser.column = column - 1;\r\n                  }\r\n              }\r\n              return code;\r\n          }\r\n          case 52:\r\n          case 53:\r\n          case 54:\r\n          case 55: {\r\n              if (context & 1024)\r\n                  return -2;\r\n              let code = first - 48;\r\n              const index = parser.index + 1;\r\n              const column = parser.column + 1;\r\n              if (index < parser.end) {\r\n                  const next = parser.source.charCodeAt(index);\r\n                  if (CharTypes[next] & 32) {\r\n                      code = (code << 3) | (next - 48);\r\n                      parser.currentChar = next;\r\n                      parser.index = index;\r\n                      parser.column = column;\r\n                  }\r\n              }\r\n              parser.flags |= 64;\r\n              return code;\r\n          }\r\n          case 56:\r\n          case 57:\r\n              return -3;\r\n          case 120: {\r\n              const ch1 = advanceChar(parser);\r\n              if ((CharTypes[ch1] & 64) === 0)\r\n                  return -4;\r\n              const hi = toHex(ch1);\r\n              const ch2 = advanceChar(parser);\r\n              if ((CharTypes[ch2] & 64) === 0)\r\n                  return -4;\r\n              const lo = toHex(ch2);\r\n              return (hi << 4) | lo;\r\n          }\r\n          case 117: {\r\n              const ch = advanceChar(parser);\r\n              if (parser.currentChar === 123) {\r\n                  let code = 0;\r\n                  while ((CharTypes[advanceChar(parser)] & 64) !== 0) {\r\n                      code = (code << 4) | toHex(parser.currentChar);\r\n                      if (code > 1114111)\r\n                          return -5;\r\n                  }\r\n                  if (parser.currentChar < 1 || parser.currentChar !== 125) {\r\n                      return -4;\r\n                  }\r\n                  return code;\r\n              }\r\n              else {\r\n                  if ((CharTypes[ch] & 64) === 0)\r\n                      return -4;\r\n                  const ch2 = parser.source.charCodeAt(parser.index + 1);\r\n                  if ((CharTypes[ch2] & 64) === 0)\r\n                      return -4;\r\n                  const ch3 = parser.source.charCodeAt(parser.index + 2);\r\n                  if ((CharTypes[ch3] & 64) === 0)\r\n                      return -4;\r\n                  const ch4 = parser.source.charCodeAt(parser.index + 3);\r\n                  if ((CharTypes[ch4] & 64) === 0)\r\n                      return -4;\r\n                  parser.index += 3;\r\n                  parser.column += 3;\r\n                  parser.currentChar = parser.source.charCodeAt(parser.index);\r\n                  return (toHex(ch) << 12) | (toHex(ch2) << 8) | (toHex(ch3) << 4) | toHex(ch4);\r\n              }\r\n          }\r\n          default:\r\n              return first;\r\n      }\r\n  }\r\n  function handleStringError(state, code, isTemplate) {\r\n      switch (code) {\r\n          case -1:\r\n              return;\r\n          case -2:\r\n              report(state, isTemplate ? 2 : 1);\r\n          case -3:\r\n              report(state, 13);\r\n          case -4:\r\n              report(state, 6);\r\n          case -5:\r\n              report(state, 101);\r\n      }\r\n  }\n\n  function scanNumber(parser, context, kind) {\r\n      let char = parser.currentChar;\r\n      let value = 0;\r\n      let digit = 9;\r\n      let atStart = kind & 64 ? 0 : 1;\r\n      let digits = 0;\r\n      let allowSeparator = 0;\r\n      if (kind & 64) {\r\n          value = '.' + scanDecimalDigitsOrSeparator(parser, char);\r\n          char = parser.currentChar;\r\n          if (char === 110)\r\n              report(parser, 11);\r\n      }\r\n      else {\r\n          if (char === 48) {\r\n              char = advanceChar(parser);\r\n              if ((char | 32) === 120) {\r\n                  kind = 8 | 128;\r\n                  char = advanceChar(parser);\r\n                  while (CharTypes[char] & (64 | 4096)) {\r\n                      if (char === 95) {\r\n                          if (!allowSeparator)\r\n                              report(parser, 146);\r\n                          allowSeparator = 0;\r\n                          char = advanceChar(parser);\r\n                          continue;\r\n                      }\r\n                      allowSeparator = 1;\r\n                      value = value * 0x10 + toHex(char);\r\n                      digits++;\r\n                      char = advanceChar(parser);\r\n                  }\r\n                  if (digits < 1 || !allowSeparator) {\r\n                      report(parser, digits < 1 ? 19 : 147);\r\n                  }\r\n              }\r\n              else if ((char | 32) === 111) {\r\n                  kind = 4 | 128;\r\n                  char = advanceChar(parser);\r\n                  while (CharTypes[char] & (32 | 4096)) {\r\n                      if (char === 95) {\r\n                          if (!allowSeparator) {\r\n                              report(parser, 146);\r\n                          }\r\n                          allowSeparator = 0;\r\n                          char = advanceChar(parser);\r\n                          continue;\r\n                      }\r\n                      allowSeparator = 1;\r\n                      value = value * 8 + (char - 48);\r\n                      digits++;\r\n                      char = advanceChar(parser);\r\n                  }\r\n                  if (digits < 1 || !allowSeparator) {\r\n                      report(parser, digits < 1 ? 0 : 147);\r\n                  }\r\n              }\r\n              else if ((char | 32) === 98) {\r\n                  kind = 2 | 128;\r\n                  char = advanceChar(parser);\r\n                  while (CharTypes[char] & (128 | 4096)) {\r\n                      if (char === 95) {\r\n                          if (!allowSeparator) {\r\n                              report(parser, 146);\r\n                          }\r\n                          allowSeparator = 0;\r\n                          char = advanceChar(parser);\r\n                          continue;\r\n                      }\r\n                      allowSeparator = 1;\r\n                      value = value * 2 + (char - 48);\r\n                      digits++;\r\n                      char = advanceChar(parser);\r\n                  }\r\n                  if (digits < 1 || !allowSeparator) {\r\n                      report(parser, digits < 1 ? 0 : 147);\r\n                  }\r\n              }\r\n              else if (CharTypes[char] & 32) {\r\n                  if (context & 1024)\r\n                      report(parser, 1);\r\n                  kind = 1;\r\n                  while (CharTypes[char] & 16) {\r\n                      if (CharTypes[char] & 512) {\r\n                          kind = 32;\r\n                          atStart = 0;\r\n                          break;\r\n                      }\r\n                      value = value * 8 + (char - 48);\r\n                      char = advanceChar(parser);\r\n                  }\r\n              }\r\n              else if (CharTypes[char] & 512) {\r\n                  if (context & 1024)\r\n                      report(parser, 1);\r\n                  parser.flags |= 64;\r\n                  kind = 32;\r\n              }\r\n              else if (char === 95) {\r\n                  report(parser, 0);\r\n              }\r\n          }\r\n          if (kind & 48) {\r\n              if (atStart) {\r\n                  while (digit >= 0 && CharTypes[char] & (16 | 4096)) {\r\n                      if (char === 95) {\r\n                          char = advanceChar(parser);\r\n                          if (char === 95 || kind & 32) {\r\n                              reportScannerError(parser.index, parser.line, parser.index + 1, 146);\r\n                          }\r\n                          allowSeparator = 1;\r\n                          continue;\r\n                      }\r\n                      allowSeparator = 0;\r\n                      value = 10 * value + (char - 48);\r\n                      char = advanceChar(parser);\r\n                      --digit;\r\n                  }\r\n                  if (allowSeparator) {\r\n                      reportScannerError(parser.index, parser.line, parser.index + 1, 147);\r\n                  }\r\n                  if (digit >= 0 && !isIdentifierStart(char) && char !== 46) {\r\n                      parser.tokenValue = value;\r\n                      if (context & 512)\r\n                          parser.tokenRaw = parser.source.slice(parser.tokenPos, parser.index);\r\n                      return 134283266;\r\n                  }\r\n              }\r\n              value += scanDecimalDigitsOrSeparator(parser, char);\r\n              char = parser.currentChar;\r\n              if (char === 46) {\r\n                  if (advanceChar(parser) === 95)\r\n                      report(parser, 0);\r\n                  kind = 64;\r\n                  value += '.' + scanDecimalDigitsOrSeparator(parser, parser.currentChar);\r\n                  char = parser.currentChar;\r\n              }\r\n          }\r\n      }\r\n      const end = parser.index;\r\n      let isBigInt = 0;\r\n      if (char === 110 && kind & 128) {\r\n          isBigInt = 1;\r\n          char = advanceChar(parser);\r\n      }\r\n      else {\r\n          if ((char | 32) === 101) {\r\n              char = advanceChar(parser);\r\n              if (CharTypes[char] & 256)\r\n                  char = advanceChar(parser);\r\n              const { index } = parser;\r\n              if ((CharTypes[char] & 16) < 1)\r\n                  report(parser, 10);\r\n              value += parser.source.substring(end, index) + scanDecimalDigitsOrSeparator(parser, char);\r\n              char = parser.currentChar;\r\n          }\r\n      }\r\n      if ((parser.index < parser.end && CharTypes[char] & 16) || isIdentifierStart(char)) {\r\n          report(parser, 12);\r\n      }\r\n      if (isBigInt) {\r\n          parser.tokenRaw = parser.source.slice(parser.tokenPos, parser.index);\r\n          parser.tokenValue = parseInt(value, 0xa);\r\n          return 122;\r\n      }\r\n      parser.tokenValue =\r\n          kind & (1 | 2 | 8 | 4)\r\n              ? value\r\n              : kind & 32\r\n                  ? parseFloat(parser.source.substring(parser.tokenPos, parser.index))\r\n                  : +value;\r\n      if (context & 512)\r\n          parser.tokenRaw = parser.source.slice(parser.tokenPos, parser.index);\r\n      return 134283266;\r\n  }\r\n  function scanDecimalDigitsOrSeparator(parser, char) {\r\n      let allowSeparator = 0;\r\n      let start = parser.index;\r\n      let ret = '';\r\n      while (CharTypes[char] & (16 | 4096)) {\r\n          if (char === 95) {\r\n              const { index } = parser;\r\n              char = advanceChar(parser);\r\n              if (char === 95) {\r\n                  reportScannerError(parser.index, parser.line, parser.index + 1, 146);\r\n              }\r\n              allowSeparator = 1;\r\n              ret += parser.source.substring(start, index);\r\n              start = parser.index;\r\n              continue;\r\n          }\r\n          allowSeparator = 0;\r\n          char = advanceChar(parser);\r\n      }\r\n      if (allowSeparator) {\r\n          reportScannerError(parser.index, parser.line, parser.index + 1, 147);\r\n      }\r\n      return ret + parser.source.substring(start, parser.index);\r\n  }\n\n  function scanTemplate(parser, context) {\r\n      const { index: start } = parser;\r\n      let token = 67174409;\r\n      let ret = '';\r\n      let char = advanceChar(parser);\r\n      while (char !== 96) {\r\n          if (char === 36 && parser.source.charCodeAt(parser.index + 1) === 123) {\r\n              advanceChar(parser);\r\n              token = 67174408;\r\n              break;\r\n          }\r\n          else if ((char & 8) === 8 && char === 92) {\r\n              char = advanceChar(parser);\r\n              if (char > 0x7e) {\r\n                  ret += fromCodePoint(char);\r\n              }\r\n              else {\r\n                  const code = parseEscape(parser, context | 1024, char);\r\n                  if (code >= 0) {\r\n                      ret += fromCodePoint(code);\r\n                  }\r\n                  else if (code !== -1 && context & 65536) {\r\n                      ret = undefined;\r\n                      char = scanBadTemplate(parser, char);\r\n                      if (char < 0)\r\n                          token = 67174408;\r\n                      break;\r\n                  }\r\n                  else {\r\n                      handleStringError(parser, code, 1);\r\n                  }\r\n              }\r\n          }\r\n          else {\r\n              if (parser.index < parser.end &&\r\n                  char === 13 &&\r\n                  parser.source.charCodeAt(parser.index) === 10) {\r\n                  ret += fromCodePoint(char);\r\n                  parser.currentChar = parser.source.charCodeAt(++parser.index);\r\n              }\r\n              if (((char & 83) < 3 && char === 10) || (char ^ 8232) <= 1) {\r\n                  parser.column = -1;\r\n                  parser.line++;\r\n              }\r\n              ret += fromCodePoint(char);\r\n          }\r\n          if (parser.index >= parser.end)\r\n              report(parser, 15);\r\n          char = advanceChar(parser);\r\n      }\r\n      advanceChar(parser);\r\n      parser.tokenValue = ret;\r\n      parser.tokenRaw = parser.source.slice(start + 1, parser.index - (token === 67174409 ? 1 : 2));\r\n      return token;\r\n  }\r\n  function scanBadTemplate(parser, ch) {\r\n      while (ch !== 96) {\r\n          switch (ch) {\r\n              case 36: {\r\n                  const index = parser.index + 1;\r\n                  if (index < parser.end && parser.source.charCodeAt(index) === 123) {\r\n                      parser.index = index;\r\n                      parser.column++;\r\n                      return -ch;\r\n                  }\r\n                  break;\r\n              }\r\n              case 10:\r\n              case 8232:\r\n              case 8233:\r\n                  parser.column = -1;\r\n                  parser.line++;\r\n          }\r\n          if (parser.index >= parser.end)\r\n              report(parser, 15);\r\n          ch = advanceChar(parser);\r\n      }\r\n      return ch;\r\n  }\r\n  function scanTemplateTail(parser, context) {\r\n      if (parser.index >= parser.end)\r\n          report(parser, 0);\r\n      parser.index--;\r\n      parser.column--;\r\n      return scanTemplate(parser, context);\r\n  }\n\n  function scanRegularExpression(parser, context) {\r\n      const bodyStart = parser.index;\r\n      let preparseState = 0;\r\n      loop: while (true) {\r\n          const ch = parser.currentChar;\r\n          advanceChar(parser);\r\n          if (preparseState & 1) {\r\n              preparseState &= ~1;\r\n          }\r\n          else {\r\n              switch (ch) {\r\n                  case 47:\r\n                      if (!preparseState)\r\n                          break loop;\r\n                      else\r\n                          break;\r\n                  case 92:\r\n                      preparseState |= 1;\r\n                      break;\r\n                  case 91:\r\n                      preparseState |= 2;\r\n                      break;\r\n                  case 93:\r\n                      preparseState &= 1;\r\n                      break;\r\n                  case 13:\r\n                  case 10:\r\n                  case 8232:\r\n                  case 8233:\r\n                      report(parser, 32);\r\n              }\r\n          }\r\n          if (parser.index >= parser.source.length) {\r\n              return report(parser, 32);\r\n          }\r\n      }\r\n      const bodyEnd = parser.index - 1;\r\n      let mask = 0;\r\n      let char = parser.currentChar;\r\n      const { index: flagStart } = parser;\r\n      while (isIdentifierPart(char)) {\r\n          switch (char) {\r\n              case 103:\r\n                  if (mask & 2)\r\n                      report(parser, 34, 'g');\r\n                  mask |= 2;\r\n                  break;\r\n              case 105:\r\n                  if (mask & 1)\r\n                      report(parser, 34, 'i');\r\n                  mask |= 1;\r\n                  break;\r\n              case 109:\r\n                  if (mask & 4)\r\n                      report(parser, 34, 'm');\r\n                  mask |= 4;\r\n                  break;\r\n              case 117:\r\n                  if (mask & 16)\r\n                      report(parser, 34, 'g');\r\n                  mask |= 16;\r\n                  break;\r\n              case 121:\r\n                  if (mask & 8)\r\n                      report(parser, 34, 'y');\r\n                  mask |= 8;\r\n                  break;\r\n              case 115:\r\n                  if (mask & 12)\r\n                      report(parser, 34, 's');\r\n                  mask |= 12;\r\n                  break;\r\n              default:\r\n                  report(parser, 33);\r\n          }\r\n          char = advanceChar(parser);\r\n      }\r\n      const flags = parser.source.slice(flagStart, parser.index);\r\n      const pattern = parser.source.slice(bodyStart, bodyEnd);\r\n      parser.tokenRegExp = { pattern, flags };\r\n      if (context & 512)\r\n          parser.tokenRaw = parser.source.slice(parser.tokenPos, parser.index);\r\n      parser.tokenValue = validate(parser, pattern, flags);\r\n      return 65540;\r\n  }\r\n  function validate(parser, pattern, flags) {\r\n      try {\r\n          RegExp(pattern);\r\n      }\r\n      catch (e) {\r\n          report(parser, 32);\r\n      }\r\n      try {\r\n          return new RegExp(pattern, flags);\r\n      }\r\n      catch (e) {\r\n          return null;\r\n      }\r\n  }\n\n  function scanJSXAttributeValue(parser, context) {\r\n      parser.startPos = parser.index;\r\n      parser.startColumn = parser.column;\r\n      parser.startLine = parser.line;\r\n      parser.token =\r\n          CharTypes[parser.currentChar] & 8192\r\n              ? scanJSXString(parser)\r\n              : scanSingleToken(parser, context, 0);\r\n      return parser.token;\r\n  }\r\n  function scanJSXString(parser) {\r\n      const quote = parser.currentChar;\r\n      let char = advanceChar(parser);\r\n      const start = parser.index;\r\n      while (char !== quote) {\r\n          if (parser.index >= parser.end)\r\n              report(parser, 14);\r\n          char = advanceChar(parser);\r\n      }\r\n      if (char !== quote)\r\n          report(parser, 14);\r\n      parser.tokenValue = parser.source.slice(start, parser.index);\r\n      advanceChar(parser);\r\n      return 134283267;\r\n  }\r\n  function scanJSXToken(parser) {\r\n      parser.startPos = parser.tokenPos = parser.index;\r\n      parser.startColumn = parser.colPos = parser.column;\r\n      parser.startLine = parser.linePos = parser.line;\r\n      if (parser.index >= parser.end)\r\n          return (parser.token = 1048576);\r\n      const token = TokenLookup[parser.source.charCodeAt(parser.index)];\r\n      switch (token) {\r\n          case 8456255: {\r\n              advanceChar(parser);\r\n              if (parser.currentChar === 47) {\r\n                  advanceChar(parser);\r\n                  parser.token = 25;\r\n              }\r\n              else {\r\n                  parser.token = 8456255;\r\n              }\r\n              break;\r\n          }\r\n          case 2162700: {\r\n              advanceChar(parser);\r\n              parser.token = 2162700;\r\n              break;\r\n          }\r\n          default:\r\n              while (parser.index < parser.end && (CharTypes[advanceChar(parser)] & 16384) === 0) { }\r\n              parser.tokenValue = parser.source.slice(parser.tokenPos, parser.index);\r\n              parser.token = 135;\r\n      }\r\n      return parser.token;\r\n  }\r\n  function scanJSXIdentifier(parser) {\r\n      if ((parser.token & 143360) === 143360) {\r\n          const { index } = parser;\r\n          let char = parser.currentChar;\r\n          while (CharTypes[char] & (32768 | 2)) {\r\n              char = advanceChar(parser);\r\n          }\r\n          parser.tokenValue += parser.source.slice(index, parser.index);\r\n      }\r\n      parser.token = 208897;\r\n      return parser.token;\r\n  }\n\n  function matchOrInsertSemicolon(parser, context, specDeviation) {\r\n      if ((parser.flags & 1) === 0 &&\r\n          (parser.token & 1048576) !== 1048576 &&\r\n          !specDeviation) {\r\n          report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      consumeOpt(parser, context, 1074790417);\r\n  }\r\n  function isValidStrictMode(parser, index, tokenPos, tokenValue) {\r\n      if (index - tokenPos < 13 && tokenValue === 'use strict') {\r\n          if ((parser.token & 1048576) === 1048576 || parser.flags & 1) {\r\n              return 1;\r\n          }\r\n      }\r\n      return 0;\r\n  }\r\n  function optionalBit(parser, context, t) {\r\n      if (parser.token !== t)\r\n          return 0;\r\n      nextToken(parser, context);\r\n      return 1;\r\n  }\r\n  function consumeOpt(parser, context, t) {\r\n      if (parser.token !== t)\r\n          return false;\r\n      nextToken(parser, context);\r\n      return true;\r\n  }\r\n  function consume(parser, context, t) {\r\n      if (parser.token !== t)\r\n          report(parser, 23, KeywordDescTable[t & 255]);\r\n      nextToken(parser, context);\r\n  }\r\n  function reinterpretToPattern(state, node) {\r\n      switch (node.type) {\r\n          case 'ArrayExpression':\r\n              node.type = 'ArrayPattern';\r\n              const elements = node.elements;\r\n              for (let i = 0, n = elements.length; i < n; ++i) {\r\n                  const element = elements[i];\r\n                  if (element)\r\n                      reinterpretToPattern(state, element);\r\n              }\r\n              return;\r\n          case 'ObjectExpression':\r\n              node.type = 'ObjectPattern';\r\n              const properties = node.properties;\r\n              for (let i = 0, n = properties.length; i < n; ++i) {\r\n                  reinterpretToPattern(state, properties[i]);\r\n              }\r\n              return;\r\n          case 'AssignmentExpression':\r\n              node.type = 'AssignmentPattern';\r\n              if (node.operator !== '=')\r\n                  report(state, 68);\r\n              delete node.operator;\r\n              reinterpretToPattern(state, node.left);\r\n              return;\r\n          case 'Property':\r\n              reinterpretToPattern(state, node.value);\r\n              return;\r\n          case 'SpreadElement':\r\n              node.type = 'RestElement';\r\n              reinterpretToPattern(state, node.argument);\r\n      }\r\n  }\r\n  function validateBindingIdentifier(parser, context, kind, t, skipEvalArgCheck) {\r\n      if (context & 1024) {\r\n          if ((t & 36864) === 36864) {\r\n              report(parser, 114);\r\n          }\r\n          if (!skipEvalArgCheck && (t & 537079808) === 537079808) {\r\n              report(parser, 115);\r\n          }\r\n      }\r\n      if ((t & 20480) === 20480) {\r\n          report(parser, 99);\r\n      }\r\n      if (kind & (8 | 16) && t === 241736) {\r\n          report(parser, 97);\r\n      }\r\n      if (context & (4194304 | 2048) && t === 209005) {\r\n          report(parser, 95);\r\n      }\r\n      if (context & (2097152 | 1024) && t === 241770) {\r\n          report(parser, 94, 'yield');\r\n      }\r\n  }\r\n  function validateFunctionName(parser, context, t) {\r\n      if (context & 1024) {\r\n          if ((t & 36864) === 36864) {\r\n              report(parser, 114);\r\n          }\r\n          if ((t & 537079808) === 537079808) {\r\n              report(parser, 115);\r\n          }\r\n          if (t === 119) {\r\n              report(parser, 92);\r\n          }\r\n          if (t === 118) {\r\n              report(parser, 92);\r\n          }\r\n      }\r\n      if ((t & 20480) === 20480) {\r\n          report(parser, 99);\r\n      }\r\n      if (context & (4194304 | 2048) && t === 209005) {\r\n          report(parser, 95);\r\n      }\r\n      if (context & (2097152 | 1024) && t === 241770) {\r\n          report(parser, 94, 'yield');\r\n      }\r\n  }\r\n  function isStrictReservedWord(parser, context, t) {\r\n      if (t === 209005) {\r\n          if (context & (4194304 | 2048))\r\n              report(parser, 95);\r\n          parser.destructible |= 128;\r\n      }\r\n      if (t === 241770 && context & 2097152)\r\n          report(parser, 94, 'yield');\r\n      return ((t & 20480) === 20480 ||\r\n          (t & 36864) === 36864 ||\r\n          t == 119);\r\n  }\r\n  function isPropertyWithPrivateFieldKey(expr) {\r\n      return !expr.property ? false : expr.property.type === 'PrivateName';\r\n  }\r\n  function isValidLabel(parser, labels, name, isIterationStatement) {\r\n      while (labels) {\r\n          if (labels['$' + name]) {\r\n              if (isIterationStatement)\r\n                  report(parser, 133);\r\n              return 1;\r\n          }\r\n          if (isIterationStatement && labels.loop)\r\n              isIterationStatement = 0;\r\n          labels = labels['$'];\r\n      }\r\n      return 0;\r\n  }\r\n  function validateAndDeclareLabel(parser, labels, name) {\r\n      let set = labels;\r\n      while (set) {\r\n          if (set['$' + name])\r\n              report(parser, 132, name);\r\n          set = set['$'];\r\n      }\r\n      labels['$' + name] = 1;\r\n  }\r\n  function finishNode(parser, context, start, line, column, node) {\r\n      if (context & 2) {\r\n          node.start = start;\r\n          node.end = parser.startPos;\r\n      }\r\n      if (context & 4) {\r\n          node.loc = {\r\n              start: {\r\n                  line,\r\n                  column\r\n              },\r\n              end: {\r\n                  line: parser.startLine,\r\n                  column: parser.startColumn\r\n              }\r\n          };\r\n          if (parser.sourceFile) {\r\n              node.loc.source = parser.sourceFile;\r\n          }\r\n      }\r\n      return node;\r\n  }\r\n  function isEqualTagName(elementName) {\r\n      switch (elementName.type) {\r\n          case 'JSXIdentifier':\r\n              return elementName.name;\r\n          case 'JSXNamespacedName':\r\n              return elementName.namespace + ':' + elementName.name;\r\n          case 'JSXMemberExpression':\r\n              return isEqualTagName(elementName.object) + '.' + isEqualTagName(elementName.property);\r\n      }\r\n  }\r\n  function createArrowHeadParsingScope(parser, context, value) {\r\n      const scope = addChildScope(createScope(), 1024);\r\n      addBlockName(parser, context, scope, value, 1, 0);\r\n      return scope;\r\n  }\r\n  function recordScopeError(parser, type, ...params) {\r\n      const { index, line, column } = parser;\r\n      return {\r\n          type,\r\n          params,\r\n          index,\r\n          line,\r\n          column\r\n      };\r\n  }\r\n  function createScope() {\r\n      return {\r\n          parent: void 0,\r\n          type: 2\r\n      };\r\n  }\r\n  function addChildScope(parent, type) {\r\n      return {\r\n          parent,\r\n          type,\r\n          scopeError: void 0\r\n      };\r\n  }\r\n  function addVarOrBlock(parser, context, scope, name, kind, origin) {\r\n      if (kind & 4) {\r\n          addVarName(parser, context, scope, name, kind);\r\n      }\r\n      else {\r\n          addBlockName(parser, context, scope, name, kind, origin);\r\n      }\r\n      if (origin & 64) {\r\n          declareUnboundVariable(parser, name);\r\n      }\r\n  }\r\n  function addBlockName(parser, context, scope, name, kind, origin) {\r\n      const value = scope['#' + name];\r\n      if (value && (value & 2) === 0) {\r\n          if (kind & 1) {\r\n              scope.scopeError = recordScopeError(parser, 140, name);\r\n          }\r\n          else if (context & 256 &&\r\n              value & 64 &&\r\n              origin & 2) ;\r\n          else {\r\n              report(parser, 140, name);\r\n          }\r\n      }\r\n      if (scope.type & 128 &&\r\n          (scope.parent['#' + name] && (scope.parent['#' + name] & 2) === 0)) {\r\n          report(parser, 140, name);\r\n      }\r\n      if (scope.type & 1024 && value && (value & 2) === 0) {\r\n          if (kind & 1) {\r\n              scope.scopeError = recordScopeError(parser, 140, name);\r\n          }\r\n      }\r\n      if (scope.type & 64) {\r\n          if (scope.parent['#' + name] & 768)\r\n              report(parser, 153, name);\r\n      }\r\n      scope['#' + name] = kind;\r\n  }\r\n  function addVarName(parser, context, scope, name, kind) {\r\n      let currentScope = scope;\r\n      while (currentScope && (currentScope.type & 256) === 0) {\r\n          const value = currentScope['#' + name];\r\n          if (value & 248) {\r\n              if (context & 256 &&\r\n                  (context & 1024) === 0 &&\r\n                  ((kind & 128 && value & 68) ||\r\n                      (value & 128 && kind & 68))) ;\r\n              else {\r\n                  report(parser, 140, name);\r\n              }\r\n          }\r\n          if (currentScope === scope) {\r\n              if (value & 1 && kind & 1) {\r\n                  currentScope.scopeError = recordScopeError(parser, 140, name);\r\n              }\r\n          }\r\n          if (value & (512 | 256)) {\r\n              if ((value & 512) === 0 ||\r\n                  (context & 256) === 0 ||\r\n                  context & 1024) {\r\n                  report(parser, 140, name);\r\n              }\r\n          }\r\n          currentScope['#' + name] = kind;\r\n          currentScope = currentScope.parent;\r\n      }\r\n  }\r\n  function declareUnboundVariable(parser, name) {\r\n      if (parser.exportedNames !== void 0 && name !== '') {\r\n          if (parser.exportedNames['#' + name]) {\r\n              report(parser, 141, name);\r\n          }\r\n          parser.exportedNames['#' + name] = 1;\r\n      }\r\n  }\r\n  function addBindingToExports(parser, name) {\r\n      if (parser.exportedBindings !== void 0 && name !== '') {\r\n          parser.exportedBindings['#' + name] = 1;\r\n      }\r\n  }\r\n  function pushComment(context, array) {\r\n      return function (type, value, start, end) {\r\n          const comment = {\r\n              type,\r\n              value\r\n          };\r\n          if (context & 2) {\r\n              comment.start = start;\r\n              comment.end = end;\r\n          }\r\n          array.push(comment);\r\n      };\r\n  }\r\n  function pushToken(context, array) {\r\n      return function (token, start, end) {\r\n          const tokens = {\r\n              token\r\n          };\r\n          if (context & 4) {\r\n              tokens.start = start;\r\n              tokens.end = end;\r\n          }\r\n          array.push(tokens);\r\n      };\r\n  }\r\n  function isValidIdentifier(context, t) {\r\n      if (context & (1024 | 2097152)) {\r\n          if (context & 2048 && t === 209005)\r\n              return false;\r\n          if (context & 2097152 && t === 241770)\r\n              return false;\r\n          return (t & 143360) === 143360 || (t & 12288) === 12288;\r\n      }\r\n      return ((t & 143360) === 143360 ||\r\n          (t & 12288) === 12288 ||\r\n          (t & 36864) === 36864);\r\n  }\r\n  function classifyIdentifier(parser, context, t, isArrow) {\r\n      if ((t & 537079808) === 537079808) {\r\n          if (context & 1024)\r\n              report(parser, 115);\r\n          if (isArrow)\r\n              parser.flags |= 512;\r\n      }\r\n      if (!isValidIdentifier(context, t))\r\n          report(parser, 0);\r\n  }\n\n  function create(source, sourceFile, onComment, onToken) {\r\n      return {\r\n          source,\r\n          flags: 0,\r\n          index: 0,\r\n          line: 1,\r\n          column: 0,\r\n          startPos: 0,\r\n          end: source.length,\r\n          tokenPos: 0,\r\n          startColumn: 0,\r\n          colPos: 0,\r\n          linePos: 0,\r\n          startLine: 1,\r\n          sourceFile,\r\n          tokenValue: '',\r\n          token: 1048576,\r\n          tokenRaw: '',\r\n          tokenRegExp: void 0,\r\n          currentChar: source.charCodeAt(0),\r\n          exportedNames: [],\r\n          exportedBindings: [],\r\n          assignable: 1,\r\n          destructible: 0,\r\n          onComment,\r\n          onToken\r\n      };\r\n  }\r\n  function parseSource(source, options, context) {\r\n      let sourceFile = '';\r\n      let onComment;\r\n      let onToken;\r\n      if (options != null) {\r\n          if (options.module)\r\n              context |= 2048 | 1024;\r\n          if (options.next)\r\n              context |= 1;\r\n          if (options.loc)\r\n              context |= 4;\r\n          if (options.ranges)\r\n              context |= 2;\r\n          if (options.uniqueKeyInPattern)\r\n              context |= -2147483648;\r\n          if (options.lexical)\r\n              context |= 64;\r\n          if (options.webcompat)\r\n              context |= 256;\r\n          if (options.directives)\r\n              context |= 8 | 512;\r\n          if (options.globalReturn)\r\n              context |= 32;\r\n          if (options.raw)\r\n              context |= 512;\r\n          if (options.preserveParens)\r\n              context |= 128;\r\n          if (options.impliedStrict)\r\n              context |= 1024;\r\n          if (options.jsx)\r\n              context |= 16;\r\n          if (options.identifierPattern)\r\n              context |= 268435456;\r\n          if (options.specDeviation)\r\n              context |= 536870912;\r\n          if (options.source)\r\n              sourceFile = options.source;\r\n          if (options.onComment != null) {\r\n              onComment = Array.isArray(options.onComment) ? pushComment(context, options.onComment) : options.onComment;\r\n          }\r\n          if (options.onToken != null) {\r\n              onToken = Array.isArray(options.onToken) ? pushToken(context, options.onToken) : options.onToken;\r\n          }\r\n      }\r\n      const parser = create(source, sourceFile, onComment, onToken);\r\n      if (context & 1)\r\n          skipHashBang(parser);\r\n      const scope = context & 64 ? createScope() : void 0;\r\n      let body = [];\r\n      let sourceType = 'script';\r\n      if (context & 2048) {\r\n          sourceType = 'module';\r\n          body = parseModuleItemList(parser, context | 8192, scope);\r\n          if (scope) {\r\n              for (const key in parser.exportedBindings) {\r\n                  if (key[0] === '#' && !scope[key])\r\n                      report(parser, 142, key.slice(1));\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          body = parseStatementList(parser, context | 8192, scope);\r\n      }\r\n      const node = {\r\n          type: 'Program',\r\n          sourceType,\r\n          body\r\n      };\r\n      if (context & 2) {\r\n          node.start = 0;\r\n          node.end = source.length;\r\n      }\r\n      if (context & 4) {\r\n          node.loc = {\r\n              start: { line: 1, column: 0 },\r\n              end: { line: parser.line, column: parser.column }\r\n          };\r\n          if (parser.sourceFile)\r\n              node.loc.source = sourceFile;\r\n      }\r\n      return node;\r\n  }\r\n  function parseStatementList(parser, context, scope) {\r\n      nextToken(parser, context | 32768 | 1073741824);\r\n      const statements = [];\r\n      while (parser.token === 134283267) {\r\n          const { index, tokenPos, tokenValue, linePos, colPos, token } = parser;\r\n          const expr = parseLiteral(parser, context);\r\n          if (isValidStrictMode(parser, index, tokenPos, tokenValue))\r\n              context |= 1024;\r\n          statements.push(parseDirective(parser, context, expr, token, tokenPos, linePos, colPos));\r\n      }\r\n      while (parser.token !== 1048576) {\r\n          statements.push(parseStatementListItem(parser, context, scope, 4, {}, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return statements;\r\n  }\r\n  function parseModuleItemList(parser, context, scope) {\r\n      nextToken(parser, context | 32768);\r\n      const statements = [];\r\n      if (context & 8) {\r\n          while (parser.token === 134283267) {\r\n              const { tokenPos, linePos, colPos, token } = parser;\r\n              statements.push(parseDirective(parser, context, parseLiteral(parser, context), token, tokenPos, linePos, colPos));\r\n          }\r\n      }\r\n      while (parser.token !== 1048576) {\r\n          statements.push(parseModuleItem(parser, context, scope, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return statements;\r\n  }\r\n  function parseModuleItem(parser, context, scope, start, line, column) {\r\n      switch (parser.token) {\r\n          case 20563:\r\n              return parseExportDeclaration(parser, context, scope, start, line, column);\r\n          case 86105:\r\n              return parseImportDeclaration(parser, context, scope, start, line, column);\r\n          case 130:\r\n              return parseDecorators(parser, context);\r\n          default:\r\n              return parseStatementListItem(parser, context, scope, 4, {}, start, line, column);\r\n      }\r\n  }\r\n  function parseStatementListItem(parser, context, scope, origin, labels, start, line, column) {\r\n      switch (parser.token) {\r\n          case 86103:\r\n              return parseFunctionDeclaration(parser, context, scope, origin, 1, 0, 0, start, line, column);\r\n          case 130:\r\n          case 86093:\r\n              return parseClassDeclaration(parser, context, scope, 0, start, line, column);\r\n          case 86089:\r\n              return parseLexicalDeclaration(parser, context, scope, 16, 0, start, line, column);\r\n          case 241736:\r\n              return parseLetIdentOrVarDeclarationStatement(parser, context, scope, origin, start, line, column);\r\n          case 20563:\r\n              report(parser, 100, 'export');\r\n          case 86105:\r\n              nextToken(parser, context);\r\n              switch (parser.token) {\r\n                  case 67174411:\r\n                      return parseImportCallDeclaration(parser, context, start, line, column);\r\n                  case 67108877:\r\n                      return parseImportMetaDeclaration(parser, context, start, line, column);\r\n                  default:\r\n                      report(parser, 100, 'import');\r\n              }\r\n          case 143468:\r\n              return parseAsyncArrowOrAsyncFunctionDeclaration(parser, context, scope, origin, labels, 1, start, line, column);\r\n          default:\r\n              return parseStatement(parser, context, scope, origin, labels, 1, start, line, column);\r\n      }\r\n  }\r\n  function parseStatement(parser, context, scope, origin, labels, allowFuncDecl, start, line, column) {\r\n      switch (parser.token) {\r\n          case 86087:\r\n              return parseVariableStatement(parser, context, scope, 0, start, line, column);\r\n          case 20571:\r\n              return parseReturnStatement(parser, context, start, line, column);\r\n          case 20568:\r\n              return parseIfStatement(parser, context, scope, labels, start, line, column);\r\n          case 20566:\r\n              return parseForStatement(parser, context, scope, labels, start, line, column);\r\n          case 20561:\r\n              return parseDoWhileStatement(parser, context, scope, labels, start, line, column);\r\n          case 20577:\r\n              return parseWhileStatement(parser, context, scope, labels, start, line, column);\r\n          case 86109:\r\n              return parseSwitchStatement(parser, context, scope, labels, start, line, column);\r\n          case 1074790417:\r\n              return parseEmptyStatement(parser, context, start, line, column);\r\n          case 2162700:\r\n              return parseBlock(parser, context, scope ? addChildScope(scope, 2) : scope, labels, start, line, column);\r\n          case 86111:\r\n              return parseThrowStatement(parser, context, start, line, column);\r\n          case 20554:\r\n              return parseBreakStatement(parser, context, labels, start, line, column);\r\n          case 20558:\r\n              return parseContinueStatement(parser, context, labels, start, line, column);\r\n          case 20576:\r\n              return parseTryStatement(parser, context, scope, labels, start, line, column);\r\n          case 20578:\r\n              return parseWithStatement(parser, context, scope, labels, start, line, column);\r\n          case 20559:\r\n              return parseDebuggerStatement(parser, context, start, line, column);\r\n          case 143468:\r\n              return parseAsyncArrowOrAsyncFunctionDeclaration(parser, context, scope, origin, labels, 0, start, line, column);\r\n          case 20556:\r\n              report(parser, 156);\r\n          case 20565:\r\n              report(parser, 157);\r\n          case 86103:\r\n              report(parser, context & 1024\r\n                  ? 73\r\n                  : (context & 256) < 1\r\n                      ? 75\r\n                      : 74);\r\n          case 86093:\r\n              report(parser, 76);\r\n          default:\r\n              return parseExpressionOrLabelledStatement(parser, context, scope, origin, labels, allowFuncDecl, start, line, column);\r\n      }\r\n  }\r\n  function parseExpressionOrLabelledStatement(parser, context, scope, origin, labels, allowFuncDecl, start, line, column) {\r\n      const { tokenValue, token } = parser;\r\n      let expr;\r\n      switch (token) {\r\n          case 241736:\r\n              expr = parseIdentifier(parser, context, 0);\r\n              if (context & 1024)\r\n                  report(parser, 82);\r\n              if (parser.token === 69271571)\r\n                  report(parser, 81);\r\n              break;\r\n          default:\r\n              expr = parsePrimaryExpression(parser, context, 2, 0, 1, 0, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      }\r\n      if (token & 143360 && parser.token === 21) {\r\n          return parseLabelledStatement(parser, context, scope, origin, labels, tokenValue, expr, token, allowFuncDecl, start, line, column);\r\n      }\r\n      expr = parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n      expr = parseAssignmentExpression(parser, context, 0, 0, start, line, column, expr);\r\n      if (parser.token === 1073741842) {\r\n          expr = parseSequenceExpression(parser, context, 0, start, line, column, expr);\r\n      }\r\n      return parseExpressionStatement(parser, context, expr, start, line, column);\r\n  }\r\n  function parseBlock(parser, context, scope, labels, start, line, column) {\r\n      const body = [];\r\n      consume(parser, context | 32768, 2162700);\r\n      while (parser.token !== 1074790415) {\r\n          body.push(parseStatementListItem(parser, context, scope, 2, { $: labels }, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      consume(parser, context | 32768, 1074790415);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'BlockStatement',\r\n          body\r\n      });\r\n  }\r\n  function parseReturnStatement(parser, context, start, line, column) {\r\n      if ((context & 32) < 1 && context & 8192)\r\n          report(parser, 89);\r\n      nextToken(parser, context | 32768);\r\n      const argument = parser.flags & 1 || parser.token & 1048576\r\n          ? null\r\n          : parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.line, parser.column);\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ReturnStatement',\r\n          argument\r\n      });\r\n  }\r\n  function parseExpressionStatement(parser, context, expression, start, line, column) {\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ExpressionStatement',\r\n          expression\r\n      });\r\n  }\r\n  function parseLabelledStatement(parser, context, scope, origin, labels, value, expr, token, allowFuncDecl, start, line, column) {\r\n      validateBindingIdentifier(parser, context, 0, token, 1);\r\n      validateAndDeclareLabel(parser, labels, value);\r\n      nextToken(parser, context | 32768);\r\n      const body = allowFuncDecl &&\r\n          (context & 1024) < 1 &&\r\n          context & 256 &&\r\n          parser.token === 86103\r\n          ? parseFunctionDeclaration(parser, context, addChildScope(scope, 2), origin, 0, 0, 0, parser.tokenPos, parser.linePos, parser.colPos)\r\n          : parseStatement(parser, context, scope, origin, labels, allowFuncDecl, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'LabeledStatement',\r\n          label: expr,\r\n          body\r\n      });\r\n  }\r\n  function parseAsyncArrowOrAsyncFunctionDeclaration(parser, context, scope, origin, labels, allowFuncDecl, start, line, column) {\r\n      const { token, tokenValue } = parser;\r\n      let expr = parseIdentifier(parser, context, 0);\r\n      if (parser.token === 21) {\r\n          return parseLabelledStatement(parser, context, scope, origin, labels, tokenValue, expr, token, 1, start, line, column);\r\n      }\r\n      const asyncNewLine = parser.flags & 1;\r\n      if (!asyncNewLine) {\r\n          if (parser.token === 86103) {\r\n              if (!allowFuncDecl)\r\n                  report(parser, 119);\r\n              return parseFunctionDeclaration(parser, context, scope, origin, 1, 0, 1, start, line, column);\r\n          }\r\n          if ((parser.token & 143360) === 143360) {\r\n              expr = parseAsyncArrowAfterIdent(parser, context, 1, start, line, column);\r\n              if (parser.token === 1073741842)\r\n                  expr = parseSequenceExpression(parser, context, 0, start, line, column, expr);\r\n              return parseExpressionStatement(parser, context, expr, start, line, column);\r\n          }\r\n      }\r\n      if (parser.token === 67174411) {\r\n          expr = parseAsyncArrowOrCallExpression(parser, context, expr, 1, 1, 0, asyncNewLine, start, line, column);\r\n      }\r\n      else {\r\n          if (parser.token === 10) {\r\n              classifyIdentifier(parser, context, token, 1);\r\n              expr = parseArrowFromIdentifier(parser, context, parser.tokenValue, expr, 0, 1, 0, start, line, column);\r\n          }\r\n          parser.assignable = 1;\r\n      }\r\n      expr = parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n      if (parser.token === 1073741842)\r\n          expr = parseSequenceExpression(parser, context, 0, start, line, column, expr);\r\n      expr = parseAssignmentExpression(parser, context, 0, 0, start, line, column, expr);\r\n      parser.assignable = 1;\r\n      return parseExpressionStatement(parser, context, expr, start, line, column);\r\n  }\r\n  function parseDirective(parser, context, expression, token, start, line, column) {\r\n      const { tokenRaw } = parser;\r\n      if (token !== 1074790417) {\r\n          parser.assignable = 2;\r\n          expression = parseMemberOrUpdateExpression(parser, context, expression, 0, start, line, column);\r\n          if (parser.token !== 1074790417) {\r\n              expression = parseAssignmentExpression(parser, context, 0, 0, start, line, column, expression);\r\n              if (parser.token === 1073741842) {\r\n                  expression = parseSequenceExpression(parser, context, 0, start, line, column, expression);\r\n              }\r\n          }\r\n          matchOrInsertSemicolon(parser, context | 32768);\r\n      }\r\n      return context & 8\r\n          ? finishNode(parser, context, start, line, column, {\r\n              type: 'ExpressionStatement',\r\n              expression,\r\n              directive: tokenRaw.slice(1, -1)\r\n          })\r\n          : finishNode(parser, context, start, line, column, {\r\n              type: 'ExpressionStatement',\r\n              expression\r\n          });\r\n  }\r\n  function parseEmptyStatement(parser, context, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'EmptyStatement'\r\n      });\r\n  }\r\n  function parseThrowStatement(parser, context, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      if (parser.flags & 1)\r\n          report(parser, 87);\r\n      const argument = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ThrowStatement',\r\n          argument\r\n      });\r\n  }\r\n  function parseIfStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context);\r\n      consume(parser, context | 32768, 67174411);\r\n      parser.assignable = 1;\r\n      const test = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.line, parser.colPos);\r\n      consume(parser, context | 32768, 16);\r\n      const consequent = parseConsequentOrAlternative(parser, context, scope, labels, parser.tokenPos, parser.linePos, parser.colPos);\r\n      let alternate = null;\r\n      if (parser.token === 20562) {\r\n          nextToken(parser, context | 32768);\r\n          alternate = parseConsequentOrAlternative(parser, context, scope, labels, parser.tokenPos, parser.linePos, parser.colPos);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'IfStatement',\r\n          test,\r\n          consequent,\r\n          alternate\r\n      });\r\n  }\r\n  function parseConsequentOrAlternative(parser, context, scope, labels, start, line, column) {\r\n      return context & 1024 ||\r\n          (context & 256) < 1 ||\r\n          parser.token !== 86103\r\n          ? parseStatement(parser, context, scope, 0, { $: labels }, 0, parser.tokenPos, parser.linePos, parser.colPos)\r\n          : parseFunctionDeclaration(parser, context, addChildScope(scope, 2), 0, 0, 0, 0, start, line, column);\r\n  }\r\n  function parseSwitchStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context);\r\n      consume(parser, context | 32768, 67174411);\r\n      const discriminant = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context, 16);\r\n      consume(parser, context, 2162700);\r\n      const cases = [];\r\n      let seenDefault = 0;\r\n      if (scope)\r\n          scope = addChildScope(scope, 8);\r\n      while (parser.token !== 1074790415) {\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          let test = null;\r\n          const consequent = [];\r\n          if (consumeOpt(parser, context | 32768, 20555)) {\r\n              test = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n          }\r\n          else {\r\n              consume(parser, context | 32768, 20560);\r\n              if (seenDefault)\r\n                  report(parser, 86);\r\n              seenDefault = 1;\r\n          }\r\n          consume(parser, context | 32768, 21);\r\n          while (parser.token !== 20555 &&\r\n              parser.token !== 1074790415 &&\r\n              parser.token !== 20560) {\r\n              consequent.push(parseStatementListItem(parser, context | 4096, scope, 2, {\r\n                  $: labels\r\n              }, parser.tokenPos, parser.linePos, parser.colPos));\r\n          }\r\n          cases.push(finishNode(parser, context, tokenPos, linePos, colPos, {\r\n              type: 'SwitchCase',\r\n              test,\r\n              consequent\r\n          }));\r\n      }\r\n      consume(parser, context | 32768, 1074790415);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'SwitchStatement',\r\n          discriminant,\r\n          cases\r\n      });\r\n  }\r\n  function parseWhileStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context);\r\n      consume(parser, context | 32768, 67174411);\r\n      const test = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 16);\r\n      const body = parseIterationStatementBody(parser, context, scope, labels);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'WhileStatement',\r\n          test,\r\n          body\r\n      });\r\n  }\r\n  function parseIterationStatementBody(parser, context, scope, labels) {\r\n      return parseStatement(parser, ((context | 134217728) ^ 134217728) | 131072, scope, 0, { loop: 1, $: labels }, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n  }\r\n  function parseContinueStatement(parser, context, labels, start, line, column) {\r\n      if ((context & 131072) < 1)\r\n          report(parser, 65);\r\n      nextToken(parser, context);\r\n      let label = null;\r\n      if ((parser.flags & 1) < 1 && parser.token & 143360) {\r\n          const { tokenValue } = parser;\r\n          label = parseIdentifier(parser, context | 32768, 0);\r\n          if (!isValidLabel(parser, labels, tokenValue, 1))\r\n              report(parser, 134, tokenValue);\r\n      }\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ContinueStatement',\r\n          label\r\n      });\r\n  }\r\n  function parseBreakStatement(parser, context, labels, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      let label = null;\r\n      if ((parser.flags & 1) < 1 && parser.token & 143360) {\r\n          const { tokenValue } = parser;\r\n          label = parseIdentifier(parser, context | 32768, 0);\r\n          if (!isValidLabel(parser, labels, tokenValue, 0))\r\n              report(parser, 134, tokenValue);\r\n      }\r\n      else if ((context & (4096 | 131072)) < 1) {\r\n          report(parser, 66);\r\n      }\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'BreakStatement',\r\n          label\r\n      });\r\n  }\r\n  function parseWithStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context);\r\n      if (context & 1024)\r\n          report(parser, 88);\r\n      consume(parser, context | 32768, 67174411);\r\n      const object = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 16);\r\n      const body = parseStatement(parser, context, scope, 2, labels, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'WithStatement',\r\n          object,\r\n          body\r\n      });\r\n  }\r\n  function parseDebuggerStatement(parser, context, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'DebuggerStatement'\r\n      });\r\n  }\r\n  function parseTryStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const firstScope = scope ? addChildScope(scope, 32) : void 0;\r\n      const block = parseBlock(parser, context, firstScope, { $: labels }, parser.tokenPos, parser.linePos, parser.colPos);\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      const handler = consumeOpt(parser, context | 32768, 20556)\r\n          ? parseCatchBlock(parser, context, scope, labels, tokenPos, linePos, colPos)\r\n          : null;\r\n      let finalizer = null;\r\n      if (parser.token === 20565) {\r\n          nextToken(parser, context | 32768);\r\n          const finalizerScope = firstScope ? addChildScope(scope, 4) : void 0;\r\n          finalizer = parseBlock(parser, context, finalizerScope, { $: labels }, tokenPos, linePos, colPos);\r\n      }\r\n      if (!handler && !finalizer) {\r\n          report(parser, 85);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'TryStatement',\r\n          block,\r\n          handler,\r\n          finalizer\r\n      });\r\n  }\r\n  function parseCatchBlock(parser, context, scope, labels, start, line, column) {\r\n      let param = null;\r\n      let additionalScope = scope;\r\n      if (consumeOpt(parser, context, 67174411)) {\r\n          if (scope)\r\n              scope = addChildScope(scope, 4);\r\n          param = parseBindingPattern(parser, context, scope, (parser.token & 2097152) === 2097152\r\n              ? 256\r\n              : 512, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n          if (parser.token === 1073741842) {\r\n              report(parser, 83);\r\n          }\r\n          else if (parser.token === 1077936157) {\r\n              report(parser, 84);\r\n          }\r\n          consume(parser, context | 32768, 16);\r\n          if (scope)\r\n              additionalScope = addChildScope(scope, 64);\r\n      }\r\n      const body = parseBlock(parser, context, additionalScope, { $: labels }, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'CatchClause',\r\n          param,\r\n          body\r\n      });\r\n  }\r\n  function parseDoWhileStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const body = parseIterationStatementBody(parser, context, scope, labels);\r\n      consume(parser, context, 20577);\r\n      consume(parser, context | 32768, 67174411);\r\n      const test = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 16);\r\n      matchOrInsertSemicolon(parser, context | 32768, context & 536870912);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'DoWhileStatement',\r\n          body,\r\n          test\r\n      });\r\n  }\r\n  function parseLetIdentOrVarDeclarationStatement(parser, context, scope, origin, start, line, column) {\r\n      const { token, tokenValue } = parser;\r\n      let expr = parseIdentifier(parser, context, 0);\r\n      if (parser.token & (143360 | 2097152)) {\r\n          const declarations = parseVariableDeclarationList(parser, context, scope, 8, 0);\r\n          matchOrInsertSemicolon(parser, context | 32768);\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'VariableDeclaration',\r\n              kind: 'let',\r\n              declarations\r\n          });\r\n      }\r\n      parser.assignable = 1;\r\n      if (context & 1024)\r\n          report(parser, 82);\r\n      if (parser.token === 21) {\r\n          return parseLabelledStatement(parser, context, scope, origin, {}, tokenValue, expr, token, 0, start, line, column);\r\n      }\r\n      if (parser.token === 10) {\r\n          let scope = void 0;\r\n          if (context & 64)\r\n              scope = createArrowHeadParsingScope(parser, context, tokenValue);\r\n          parser.flags = (parser.flags | 128) ^ 128;\r\n          expr = parseArrowFunctionExpression(parser, context, scope, [expr], 0, start, line, column);\r\n      }\r\n      else {\r\n          expr = parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n          expr = parseAssignmentExpression(parser, context, 0, 0, start, line, column, expr);\r\n      }\r\n      if (parser.token === 1073741842) {\r\n          expr = parseSequenceExpression(parser, context, 0, start, line, column, expr);\r\n      }\r\n      return parseExpressionStatement(parser, context, expr, start, line, column);\r\n  }\r\n  function parseLexicalDeclaration(parser, context, scope, kind, origin, start, line, column) {\r\n      nextToken(parser, context);\r\n      const declarations = parseVariableDeclarationList(parser, context, scope, kind, origin);\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'VariableDeclaration',\r\n          kind: kind & 8 ? 'let' : 'const',\r\n          declarations\r\n      });\r\n  }\r\n  function parseVariableStatement(parser, context, scope, origin, start, line, column) {\r\n      nextToken(parser, context);\r\n      const declarations = parseVariableDeclarationList(parser, context, scope, 4, origin);\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'VariableDeclaration',\r\n          kind: 'var',\r\n          declarations\r\n      });\r\n  }\r\n  function parseVariableDeclarationList(parser, context, scope, kind, origin) {\r\n      let bindingCount = 1;\r\n      const list = [parseVariableDeclaration(parser, context, scope, kind, origin)];\r\n      while (consumeOpt(parser, context, 1073741842)) {\r\n          bindingCount++;\r\n          list.push(parseVariableDeclaration(parser, context, scope, kind, origin));\r\n      }\r\n      if (bindingCount > 1 && origin & 32 && parser.token & 262144) {\r\n          report(parser, 58, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      return list;\r\n  }\r\n  function parseVariableDeclaration(parser, context, scope, kind, origin) {\r\n      const { token, tokenPos, linePos, colPos } = parser;\r\n      let init = null;\r\n      const id = parseBindingPattern(parser, context, scope, kind, origin, tokenPos, linePos, colPos);\r\n      if (parser.token === 1077936157) {\r\n          nextToken(parser, context | 32768);\r\n          init = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n          if (origin & 32 || (token & 2097152) < 1) {\r\n              if (parser.token === 274546 ||\r\n                  (parser.token === 8738865 &&\r\n                      (token & 2097152 ||\r\n                          (kind & 4) < 1 ||\r\n                          (context & 256) < 1 ||\r\n                          context & 1024))) {\r\n                  reportMessageAt(tokenPos, parser.line, parser.index - 3, 57, parser.token === 274546 ? 'of' : 'in');\r\n              }\r\n          }\r\n      }\r\n      else if ((kind & 16 || (token & 2097152) > 0) &&\r\n          (parser.token & 262144) !== 262144) {\r\n          report(parser, 56, kind & 16 ? 'const' : 'destructuring');\r\n      }\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'VariableDeclarator',\r\n          id,\r\n          init\r\n      });\r\n  }\r\n  function parseForStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context);\r\n      const forAwait = (context & 4194304) > 0 && consumeOpt(parser, context, 209005);\r\n      consume(parser, context | 32768, 67174411);\r\n      if (scope)\r\n          scope = addChildScope(scope, 1);\r\n      let test = null;\r\n      let update = null;\r\n      let destructible = 0;\r\n      let init = null;\r\n      let isVarDecl = parser.token === 86087 || parser.token === 241736 || parser.token === 86089;\r\n      let right;\r\n      const { token, tokenPos, linePos, colPos } = parser;\r\n      if (isVarDecl) {\r\n          if (token === 241736) {\r\n              init = parseIdentifier(parser, context, 0);\r\n              if (parser.token & (143360 | 2097152)) {\r\n                  if (parser.token === 8738865) {\r\n                      if (context & 1024)\r\n                          report(parser, 64);\r\n                  }\r\n                  else {\r\n                      init = finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                          type: 'VariableDeclaration',\r\n                          kind: 'let',\r\n                          declarations: parseVariableDeclarationList(parser, context | 134217728, scope, 8, 32)\r\n                      });\r\n                  }\r\n                  parser.assignable = 1;\r\n              }\r\n              else if (context & 1024) {\r\n                  report(parser, 64);\r\n              }\r\n              else {\r\n                  isVarDecl = false;\r\n                  parser.assignable = 1;\r\n                  init = parseMemberOrUpdateExpression(parser, context, init, 0, tokenPos, linePos, colPos);\r\n                  if (parser.token === 274546)\r\n                      report(parser, 111);\r\n              }\r\n          }\r\n          else {\r\n              nextToken(parser, context);\r\n              init = finishNode(parser, context, tokenPos, linePos, colPos, token === 86087\r\n                  ? {\r\n                      type: 'VariableDeclaration',\r\n                      kind: 'var',\r\n                      declarations: parseVariableDeclarationList(parser, context | 134217728, scope, 4, 32)\r\n                  }\r\n                  : {\r\n                      type: 'VariableDeclaration',\r\n                      kind: 'const',\r\n                      declarations: parseVariableDeclarationList(parser, context | 134217728, scope, 16, 32)\r\n                  });\r\n              parser.assignable = 1;\r\n          }\r\n      }\r\n      else if (token === 1074790417) {\r\n          if (forAwait)\r\n              report(parser, 79);\r\n      }\r\n      else if ((token & 2097152) === 2097152) {\r\n          init =\r\n              token === 2162700\r\n                  ? parseObjectLiteralOrPattern(parser, context, void 0, 1, 0, 0, 2, 32, tokenPos, linePos, colPos)\r\n                  : parseArrayExpressionOrPattern(parser, context, void 0, 1, 0, 0, 2, 32, tokenPos, linePos, colPos);\r\n          destructible = parser.destructible;\r\n          if (context & 256 && destructible & 64) {\r\n              report(parser, 60);\r\n          }\r\n          parser.assignable =\r\n              destructible & 16 ? 2 : 1;\r\n          init = parseMemberOrUpdateExpression(parser, context | 134217728, init, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      }\r\n      else {\r\n          init = parseLeftHandSideExpression(parser, context | 134217728, 1, 0, 1, tokenPos, linePos, colPos);\r\n      }\r\n      if ((parser.token & 262144) === 262144) {\r\n          if (parser.token === 274546) {\r\n              if (parser.assignable & 2)\r\n                  report(parser, 77, forAwait ? 'await' : 'of');\r\n              reinterpretToPattern(parser, init);\r\n              nextToken(parser, context | 32768);\r\n              right = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n              consume(parser, context | 32768, 16);\r\n              const body = parseIterationStatementBody(parser, context, scope, labels);\r\n              return finishNode(parser, context, start, line, column, {\r\n                  type: 'ForOfStatement',\r\n                  left: init,\r\n                  right,\r\n                  body,\r\n                  await: forAwait\r\n              });\r\n          }\r\n          if (parser.assignable & 2)\r\n              report(parser, 77, 'in');\r\n          reinterpretToPattern(parser, init);\r\n          nextToken(parser, context | 32768);\r\n          if (forAwait)\r\n              report(parser, 79);\r\n          right = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n          consume(parser, context | 32768, 16);\r\n          const body = parseIterationStatementBody(parser, context, scope, labels);\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'ForInStatement',\r\n              body,\r\n              left: init,\r\n              right\r\n          });\r\n      }\r\n      if (forAwait)\r\n          report(parser, 79);\r\n      if (!isVarDecl) {\r\n          if (destructible & 8 && parser.token !== 1077936157) {\r\n              report(parser, 77, 'loop');\r\n          }\r\n          init = parseAssignmentExpression(parser, context | 134217728, 0, 0, tokenPos, linePos, colPos, init);\r\n      }\r\n      if (parser.token === 1073741842)\r\n          init = parseSequenceExpression(parser, context, 0, parser.tokenPos, parser.linePos, parser.colPos, init);\r\n      consume(parser, context | 32768, 1074790417);\r\n      if (parser.token !== 1074790417)\r\n          test = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 1074790417);\r\n      if (parser.token !== 16)\r\n          update = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 16);\r\n      const body = parseIterationStatementBody(parser, context, scope, labels);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ForStatement',\r\n          init,\r\n          test,\r\n          update,\r\n          body\r\n      });\r\n  }\r\n  function parseRestrictedIdentifier(parser, context, scope) {\r\n      if (!isValidIdentifier(context, parser.token))\r\n          report(parser, 114);\r\n      if ((parser.token & 537079808) === 537079808)\r\n          report(parser, 115);\r\n      if (scope)\r\n          addBlockName(parser, context, scope, parser.tokenValue, 8, 0);\r\n      return parseIdentifier(parser, context, 0);\r\n  }\r\n  function parseImportDeclaration(parser, context, scope, start, line, column) {\r\n      nextToken(parser, context);\r\n      let source = null;\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      let specifiers = [];\r\n      if (parser.token === 134283267) {\r\n          source = parseLiteral(parser, context);\r\n      }\r\n      else {\r\n          if (parser.token & 143360) {\r\n              const local = parseRestrictedIdentifier(parser, context, scope);\r\n              specifiers = [\r\n                  finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                      type: 'ImportDefaultSpecifier',\r\n                      local\r\n                  })\r\n              ];\r\n              if (consumeOpt(parser, context, 1073741842)) {\r\n                  switch (parser.token) {\r\n                      case 8457011:\r\n                          specifiers.push(parseImportNamespaceSpecifier(parser, context, scope));\r\n                          break;\r\n                      case 2162700:\r\n                          parseImportSpecifierOrNamedImports(parser, context, scope, specifiers);\r\n                          break;\r\n                      default:\r\n                          report(parser, 104);\r\n                  }\r\n              }\r\n          }\r\n          else {\r\n              switch (parser.token) {\r\n                  case 8457011:\r\n                      specifiers = [parseImportNamespaceSpecifier(parser, context, scope)];\r\n                      break;\r\n                  case 2162700:\r\n                      parseImportSpecifierOrNamedImports(parser, context, scope, specifiers);\r\n                      break;\r\n                  case 67174411:\r\n                      return parseImportCallDeclaration(parser, context, start, line, column);\r\n                  case 67108877:\r\n                      if (context & 1) {\r\n                          return parseImportMetaDeclaration(parser, context, start, line, column);\r\n                      }\r\n                  default:\r\n                      report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n              }\r\n          }\r\n          source = parseModuleSpecifier(parser, context);\r\n      }\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ImportDeclaration',\r\n          specifiers,\r\n          source\r\n      });\r\n  }\r\n  function parseImportNamespaceSpecifier(parser, context, scope) {\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      nextToken(parser, context);\r\n      consume(parser, context, 12395);\r\n      if ((parser.token & 134217728) === 134217728) {\r\n          reportMessageAt(tokenPos, parser.line, parser.index, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'ImportNamespaceSpecifier',\r\n          local: parseRestrictedIdentifier(parser, context, scope)\r\n      });\r\n  }\r\n  function parseModuleSpecifier(parser, context) {\r\n      consumeOpt(parser, context, 12401);\r\n      if (parser.token !== 134283267)\r\n          report(parser, 102, 'Import');\r\n      return parseLiteral(parser, context);\r\n  }\r\n  function parseImportSpecifierOrNamedImports(parser, context, scope, specifiers) {\r\n      nextToken(parser, context);\r\n      while (parser.token & 143360) {\r\n          let { token, tokenValue, tokenPos, linePos, colPos } = parser;\r\n          const imported = parseIdentifier(parser, context, 0);\r\n          let local;\r\n          if (consumeOpt(parser, context, 12395)) {\r\n              if ((parser.token & 134217728) === 134217728 || parser.token === 1073741842) {\r\n                  report(parser, 103);\r\n              }\r\n              else {\r\n                  validateBindingIdentifier(parser, context, 16, parser.token, 0);\r\n              }\r\n              tokenValue = parser.tokenValue;\r\n              local = parseIdentifier(parser, context, 0);\r\n          }\r\n          else {\r\n              validateBindingIdentifier(parser, context, 16, token, 0);\r\n              local = imported;\r\n          }\r\n          if (scope)\r\n              addBlockName(parser, context, scope, tokenValue, 8, 0);\r\n          specifiers.push(finishNode(parser, context, tokenPos, linePos, colPos, {\r\n              type: 'ImportSpecifier',\r\n              local,\r\n              imported\r\n          }));\r\n          if (parser.token !== 1074790415)\r\n              consume(parser, context, 1073741842);\r\n      }\r\n      consume(parser, context, 1074790415);\r\n      return specifiers;\r\n  }\r\n  function parseImportMetaDeclaration(parser, context, start, line, column) {\r\n      let expr = parseImportMetaExpression(parser, context, finishNode(parser, context, start, line, column, {\r\n          type: 'Identifier',\r\n          name: 'import'\r\n      }), start, line, column);\r\n      expr = parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n      expr = parseAssignmentExpression(parser, context, 0, 0, start, line, column, expr);\r\n      return parseExpressionStatement(parser, context, expr, start, line, column);\r\n  }\r\n  function parseImportCallDeclaration(parser, context, start, line, column) {\r\n      let expr = parseImportExpression(parser, context, 0, start, line, column);\r\n      expr = parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n      return parseExpressionStatement(parser, context, expr, start, line, column);\r\n  }\r\n  function parseExportDeclaration(parser, context, scope, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      let specifiers = [];\r\n      let declaration = null;\r\n      let source = null;\r\n      let key;\r\n      if (consumeOpt(parser, context | 32768, 20560)) {\r\n          switch (parser.token) {\r\n              case 86103: {\r\n                  declaration = parseFunctionDeclaration(parser, context, scope, 4, 1, 1, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  break;\r\n              }\r\n              case 130:\r\n              case 86093:\r\n                  declaration = parseClassDeclaration(parser, context, scope, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  break;\r\n              case 143468:\r\n                  const { tokenPos, linePos, colPos } = parser;\r\n                  declaration = parseIdentifier(parser, context, 0);\r\n                  const { flags } = parser;\r\n                  if ((flags & 1) < 1) {\r\n                      if (parser.token === 86103) {\r\n                          declaration = parseFunctionDeclaration(parser, context, scope, 4, 1, 1, 1, tokenPos, linePos, colPos);\r\n                      }\r\n                      else {\r\n                          if (parser.token === 67174411) {\r\n                              declaration = parseAsyncArrowOrCallExpression(parser, context, declaration, 1, 1, 0, flags, tokenPos, linePos, colPos);\r\n                              declaration = parseMemberOrUpdateExpression(parser, context, declaration, 0, tokenPos, linePos, colPos);\r\n                              declaration = parseAssignmentExpression(parser, context, 0, 0, tokenPos, linePos, colPos, declaration);\r\n                          }\r\n                          else if (parser.token & 143360) {\r\n                              if (scope)\r\n                                  scope = createArrowHeadParsingScope(parser, context, parser.tokenValue);\r\n                              declaration = parseIdentifier(parser, context, 0);\r\n                              declaration = parseArrowFunctionExpression(parser, context, scope, [declaration], 1, tokenPos, linePos, colPos);\r\n                          }\r\n                      }\r\n                  }\r\n                  break;\r\n              default:\r\n                  declaration = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  matchOrInsertSemicolon(parser, context | 32768);\r\n          }\r\n          if (scope)\r\n              declareUnboundVariable(parser, 'default');\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'ExportDefaultDeclaration',\r\n              declaration\r\n          });\r\n      }\r\n      switch (parser.token) {\r\n          case 8457011: {\r\n              nextToken(parser, context);\r\n              const isNamedDeclaration = consumeOpt(parser, context, 12395);\r\n              if (isNamedDeclaration) {\r\n                  if (scope)\r\n                      declareUnboundVariable(parser, parser.tokenValue);\r\n                  specifiers = [\r\n                      finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                          type: 'ExportNamespaceSpecifier',\r\n                          specifier: parseIdentifier(parser, context, 0)\r\n                      })\r\n                  ];\r\n              }\r\n              consume(parser, context, 12401);\r\n              if (parser.token !== 134283267)\r\n                  report(parser, 102, 'Export');\r\n              source = parseLiteral(parser, context);\r\n              matchOrInsertSemicolon(parser, context | 32768);\r\n              return isNamedDeclaration\r\n                  ? finishNode(parser, context, start, line, column, {\r\n                      type: 'ExportNamedDeclaration',\r\n                      source,\r\n                      specifiers\r\n                  })\r\n                  : finishNode(parser, context, start, line, column, {\r\n                      type: 'ExportAllDeclaration',\r\n                      source\r\n                  });\r\n          }\r\n          case 2162700: {\r\n              nextToken(parser, context);\r\n              const tmpExportedNames = [];\r\n              const tmpExportedBindings = [];\r\n              while (parser.token & 143360) {\r\n                  const { tokenPos, tokenValue, linePos, colPos } = parser;\r\n                  const local = parseIdentifier(parser, context, 0);\r\n                  let exported;\r\n                  if (parser.token === 12395) {\r\n                      nextToken(parser, context);\r\n                      if ((parser.token & 134217728) === 134217728) {\r\n                          report(parser, 103);\r\n                      }\r\n                      if (scope) {\r\n                          tmpExportedNames.push(parser.tokenValue);\r\n                          tmpExportedBindings.push(tokenValue);\r\n                      }\r\n                      exported = parseIdentifier(parser, context, 0);\r\n                  }\r\n                  else {\r\n                      if (scope) {\r\n                          tmpExportedNames.push(parser.tokenValue);\r\n                          tmpExportedBindings.push(parser.tokenValue);\r\n                      }\r\n                      exported = local;\r\n                  }\r\n                  specifiers.push(finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                      type: 'ExportSpecifier',\r\n                      local,\r\n                      exported\r\n                  }));\r\n                  if (parser.token !== 1074790415)\r\n                      consume(parser, context, 1073741842);\r\n              }\r\n              consume(parser, context, 1074790415);\r\n              if (consumeOpt(parser, context, 12401)) {\r\n                  if (parser.token !== 134283267)\r\n                      report(parser, 102, 'Export');\r\n                  source = parseLiteral(parser, context);\r\n              }\r\n              else if (scope) {\r\n                  let i = 0;\r\n                  let iMax = tmpExportedNames.length;\r\n                  for (; i < iMax; i++) {\r\n                      declareUnboundVariable(parser, tmpExportedNames[i]);\r\n                  }\r\n                  i = 0;\r\n                  iMax = tmpExportedBindings.length;\r\n                  for (; i < iMax; i++) {\r\n                      addBindingToExports(parser, tmpExportedBindings[i]);\r\n                  }\r\n              }\r\n              matchOrInsertSemicolon(parser, context | 32768);\r\n              break;\r\n          }\r\n          case 86093:\r\n              declaration = parseClassDeclaration(parser, context, scope, 2, parser.tokenPos, parser.linePos, parser.colPos);\r\n              break;\r\n          case 86103:\r\n              declaration = parseFunctionDeclaration(parser, context, scope, 4, 1, 2, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n              break;\r\n          case 241736:\r\n              declaration = parseLexicalDeclaration(parser, context, scope, 8, 64, parser.tokenPos, parser.linePos, parser.colPos);\r\n              break;\r\n          case 86089:\r\n              declaration = parseLexicalDeclaration(parser, context, scope, 16, 64, parser.tokenPos, parser.linePos, parser.colPos);\r\n              break;\r\n          case 86087:\r\n              declaration = parseVariableStatement(parser, context, scope, 64, parser.tokenPos, parser.linePos, parser.colPos);\r\n              break;\r\n          case 143468:\r\n              const { tokenPos, linePos, colPos } = parser;\r\n              nextToken(parser, context);\r\n              if ((parser.flags & 1) < 1 && parser.token === 86103) {\r\n                  declaration = parseFunctionDeclaration(parser, context, scope, 4, 1, 2, 1, tokenPos, linePos, colPos);\r\n                  if (scope) {\r\n                      key = declaration.id ? declaration.id.name : '';\r\n                      declareUnboundVariable(parser, key);\r\n                  }\r\n                  break;\r\n              }\r\n          default:\r\n              report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ExportNamedDeclaration',\r\n          declaration,\r\n          specifiers,\r\n          source\r\n      });\r\n  }\r\n  function parseExpression(parser, context, canAssign, isPattern, inGroup, start, line, column) {\r\n      let expr = parsePrimaryExpression(parser, context, 2, 0, canAssign, isPattern, inGroup, 1, start, line, column);\r\n      expr = parseMemberOrUpdateExpression(parser, context, expr, inGroup, start, line, column);\r\n      return parseAssignmentExpression(parser, context, inGroup, 0, start, line, column, expr);\r\n  }\r\n  function parseSequenceExpression(parser, context, inGroup, start, line, column, expr) {\r\n      const expressions = [expr];\r\n      while (consumeOpt(parser, context | 32768, 1073741842)) {\r\n          expressions.push(parseExpression(parser, context, 1, 0, inGroup, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'SequenceExpression',\r\n          expressions\r\n      });\r\n  }\r\n  function parseExpressions(parser, context, inGroup, canAssign, start, line, column) {\r\n      const expr = parseExpression(parser, context, canAssign, 0, inGroup, start, line, column);\r\n      return parser.token === 1073741842\r\n          ? parseSequenceExpression(parser, context, inGroup, start, line, column, expr)\r\n          : expr;\r\n  }\r\n  function parseAssignmentExpression(parser, context, inGroup, isPattern, start, line, column, left) {\r\n      const { token } = parser;\r\n      if ((token & 4194304) === 4194304) {\r\n          if (parser.assignable & 2)\r\n              report(parser, 24);\r\n          if ((!isPattern && (token === 1077936157 && left.type === 'ArrayExpression')) ||\r\n              left.type === 'ObjectExpression') {\r\n              reinterpretToPattern(parser, left);\r\n          }\r\n          nextToken(parser, context | 32768);\r\n          const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n          parser.assignable = 2;\r\n          return finishNode(parser, context, start, line, column, isPattern\r\n              ? {\r\n                  type: 'AssignmentPattern',\r\n                  left,\r\n                  right\r\n              }\r\n              : {\r\n                  type: 'AssignmentExpression',\r\n                  left,\r\n                  operator: KeywordDescTable[token & 255],\r\n                  right\r\n              });\r\n      }\r\n      if ((token & 8454144) === 8454144) {\r\n          left = parseBinaryExpression(parser, context, inGroup, start, line, column, 4, token, left);\r\n      }\r\n      if (consumeOpt(parser, context | 32768, 22)) {\r\n          left = parseConditionalExpression(parser, context, left, start, line, column);\r\n      }\r\n      return left;\r\n  }\r\n  function parseAssignmentExpressionOrPattern(parser, context, inGroup, isPattern, start, line, column, left) {\r\n      const { token } = parser;\r\n      nextToken(parser, context | 32768);\r\n      const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n      left = finishNode(parser, context, start, line, column, isPattern\r\n          ? {\r\n              type: 'AssignmentPattern',\r\n              left,\r\n              right\r\n          }\r\n          : {\r\n              type: 'AssignmentExpression',\r\n              left,\r\n              operator: KeywordDescTable[token & 255],\r\n              right\r\n          });\r\n      parser.assignable = 2;\r\n      return left;\r\n  }\r\n  function parseConditionalExpression(parser, context, test, start, line, column) {\r\n      const consequent = parseExpression(parser, (context | 134217728) ^ 134217728, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 21);\r\n      parser.assignable = 1;\r\n      const alternate = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ConditionalExpression',\r\n          test,\r\n          consequent,\r\n          alternate\r\n      });\r\n  }\r\n  function parseBinaryExpression(parser, context, inGroup, start, line, column, minPrec, operator, left) {\r\n      const bit = -((context & 134217728) > 0) & 8738865;\r\n      let t;\r\n      let prec;\r\n      parser.assignable = 2;\r\n      while (parser.token & 8454144) {\r\n          t = parser.token;\r\n          prec = t & 3840;\r\n          if ((t & 524288 && operator & 268435456) || (operator & 524288 && t & 268435456)) {\r\n              report(parser, 159);\r\n          }\r\n          if (prec + ((t === 8457270) << 8) - ((bit === t) << 12) <= minPrec)\r\n              break;\r\n          nextToken(parser, context | 32768);\r\n          left = finishNode(parser, context, start, line, column, {\r\n              type: t & 524288 ? 'LogicalExpression' : t & 268435456 ? 'CoalesceExpression' : 'BinaryExpression',\r\n              left,\r\n              right: parseBinaryExpression(parser, context, inGroup, parser.tokenPos, parser.linePos, parser.colPos, prec, t, parseLeftHandSideExpression(parser, context, 0, inGroup, 1, parser.tokenPos, parser.linePos, parser.colPos)),\r\n              operator: KeywordDescTable[t & 255]\r\n          });\r\n      }\r\n      if (parser.token === 1077936157)\r\n          report(parser, 24);\r\n      return left;\r\n  }\r\n  function parseUnaryExpression(parser, context, isLHS, start, line, column, inGroup) {\r\n      if (!isLHS)\r\n          report(parser, 0);\r\n      const unaryOperator = parser.token;\r\n      nextToken(parser, context | 32768);\r\n      const arg = parseLeftHandSideExpression(parser, context, 0, inGroup, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      if (parser.token === 8457270)\r\n          report(parser, 31);\r\n      if (context & 1024 && unaryOperator === 16863275) {\r\n          if (arg.type === 'Identifier') {\r\n              report(parser, 117);\r\n          }\r\n          else if (isPropertyWithPrivateFieldKey(arg)) {\r\n              report(parser, 123);\r\n          }\r\n      }\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'UnaryExpression',\r\n          operator: KeywordDescTable[unaryOperator & 255],\r\n          argument: arg,\r\n          prefix: true\r\n      });\r\n  }\r\n  function parseAsyncExpression(parser, context, inGroup, isLHS, canAssign, isPattern, inNew, start, line, column) {\r\n      const { token } = parser;\r\n      const expr = parseIdentifier(parser, context, isPattern);\r\n      const { flags } = parser;\r\n      if ((flags & 1) < 1) {\r\n          if (parser.token === 86103) {\r\n              return parseFunctionExpression(parser, context, 1, inGroup, start, line, column);\r\n          }\r\n          if ((parser.token & 143360) === 143360) {\r\n              if (!isLHS)\r\n                  report(parser, 0);\r\n              return parseAsyncArrowAfterIdent(parser, context, canAssign, start, line, column);\r\n          }\r\n      }\r\n      if (!inNew && parser.token === 67174411) {\r\n          return parseAsyncArrowOrCallExpression(parser, context, expr, canAssign, 1, 0, flags, start, line, column);\r\n      }\r\n      if (parser.token === 10) {\r\n          classifyIdentifier(parser, context, token, 1);\r\n          if (inNew)\r\n              report(parser, 48);\r\n          return parseArrowFromIdentifier(parser, context, parser.tokenValue, expr, inNew, canAssign, 0, start, line, column);\r\n      }\r\n      return expr;\r\n  }\r\n  function parseYieldExpression(parser, context, inGroup, canAssign, start, line, column) {\r\n      if (inGroup)\r\n          parser.destructible |= 256;\r\n      if (context & 2097152) {\r\n          nextToken(parser, context | 32768);\r\n          if (context & 8388608)\r\n              report(parser, 30);\r\n          if (!canAssign)\r\n              report(parser, 24);\r\n          if (parser.token === 22)\r\n              report(parser, 120);\r\n          let argument = null;\r\n          let delegate = false;\r\n          if ((parser.flags & 1) < 1) {\r\n              delegate = consumeOpt(parser, context | 32768, 8457011);\r\n              if (parser.token & 65536 || delegate) {\r\n                  argument = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n              }\r\n          }\r\n          parser.assignable = 2;\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'YieldExpression',\r\n              argument,\r\n              delegate\r\n          });\r\n      }\r\n      if (context & 1024)\r\n          report(parser, 94, 'yield');\r\n      return parseIdentifierOrArrow(parser, context, start, line, column);\r\n  }\r\n  function parseAwaitExpression(parser, context, inNew, inGroup, start, line, column) {\r\n      if (inGroup)\r\n          parser.destructible |= 128;\r\n      if (context & 4194304) {\r\n          if (inNew)\r\n              report(parser, 0);\r\n          if (context & 8388608) {\r\n              reportMessageAt(parser.index, parser.line, parser.index, 29);\r\n          }\r\n          nextToken(parser, context | 32768);\r\n          const argument = parseLeftHandSideExpression(parser, context, 0, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n          parser.assignable = 2;\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'AwaitExpression',\r\n              argument\r\n          });\r\n      }\r\n      if (context & 2048)\r\n          report(parser, 107, 'Await');\r\n      return parseIdentifierOrArrow(parser, context, start, line, column);\r\n  }\r\n  function parseFunctionBody(parser, context, scope, origin, firstRestricted, scopeError) {\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      consume(parser, context | 32768, 2162700);\r\n      const body = [];\r\n      const prevContext = context;\r\n      if (parser.token !== 1074790415) {\r\n          while (parser.token === 134283267) {\r\n              const { index, tokenPos, tokenValue, token } = parser;\r\n              const expr = parseLiteral(parser, context);\r\n              if (isValidStrictMode(parser, index, tokenPos, tokenValue)) {\r\n                  context |= 1024;\r\n                  if (parser.flags & 128) {\r\n                      reportMessageAt(parser.index, parser.line, parser.tokenPos, 63);\r\n                  }\r\n                  if (parser.flags & 64) {\r\n                      reportMessageAt(parser.index, parser.line, parser.tokenPos, 8);\r\n                  }\r\n              }\r\n              body.push(parseDirective(parser, context, expr, token, tokenPos, parser.linePos, parser.colPos));\r\n          }\r\n          if (context & 1024) {\r\n              if (firstRestricted) {\r\n                  if ((firstRestricted & 537079808) === 537079808) {\r\n                      report(parser, 115);\r\n                  }\r\n                  if ((firstRestricted & 36864) === 36864) {\r\n                      report(parser, 38);\r\n                  }\r\n              }\r\n              if (parser.flags & 512)\r\n                  report(parser, 115);\r\n              if (parser.flags & 256)\r\n                  report(parser, 114);\r\n          }\r\n          if (context & 64 &&\r\n              scope &&\r\n              (scopeError !== void 0 && (prevContext & 1024) < 1 && (context & 8192) < 1)) {\r\n              reportScopeError(scopeError);\r\n          }\r\n      }\r\n      parser.flags =\r\n          (parser.flags | 512 | 256 | 64) ^\r\n              (512 | 256 | 64);\r\n      parser.destructible = (parser.destructible | 256) ^ 256;\r\n      while (parser.token !== 1074790415) {\r\n          body.push(parseStatementListItem(parser, context, scope, 4, {}, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      consume(parser, origin & (16 | 8) ? context | 32768 : context, 1074790415);\r\n      parser.flags &= ~(128 | 64);\r\n      if (parser.token === 1077936157)\r\n          report(parser, 24);\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'BlockStatement',\r\n          body\r\n      });\r\n  }\r\n  function parseSuperExpression(parser, context, start, line, column) {\r\n      nextToken(parser, context);\r\n      switch (parser.token) {\r\n          case 67108988:\r\n              report(parser, 161);\r\n          case 67174411: {\r\n              if ((context & 524288) < 1)\r\n                  report(parser, 26);\r\n              if (context & 16384)\r\n                  report(parser, 143);\r\n              parser.assignable = 2;\r\n              break;\r\n          }\r\n          case 69271571:\r\n          case 67108877: {\r\n              if ((context & 262144) < 1)\r\n                  report(parser, 27);\r\n              if (context & 16384)\r\n                  report(parser, 143);\r\n              parser.assignable = 1;\r\n              break;\r\n          }\r\n          default:\r\n              report(parser, 28, 'super');\r\n      }\r\n      return finishNode(parser, context, start, line, column, { type: 'Super' });\r\n  }\r\n  function parseLeftHandSideExpression(parser, context, canAssign, inGroup, isLHS, start, line, column) {\r\n      const expression = parsePrimaryExpression(parser, context, 2, 0, canAssign, 0, inGroup, isLHS, start, line, column);\r\n      return parseMemberOrUpdateExpression(parser, context, expression, inGroup, start, line, column);\r\n  }\r\n  function parseUpdateExpression(parser, context, expr, start, line, column) {\r\n      if (parser.assignable & 2)\r\n          report(parser, 52);\r\n      const { token } = parser;\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'UpdateExpression',\r\n          argument: expr,\r\n          operator: KeywordDescTable[token & 255],\r\n          prefix: false\r\n      });\r\n  }\r\n  function parseMemberOrUpdateExpression(parser, context, expr, inGroup, start, line, column) {\r\n      if ((parser.token & 33619968) === 33619968 && (parser.flags & 1) < 1) {\r\n          return parseUpdateExpression(parser, context, expr, start, line, column);\r\n      }\r\n      if ((parser.token & 67108864) === 67108864) {\r\n          context = (context | 134217728 | 8192) ^ (134217728 | 8192);\r\n          switch (parser.token) {\r\n              case 67108877: {\r\n                  nextToken(parser, context | 1073741824);\r\n                  parser.assignable = 1;\r\n                  const property = parsePropertyOrPrivatePropertyName(parser, context);\r\n                  expr = finishNode(parser, context, start, line, column, {\r\n                      type: 'MemberExpression',\r\n                      object: expr,\r\n                      computed: false,\r\n                      property\r\n                  });\r\n                  break;\r\n              }\r\n              case 69271571: {\r\n                  nextToken(parser, context | 32768);\r\n                  const { tokenPos, linePos, colPos } = parser;\r\n                  const property = parseExpressions(parser, context, inGroup, 1, tokenPos, linePos, colPos);\r\n                  consume(parser, context, 20);\r\n                  parser.assignable = 1;\r\n                  expr = finishNode(parser, context, start, line, column, {\r\n                      type: 'MemberExpression',\r\n                      object: expr,\r\n                      computed: true,\r\n                      property\r\n                  });\r\n                  break;\r\n              }\r\n              case 67174411: {\r\n                  if ((parser.flags & 1024) === 1024) {\r\n                      parser.flags = (parser.flags | 1024) ^ 1024;\r\n                      return expr;\r\n                  }\r\n                  const args = parseArguments(parser, context, inGroup);\r\n                  parser.assignable = 2;\r\n                  expr = finishNode(parser, context, start, line, column, {\r\n                      type: 'CallExpression',\r\n                      callee: expr,\r\n                      arguments: args\r\n                  });\r\n                  break;\r\n              }\r\n              case 67108988: {\r\n                  nextToken(parser, context);\r\n                  parser.assignable = 2;\r\n                  expr = finishNode(parser, context, start, line, column, {\r\n                      type: 'OptionalExpression',\r\n                      object: expr,\r\n                      chain: parseOptionalChain(parser, context, start, line, column)\r\n                  });\r\n                  break;\r\n              }\r\n              default:\r\n                  parser.assignable = 2;\r\n                  expr = finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                      type: 'TaggedTemplateExpression',\r\n                      tag: expr,\r\n                      quasi: parser.token === 67174408\r\n                          ? parseTemplate(parser, context | 65536, start, line, column)\r\n                          : parseTemplateLiteral(parser, context, start, line, column)\r\n                  });\r\n          }\r\n          return parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n      }\r\n      return expr;\r\n  }\r\n  function parseOptionalChain(parser, context, start, line, column) {\r\n      let base = null;\r\n      if (parser.token === 69271571) {\r\n          nextToken(parser, context | 32768);\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          const property = parseExpressions(parser, context, 0, 1, tokenPos, linePos, colPos);\r\n          consume(parser, context, 20);\r\n          parser.assignable = 2;\r\n          base = finishNode(parser, context, tokenPos, linePos, colPos, {\r\n              type: 'OptionalChain',\r\n              base: null,\r\n              computed: true,\r\n              property\r\n          });\r\n      }\r\n      else if (parser.token === 67174411) {\r\n          const args = parseArguments(parser, context, 0);\r\n          parser.assignable = 2;\r\n          base = finishNode(parser, context, start, line, column, {\r\n              type: 'OptionalChain',\r\n              base: null,\r\n              arguments: args\r\n          });\r\n      }\r\n      else {\r\n          if ((parser.token & (143360 | 4096)) < 1)\r\n              report(parser, 154);\r\n          const property = parseIdentifier(parser, context, 0);\r\n          parser.assignable = 2;\r\n          base = finishNode(parser, context, start, line, column, {\r\n              type: 'OptionalChain',\r\n              base: null,\r\n              computed: false,\r\n              property\r\n          });\r\n      }\r\n      while ((parser.token & 67108864) === 67108864) {\r\n          if (parser.token === 67108877) {\r\n              nextToken(parser, context);\r\n              parser.assignable = 1;\r\n              if ((parser.token & (143360 | 4096)) < 1)\r\n                  report(parser, 154);\r\n              const property = parseIdentifier(parser, context, 0);\r\n              base = finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                  type: 'OptionalChain',\r\n                  base,\r\n                  computed: false,\r\n                  property\r\n              });\r\n          }\r\n          else if (parser.token === 69271571) {\r\n              nextToken(parser, context | 32768);\r\n              const { tokenPos, linePos, colPos } = parser;\r\n              const property = parseExpressions(parser, context, 0, 1, tokenPos, linePos, colPos);\r\n              consume(parser, context, 20);\r\n              parser.assignable = 2;\r\n              base = finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                  type: 'OptionalChain',\r\n                  base,\r\n                  computed: true,\r\n                  property\r\n              });\r\n          }\r\n          else if (parser.token === 67174411) {\r\n              const args = parseArguments(parser, context, 0);\r\n              parser.assignable = 2;\r\n              base = finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                  type: 'OptionalChain',\r\n                  base,\r\n                  arguments: args\r\n              });\r\n          }\r\n          else if (parser.token === 67174408 || parser.token === 67174409) {\r\n              report(parser, 160);\r\n          }\r\n          else {\r\n              break;\r\n          }\r\n      }\r\n      return base;\r\n  }\r\n  function parsePropertyOrPrivatePropertyName(parser, context) {\r\n      if ((parser.token & (143360 | 4096)) < 1 && parser.token !== 128) {\r\n          report(parser, 154);\r\n      }\r\n      return context & 1 && parser.token === 128\r\n          ? parsePrivateName(parser, context, parser.tokenPos, parser.linePos, parser.colPos)\r\n          : parseIdentifier(parser, context, 0);\r\n  }\r\n  function parseUpdateExpressionPrefixed(parser, context, inNew, isLHS, start, line, column) {\r\n      if (inNew)\r\n          report(parser, 53);\r\n      if (!isLHS)\r\n          report(parser, 0);\r\n      const { token } = parser;\r\n      nextToken(parser, context | 32768);\r\n      const arg = parseLeftHandSideExpression(parser, context, 0, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      if (parser.assignable & 2) {\r\n          report(parser, 52);\r\n      }\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'UpdateExpression',\r\n          argument: arg,\r\n          operator: KeywordDescTable[token & 255],\r\n          prefix: true\r\n      });\r\n  }\r\n  function parsePrimaryExpression(parser, context, kind, inNew, canAssign, isPattern, inGroup, isLHS, start, line, column) {\r\n      if ((parser.token & 143360) === 143360) {\r\n          switch (parser.token) {\r\n              case 209005:\r\n                  return parseAwaitExpression(parser, context, inNew, inGroup, start, line, column);\r\n              case 241770:\r\n                  return parseYieldExpression(parser, context, inGroup, canAssign, start, line, column);\r\n              case 143468:\r\n                  return parseAsyncExpression(parser, context, inGroup, isLHS, canAssign, isPattern, inNew, start, line, column);\r\n          }\r\n          const { token, tokenValue } = parser;\r\n          const expr = parseIdentifier(parser, context | 65536, isPattern);\r\n          if (parser.token === 10) {\r\n              if (!isLHS)\r\n                  report(parser, 0);\r\n              classifyIdentifier(parser, context, token, 1);\r\n              return parseArrowFromIdentifier(parser, context, tokenValue, expr, inNew, canAssign, 0, start, line, column);\r\n          }\r\n          if (context & 16384 && token === 537079925)\r\n              report(parser, 126);\r\n          if (token === 241736) {\r\n              if (context & 1024)\r\n                  report(parser, 109);\r\n              if (kind & (8 | 16))\r\n                  report(parser, 97);\r\n          }\r\n          parser.assignable =\r\n              context & 1024 && (token & 537079808) === 537079808\r\n                  ? 2\r\n                  : 1;\r\n          return expr;\r\n      }\r\n      if ((parser.token & 134217728) === 134217728) {\r\n          return parseLiteral(parser, context);\r\n      }\r\n      switch (parser.token) {\r\n          case 33619995:\r\n          case 33619996:\r\n              return parseUpdateExpressionPrefixed(parser, context, inNew, isLHS, start, line, column);\r\n          case 16863275:\r\n          case 16842797:\r\n          case 16842798:\r\n          case 25233967:\r\n          case 25233968:\r\n          case 16863274:\r\n          case 16863276:\r\n              return parseUnaryExpression(parser, context, isLHS, start, line, column, inGroup);\r\n          case 86103:\r\n              return parseFunctionExpression(parser, context, 0, inGroup, start, line, column);\r\n          case 2162700:\r\n              return parseObjectLiteral(parser, context, canAssign ? 0 : 1, inGroup, start, line, column);\r\n          case 69271571:\r\n              return parseArrayLiteral(parser, context, canAssign ? 0 : 1, inGroup, start, line, column);\r\n          case 67174411:\r\n              return parseParenthesizedExpression(parser, context, canAssign, 1, 0, start, line, column);\r\n          case 86021:\r\n          case 86022:\r\n          case 86023:\r\n              return parseNullOrTrueOrFalseLiteral(parser, context, start, line, column);\r\n          case 86110:\r\n              return parseThisExpression(parser, context);\r\n          case 65540:\r\n              return parseRegExpLiteral(parser, context, start, line, column);\r\n          case 130:\r\n          case 86093:\r\n              return parseClassExpression(parser, context, inGroup, start, line, column);\r\n          case 86108:\r\n              return parseSuperExpression(parser, context, start, line, column);\r\n          case 67174409:\r\n              return parseTemplateLiteral(parser, context, start, line, column);\r\n          case 67174408:\r\n              return parseTemplate(parser, context, start, line, column);\r\n          case 86106:\r\n              return parseNewExpression(parser, context, inGroup, start, line, column);\r\n          case 122:\r\n              return parseBigIntLiteral(parser, context, start, line, column);\r\n          case 128:\r\n              return parsePrivateName(parser, context, start, line, column);\r\n          case 86105:\r\n              return parseImportCallOrMetaExpression(parser, context, inNew, inGroup, start, line, column);\r\n          case 8456255:\r\n              if (context & 16)\r\n                  return parseJSXRootElementOrFragment(parser, context, 1, start, line, column);\r\n          default:\r\n              if (isValidIdentifier(context, parser.token))\r\n                  return parseIdentifierOrArrow(parser, context, start, line, column);\r\n              report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n  }\r\n  function parseImportCallOrMetaExpression(parser, context, inNew, inGroup, start, line, column) {\r\n      let expr = parseIdentifier(parser, context, 0);\r\n      if (context & 1 && parser.token === 67108877) {\r\n          return parseImportMetaExpression(parser, context, expr, start, line, column);\r\n      }\r\n      if (inNew)\r\n          report(parser, 137);\r\n      expr = parseImportExpression(parser, context, inGroup, start, line, column);\r\n      parser.assignable = 2;\r\n      return parseMemberOrUpdateExpression(parser, context, expr, inGroup, start, line, column);\r\n  }\r\n  function parseImportMetaExpression(parser, context, meta, start, line, column) {\r\n      if ((context & 2048) === 0)\r\n          report(parser, 163);\r\n      nextToken(parser, context);\r\n      if (parser.token !== 143492 && parser.tokenValue !== 'meta')\r\n          report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'MetaProperty',\r\n          meta,\r\n          property: parseIdentifier(parser, context, 0)\r\n      });\r\n  }\r\n  function parseImportExpression(parser, context, inGroup, start, line, column) {\r\n      consume(parser, context | 32768, 67174411);\r\n      if (parser.token === 14)\r\n          report(parser, 138);\r\n      const source = parseExpression(parser, context, 1, 0, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context, 16);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ImportExpression',\r\n          source\r\n      });\r\n  }\r\n  function parseBigIntLiteral(parser, context, start, line, column) {\r\n      const { tokenRaw, tokenValue } = parser;\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, context & 512\r\n          ? {\r\n              type: 'BigIntLiteral',\r\n              value: tokenValue,\r\n              bigint: tokenRaw,\r\n              raw: tokenRaw\r\n          }\r\n          : {\r\n              type: 'BigIntLiteral',\r\n              value: tokenValue,\r\n              bigint: tokenRaw\r\n          });\r\n  }\r\n  function parseTemplateLiteral(parser, context, start, line, column) {\r\n      parser.assignable = 2;\r\n      consume(parser, context, 67174409);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'TemplateLiteral',\r\n          expressions: [],\r\n          quasis: [parseTemplateElement(parser, context, true)]\r\n      });\r\n  }\r\n  function parseTemplate(parser, context, start, line, column) {\r\n      context = (context | 134217728) ^ 134217728;\r\n      const quasis = [parseTemplateElement(parser, context, false)];\r\n      consume(parser, context | 32768, 67174408);\r\n      const expressions = [parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos)];\r\n      if (parser.token !== 1074790415)\r\n          report(parser, 80);\r\n      while ((parser.token = scanTemplateTail(parser, context)) !== 67174409) {\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          quasis.push(parseTemplateElement(parser, context, false));\r\n          consume(parser, context | 32768, 67174408);\r\n          expressions.push(parseExpressions(parser, context, 0, 1, tokenPos, linePos, colPos));\r\n          if (parser.token !== 1074790415)\r\n              report(parser, 80);\r\n      }\r\n      quasis.push(parseTemplateElement(parser, context, true));\r\n      consume(parser, context, 67174409);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'TemplateLiteral',\r\n          expressions,\r\n          quasis\r\n      });\r\n  }\r\n  function parseTemplateElement(parser, context, tail) {\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'TemplateElement',\r\n          value: {\r\n              cooked: parser.tokenValue,\r\n              raw: parser.tokenRaw\r\n          },\r\n          tail\r\n      });\r\n  }\r\n  function parseSpreadElement(parser, context, start, line, column) {\r\n      context = (context | 134217728) ^ 134217728;\r\n      consume(parser, context | 32768, 14);\r\n      const argument = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      parser.assignable = 1;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'SpreadElement',\r\n          argument\r\n      });\r\n  }\r\n  function parseArguments(parser, context, inGroup) {\r\n      nextToken(parser, context | 32768);\r\n      const args = [];\r\n      if (parser.token === 16) {\r\n          nextToken(parser, context);\r\n          return args;\r\n      }\r\n      while (parser.token !== 16) {\r\n          if (parser.token === 14) {\r\n              args.push(parseSpreadElement(parser, context, parser.tokenPos, parser.linePos, parser.colPos));\r\n          }\r\n          else {\r\n              args.push(parseExpression(parser, context, 1, 0, inGroup, parser.tokenPos, parser.linePos, parser.colPos));\r\n          }\r\n          if (parser.token !== 1073741842)\r\n              break;\r\n          nextToken(parser, context | 32768);\r\n          if (parser.token === 16)\r\n              break;\r\n      }\r\n      consume(parser, context, 16);\r\n      return args;\r\n  }\r\n  function parseIdentifier(parser, context, isPattern) {\r\n      const { tokenValue, tokenPos, linePos, colPos } = parser;\r\n      nextToken(parser, context);\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, context & 268435456\r\n          ? {\r\n              type: 'Identifier',\r\n              name: tokenValue,\r\n              pattern: isPattern === 1\r\n          }\r\n          : {\r\n              type: 'Identifier',\r\n              name: tokenValue\r\n          });\r\n  }\r\n  function parseLiteral(parser, context) {\r\n      const { tokenValue, tokenRaw, tokenPos, linePos, colPos } = parser;\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, context & 512\r\n          ? {\r\n              type: 'Literal',\r\n              value: tokenValue,\r\n              raw: tokenRaw\r\n          }\r\n          : {\r\n              type: 'Literal',\r\n              value: tokenValue\r\n          });\r\n  }\r\n  function parseNullOrTrueOrFalseLiteral(parser, context, start, line, column) {\r\n      const raw = KeywordDescTable[parser.token & 255];\r\n      const value = parser.token === 86023 ? null : raw === 'true';\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, context & 512\r\n          ? {\r\n              type: 'Literal',\r\n              value,\r\n              raw\r\n          }\r\n          : {\r\n              type: 'Literal',\r\n              value\r\n          });\r\n  }\r\n  function parseThisExpression(parser, context) {\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'ThisExpression'\r\n      });\r\n  }\r\n  function parseFunctionDeclaration(parser, context, scope, origin, allowGen, flags, isAsync, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const isGenerator = allowGen ? optionalBit(parser, context, 8457011) : 0;\r\n      let id = null;\r\n      let firstRestricted;\r\n      let functionScope = scope ? createScope() : void 0;\r\n      if (parser.token === 67174411) {\r\n          if ((flags & 1) < 1)\r\n              report(parser, 37, 'Function');\r\n      }\r\n      else {\r\n          const kind = origin & 4 && ((context & 8192) < 1 || (context & 2048) < 1)\r\n              ? 4\r\n              : 64;\r\n          validateFunctionName(parser, context | ((context & 3072) << 11), parser.token);\r\n          if (scope) {\r\n              if (kind & 4) {\r\n                  addVarName(parser, context, scope, parser.tokenValue, kind);\r\n              }\r\n              else {\r\n                  addBlockName(parser, context, scope, parser.tokenValue, kind, origin);\r\n              }\r\n              functionScope = addChildScope(functionScope, 256);\r\n              if (flags) {\r\n                  if (flags & 2) {\r\n                      declareUnboundVariable(parser, parser.tokenValue);\r\n                  }\r\n              }\r\n          }\r\n          firstRestricted = parser.token;\r\n          id = parseIdentifier(parser, context, 0);\r\n      }\r\n      context =\r\n          ((context | 32243712) ^ 32243712) |\r\n              67108864 |\r\n              ((isAsync * 2 + isGenerator) << 21) |\r\n              (isGenerator ? 0 : 1073741824);\r\n      if (scope)\r\n          functionScope = addChildScope(functionScope, 512);\r\n      const params = parseFormalParametersOrFormalList(parser, context | 8388608, functionScope, 0, 1);\r\n      const body = parseFunctionBody(parser, (context | 8192 | 4096 | 131072) ^\r\n          (8192 | 4096 | 131072), scope ? addChildScope(functionScope, 128) : functionScope, 8, firstRestricted, scope ? functionScope.scopeError : void 0);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'FunctionDeclaration',\r\n          id,\r\n          params,\r\n          body,\r\n          async: isAsync === 1,\r\n          generator: isGenerator === 1\r\n      });\r\n  }\r\n  function parseFunctionExpression(parser, context, isAsync, inGroup, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const isGenerator = optionalBit(parser, context, 8457011);\r\n      const generatorAndAsyncFlags = (isAsync * 2 + isGenerator) << 21;\r\n      let id = null;\r\n      let firstRestricted;\r\n      let scope = context & 64 ? createScope() : void 0;\r\n      if ((parser.token & (143360 | 4096 | 36864)) > 0) {\r\n          validateFunctionName(parser, ((context | 0x1ec0000) ^ 0x1ec0000) | generatorAndAsyncFlags, parser.token);\r\n          if (scope)\r\n              scope = addChildScope(scope, 256);\r\n          firstRestricted = parser.token;\r\n          id = parseIdentifier(parser, context, 0);\r\n      }\r\n      context =\r\n          ((context | 32243712) ^ 32243712) |\r\n              67108864 |\r\n              generatorAndAsyncFlags |\r\n              (isGenerator ? 0 : 1073741824);\r\n      if (scope)\r\n          scope = addChildScope(scope, 512);\r\n      const params = parseFormalParametersOrFormalList(parser, context | 8388608, scope, inGroup, 1);\r\n      const body = parseFunctionBody(parser, context & ~(0x8001000 | 8192 | 4096 | 131072 | 16384), scope ? addChildScope(scope, 128) : scope, 0, firstRestricted, void 0);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'FunctionExpression',\r\n          id,\r\n          params,\r\n          body,\r\n          async: isAsync === 1,\r\n          generator: isGenerator === 1\r\n      });\r\n  }\r\n  function parseArrayLiteral(parser, context, skipInitializer, inGroup, start, line, column) {\r\n      const expr = parseArrayExpressionOrPattern(parser, context, void 0, skipInitializer, inGroup, 0, 2, 0, start, line, column);\r\n      if (context & 256 && parser.destructible & 64) {\r\n          report(parser, 60);\r\n      }\r\n      if (parser.destructible & 8) {\r\n          report(parser, 59);\r\n      }\r\n      return expr;\r\n  }\r\n  function parseArrayExpressionOrPattern(parser, context, scope, skipInitializer, inGroup, isPattern, kind, origin, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const elements = [];\r\n      let destructible = 0;\r\n      context = (context | 134217728) ^ 134217728;\r\n      while (parser.token !== 20) {\r\n          if (consumeOpt(parser, context | 32768, 1073741842)) {\r\n              elements.push(null);\r\n          }\r\n          else {\r\n              let left;\r\n              const { token, tokenPos, linePos, colPos, tokenValue } = parser;\r\n              if (token & 143360) {\r\n                  left = parsePrimaryExpression(parser, context, kind, 0, 1, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n                  if (parser.token === 1077936157) {\r\n                      if (parser.assignable & 2)\r\n                          report(parser, 24);\r\n                      nextToken(parser, context | 32768);\r\n                      if (scope)\r\n                          addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n                      const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                      left = finishNode(parser, context, tokenPos, linePos, colPos, isPattern\r\n                          ? {\r\n                              type: 'AssignmentPattern',\r\n                              left,\r\n                              right\r\n                          }\r\n                          : {\r\n                              type: 'AssignmentExpression',\r\n                              operator: '=',\r\n                              left,\r\n                              right\r\n                          });\r\n                      destructible |=\r\n                          parser.destructible & 256\r\n                              ? 256\r\n                              : 0 | (parser.destructible & 128)\r\n                                  ? 128\r\n                                  : 0;\r\n                  }\r\n                  else if (parser.token === 1073741842 || parser.token === 20) {\r\n                      if (parser.assignable & 2) {\r\n                          destructible |= 16;\r\n                      }\r\n                      else if (scope) {\r\n                          addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n                      }\r\n                      destructible |=\r\n                          parser.destructible & 256\r\n                              ? 256\r\n                              : 0 | (parser.destructible & 128)\r\n                                  ? 128\r\n                                  : 0;\r\n                  }\r\n                  else {\r\n                      destructible |=\r\n                          kind & 1\r\n                              ? 32\r\n                              : (kind & 2) < 1\r\n                                  ? 16\r\n                                  : 0;\r\n                      left = parseMemberOrUpdateExpression(parser, context, left, inGroup, tokenPos, linePos, colPos);\r\n                      if (parser.token !== 1073741842 && parser.token !== 20) {\r\n                          if (parser.token !== 1077936157)\r\n                              destructible |= 16;\r\n                          left = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, left);\r\n                      }\r\n                      else if (parser.token !== 1077936157) {\r\n                          destructible |=\r\n                              parser.assignable & 2\r\n                                  ? 16\r\n                                  : 32;\r\n                      }\r\n                  }\r\n              }\r\n              else if (token & 2097152) {\r\n                  left =\r\n                      parser.token === 2162700\r\n                          ? parseObjectLiteralOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos)\r\n                          : parseArrayExpressionOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos);\r\n                  destructible |= parser.destructible;\r\n                  parser.assignable =\r\n                      parser.destructible & 16\r\n                          ? 2\r\n                          : 1;\r\n                  if (parser.token === 1073741842 || parser.token === 20) {\r\n                      if (parser.assignable & 2) {\r\n                          destructible |= 16;\r\n                      }\r\n                  }\r\n                  else if (parser.destructible & 8) {\r\n                      report(parser, 68);\r\n                  }\r\n                  else {\r\n                      left = parseMemberOrUpdateExpression(parser, context, left, inGroup, tokenPos, linePos, colPos);\r\n                      destructible = parser.assignable & 2 ? 16 : 0;\r\n                      if (parser.token !== 1073741842 && parser.token !== 20) {\r\n                          left = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, left);\r\n                      }\r\n                      else if (parser.token !== 1077936157) {\r\n                          destructible |=\r\n                              parser.assignable & 2\r\n                                  ? 16\r\n                                  : 32;\r\n                      }\r\n                  }\r\n              }\r\n              else if (token === 14) {\r\n                  left = parseSpreadOrRestElement(parser, context, scope, 20, kind, origin, 0, inGroup, isPattern, tokenPos, linePos, colPos);\r\n                  destructible |= parser.destructible;\r\n                  if (parser.token !== 1073741842 && parser.token !== 20)\r\n                      report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n              }\r\n              else {\r\n                  left = parseLeftHandSideExpression(parser, context, 1, 0, 1, tokenPos, linePos, colPos);\r\n                  if (parser.token !== 1073741842 && parser.token !== 20) {\r\n                      left = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, left);\r\n                      if ((kind & (2 | 1)) < 1 && token === 67174411)\r\n                          destructible |= 16;\r\n                  }\r\n                  else if (parser.assignable & 2) {\r\n                      destructible |= 16;\r\n                  }\r\n                  else if (token === 67174411) {\r\n                      destructible |=\r\n                          parser.assignable & 1 && kind & (2 | 1)\r\n                              ? 32\r\n                              : 16;\r\n                  }\r\n              }\r\n              elements.push(left);\r\n              if (consumeOpt(parser, context | 32768, 1073741842)) {\r\n                  if (parser.token === 20)\r\n                      break;\r\n              }\r\n              else\r\n                  break;\r\n          }\r\n      }\r\n      consume(parser, context, 20);\r\n      const node = finishNode(parser, context, start, line, column, {\r\n          type: isPattern ? 'ArrayPattern' : 'ArrayExpression',\r\n          elements\r\n      });\r\n      if (!skipInitializer && parser.token & 4194304) {\r\n          return parseArrayOrObjectAssignmentPattern(parser, context, destructible, inGroup, isPattern, start, line, column, node);\r\n      }\r\n      parser.destructible = destructible;\r\n      return node;\r\n  }\r\n  function parseArrayOrObjectAssignmentPattern(parser, context, destructible, inGroup, isPattern, start, line, column, node) {\r\n      if (parser.token !== 1077936157)\r\n          report(parser, 24);\r\n      nextToken(parser, context | 32768);\r\n      if (destructible & 16)\r\n          report(parser, 24);\r\n      if (!isPattern)\r\n          reinterpretToPattern(parser, node);\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      const right = parseExpression(parser, context, 1, 1, inGroup, tokenPos, linePos, colPos);\r\n      parser.destructible =\r\n          ((destructible | 64 | 8) ^\r\n              (8 | 64)) |\r\n              (parser.destructible & 128 ? 128 : 0) |\r\n              (parser.destructible & 256 ? 256 : 0);\r\n      return finishNode(parser, context, start, line, column, isPattern\r\n          ? {\r\n              type: 'AssignmentPattern',\r\n              left: node,\r\n              right\r\n          }\r\n          : {\r\n              type: 'AssignmentExpression',\r\n              left: node,\r\n              operator: '=',\r\n              right\r\n          });\r\n  }\r\n  function parseSpreadOrRestElement(parser, context, scope, closingToken, kind, origin, isAsync, inGroup, isPattern, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      let argument = null;\r\n      let destructible = 0;\r\n      let { token, tokenValue, tokenPos, linePos, colPos } = parser;\r\n      if (token & (4096 | 143360)) {\r\n          parser.assignable = 1;\r\n          argument = parsePrimaryExpression(parser, context, kind, 0, 1, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n          token = parser.token;\r\n          argument = parseMemberOrUpdateExpression(parser, context, argument, inGroup, tokenPos, linePos, colPos);\r\n          if (parser.token !== 1073741842 && parser.token !== closingToken) {\r\n              if (parser.assignable & 2 && parser.token === 1077936157)\r\n                  report(parser, 68);\r\n              destructible |= 16;\r\n              argument = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, argument);\r\n          }\r\n          if (parser.assignable & 2) {\r\n              destructible |= 16;\r\n          }\r\n          else if (token === closingToken || token === 1073741842) {\r\n              if (scope)\r\n                  addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n          }\r\n          else {\r\n              destructible |= 32;\r\n          }\r\n          destructible |= parser.destructible & 128 ? 128 : 0;\r\n      }\r\n      else if (token === closingToken) {\r\n          report(parser, 39);\r\n      }\r\n      else if (token & 2097152) {\r\n          argument =\r\n              parser.token === 2162700\r\n                  ? parseObjectLiteralOrPattern(parser, context, scope, 1, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos)\r\n                  : parseArrayExpressionOrPattern(parser, context, scope, 1, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos);\r\n          token = parser.token;\r\n          if (token !== 1077936157 && token !== closingToken && token !== 1073741842) {\r\n              if (parser.destructible & 8)\r\n                  report(parser, 68);\r\n              argument = parseMemberOrUpdateExpression(parser, context, argument, inGroup, tokenPos, linePos, colPos);\r\n              destructible |= parser.assignable & 2 ? 16 : 0;\r\n              if ((parser.token & 4194304) === 4194304) {\r\n                  if (parser.token !== 1077936157)\r\n                      destructible |= 16;\r\n                  argument = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, argument);\r\n              }\r\n              else {\r\n                  if ((parser.token & 8454144) === 8454144) {\r\n                      argument = parseBinaryExpression(parser, context, 1, tokenPos, linePos, colPos, 4, token, argument);\r\n                  }\r\n                  if (consumeOpt(parser, context | 32768, 22)) {\r\n                      argument = parseConditionalExpression(parser, context, argument, tokenPos, linePos, colPos);\r\n                  }\r\n                  destructible |=\r\n                      parser.assignable & 2\r\n                          ? 16\r\n                          : 32;\r\n              }\r\n          }\r\n          else {\r\n              destructible |=\r\n                  closingToken === 1074790415 && token !== 1077936157\r\n                      ? 16\r\n                      : parser.destructible;\r\n          }\r\n      }\r\n      else {\r\n          destructible |= 32;\r\n          argument = parseLeftHandSideExpression(parser, context, 1, inGroup, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n          const { token, tokenPos, linePos, colPos } = parser;\r\n          if (token === 1077936157 && token !== closingToken && token !== 1073741842) {\r\n              if (parser.assignable & 2)\r\n                  report(parser, 24);\r\n              argument = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, argument);\r\n              destructible |= 16;\r\n          }\r\n          else {\r\n              if (token === 1073741842) {\r\n                  destructible |= 16;\r\n              }\r\n              else if (token !== closingToken) {\r\n                  argument = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, argument);\r\n              }\r\n              destructible |=\r\n                  parser.assignable & 1 ? 32 : 16;\r\n          }\r\n          parser.destructible = destructible;\r\n          if (parser.token !== closingToken && parser.token !== 1073741842)\r\n              report(parser, 155);\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: isPattern ? 'RestElement' : 'SpreadElement',\r\n              argument: argument\r\n          });\r\n      }\r\n      if (parser.token !== closingToken) {\r\n          if (kind & 1)\r\n              destructible |= isAsync ? 16 : 32;\r\n          if (consumeOpt(parser, context | 32768, 1077936157)) {\r\n              if (destructible & 16)\r\n                  report(parser, 24);\r\n              reinterpretToPattern(parser, argument);\r\n              const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n              argument = finishNode(parser, context, tokenPos, linePos, colPos, isPattern\r\n                  ? {\r\n                      type: 'AssignmentPattern',\r\n                      left: argument,\r\n                      right\r\n                  }\r\n                  : {\r\n                      type: 'AssignmentExpression',\r\n                      left: argument,\r\n                      operator: '=',\r\n                      right\r\n                  });\r\n              destructible = 16;\r\n          }\r\n          else {\r\n              destructible |= 16;\r\n          }\r\n      }\r\n      parser.destructible = destructible;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: isPattern ? 'RestElement' : 'SpreadElement',\r\n          argument: argument\r\n      });\r\n  }\r\n  function parseMethodDefinition(parser, context, kind, inGroup, start, line, column) {\r\n      const modifierFlags = (kind & 64) < 1 ? 31981568 : 14680064;\r\n      context =\r\n          ((context | modifierFlags) ^ modifierFlags) |\r\n              ((kind & 88) << 18) |\r\n              100925440;\r\n      let scope = context & 64 ? addChildScope(createScope(), 512) : void 0;\r\n      const params = parseMethodFormals(parser, context | 8388608, scope, kind, 1, inGroup);\r\n      if (scope)\r\n          scope = addChildScope(scope, 128);\r\n      const body = parseFunctionBody(parser, context & ~(0x8001000 | 8192), scope, 0, void 0, void 0);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'FunctionExpression',\r\n          params,\r\n          body,\r\n          async: (kind & 16) > 0,\r\n          generator: (kind & 8) > 0,\r\n          id: null\r\n      });\r\n  }\r\n  function parseObjectLiteral(parser, context, skipInitializer, inGroup, start, line, column) {\r\n      const expr = parseObjectLiteralOrPattern(parser, context, void 0, skipInitializer, inGroup, 0, 2, 0, start, line, column);\r\n      if (context & 256 && parser.destructible & 64) {\r\n          report(parser, 60);\r\n      }\r\n      if (parser.destructible & 8) {\r\n          report(parser, 59);\r\n      }\r\n      return expr;\r\n  }\r\n  function parseObjectLiteralOrPattern(parser, context, scope, skipInitializer, inGroup, isPattern, kind, origin, start, line, column) {\r\n      nextToken(parser, context);\r\n      const properties = [];\r\n      let destructible = 0;\r\n      let prototypeCount = 0;\r\n      context = (context | 134217728) ^ 134217728;\r\n      while (parser.token !== 1074790415) {\r\n          const { token, tokenValue, linePos, colPos, tokenPos } = parser;\r\n          if (token === 14) {\r\n              properties.push(parseSpreadOrRestElement(parser, context, scope, 1074790415, kind, origin, 0, inGroup, isPattern, tokenPos, linePos, colPos));\r\n          }\r\n          else {\r\n              let state = 0;\r\n              let key = null;\r\n              let value;\r\n              const t = parser.token;\r\n              if (parser.token & (143360 | 4096) || parser.token === 118) {\r\n                  key = parseIdentifier(parser, context, 0);\r\n                  if (parser.token === 1073741842 || parser.token === 1074790415 || parser.token === 1077936157) {\r\n                      state |= 4;\r\n                      if (context & 1024 && (token & 537079808) === 537079808) {\r\n                          destructible |= 16;\r\n                      }\r\n                      else {\r\n                          validateBindingIdentifier(parser, context, kind, token, 0);\r\n                      }\r\n                      if (scope)\r\n                          addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n                      if (consumeOpt(parser, context | 32768, 1077936157)) {\r\n                          destructible |= 8;\r\n                          const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                          destructible |=\r\n                              parser.destructible & 256\r\n                                  ? 256\r\n                                  : 0 | (parser.destructible & 128)\r\n                                      ? 128\r\n                                      : 0;\r\n                          value = finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                              type: 'AssignmentPattern',\r\n                              left: context & -2147483648 ? Object.assign({}, key) : key,\r\n                              right\r\n                          });\r\n                      }\r\n                      else {\r\n                          destructible |=\r\n                              (token === 209005 ? 128 : 0) |\r\n                                  (token === 118 ? 16 : 0);\r\n                          value = context & -2147483648 ? Object.assign({}, key) : key;\r\n                      }\r\n                  }\r\n                  else if (consumeOpt(parser, context | 32768, 21)) {\r\n                      const { tokenPos, linePos, colPos } = parser;\r\n                      if (tokenValue === '__proto__')\r\n                          prototypeCount++;\r\n                      if (parser.token & 143360) {\r\n                          const tokenAfterColon = parser.token;\r\n                          const valueAfterColon = parser.tokenValue;\r\n                          destructible |= t === 118 ? 16 : 0;\r\n                          value = parsePrimaryExpression(parser, context, kind, 0, 1, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n                          const { token } = parser;\r\n                          value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (token === 1077936157 || token === 1074790415 || token === 1073741842) {\r\n                                  destructible |= parser.destructible & 128 ? 128 : 0;\r\n                                  if (parser.assignable & 2) {\r\n                                      destructible |= 16;\r\n                                  }\r\n                                  else if (scope && (tokenAfterColon & 143360) === 143360) {\r\n                                      addVarOrBlock(parser, context, scope, valueAfterColon, kind, origin);\r\n                                  }\r\n                              }\r\n                              else {\r\n                                  destructible |=\r\n                                      parser.assignable & 1\r\n                                          ? 32\r\n                                          : 16;\r\n                              }\r\n                          }\r\n                          else if ((parser.token & 4194304) === 4194304) {\r\n                              if (parser.assignable & 2) {\r\n                                  destructible |= 16;\r\n                              }\r\n                              else if (token !== 1077936157) {\r\n                                  destructible |= 32;\r\n                              }\r\n                              else if (scope) {\r\n                                  addVarOrBlock(parser, context, scope, valueAfterColon, kind, origin);\r\n                              }\r\n                              value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                          }\r\n                          else {\r\n                              destructible |= 16;\r\n                              if ((parser.token & 8454144) === 8454144) {\r\n                                  value = parseBinaryExpression(parser, context, 1, tokenPos, linePos, colPos, 4, token, value);\r\n                              }\r\n                              if (consumeOpt(parser, context | 32768, 22)) {\r\n                                  value = parseConditionalExpression(parser, context, value, tokenPos, linePos, colPos);\r\n                              }\r\n                          }\r\n                      }\r\n                      else if ((parser.token & 2097152) === 2097152) {\r\n                          value =\r\n                              parser.token === 69271571\r\n                                  ? parseArrayExpressionOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos)\r\n                                  : parseObjectLiteralOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos);\r\n                          destructible = parser.destructible;\r\n                          parser.assignable =\r\n                              destructible & 16 ? 2 : 1;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2)\r\n                                  destructible |= 16;\r\n                          }\r\n                          else if (parser.destructible & 8) {\r\n                              report(parser, 68);\r\n                          }\r\n                          else {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                              destructible = parser.assignable & 2 ? 16 : 0;\r\n                              if ((parser.token & 4194304) === 4194304) {\r\n                                  value = parseAssignmentExpressionOrPattern(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                              }\r\n                              else {\r\n                                  if ((parser.token & 8454144) === 8454144) {\r\n                                      value = parseBinaryExpression(parser, context, 1, tokenPos, linePos, colPos, 4, token, value);\r\n                                  }\r\n                                  if (consumeOpt(parser, context | 32768, 22)) {\r\n                                      value = parseConditionalExpression(parser, context, value, tokenPos, linePos, colPos);\r\n                                  }\r\n                                  destructible |=\r\n                                      parser.assignable & 2\r\n                                          ? 16\r\n                                          : 32;\r\n                              }\r\n                          }\r\n                      }\r\n                      else {\r\n                          value = parseLeftHandSideExpression(parser, context, 1, inGroup, 1, tokenPos, linePos, colPos);\r\n                          destructible |=\r\n                              parser.assignable & 1\r\n                                  ? 32\r\n                                  : 16;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2)\r\n                                  destructible |= 16;\r\n                          }\r\n                          else {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, tokenPos, colPos);\r\n                              destructible = parser.assignable & 2 ? 16 : 0;\r\n                              if (parser.token !== 1073741842 && token !== 1074790415) {\r\n                                  if (parser.token !== 1077936157)\r\n                                      destructible |= 16;\r\n                                  value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, tokenPos, colPos, value);\r\n                              }\r\n                          }\r\n                      }\r\n                  }\r\n                  else if (parser.token === 69271571) {\r\n                      destructible |= 16;\r\n                      if (token === 143468)\r\n                          state |= 16;\r\n                      state |=\r\n                          (token === 12399\r\n                              ? 256\r\n                              : token === 12400\r\n                                  ? 512\r\n                                  : 1) | 2;\r\n                      key = parseComputedPropertyName(parser, context, inGroup);\r\n                      destructible |= parser.assignable;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else if (parser.token & (143360 | 4096)) {\r\n                      destructible |= 16;\r\n                      if (token === 118)\r\n                          report(parser, 92);\r\n                      if (token === 143468) {\r\n                          if (parser.flags & 1)\r\n                              report(parser, 128);\r\n                          state |= 16;\r\n                      }\r\n                      key = parseIdentifier(parser, context, 0);\r\n                      state |=\r\n                          token === 12399\r\n                              ? 256\r\n                              : token === 12400\r\n                                  ? 512\r\n                                  : 1;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else if (parser.token === 67174411) {\r\n                      destructible |= 16;\r\n                      state |= 1;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else if (parser.token === 8457011) {\r\n                      destructible |= 16;\r\n                      if (token === 12399 || token === 12400) {\r\n                          report(parser, 40);\r\n                      }\r\n                      else if (token === 143480) {\r\n                          report(parser, 92);\r\n                      }\r\n                      nextToken(parser, context);\r\n                      state |=\r\n                          8 | 1 | (token === 143468 ? 16 : 0);\r\n                      if (parser.token & 143360) {\r\n                          key = parseIdentifier(parser, context, 0);\r\n                      }\r\n                      else if ((parser.token & 134217728) === 134217728) {\r\n                          key = parseLiteral(parser, context);\r\n                      }\r\n                      else if (parser.token === 69271571) {\r\n                          state |= 2;\r\n                          key = parseComputedPropertyName(parser, context, inGroup);\r\n                          destructible |= parser.assignable;\r\n                      }\r\n                      else {\r\n                          report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n                      }\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else if ((parser.token & 134217728) === 134217728) {\r\n                      if (token === 143468)\r\n                          state |= 16;\r\n                      state |=\r\n                          token === 12399\r\n                              ? 256\r\n                              : token === 12400\r\n                                  ? 512\r\n                                  : 1;\r\n                      destructible |= 16;\r\n                      key = parseLiteral(parser, context);\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else {\r\n                      report(parser, 129);\r\n                  }\r\n              }\r\n              else if ((parser.token & 134217728) === 134217728) {\r\n                  key = parseLiteral(parser, context);\r\n                  if (parser.token === 21) {\r\n                      consume(parser, context | 32768, 21);\r\n                      const { tokenPos, linePos, colPos } = parser;\r\n                      if (tokenValue === '__proto__')\r\n                          prototypeCount++;\r\n                      if (parser.token & 143360) {\r\n                          value = parsePrimaryExpression(parser, context, kind, 0, 1, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n                          const { token, tokenValue: valueAfterColon } = parser;\r\n                          value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (token === 1077936157 || token === 1074790415 || token === 1073741842) {\r\n                                  if (parser.assignable & 2) {\r\n                                      destructible |= 16;\r\n                                  }\r\n                                  else if (scope) {\r\n                                      addVarOrBlock(parser, context, scope, valueAfterColon, kind, origin);\r\n                                  }\r\n                              }\r\n                              else {\r\n                                  destructible |=\r\n                                      parser.assignable & 1\r\n                                          ? 32\r\n                                          : 16;\r\n                              }\r\n                          }\r\n                          else if (parser.token === 1077936157) {\r\n                              if (parser.assignable & 2)\r\n                                  destructible |= 16;\r\n                              value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                          }\r\n                          else {\r\n                              destructible |= 16;\r\n                              value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                          }\r\n                      }\r\n                      else if ((parser.token & 2097152) === 2097152) {\r\n                          value =\r\n                              parser.token === 69271571\r\n                                  ? parseArrayExpressionOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos)\r\n                                  : parseObjectLiteralOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos);\r\n                          destructible = parser.destructible;\r\n                          parser.assignable =\r\n                              destructible & 16 ? 2 : 1;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2) {\r\n                                  destructible |= 16;\r\n                              }\r\n                          }\r\n                          else if ((parser.destructible & 8) !== 8) {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                              destructible = parser.assignable & 2 ? 16 : 0;\r\n                              if ((parser.token & 4194304) === 4194304) {\r\n                                  value = parseAssignmentExpressionOrPattern(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                              }\r\n                              else {\r\n                                  if ((parser.token & 8454144) === 8454144) {\r\n                                      value = parseBinaryExpression(parser, context, 1, tokenPos, linePos, colPos, 4, token, value);\r\n                                  }\r\n                                  if (consumeOpt(parser, context | 32768, 22)) {\r\n                                      value = parseConditionalExpression(parser, context, value, tokenPos, linePos, colPos);\r\n                                  }\r\n                                  destructible |=\r\n                                      parser.assignable & 2\r\n                                          ? 16\r\n                                          : 32;\r\n                              }\r\n                          }\r\n                      }\r\n                      else {\r\n                          value = parseLeftHandSideExpression(parser, context, 1, 0, 1, tokenPos, linePos, colPos);\r\n                          destructible |=\r\n                              parser.assignable & 1\r\n                                  ? 32\r\n                                  : 16;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2) {\r\n                                  destructible |= 16;\r\n                              }\r\n                          }\r\n                          else {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                              destructible = parser.assignable & 1 ? 0 : 16;\r\n                              if (parser.token !== 1073741842 && parser.token !== 1074790415) {\r\n                                  if (parser.token !== 1077936157)\r\n                                      destructible |= 16;\r\n                                  value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                              }\r\n                          }\r\n                      }\r\n                  }\r\n                  else if (parser.token === 67174411) {\r\n                      state |= 1;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                      destructible = parser.assignable | 16;\r\n                  }\r\n                  else {\r\n                      report(parser, 130);\r\n                  }\r\n              }\r\n              else if (parser.token === 69271571) {\r\n                  key = parseComputedPropertyName(parser, context, inGroup);\r\n                  destructible |= parser.destructible & 256 ? 256 : 0;\r\n                  state |= 2;\r\n                  if (parser.token === 21) {\r\n                      nextToken(parser, context | 32768);\r\n                      const { tokenPos, linePos, colPos, tokenValue, token: tokenAfterColon } = parser;\r\n                      if (parser.token & 143360) {\r\n                          value = parsePrimaryExpression(parser, context, kind, 0, 1, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n                          const { token } = parser;\r\n                          value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                          if ((parser.token & 4194304) === 4194304) {\r\n                              destructible |=\r\n                                  parser.assignable & 2\r\n                                      ? 16\r\n                                      : token === 1077936157\r\n                                          ? 0\r\n                                          : 32;\r\n                              value = parseAssignmentExpressionOrPattern(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                          }\r\n                          else if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (token === 1077936157 || token === 1074790415 || token === 1073741842) {\r\n                                  if (parser.assignable & 2) {\r\n                                      destructible |= 16;\r\n                                  }\r\n                                  else if (scope && (tokenAfterColon & 143360) === 143360) {\r\n                                      addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n                                  }\r\n                              }\r\n                              else {\r\n                                  destructible |=\r\n                                      parser.assignable & 1\r\n                                          ? 32\r\n                                          : 16;\r\n                              }\r\n                          }\r\n                          else {\r\n                              destructible |= 16;\r\n                              value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                          }\r\n                      }\r\n                      else if ((parser.token & 2097152) === 2097152) {\r\n                          value =\r\n                              parser.token === 69271571\r\n                                  ? parseArrayExpressionOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos)\r\n                                  : parseObjectLiteralOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos);\r\n                          destructible = parser.destructible;\r\n                          parser.assignable =\r\n                              destructible & 16 ? 2 : 1;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2)\r\n                                  destructible |= 16;\r\n                          }\r\n                          else if (destructible & 8) {\r\n                              report(parser, 59);\r\n                          }\r\n                          else {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                              destructible =\r\n                                  parser.assignable & 2 ? destructible | 16 : 0;\r\n                              if ((parser.token & 4194304) === 4194304) {\r\n                                  if (parser.token !== 1077936157)\r\n                                      destructible |= 16;\r\n                                  value = parseAssignmentExpressionOrPattern(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                              }\r\n                              else {\r\n                                  if ((parser.token & 8454144) === 8454144) {\r\n                                      value = parseBinaryExpression(parser, context, 1, tokenPos, linePos, colPos, 4, token, value);\r\n                                  }\r\n                                  if (consumeOpt(parser, context | 32768, 22)) {\r\n                                      value = parseConditionalExpression(parser, context, value, tokenPos, linePos, colPos);\r\n                                  }\r\n                                  destructible |=\r\n                                      parser.assignable & 2\r\n                                          ? 16\r\n                                          : 32;\r\n                              }\r\n                          }\r\n                      }\r\n                      else {\r\n                          value = parseLeftHandSideExpression(parser, context, 1, 0, 1, tokenPos, linePos, colPos);\r\n                          destructible |=\r\n                              parser.assignable & 1\r\n                                  ? 32\r\n                                  : 16;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2)\r\n                                  destructible |= 16;\r\n                          }\r\n                          else {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                              destructible = parser.assignable & 1 ? 0 : 16;\r\n                              if (parser.token !== 1073741842 && parser.token !== 1074790415) {\r\n                                  if (parser.token !== 1077936157)\r\n                                      destructible |= 16;\r\n                                  value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                              }\r\n                          }\r\n                      }\r\n                  }\r\n                  else if (parser.token === 67174411) {\r\n                      state |= 1;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, linePos, colPos);\r\n                      destructible = 16;\r\n                  }\r\n                  else {\r\n                      report(parser, 41);\r\n                  }\r\n              }\r\n              else if (token === 8457011) {\r\n                  consume(parser, context | 32768, 8457011);\r\n                  state |= 8;\r\n                  if (parser.token & 143360) {\r\n                      const { token, line, index } = parser;\r\n                      key = parseIdentifier(parser, context, 0);\r\n                      state |= 1;\r\n                      if (parser.token === 67174411) {\r\n                          destructible |= 16;\r\n                          value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                      }\r\n                      else {\r\n                          reportMessageAt(index, line, index, token === 143468\r\n                              ? 43\r\n                              : token === 12399 || parser.token === 12400\r\n                                  ? 42\r\n                                  : 44, KeywordDescTable[token & 255]);\r\n                      }\r\n                  }\r\n                  else if ((parser.token & 134217728) === 134217728) {\r\n                      destructible |= 16;\r\n                      key = parseLiteral(parser, context);\r\n                      state |= 1;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, tokenPos, linePos, colPos);\r\n                  }\r\n                  else if (parser.token === 69271571) {\r\n                      destructible |= 16;\r\n                      state |= 2 | 1;\r\n                      key = parseComputedPropertyName(parser, context, inGroup);\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else {\r\n                      report(parser, 122);\r\n                  }\r\n              }\r\n              else {\r\n                  report(parser, 28, KeywordDescTable[token & 255]);\r\n              }\r\n              destructible |= parser.destructible & 128 ? 128 : 0;\r\n              parser.destructible = destructible;\r\n              properties.push(finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                  type: 'Property',\r\n                  key: key,\r\n                  value,\r\n                  kind: !(state & 768) ? 'init' : state & 512 ? 'set' : 'get',\r\n                  computed: (state & 2) > 0,\r\n                  method: (state & 1) > 0,\r\n                  shorthand: (state & 4) > 0\r\n              }));\r\n          }\r\n          destructible |= parser.destructible;\r\n          if (parser.token !== 1073741842)\r\n              break;\r\n          nextToken(parser, context);\r\n      }\r\n      consume(parser, context, 1074790415);\r\n      if (prototypeCount > 1)\r\n          destructible |= 64;\r\n      const node = finishNode(parser, context, start, line, column, {\r\n          type: isPattern ? 'ObjectPattern' : 'ObjectExpression',\r\n          properties\r\n      });\r\n      if (!skipInitializer && parser.token & 4194304) {\r\n          return parseArrayOrObjectAssignmentPattern(parser, context, destructible, inGroup, isPattern, start, line, column, node);\r\n      }\r\n      parser.destructible = destructible;\r\n      return node;\r\n  }\r\n  function parseMethodFormals(parser, context, scope, kind, type, inGroup) {\r\n      consume(parser, context, 67174411);\r\n      const params = [];\r\n      parser.flags = (parser.flags | 128) ^ 128;\r\n      if (parser.token === 16) {\r\n          if (kind & 512) {\r\n              report(parser, 35, 'Setter', 'one', '');\r\n          }\r\n          nextToken(parser, context);\r\n          return params;\r\n      }\r\n      if (kind & 256) {\r\n          report(parser, 35, 'Getter', 'no', 's');\r\n      }\r\n      if (kind & 512 && parser.token === 14) {\r\n          report(parser, 36);\r\n      }\r\n      context = (context | 134217728) ^ 134217728;\r\n      let setterArgs = 0;\r\n      let isSimpleParameterList = 0;\r\n      while (parser.token !== 1073741842) {\r\n          let left = null;\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          if (parser.token & 143360) {\r\n              if ((context & 1024) < 1) {\r\n                  if ((parser.token & 36864) === 36864) {\r\n                      parser.flags |= 256;\r\n                  }\r\n                  if ((parser.token & 537079808) === 537079808) {\r\n                      parser.flags |= 512;\r\n                  }\r\n              }\r\n              left = parseAndClassifyIdentifier(parser, context, scope, kind | 1, 0, tokenPos, linePos, colPos);\r\n          }\r\n          else {\r\n              if (parser.token === 2162700) {\r\n                  left = parseObjectLiteralOrPattern(parser, context, scope, 1, inGroup, 1, type, 0, tokenPos, linePos, colPos);\r\n              }\r\n              else if (parser.token === 69271571) {\r\n                  left = parseArrayExpressionOrPattern(parser, context, scope, 1, inGroup, 1, type, 0, tokenPos, linePos, colPos);\r\n              }\r\n              else if (parser.token === 14) {\r\n                  left = parseSpreadOrRestElement(parser, context, scope, 16, type, 0, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n              }\r\n              isSimpleParameterList = 1;\r\n              if (parser.destructible & (32 | 16))\r\n                  report(parser, 47);\r\n          }\r\n          if (parser.token === 1077936157) {\r\n              nextToken(parser, context | 32768);\r\n              isSimpleParameterList = 1;\r\n              const right = parseExpression(parser, context, 1, 1, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n              left = finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                  type: 'AssignmentPattern',\r\n                  left: left,\r\n                  right\r\n              });\r\n          }\r\n          setterArgs++;\r\n          params.push(left);\r\n          if (!consumeOpt(parser, context, 1073741842))\r\n              break;\r\n          if (parser.token === 16) {\r\n              break;\r\n          }\r\n      }\r\n      if (kind & 512 && setterArgs !== 1) {\r\n          report(parser, 35, 'Setter', 'one', '');\r\n      }\r\n      if (scope && scope.scopeError !== void 0)\r\n          reportScopeError(scope.scopeError);\r\n      if (isSimpleParameterList)\r\n          parser.flags |= 128;\r\n      consume(parser, context, 16);\r\n      return params;\r\n  }\r\n  function parseComputedPropertyName(parser, context, inGroup) {\r\n      nextToken(parser, context | 32768);\r\n      const key = parseExpression(parser, (context | 134217728) ^ 134217728, 1, 0, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context, 20);\r\n      return key;\r\n  }\r\n  function parseParenthesizedExpression(parser, context, canAssign, kind, origin, start, line, column) {\r\n      parser.flags = (parser.flags | 128) ^ 128;\r\n      nextToken(parser, context | 32768 | 1073741824);\r\n      const scope = context & 64 ? addChildScope(createScope(), 1024) : void 0;\r\n      context = (context | 134217728 | 8192) ^ (8192 | 134217728);\r\n      if (consumeOpt(parser, context, 16)) {\r\n          return parseParenthesizedArrow(parser, context, scope, [], canAssign, 0, start, line, column);\r\n      }\r\n      let destructible = 0;\r\n      parser.destructible &= ~(256 | 128);\r\n      let expr;\r\n      let expressions = [];\r\n      let isSequence = 0;\r\n      let isSimpleParameterList = 0;\r\n      const { tokenPos: iStart, linePos: lStart, colPos: cStart } = parser;\r\n      parser.assignable = 1;\r\n      while (parser.token !== 16) {\r\n          const { token, tokenPos, linePos, colPos } = parser;\r\n          if (token & (143360 | 4096)) {\r\n              if (scope)\r\n                  addBlockName(parser, context, scope, parser.tokenValue, 1, 0);\r\n              expr = parsePrimaryExpression(parser, context, kind, 0, 1, 0, 1, 1, tokenPos, linePos, colPos);\r\n              if (parser.token === 16 || parser.token === 1073741842) {\r\n                  if (parser.assignable & 2) {\r\n                      destructible |= 16;\r\n                      isSimpleParameterList = 1;\r\n                  }\r\n                  else if ((token & 537079808) === 537079808 ||\r\n                      (token & 36864) === 36864) {\r\n                      isSimpleParameterList = 1;\r\n                  }\r\n              }\r\n              else {\r\n                  if (parser.token === 1077936157) {\r\n                      isSimpleParameterList = 1;\r\n                  }\r\n                  else {\r\n                      destructible |= 16;\r\n                  }\r\n                  expr = parseMemberOrUpdateExpression(parser, context, expr, 1, tokenPos, linePos, colPos);\r\n                  if (parser.token !== 16 && parser.token !== 1073741842) {\r\n                      expr = parseAssignmentExpression(parser, context, 1, 0, tokenPos, linePos, colPos, expr);\r\n                  }\r\n              }\r\n          }\r\n          else if ((token & 2097152) === 2097152) {\r\n              expr =\r\n                  token === 2162700\r\n                      ? parseObjectLiteralOrPattern(parser, context | 1073741824, scope, 0, 1, 0, kind, origin, tokenPos, linePos, colPos)\r\n                      : parseArrayExpressionOrPattern(parser, context | 1073741824, scope, 0, 1, 0, kind, origin, tokenPos, linePos, colPos);\r\n              destructible |= parser.destructible;\r\n              isSimpleParameterList = 1;\r\n              parser.assignable = 2;\r\n              if (parser.token !== 16 && parser.token !== 1073741842) {\r\n                  if (destructible & 8)\r\n                      report(parser, 118);\r\n                  expr = parseMemberOrUpdateExpression(parser, context, expr, 0, tokenPos, linePos, colPos);\r\n                  destructible |= 16;\r\n                  if (parser.token !== 16 && parser.token !== 1073741842) {\r\n                      expr = parseAssignmentExpression(parser, context, 0, 0, tokenPos, linePos, colPos, expr);\r\n                  }\r\n              }\r\n          }\r\n          else if (token === 14) {\r\n              expr = parseSpreadOrRestElement(parser, context, scope, 16, kind, origin, 0, 1, 0, tokenPos, linePos, colPos);\r\n              if (parser.destructible & 16)\r\n                  report(parser, 71);\r\n              isSimpleParameterList = 1;\r\n              if (isSequence && (parser.token === 16 || parser.token === 1073741842)) {\r\n                  expressions.push(expr);\r\n              }\r\n              destructible |= 8;\r\n              break;\r\n          }\r\n          else {\r\n              destructible |= 16;\r\n              expr = parseExpression(parser, context, 1, 0, 1, tokenPos, linePos, colPos);\r\n              if (isSequence && (parser.token === 16 || parser.token === 1073741842)) {\r\n                  expressions.push(expr);\r\n              }\r\n              if (parser.token === 1073741842) {\r\n                  if (!isSequence) {\r\n                      isSequence = 1;\r\n                      expressions = [expr];\r\n                  }\r\n              }\r\n              if (isSequence) {\r\n                  while (consumeOpt(parser, context | 32768, 1073741842)) {\r\n                      expressions.push(parseExpression(parser, context, 1, 0, 1, parser.tokenPos, parser.linePos, parser.colPos));\r\n                  }\r\n                  parser.assignable = 2;\r\n                  expr = finishNode(parser, context, iStart, lStart, cStart, {\r\n                      type: 'SequenceExpression',\r\n                      expressions\r\n                  });\r\n              }\r\n              consume(parser, context, 16);\r\n              parser.destructible = destructible;\r\n              return expr;\r\n          }\r\n          if (isSequence && (parser.token === 16 || parser.token === 1073741842)) {\r\n              expressions.push(expr);\r\n          }\r\n          if (!consumeOpt(parser, context | 32768, 1073741842))\r\n              break;\r\n          if (!isSequence) {\r\n              isSequence = 1;\r\n              expressions = [expr];\r\n          }\r\n          if (parser.token === 16) {\r\n              destructible |= 8;\r\n              break;\r\n          }\r\n      }\r\n      if (isSequence) {\r\n          parser.assignable = 2;\r\n          expr = finishNode(parser, context, iStart, lStart, cStart, {\r\n              type: 'SequenceExpression',\r\n              expressions\r\n          });\r\n      }\r\n      consume(parser, context, 16);\r\n      if (destructible & 16 && destructible & 8)\r\n          report(parser, 145);\r\n      destructible |=\r\n          parser.destructible & 256\r\n              ? 256\r\n              : 0 | (parser.destructible & 128)\r\n                  ? 128\r\n                  : 0;\r\n      if (parser.token === 10) {\r\n          if (destructible & (32 | 16))\r\n              report(parser, 46);\r\n          if (context & (4194304 | 2048) && destructible & 128)\r\n              report(parser, 29);\r\n          if (context & (1024 | 2097152) && destructible & 256) {\r\n              report(parser, 30);\r\n          }\r\n          if (isSimpleParameterList)\r\n              parser.flags |= 128;\r\n          return parseParenthesizedArrow(parser, context, scope, isSequence ? expressions : [expr], canAssign, 0, start, line, column);\r\n      }\r\n      else if (destructible & 8) {\r\n          report(parser, 139);\r\n      }\r\n      parser.destructible = ((parser.destructible | 256) ^ 256) | destructible;\r\n      return context & 128\r\n          ? finishNode(parser, context, iStart, lStart, cStart, {\r\n              type: 'ParenthesizedExpression',\r\n              expression: expr\r\n          })\r\n          : expr;\r\n  }\r\n  function parseIdentifierOrArrow(parser, context, start, line, column) {\r\n      const { tokenValue } = parser;\r\n      const expr = parseIdentifier(parser, context, 0);\r\n      parser.assignable = 1;\r\n      if (parser.token === 10) {\r\n          let scope = void 0;\r\n          if (context & 64)\r\n              scope = createArrowHeadParsingScope(parser, context, tokenValue);\r\n          parser.flags = (parser.flags | 128) ^ 128;\r\n          return parseArrowFunctionExpression(parser, context, scope, [expr], 0, start, line, column);\r\n      }\r\n      return expr;\r\n  }\r\n  function parseArrowFromIdentifier(parser, context, value, expr, inNew, canAssign, isAsync, start, line, column) {\r\n      if (!canAssign)\r\n          report(parser, 54);\r\n      if (inNew)\r\n          report(parser, 48);\r\n      parser.flags &= ~128;\r\n      const scope = context & 64 ? createArrowHeadParsingScope(parser, context, value) : void 0;\r\n      return parseArrowFunctionExpression(parser, context, scope, [expr], isAsync, start, line, column);\r\n  }\r\n  function parseParenthesizedArrow(parser, context, scope, params, canAssign, isAsync, start, line, column) {\r\n      if (!canAssign)\r\n          report(parser, 54);\r\n      for (let i = 0; i < params.length; ++i)\r\n          reinterpretToPattern(parser, params[i]);\r\n      return parseArrowFunctionExpression(parser, context, scope, params, isAsync, start, line, column);\r\n  }\r\n  function parseArrowFunctionExpression(parser, context, scope, params, isAsync, start, line, column) {\r\n      if (parser.flags & 1)\r\n          report(parser, 45);\r\n      consume(parser, context | 32768, 10);\r\n      context = ((context | 15728640) ^ 15728640) | (isAsync << 22);\r\n      const expression = parser.token !== 2162700;\r\n      let body;\r\n      if (scope && scope.scopeError !== void 0) {\r\n          reportScopeError(scope.scopeError);\r\n      }\r\n      if (expression) {\r\n          body = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      }\r\n      else {\r\n          if (scope)\r\n              scope = addChildScope(scope, 128);\r\n          body = parseFunctionBody(parser, (context | 134221824 | 8192 | 16384) ^\r\n              (134221824 | 8192 | 16384), scope, 16, void 0, void 0);\r\n          switch (parser.token) {\r\n              case 69271571:\r\n                  if ((parser.flags & 1) < 1) {\r\n                      report(parser, 112);\r\n                  }\r\n                  break;\r\n              case 67108877:\r\n              case 67174409:\r\n              case 22:\r\n                  report(parser, 113);\r\n              case 67174411:\r\n                  if ((parser.flags & 1) < 1) {\r\n                      report(parser, 112);\r\n                  }\r\n                  parser.flags |= 1024;\r\n                  break;\r\n          }\r\n          if ((parser.token & 8454144) === 8454144 && (parser.flags & 1) < 1)\r\n              report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n          if ((parser.token & 33619968) === 33619968)\r\n              report(parser, 121);\r\n      }\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ArrowFunctionExpression',\r\n          params,\r\n          body,\r\n          async: isAsync === 1,\r\n          expression\r\n      });\r\n  }\r\n  function parseFormalParametersOrFormalList(parser, context, scope, inGroup, kind) {\r\n      consume(parser, context, 67174411);\r\n      parser.flags = (parser.flags | 128) ^ 128;\r\n      const params = [];\r\n      if (consumeOpt(parser, context, 16))\r\n          return params;\r\n      context = (context | 134217728) ^ 134217728;\r\n      let isSimpleParameterList = 0;\r\n      while (parser.token !== 1073741842) {\r\n          let left;\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          if (parser.token & 143360) {\r\n              if ((context & 1024) < 1) {\r\n                  if ((parser.token & 36864) === 36864) {\r\n                      parser.flags |= 256;\r\n                  }\r\n                  if ((parser.token & 537079808) === 537079808) {\r\n                      parser.flags |= 512;\r\n                  }\r\n              }\r\n              left = parseAndClassifyIdentifier(parser, context, scope, kind | 1, 0, tokenPos, linePos, colPos);\r\n          }\r\n          else {\r\n              if (parser.token === 2162700) {\r\n                  left = parseObjectLiteralOrPattern(parser, context, scope, 1, inGroup, 1, kind, 0, tokenPos, linePos, colPos);\r\n              }\r\n              else if (parser.token === 69271571) {\r\n                  left = parseArrayExpressionOrPattern(parser, context, scope, 1, inGroup, 1, kind, 0, tokenPos, linePos, colPos);\r\n              }\r\n              else if (parser.token === 14) {\r\n                  left = parseSpreadOrRestElement(parser, context, scope, 16, kind, 0, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n              }\r\n              else {\r\n                  report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n              }\r\n              isSimpleParameterList = 1;\r\n              if (parser.destructible & (32 | 16)) {\r\n                  report(parser, 47);\r\n              }\r\n          }\r\n          if (parser.token === 1077936157) {\r\n              nextToken(parser, context | 32768);\r\n              isSimpleParameterList = 1;\r\n              const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n              left = finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                  type: 'AssignmentPattern',\r\n                  left,\r\n                  right\r\n              });\r\n          }\r\n          params.push(left);\r\n          if (!consumeOpt(parser, context, 1073741842))\r\n              break;\r\n          if (parser.token === 16) {\r\n              break;\r\n          }\r\n      }\r\n      if (isSimpleParameterList)\r\n          parser.flags |= 128;\r\n      if (scope && ((isSimpleParameterList || context & 1024) && scope.scopeError !== void 0)) {\r\n          reportScopeError(scope.scopeError);\r\n      }\r\n      consume(parser, context, 16);\r\n      return params;\r\n  }\r\n  function parseMembeExpressionNoCall(parser, context, expr, inGroup, start, line, column) {\r\n      const { token } = parser;\r\n      if (token & 67108864) {\r\n          if (token === 67108877) {\r\n              nextToken(parser, context | 1073741824);\r\n              parser.assignable = 1;\r\n              const property = parsePropertyOrPrivatePropertyName(parser, context);\r\n              return parseMembeExpressionNoCall(parser, context, finishNode(parser, context, start, line, column, {\r\n                  type: 'MemberExpression',\r\n                  object: expr,\r\n                  computed: false,\r\n                  property\r\n              }), 0, start, line, column);\r\n          }\r\n          else if (token === 69271571) {\r\n              nextToken(parser, context | 32768);\r\n              const { tokenPos, linePos, colPos } = parser;\r\n              const property = parseExpressions(parser, context, inGroup, 1, tokenPos, linePos, colPos);\r\n              consume(parser, context, 20);\r\n              parser.assignable = 1;\r\n              return parseMembeExpressionNoCall(parser, context, finishNode(parser, context, start, line, column, {\r\n                  type: 'MemberExpression',\r\n                  object: expr,\r\n                  computed: true,\r\n                  property\r\n              }), 0, start, line, column);\r\n          }\r\n          else if (token === 67174408 || token === 67174409) {\r\n              parser.assignable = 2;\r\n              return parseMembeExpressionNoCall(parser, context, finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                  type: 'TaggedTemplateExpression',\r\n                  tag: expr,\r\n                  quasi: parser.token === 67174408\r\n                      ? parseTemplate(parser, context | 65536, start, line, column)\r\n                      : parseTemplateLiteral(parser, context, start, line, column)\r\n              }), 0, start, line, column);\r\n          }\r\n      }\r\n      return expr;\r\n  }\r\n  function parseNewExpression(parser, context, inGroup, start, line, column) {\r\n      const id = parseIdentifier(parser, context | 32768, 0);\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      if (consumeOpt(parser, context, 67108877)) {\r\n          if (context & 67108864 && parser.token === 143491) {\r\n              parser.assignable = 2;\r\n              return parseMetaProperty(parser, context, id, start, line, column);\r\n          }\r\n          report(parser, 91);\r\n      }\r\n      parser.assignable = 2;\r\n      if ((parser.token & 16842752) === 16842752) {\r\n          report(parser, 62, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      const expr = parsePrimaryExpression(parser, context, 2, 1, 0, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n      context = (context | 134217728) ^ 134217728;\r\n      if (parser.token === 67108988)\r\n          report(parser, 162);\r\n      const callee = parseMembeExpressionNoCall(parser, context, expr, inGroup, tokenPos, linePos, colPos);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'NewExpression',\r\n          callee,\r\n          arguments: parser.token === 67174411 ? parseArguments(parser, context, inGroup) : []\r\n      });\r\n  }\r\n  function parseMetaProperty(parser, context, meta, start, line, column) {\r\n      const property = parseIdentifier(parser, context, 0);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'MetaProperty',\r\n          meta,\r\n          property\r\n      });\r\n  }\r\n  function parseAsyncArrowAfterIdent(parser, context, canAssign, start, line, column) {\r\n      if (parser.token === 209005)\r\n          report(parser, 29);\r\n      if (context & (1024 | 2097152) && parser.token === 241770) {\r\n          report(parser, 30);\r\n      }\r\n      if ((parser.token & 537079808) === 537079808) {\r\n          parser.flags |= 512;\r\n      }\r\n      return parseArrowFromIdentifier(parser, context, parser.tokenValue, parseIdentifier(parser, context, 0), 0, canAssign, 1, start, line, column);\r\n  }\r\n  function parseAsyncArrowOrCallExpression(parser, context, callee, canAssign, kind, origin, flags, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const scope = context & 64 ? addChildScope(createScope(), 1024) : void 0;\r\n      context = (context | 134217728) ^ 134217728;\r\n      if (consumeOpt(parser, context, 16)) {\r\n          if (parser.token === 10) {\r\n              if (flags & 1)\r\n                  report(parser, 45);\r\n              return parseParenthesizedArrow(parser, context, scope, [], canAssign, 1, start, line, column);\r\n          }\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'CallExpression',\r\n              callee,\r\n              arguments: []\r\n          });\r\n      }\r\n      let destructible = 0;\r\n      let expr = null;\r\n      let isSimpleParameterList = 0;\r\n      parser.destructible =\r\n          (parser.destructible | 256 | 128) ^\r\n              (256 | 128);\r\n      const params = [];\r\n      while (parser.token !== 16) {\r\n          const { token, tokenPos, linePos, colPos } = parser;\r\n          if (token & (143360 | 4096)) {\r\n              if (scope)\r\n                  addBlockName(parser, context, scope, parser.tokenValue, kind, 0);\r\n              expr = parsePrimaryExpression(parser, context, kind, 0, 1, 0, 1, 1, tokenPos, linePos, colPos);\r\n              if (parser.token === 16 || parser.token === 1073741842) {\r\n                  if (parser.assignable & 2) {\r\n                      destructible |= 16;\r\n                      isSimpleParameterList = 1;\r\n                  }\r\n                  else if ((token & 537079808) === 537079808) {\r\n                      parser.flags |= 512;\r\n                  }\r\n                  else if ((token & 36864) === 36864) {\r\n                      parser.flags |= 256;\r\n                  }\r\n              }\r\n              else {\r\n                  if (parser.token === 1077936157) {\r\n                      isSimpleParameterList = 1;\r\n                  }\r\n                  else {\r\n                      destructible |= 16;\r\n                  }\r\n                  expr = parseMemberOrUpdateExpression(parser, context, expr, 1, tokenPos, linePos, colPos);\r\n                  if (parser.token !== 16 && parser.token !== 1073741842) {\r\n                      expr = parseAssignmentExpression(parser, context, 1, 0, tokenPos, linePos, colPos, expr);\r\n                  }\r\n              }\r\n          }\r\n          else if (token & 2097152) {\r\n              expr =\r\n                  token === 2162700\r\n                      ? parseObjectLiteralOrPattern(parser, context, scope, 0, 1, 0, kind, origin, tokenPos, linePos, colPos)\r\n                      : parseArrayExpressionOrPattern(parser, context, scope, 0, 1, 0, kind, origin, tokenPos, linePos, colPos);\r\n              destructible |= parser.destructible;\r\n              isSimpleParameterList = 1;\r\n              if (parser.token !== 16 && parser.token !== 1073741842) {\r\n                  if (destructible & 8)\r\n                      report(parser, 118);\r\n                  expr = parseMemberOrUpdateExpression(parser, context, expr, 0, tokenPos, linePos, colPos);\r\n                  destructible |= 16;\r\n                  if ((parser.token & 8454144) === 8454144) {\r\n                      expr = parseBinaryExpression(parser, context, 1, start, line, column, 4, token, expr);\r\n                  }\r\n                  if (consumeOpt(parser, context | 32768, 22)) {\r\n                      expr = parseConditionalExpression(parser, context, expr, start, line, column);\r\n                  }\r\n              }\r\n          }\r\n          else if (token === 14) {\r\n              expr = parseSpreadOrRestElement(parser, context, scope, 16, kind, origin, 1, 1, 0, tokenPos, linePos, colPos);\r\n              destructible |= (parser.token === 16 ? 0 : 16) | parser.destructible;\r\n              isSimpleParameterList = 1;\r\n          }\r\n          else {\r\n              expr = parseExpression(parser, context, 1, 0, 0, tokenPos, linePos, colPos);\r\n              destructible = parser.assignable;\r\n              params.push(expr);\r\n              while (consumeOpt(parser, context | 32768, 1073741842)) {\r\n                  params.push(parseExpression(parser, context, 1, 0, 0, tokenPos, linePos, colPos));\r\n              }\r\n              destructible |= parser.assignable;\r\n              consume(parser, context, 16);\r\n              parser.destructible = destructible | 16;\r\n              parser.assignable = 2;\r\n              return finishNode(parser, context, start, line, column, {\r\n                  type: 'CallExpression',\r\n                  callee,\r\n                  arguments: params\r\n              });\r\n          }\r\n          params.push(expr);\r\n          if (!consumeOpt(parser, context | 32768, 1073741842))\r\n              break;\r\n      }\r\n      consume(parser, context, 16);\r\n      destructible |=\r\n          parser.destructible & 256\r\n              ? 256\r\n              : 0 | (parser.destructible & 128)\r\n                  ? 128\r\n                  : 0;\r\n      if (parser.token === 10) {\r\n          if (destructible & (32 | 16))\r\n              report(parser, 25);\r\n          if (parser.flags & 1 || flags & 1)\r\n              report(parser, 45);\r\n          if (destructible & 128)\r\n              report(parser, 29);\r\n          if (context & (1024 | 2097152) && destructible & 256)\r\n              report(parser, 30);\r\n          if (isSimpleParameterList)\r\n              parser.flags |= 128;\r\n          return parseParenthesizedArrow(parser, context, scope, params, canAssign, 1, start, line, column);\r\n      }\r\n      else if (destructible & 8) {\r\n          report(parser, 59);\r\n      }\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'CallExpression',\r\n          callee,\r\n          arguments: params\r\n      });\r\n  }\r\n  function parseRegExpLiteral(parser, context, start, line, column) {\r\n      const { tokenRaw, tokenRegExp, tokenValue } = parser;\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return context & 512\r\n          ? finishNode(parser, context, start, line, column, {\r\n              type: 'Literal',\r\n              value: tokenValue,\r\n              regex: tokenRegExp,\r\n              raw: tokenRaw\r\n          })\r\n          : finishNode(parser, context, start, line, column, {\r\n              type: 'Literal',\r\n              value: tokenValue,\r\n              regex: tokenRegExp\r\n          });\r\n  }\r\n  function parseClassDeclaration(parser, context, scope, flags, start, line, column) {\r\n      context = (context | 16777216 | 1024) ^ 16777216;\r\n      const decorators = context & 1 ? parseDecorators(parser, context) : [];\r\n      nextToken(parser, context);\r\n      let id = null;\r\n      let superClass = null;\r\n      const { tokenValue } = parser;\r\n      if (((parser.token & 4351) ^ 84) >\r\n          4096) {\r\n          if (isStrictReservedWord(parser, context, parser.token)) {\r\n              report(parser, 114);\r\n          }\r\n          if ((parser.token & 537079808) === 537079808) {\r\n              report(parser, 115);\r\n          }\r\n          if (scope) {\r\n              addBlockName(parser, context, scope, tokenValue, 32, 0);\r\n              if (flags) {\r\n                  if (flags & 2) {\r\n                      declareUnboundVariable(parser, tokenValue);\r\n                  }\r\n              }\r\n          }\r\n          id = parseIdentifier(parser, context, 0);\r\n      }\r\n      else {\r\n          if ((flags & 1) < 1)\r\n              report(parser, 37, 'Class');\r\n      }\r\n      let inheritedContext = context;\r\n      if (consumeOpt(parser, context | 32768, 20564)) {\r\n          superClass = parseLeftHandSideExpression(parser, context, 0, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n          inheritedContext |= 524288;\r\n      }\r\n      else {\r\n          inheritedContext = (inheritedContext | 524288) ^ 524288;\r\n      }\r\n      const body = parseClassBody(parser, inheritedContext, context, scope, 2, 8, 0);\r\n      return finishNode(parser, context, start, line, column, context & 1\r\n          ? {\r\n              type: 'ClassDeclaration',\r\n              id,\r\n              superClass,\r\n              decorators,\r\n              body\r\n          }\r\n          : {\r\n              type: 'ClassDeclaration',\r\n              id,\r\n              superClass,\r\n              body\r\n          });\r\n  }\r\n  function parseClassExpression(parser, context, inGroup, start, line, column) {\r\n      let id = null;\r\n      let superClass = null;\r\n      context = (context | 1024 | 16777216) ^ 16777216;\r\n      const decorators = context & 1 ? parseDecorators(parser, context) : [];\r\n      nextToken(parser, context);\r\n      if (((parser.token & 0x10ff) ^ 0x54) > 0x1000) {\r\n          if (isStrictReservedWord(parser, context, parser.token))\r\n              report(parser, 114);\r\n          if ((parser.token & 537079808) === 537079808) {\r\n              report(parser, 115);\r\n          }\r\n          id = parseIdentifier(parser, context, 0);\r\n      }\r\n      let inheritedContext = context;\r\n      if (consumeOpt(parser, context | 32768, 20564)) {\r\n          superClass = parseLeftHandSideExpression(parser, context, 0, inGroup, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n          inheritedContext |= 524288;\r\n      }\r\n      else {\r\n          inheritedContext = (inheritedContext | 524288) ^ 524288;\r\n      }\r\n      const body = parseClassBody(parser, inheritedContext, context, void 0, 2, 0, inGroup);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, context & 1\r\n          ? {\r\n              type: 'ClassExpression',\r\n              id,\r\n              superClass,\r\n              decorators,\r\n              body\r\n          }\r\n          : {\r\n              type: 'ClassExpression',\r\n              id,\r\n              superClass,\r\n              body\r\n          });\r\n  }\r\n  function parseDecorators(parser, context) {\r\n      const list = [];\r\n      while (parser.token === 130) {\r\n          list.push(parseDecoratorList(parser, context, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return list;\r\n  }\r\n  function parseDecoratorList(parser, context, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      let expression = parsePrimaryExpression(parser, context, 2, 0, 1, 0, 0, 1, start, line, column);\r\n      expression = parseMemberOrUpdateExpression(parser, context, expression, 0, start, line, column);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'Decorator',\r\n          expression\r\n      });\r\n  }\r\n  function parseClassBody(parser, context, inheritedContext, scope, kind, origin, inGroup) {\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      consume(parser, context | 32768, 2162700);\r\n      context = (context | 134217728) ^ 134217728;\r\n      parser.flags = (parser.flags | 32) ^ 32;\r\n      const body = [];\r\n      let decorators = [];\r\n      while (parser.token !== 1074790415) {\r\n          let length = 0;\r\n          decorators = parseDecorators(parser, context);\r\n          length = decorators.length;\r\n          if (length > 0 && parser.tokenValue === 'constructor') {\r\n              report(parser, 106);\r\n          }\r\n          if (parser.token === 1074790415)\r\n              report(parser, 105);\r\n          if (consumeOpt(parser, context, 1074790417)) {\r\n              if (length > 0)\r\n                  report(parser, 116);\r\n              continue;\r\n          }\r\n          body.push(parseClassElementList(parser, context, scope, inheritedContext, kind, decorators, 0, inGroup, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      consume(parser, origin & 8 ? context | 32768 : context, 1074790415);\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'ClassBody',\r\n          body\r\n      });\r\n  }\r\n  function parseClassElementList(parser, context, scope, inheritedContext, type, decorators, isStatic, inGroup, start, line, column) {\r\n      let kind = isStatic ? 32 : 0;\r\n      let key = null;\r\n      const { token, tokenPos, linePos, colPos } = parser;\r\n      if (token & (143360 | 36864)) {\r\n          key = parseIdentifier(parser, context, 0);\r\n          switch (token) {\r\n              case 36969:\r\n                  if (!isStatic && parser.token !== 67174411) {\r\n                      return parseClassElementList(parser, context, scope, inheritedContext, type, decorators, 1, inGroup, start, line, column);\r\n                  }\r\n                  break;\r\n              case 143468:\r\n                  if (parser.token !== 67174411 && (parser.flags & 1) < 1) {\r\n                      if (context & 1 && (parser.token & 1073741824) === 1073741824) {\r\n                          return parseFieldDefinition(parser, context, key, kind, decorators, tokenPos, linePos, colPos);\r\n                      }\r\n                      kind |= 16 | (optionalBit(parser, context, 8457011) ? 8 : 0);\r\n                  }\r\n                  break;\r\n              case 12399:\r\n                  if (parser.token !== 67174411) {\r\n                      if (context & 1 && (parser.token & 1073741824) === 1073741824) {\r\n                          return parseFieldDefinition(parser, context, key, kind, decorators, tokenPos, linePos, colPos);\r\n                      }\r\n                      kind |= 256;\r\n                  }\r\n                  break;\r\n              case 12400:\r\n                  if (parser.token !== 67174411) {\r\n                      if (context & 1 && (parser.token & 1073741824) === 1073741824) {\r\n                          return parseFieldDefinition(parser, context, key, kind, decorators, tokenPos, linePos, colPos);\r\n                      }\r\n                      kind |= 512;\r\n                  }\r\n                  break;\r\n          }\r\n      }\r\n      else if (token === 69271571) {\r\n          kind = 2;\r\n          key = parseComputedPropertyName(parser, inheritedContext, inGroup);\r\n      }\r\n      else if ((token & 134217728) === 134217728) {\r\n          key = parseLiteral(parser, context);\r\n      }\r\n      else if (token === 8457011) {\r\n          kind |= 8;\r\n          nextToken(parser, context);\r\n      }\r\n      else if (context & 1 && parser.token === 128) {\r\n          kind |= 4096;\r\n          key = parsePrivateName(parser, context, tokenPos, linePos, colPos);\r\n          context = context | 16384;\r\n      }\r\n      else if (context & 1 && (parser.token & 1073741824) === 1073741824) {\r\n          kind |= 128;\r\n          context = context | 16384;\r\n      }\r\n      else if (token === 119) {\r\n          key = parseIdentifier(parser, context, 0);\r\n          if (parser.token !== 67174411)\r\n              report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      else {\r\n          report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      if (kind & (8 | 16 | 768)) {\r\n          if (parser.token & 143360) {\r\n              key = parseIdentifier(parser, context, 0);\r\n          }\r\n          else if ((parser.token & 134217728) === 134217728) {\r\n              key = parseLiteral(parser, context);\r\n          }\r\n          else if (parser.token === 69271571) {\r\n              kind |= 2;\r\n              key = parseComputedPropertyName(parser, context, 0);\r\n          }\r\n          else if (parser.token === 119) {\r\n              key = parseIdentifier(parser, context, 0);\r\n          }\r\n          else if (context & 1 && parser.token === 128) {\r\n              kind |= 4096;\r\n              key = parsePrivateName(parser, context, tokenPos, linePos, colPos);\r\n          }\r\n          else\r\n              report(parser, 131);\r\n      }\r\n      if ((kind & 2) < 1) {\r\n          if (parser.tokenValue === 'constructor') {\r\n              if ((parser.token & 1073741824) === 1073741824) {\r\n                  report(parser, 125);\r\n              }\r\n              else if ((kind & 32) < 1 && parser.token === 67174411) {\r\n                  if (kind & (768 | 16 | 128 | 8)) {\r\n                      report(parser, 50, 'accessor');\r\n                  }\r\n                  else if ((context & 524288) < 1) {\r\n                      if (parser.flags & 32)\r\n                          report(parser, 51);\r\n                      else\r\n                          parser.flags |= 32;\r\n                  }\r\n              }\r\n              kind |= 64;\r\n          }\r\n          else if ((kind & 4096) < 1 &&\r\n              kind & (32 | 768 | 8 | 16) &&\r\n              parser.tokenValue === 'prototype') {\r\n              report(parser, 49);\r\n          }\r\n      }\r\n      if (context & 1 && parser.token !== 67174411) {\r\n          return parseFieldDefinition(parser, context, key, kind, decorators, tokenPos, linePos, colPos);\r\n      }\r\n      const value = parseMethodDefinition(parser, context, kind, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, context & 1\r\n          ? {\r\n              type: 'MethodDefinition',\r\n              kind: (kind & 32) < 1 && kind & 64\r\n                  ? 'constructor'\r\n                  : kind & 256\r\n                      ? 'get'\r\n                      : kind & 512\r\n                          ? 'set'\r\n                          : 'method',\r\n              static: (kind & 32) > 0,\r\n              computed: (kind & 2) > 0,\r\n              key,\r\n              decorators,\r\n              value\r\n          }\r\n          : {\r\n              type: 'MethodDefinition',\r\n              kind: (kind & 32) < 1 && kind & 64\r\n                  ? 'constructor'\r\n                  : kind & 256\r\n                      ? 'get'\r\n                      : kind & 512\r\n                          ? 'set'\r\n                          : 'method',\r\n              static: (kind & 32) > 0,\r\n              computed: (kind & 2) > 0,\r\n              key,\r\n              value\r\n          });\r\n  }\r\n  function parsePrivateName(parser, context, start, line, column) {\r\n      nextToken(parser, context);\r\n      const { tokenValue } = parser;\r\n      if (tokenValue === 'constructor')\r\n          report(parser, 124);\r\n      nextToken(parser, context);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'PrivateName',\r\n          name: tokenValue\r\n      });\r\n  }\r\n  function parseFieldDefinition(parser, context, key, state, decorators, start, line, column) {\r\n      let value = null;\r\n      if (state & 8)\r\n          report(parser, 0);\r\n      if (parser.token === 1077936157) {\r\n          nextToken(parser, context | 32768);\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          if (parser.token === 537079925)\r\n              report(parser, 115);\r\n          value = parsePrimaryExpression(parser, context | 16384, 2, 0, 1, 0, 0, 1, tokenPos, linePos, colPos);\r\n          if ((parser.token & 1073741824) !== 1073741824) {\r\n              value = parseMemberOrUpdateExpression(parser, context | 16384, value, 0, tokenPos, linePos, colPos);\r\n              value = parseAssignmentExpression(parser, context | 16384, 0, 0, tokenPos, linePos, colPos, value);\r\n              if (parser.token === 1073741842) {\r\n                  value = parseSequenceExpression(parser, context, 0, start, line, column, value);\r\n              }\r\n          }\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'FieldDefinition',\r\n          key,\r\n          value,\r\n          static: (state & 32) > 0,\r\n          computed: (state & 2) > 0,\r\n          decorators\r\n      });\r\n  }\r\n  function parseBindingPattern(parser, context, scope, type, origin, start, line, column) {\r\n      if (parser.token & 143360)\r\n          return parseAndClassifyIdentifier(parser, context, scope, type, origin, start, line, column);\r\n      if ((parser.token & 2097152) !== 2097152)\r\n          report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      const left = parser.token === 69271571\r\n          ? parseArrayExpressionOrPattern(parser, context, scope, 1, 0, 1, type, origin, start, line, column)\r\n          : parseObjectLiteralOrPattern(parser, context, scope, 1, 0, 1, type, origin, start, line, column);\r\n      if (parser.destructible & 16)\r\n          report(parser, 47);\r\n      if (parser.destructible & 32)\r\n          report(parser, 47);\r\n      return left;\r\n  }\r\n  function parseAndClassifyIdentifier(parser, context, scope, kind, origin, start, line, column) {\r\n      const { tokenValue, token } = parser;\r\n      if (context & 1024) {\r\n          if ((token & 537079808) === 537079808) {\r\n              report(parser, 115);\r\n          }\r\n          else if ((token & 36864) === 36864) {\r\n              report(parser, 114);\r\n          }\r\n      }\r\n      if ((token & 20480) === 20480) {\r\n          report(parser, 99);\r\n      }\r\n      if (context & (2048 | 2097152) && token === 241770) {\r\n          report(parser, 30);\r\n      }\r\n      if (token === 241736) {\r\n          if (kind & (8 | 16))\r\n              report(parser, 97);\r\n      }\r\n      if (context & (4194304 | 2048) && token === 209005) {\r\n          report(parser, 95);\r\n      }\r\n      nextToken(parser, context);\r\n      if (scope)\r\n          addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'Identifier',\r\n          name: tokenValue\r\n      });\r\n  }\r\n  function parseJSXRootElementOrFragment(parser, context, inJSXChild, start, line, column) {\r\n      nextToken(parser, context);\r\n      if (parser.token === 8456256) {\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'JSXFragment',\r\n              openingFragment: parseOpeningFragment(parser, context, start, line, column),\r\n              children: parseJSXChildren(parser, context),\r\n              closingFragment: parseJSXClosingFragment(parser, context, inJSXChild, parser.tokenPos, parser.linePos, parser.colPos)\r\n          });\r\n      }\r\n      let closingElement = null;\r\n      let children = [];\r\n      const openingElement = parseJSXOpeningFragmentOrSelfCloseElement(parser, context, inJSXChild, start, line, column);\r\n      if (!openingElement.selfClosing) {\r\n          children = parseJSXChildren(parser, context);\r\n          closingElement = parseJSXClosingElement(parser, context, inJSXChild, parser.tokenPos, parser.linePos, parser.colPos);\r\n          const close = isEqualTagName(closingElement.name);\r\n          if (isEqualTagName(openingElement.name) !== close)\r\n              report(parser, 149, close);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXElement',\r\n          children,\r\n          openingElement,\r\n          closingElement\r\n      });\r\n  }\r\n  function parseOpeningFragment(parser, context, start, line, column) {\r\n      scanJSXToken(parser);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXOpeningFragment'\r\n      });\r\n  }\r\n  function parseJSXClosingElement(parser, context, inJSXChild, start, line, column) {\r\n      consume(parser, context, 25);\r\n      const name = parseJSXElementName(parser, context, parser.tokenPos, parser.linePos, parser.colPos);\r\n      if (inJSXChild) {\r\n          consume(parser, context, 8456256);\r\n      }\r\n      else {\r\n          parser.token = scanJSXToken(parser);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXClosingElement',\r\n          name\r\n      });\r\n  }\r\n  function parseJSXClosingFragment(parser, context, inJSXChild, start, line, column) {\r\n      consume(parser, context, 25);\r\n      if (inJSXChild) {\r\n          consume(parser, context, 8456256);\r\n      }\r\n      else {\r\n          consume(parser, context, 8456256);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXClosingFragment'\r\n      });\r\n  }\r\n  function parseJSXChildren(parser, context) {\r\n      const children = [];\r\n      while (parser.token !== 25) {\r\n          parser.index = parser.tokenPos = parser.startPos;\r\n          parser.column = parser.colPos = parser.startColumn;\r\n          parser.line = parser.linePos = parser.startLine;\r\n          scanJSXToken(parser);\r\n          children.push(parseJSXChild(parser, context, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return children;\r\n  }\r\n  function parseJSXChild(parser, context, start, line, column) {\r\n      if (parser.token === 135)\r\n          return parseJSXText(parser, context, start, line, column);\r\n      if (parser.token === 2162700)\r\n          return parseJSXExpressionContainer(parser, context, 0, 0, start, line, column);\r\n      if (parser.token === 8456255)\r\n          return parseJSXRootElementOrFragment(parser, context, 0, start, line, column);\r\n      report(parser, 0);\r\n  }\r\n  function parseJSXText(parser, context, start, line, column) {\r\n      scanJSXToken(parser);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXText',\r\n          value: parser.tokenValue\r\n      });\r\n  }\r\n  function parseJSXOpeningFragmentOrSelfCloseElement(parser, context, inJSXChild, start, line, column) {\r\n      if ((parser.token & 143360) !== 143360 && (parser.token & 4096) !== 4096)\r\n          report(parser, 0);\r\n      const tagName = parseJSXElementName(parser, context, parser.tokenPos, parser.linePos, parser.colPos);\r\n      const attributes = parseJSXAttributes(parser, context);\r\n      const selfClosing = parser.token === 8457013;\r\n      if (parser.token === 8456256) {\r\n          scanJSXToken(parser);\r\n      }\r\n      else {\r\n          consume(parser, context, 8457013);\r\n          if (inJSXChild) {\r\n              consume(parser, context, 8456256);\r\n          }\r\n          else {\r\n              scanJSXToken(parser);\r\n          }\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXOpeningElement',\r\n          name: tagName,\r\n          attributes,\r\n          selfClosing\r\n      });\r\n  }\r\n  function parseJSXElementName(parser, context, start, line, column) {\r\n      scanJSXIdentifier(parser);\r\n      let key = parseJSXIdentifier(parser, context, start, line, column);\r\n      if (parser.token === 21)\r\n          return parseJSXNamespacedName(parser, context, key, start, line, column);\r\n      while (consumeOpt(parser, context, 67108877)) {\r\n          scanJSXIdentifier(parser);\r\n          key = parseJSXMemberExpression(parser, context, key, start, line, column);\r\n      }\r\n      return key;\r\n  }\r\n  function parseJSXMemberExpression(parser, context, object, start, line, column) {\r\n      const property = parseJSXIdentifier(parser, context, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXMemberExpression',\r\n          object,\r\n          property\r\n      });\r\n  }\r\n  function parseJSXAttributes(parser, context) {\r\n      const attributes = [];\r\n      while (parser.token !== 8457013 && parser.token !== 8456256) {\r\n          attributes.push(parseJsxAttribute(parser, context, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return attributes;\r\n  }\r\n  function parseJSXSpreadAttribute(parser, context, start, line, column) {\r\n      nextToken(parser, context);\r\n      consume(parser, context, 14);\r\n      const expression = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context, 1074790415);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXSpreadAttribute',\r\n          argument: expression\r\n      });\r\n  }\r\n  function parseJsxAttribute(parser, context, start, line, column) {\r\n      if (parser.token === 2162700)\r\n          return parseJSXSpreadAttribute(parser, context, start, line, column);\r\n      scanJSXIdentifier(parser);\r\n      let value = null;\r\n      let name = parseJSXIdentifier(parser, context, start, line, column);\r\n      if (parser.token === 21) {\r\n          name = parseJSXNamespacedName(parser, context, name, start, line, column);\r\n      }\r\n      if (parser.token === 1077936157) {\r\n          const token = scanJSXAttributeValue(parser, context);\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          switch (token) {\r\n              case 134283267:\r\n                  value = parseLiteral(parser, context);\r\n                  break;\r\n              case 8456255:\r\n                  value = parseJSXRootElementOrFragment(parser, context, 1, tokenPos, linePos, colPos);\r\n                  break;\r\n              case 2162700:\r\n                  value = parseJSXExpressionContainer(parser, context, 1, 1, tokenPos, linePos, colPos);\r\n                  break;\r\n              default:\r\n                  report(parser, 148);\r\n          }\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXAttribute',\r\n          value,\r\n          name\r\n      });\r\n  }\r\n  function parseJSXNamespacedName(parser, context, namespace, start, line, column) {\r\n      consume(parser, context, 21);\r\n      const name = parseJSXIdentifier(parser, context, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXNamespacedName',\r\n          namespace,\r\n          name\r\n      });\r\n  }\r\n  function parseJSXExpressionContainer(parser, context, inJSXChild, isAttr, start, line, column) {\r\n      nextToken(parser, context);\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      if (parser.token === 14)\r\n          return parseJSXSpreadChild(parser, context, tokenPos, linePos, colPos);\r\n      let expression = null;\r\n      if (parser.token === 1074790415) {\r\n          if (isAttr)\r\n              report(parser, 151);\r\n          expression = parseJSXEmptyExpression(parser, context, tokenPos, linePos, colPos);\r\n      }\r\n      else {\r\n          expression = parseExpression(parser, context, 1, 0, 0, tokenPos, linePos, colPos);\r\n      }\r\n      if (inJSXChild) {\r\n          consume(parser, context, 1074790415);\r\n      }\r\n      else {\r\n          scanJSXToken(parser);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXExpressionContainer',\r\n          expression\r\n      });\r\n  }\r\n  function parseJSXSpreadChild(parser, context, start, line, column) {\r\n      consume(parser, context, 14);\r\n      const expression = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context, 1074790415);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXSpreadChild',\r\n          expression\r\n      });\r\n  }\r\n  function parseJSXEmptyExpression(parser, context, start, line, column) {\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXEmptyExpression'\r\n      });\r\n  }\r\n  function parseJSXIdentifier(parser, context, start, line, column) {\r\n      const { tokenValue } = parser;\r\n      nextToken(parser, context);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXIdentifier',\r\n          name: tokenValue\r\n      });\r\n  }\n\n\n\n  var estree = /*#__PURE__*/Object.freeze({\n    __proto__: null\n  });\n\n  function parseScript(source, options) {\r\n      return parseSource(source, options, 0);\r\n  }\r\n  function parseModule(source, options) {\r\n      return parseSource(source, options, 1024 | 2048);\r\n  }\r\n  function parse(source, options) {\r\n      return parseSource(source, options, 0);\r\n  }\r\n  const version = '1.9.12';\n\n  exports.ESTree = estree;\n  exports.parse = parse;\n  exports.parseModule = parseModule;\n  exports.parseScript = parseScript;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//# sourceURL=webpack:///./node_modules/meriyah/dist/meriyah.umd.js?")}}]);