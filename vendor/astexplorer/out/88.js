(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{"./node_modules/exports-loader/index.js?traceur!./node_modules/traceur/bin/traceur.js":function(module,exports){eval('(function(global) {\n  \'use strict\';\n  if (global.$traceurRuntime) {\n    return;\n  }\n  function setupGlobals(global) {\n    global.Reflect = global.Reflect || {};\n    global.Reflect.global = global.Reflect.global || global;\n  }\n  setupGlobals(global);\n  var typeOf = function(x) {\n    return typeof x;\n  };\n  global.$traceurRuntime = {\n    options: {},\n    setupGlobals: setupGlobals,\n    typeof: typeOf\n  };\n})(typeof window !== \'undefined\' ? window : typeof global !== \'undefined\' ? global : typeof self !== \'undefined\' ? self : this);\n(function() {\n  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var out = [];\n    if (opt_scheme) {\n      out.push(opt_scheme, \':\');\n    }\n    if (opt_domain) {\n      out.push(\'//\');\n      if (opt_userInfo) {\n        out.push(opt_userInfo, \'@\');\n      }\n      out.push(opt_domain);\n      if (opt_port) {\n        out.push(\':\', opt_port);\n      }\n    }\n    if (opt_path) {\n      out.push(opt_path);\n    }\n    if (opt_queryData) {\n      out.push(\'?\', opt_queryData);\n    }\n    if (opt_fragment) {\n      out.push(\'#\', opt_fragment);\n    }\n    return out.join(\'\');\n  }\n  var splitRe = new RegExp(\'^\' + \'(?:\' + \'([^:/?#.]+)\' + \':)?\' + \'(?://\' + \'(?:([^/?#]*)@)?\' + \'([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)\' + \'(?::([0-9]+))?\' + \')?\' + \'([^?#]+)?\' + \'(?:\\\\?([^#]*))?\' + \'(?:#(.*))?\' + \'$\');\n  var ComponentIndex = {\n    SCHEME: 1,\n    USER_INFO: 2,\n    DOMAIN: 3,\n    PORT: 4,\n    PATH: 5,\n    QUERY_DATA: 6,\n    FRAGMENT: 7\n  };\n  function split(uri) {\n    return (uri.match(splitRe));\n  }\n  function removeDotSegments(path) {\n    if (path === \'/\')\n      return \'/\';\n    var leadingSlash = path[0] === \'/\' ? \'/\' : \'\';\n    var trailingSlash = path.slice(-1) === \'/\' ? \'/\' : \'\';\n    var segments = path.split(\'/\');\n    var out = [];\n    var up = 0;\n    for (var pos = 0; pos < segments.length; pos++) {\n      var segment = segments[pos];\n      switch (segment) {\n        case \'\':\n        case \'.\':\n          break;\n        case \'..\':\n          if (out.length)\n            out.pop();\n          else\n            up++;\n          break;\n        default:\n          out.push(segment);\n      }\n    }\n    if (!leadingSlash) {\n      while (up-- > 0) {\n        out.unshift(\'..\');\n      }\n      if (out.length === 0)\n        out.push(\'.\');\n    }\n    return leadingSlash + out.join(\'/\') + trailingSlash;\n  }\n  function joinAndCanonicalizePath(parts) {\n    var path = parts[ComponentIndex.PATH] || \'\';\n    path = removeDotSegments(path);\n    parts[ComponentIndex.PATH] = path;\n    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);\n  }\n  function canonicalizeUrl(url) {\n    var parts = split(url);\n    return joinAndCanonicalizePath(parts);\n  }\n  function resolveUrl(base, url) {\n    var parts = split(url);\n    var baseParts = split(base);\n    if (parts[ComponentIndex.SCHEME]) {\n      return joinAndCanonicalizePath(parts);\n    } else {\n      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];\n    }\n    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {\n      if (!parts[i]) {\n        parts[i] = baseParts[i];\n      }\n    }\n    if (parts[ComponentIndex.PATH][0] == \'/\') {\n      return joinAndCanonicalizePath(parts);\n    }\n    var path = baseParts[ComponentIndex.PATH];\n    var index = path.lastIndexOf(\'/\');\n    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];\n    parts[ComponentIndex.PATH] = path;\n    return joinAndCanonicalizePath(parts);\n  }\n  function isAbsolute(name) {\n    if (!name)\n      return false;\n    if (name[0] === \'/\')\n      return true;\n    var parts = split(name);\n    if (parts[ComponentIndex.SCHEME])\n      return true;\n    return false;\n  }\n  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;\n  $traceurRuntime.isAbsolute = isAbsolute;\n  $traceurRuntime.removeDotSegments = removeDotSegments;\n  $traceurRuntime.resolveUrl = resolveUrl;\n})();\n(function(global) {\n  \'use strict\';\n  var $__3 = $traceurRuntime,\n      canonicalizeUrl = $__3.canonicalizeUrl,\n      resolveUrl = $__3.resolveUrl,\n      isAbsolute = $__3.isAbsolute;\n  var moduleInstantiators = Object.create(null);\n  var baseURL;\n  if (global.location && global.location.href)\n    baseURL = resolveUrl(global.location.href, \'./\');\n  else\n    baseURL = \'\';\n  function UncoatedModuleEntry(url, uncoatedModule) {\n    this.url = url;\n    this.value_ = uncoatedModule;\n  }\n  function ModuleEvaluationError(erroneousModuleName, cause) {\n    this.message = this.constructor.name + \': \' + this.stripCause(cause) + \' in \' + erroneousModuleName;\n    if (!(cause instanceof ModuleEvaluationError) && cause.stack)\n      this.stack = this.stripStack(cause.stack);\n    else\n      this.stack = \'\';\n  }\n  ModuleEvaluationError.prototype = Object.create(Error.prototype);\n  ModuleEvaluationError.prototype.constructor = ModuleEvaluationError;\n  ModuleEvaluationError.prototype.stripError = function(message) {\n    return message.replace(/.*Error:/, this.constructor.name + \':\');\n  };\n  ModuleEvaluationError.prototype.stripCause = function(cause) {\n    if (!cause)\n      return \'\';\n    if (!cause.message)\n      return cause + \'\';\n    return this.stripError(cause.message);\n  };\n  ModuleEvaluationError.prototype.loadedBy = function(moduleName) {\n    this.stack += \'\\n loaded by \' + moduleName;\n  };\n  ModuleEvaluationError.prototype.stripStack = function(causeStack) {\n    var stack = [];\n    causeStack.split(\'\\n\').some(function(frame) {\n      if (/UncoatedModuleInstantiator/.test(frame))\n        return true;\n      stack.push(frame);\n    });\n    stack[0] = this.stripError(stack[0]);\n    return stack.join(\'\\n\');\n  };\n  function beforeLines(lines, number) {\n    var result = [];\n    var first = number - 3;\n    if (first < 0)\n      first = 0;\n    for (var i = first; i < number; i++) {\n      result.push(lines[i]);\n    }\n    return result;\n  }\n  function afterLines(lines, number) {\n    var last = number + 1;\n    if (last > lines.length - 1)\n      last = lines.length - 1;\n    var result = [];\n    for (var i = number; i <= last; i++) {\n      result.push(lines[i]);\n    }\n    return result;\n  }\n  function columnSpacing(columns) {\n    var result = \'\';\n    for (var i = 0; i < columns - 1; i++) {\n      result += \'-\';\n    }\n    return result;\n  }\n  function UncoatedModuleInstantiator(url, func) {\n    UncoatedModuleEntry.call(this, url, null);\n    this.func = func;\n  }\n  UncoatedModuleInstantiator.prototype = Object.create(UncoatedModuleEntry.prototype);\n  UncoatedModuleInstantiator.prototype.getUncoatedModule = function() {\n    var $__2 = this;\n    if (this.value_)\n      return this.value_;\n    try {\n      var relativeRequire;\n      if (typeof $traceurRuntime !== undefined && $traceurRuntime.require) {\n        relativeRequire = $traceurRuntime.require.bind(null, this.url);\n      }\n      return this.value_ = this.func.call(global, relativeRequire);\n    } catch (ex) {\n      if (ex instanceof ModuleEvaluationError) {\n        ex.loadedBy(this.url);\n        throw ex;\n      }\n      if (ex.stack) {\n        var lines = this.func.toString().split(\'\\n\');\n        var evaled = [];\n        ex.stack.split(\'\\n\').some(function(frame, index) {\n          if (frame.indexOf(\'UncoatedModuleInstantiator.getUncoatedModule\') > 0)\n            return true;\n          var m = /(at\\s[^\\s]*\\s).*>:(\\d*):(\\d*)\\)/.exec(frame);\n          if (m) {\n            var line = parseInt(m[2], 10);\n            evaled = evaled.concat(beforeLines(lines, line));\n            if (index === 1) {\n              evaled.push(columnSpacing(m[3]) + \'^ \' + $__2.url);\n            } else {\n              evaled.push(columnSpacing(m[3]) + \'^\');\n            }\n            evaled = evaled.concat(afterLines(lines, line));\n            evaled.push(\'= = = = = = = = =\');\n          } else {\n            evaled.push(frame);\n          }\n        });\n        ex.stack = evaled.join(\'\\n\');\n      }\n      throw new ModuleEvaluationError(this.url, ex);\n    }\n  };\n  function getUncoatedModuleInstantiator(name) {\n    if (!name)\n      return;\n    var url = ModuleStore.normalize(name);\n    return moduleInstantiators[url];\n  }\n  ;\n  var moduleInstances = Object.create(null);\n  var liveModuleSentinel = {};\n  function Module(uncoatedModule) {\n    var isLive = arguments[1];\n    var coatedModule = Object.create(null);\n    Object.getOwnPropertyNames(uncoatedModule).forEach(function(name) {\n      var getter,\n          value;\n      if (isLive === liveModuleSentinel) {\n        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);\n        if (descr.get)\n          getter = descr.get;\n      }\n      if (!getter) {\n        value = uncoatedModule[name];\n        getter = function() {\n          return value;\n        };\n      }\n      Object.defineProperty(coatedModule, name, {\n        get: getter,\n        enumerable: true\n      });\n    });\n    Object.preventExtensions(coatedModule);\n    return coatedModule;\n  }\n  var ModuleStore = {\n    normalize: function(name, refererName, refererAddress) {\n      if (typeof name !== \'string\')\n        throw new TypeError(\'module name must be a string, not \' + typeof name);\n      if (isAbsolute(name))\n        return canonicalizeUrl(name);\n      if (/[^\\.]\\/\\.\\.\\//.test(name)) {\n        throw new Error(\'module name embeds /../: \' + name);\n      }\n      if (name[0] === \'.\' && refererName)\n        return resolveUrl(refererName, name);\n      return canonicalizeUrl(name);\n    },\n    get: function(normalizedName) {\n      var m = getUncoatedModuleInstantiator(normalizedName);\n      if (!m)\n        return undefined;\n      var moduleInstance = moduleInstances[m.url];\n      if (moduleInstance)\n        return moduleInstance;\n      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);\n      return moduleInstances[m.url] = moduleInstance;\n    },\n    set: function(normalizedName, module) {\n      normalizedName = String(normalizedName);\n      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, function() {\n        return module;\n      });\n      moduleInstances[normalizedName] = module;\n    },\n    get baseURL() {\n      return baseURL;\n    },\n    set baseURL(v) {\n      baseURL = String(v);\n    },\n    registerModule: function(name, deps, func) {\n      var normalizedName = ModuleStore.normalize(name);\n      if (moduleInstantiators[normalizedName])\n        throw new Error(\'duplicate module named \' + normalizedName);\n      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);\n    },\n    bundleStore: Object.create(null),\n    register: function(name, deps, func) {\n      if (!deps || !deps.length && !func.length) {\n        this.registerModule(name, deps, func);\n      } else {\n        this.bundleStore[name] = {\n          deps: deps,\n          execute: function() {\n            var $__2 = arguments;\n            var depMap = {};\n            deps.forEach(function(dep, index) {\n              return depMap[dep] = $__2[index];\n            });\n            var registryEntry = func.call(this, depMap);\n            registryEntry.execute.call(this);\n            return registryEntry.exports;\n          }\n        };\n      }\n    },\n    getAnonymousModule: function(func) {\n      return new Module(func(), liveModuleSentinel);\n    }\n  };\n  var moduleStoreModule = new Module({ModuleStore: ModuleStore});\n  ModuleStore.set(\'@traceur/src/runtime/ModuleStore.js\', moduleStoreModule);\n  var setupGlobals = $traceurRuntime.setupGlobals;\n  $traceurRuntime.setupGlobals = function(global) {\n    setupGlobals(global);\n  };\n  $traceurRuntime.ModuleStore = ModuleStore;\n  $traceurRuntime.registerModule = ModuleStore.registerModule.bind(ModuleStore);\n  $traceurRuntime.getModule = ModuleStore.get;\n  $traceurRuntime.setModule = ModuleStore.set;\n  $traceurRuntime.normalizeModuleName = ModuleStore.normalize;\n})(typeof window !== \'undefined\' ? window : typeof global !== \'undefined\' ? global : typeof self !== \'undefined\' ? self : this);\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/new-unique-string.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/new-unique-string.js";\n  var random = Math.random;\n  var counter = Date.now() % 1e9;\n  function newUniqueString() {\n    return \'__$\' + (random() * 1e9 >>> 1) + \'$\' + ++counter + \'$__\';\n  }\n  return {get default() {\n      return newUniqueString;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/has-native-symbols.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/has-native-symbols.js";\n  var v = !!Object.getOwnPropertySymbols && typeof Symbol === \'function\';\n  function hasNativeSymbol() {\n    return v;\n  }\n  return {get default() {\n      return hasNativeSymbol;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/symbols.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/symbols.js";\n  var newUniqueString = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../new-unique-string.js", "traceur@0.0.111/src/runtime/modules/symbols.js")).default;\n  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur@0.0.111/src/runtime/modules/symbols.js")).default;\n  var $create = Object.create;\n  var $defineProperty = Object.defineProperty;\n  var $freeze = Object.freeze;\n  var $getOwnPropertyNames = Object.getOwnPropertyNames;\n  var $keys = Object.keys;\n  var $TypeError = TypeError;\n  function nonEnum(value) {\n    return {\n      configurable: true,\n      enumerable: false,\n      value: value,\n      writable: true\n    };\n  }\n  var symbolInternalProperty = newUniqueString();\n  var symbolDescriptionProperty = newUniqueString();\n  var symbolDataProperty = newUniqueString();\n  var symbolValues = $create(null);\n  var SymbolImpl = function Symbol(description) {\n    var value = new SymbolValue(description);\n    if (!(this instanceof SymbolImpl))\n      return value;\n    throw new $TypeError(\'Symbol cannot be new\\\'ed\');\n  };\n  $defineProperty(SymbolImpl.prototype, \'constructor\', nonEnum(SymbolImpl));\n  $defineProperty(SymbolImpl.prototype, \'toString\', nonEnum(function() {\n    var symbolValue = this[symbolDataProperty];\n    return symbolValue[symbolInternalProperty];\n  }));\n  $defineProperty(SymbolImpl.prototype, \'valueOf\', nonEnum(function() {\n    var symbolValue = this[symbolDataProperty];\n    if (!symbolValue)\n      throw $TypeError(\'Conversion from symbol to string\');\n    return symbolValue[symbolInternalProperty];\n  }));\n  function SymbolValue(description) {\n    var key = newUniqueString();\n    $defineProperty(this, symbolDataProperty, {value: this});\n    $defineProperty(this, symbolInternalProperty, {value: key});\n    $defineProperty(this, symbolDescriptionProperty, {value: description});\n    $freeze(this);\n    symbolValues[key] = this;\n  }\n  $defineProperty(SymbolValue.prototype, \'constructor\', nonEnum(SymbolImpl));\n  $defineProperty(SymbolValue.prototype, \'toString\', {\n    value: SymbolImpl.prototype.toString,\n    enumerable: false\n  });\n  $defineProperty(SymbolValue.prototype, \'valueOf\', {\n    value: SymbolImpl.prototype.valueOf,\n    enumerable: false\n  });\n  $freeze(SymbolValue.prototype);\n  function isSymbolString(s) {\n    return symbolValues[s];\n  }\n  function removeSymbolKeys(array) {\n    var rv = [];\n    for (var i = 0; i < array.length; i++) {\n      if (!isSymbolString(array[i])) {\n        rv.push(array[i]);\n      }\n    }\n    return rv;\n  }\n  function getOwnPropertyNames(object) {\n    return removeSymbolKeys($getOwnPropertyNames(object));\n  }\n  function keys(object) {\n    return removeSymbolKeys($keys(object));\n  }\n  function getOwnPropertySymbols(object) {\n    var rv = [];\n    var names = $getOwnPropertyNames(object);\n    for (var i = 0; i < names.length; i++) {\n      var symbol = symbolValues[names[i]];\n      if (symbol) {\n        rv.push(symbol);\n      }\n    }\n    return rv;\n  }\n  function polyfillSymbol(global) {\n    var Object = global.Object;\n    if (!hasNativeSymbol()) {\n      global.Symbol = SymbolImpl;\n      Object.getOwnPropertyNames = getOwnPropertyNames;\n      Object.keys = keys;\n      $defineProperty(Object, \'getOwnPropertySymbols\', nonEnum(getOwnPropertySymbols));\n    }\n    if (!global.Symbol.iterator) {\n      global.Symbol.iterator = global.Symbol(\'Symbol.iterator\');\n    }\n    if (!global.Symbol.observer) {\n      global.Symbol.observer = global.Symbol(\'Symbol.observer\');\n    }\n  }\n  var g = typeof window !== \'undefined\' ? window : typeof global !== \'undefined\' ? global : typeof self !== \'undefined\' ? self : (void 0);\n  polyfillSymbol(g);\n  var typeOf = hasNativeSymbol() ? function(x) {\n    return typeof x;\n  } : function(x) {\n    return x instanceof SymbolValue ? \'symbol\' : typeof x;\n  };\n  return {get typeof() {\n      return typeOf;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/typeof.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/typeof.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_symbols_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./symbols.js", "traceur@0.0.111/src/runtime/modules/typeof.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_symbols_46_js__.typeof;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/symbols.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/symbols.js";\n  var t = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/typeof.js", "traceur@0.0.111/src/runtime/symbols.js")).default;\n  $traceurRuntime.typeof = t;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/createClass.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/createClass.js";\n  var $Object = Object;\n  var $TypeError = TypeError;\n  var $__1 = Object,\n      create = $__1.create,\n      defineProperties = $__1.defineProperties,\n      defineProperty = $__1.defineProperty,\n      getOwnPropertyDescriptor = $__1.getOwnPropertyDescriptor,\n      getOwnPropertyNames = $__1.getOwnPropertyNames,\n      getOwnPropertySymbols = $__1.getOwnPropertySymbols;\n  function forEachPropertyKey(object, f) {\n    getOwnPropertyNames(object).forEach(f);\n    if (getOwnPropertySymbols) {\n      getOwnPropertySymbols(object).forEach(f);\n    }\n  }\n  function getDescriptors(object) {\n    var descriptors = {};\n    forEachPropertyKey(object, function(key) {\n      descriptors[key] = getOwnPropertyDescriptor(object, key);\n      descriptors[key].enumerable = false;\n    });\n    return descriptors;\n  }\n  var nonEnum = {enumerable: false};\n  function makePropertiesNonEnumerable(object) {\n    forEachPropertyKey(object, function(key) {\n      defineProperty(object, key, nonEnum);\n    });\n  }\n  function createClass(ctor, object, staticObject, superClass) {\n    defineProperty(object, \'constructor\', {\n      value: ctor,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n    if (arguments.length > 3) {\n      if (typeof superClass === \'function\')\n        ctor.__proto__ = superClass;\n      ctor.prototype = create(getProtoParent(superClass), getDescriptors(object));\n    } else {\n      makePropertiesNonEnumerable(object);\n      ctor.prototype = object;\n    }\n    defineProperty(ctor, \'prototype\', {\n      configurable: false,\n      writable: false\n    });\n    return defineProperties(ctor, getDescriptors(staticObject));\n  }\n  function getProtoParent(superClass) {\n    if (typeof superClass === \'function\') {\n      var prototype = superClass.prototype;\n      if ($Object(prototype) === prototype || prototype === null)\n        return superClass.prototype;\n      throw new $TypeError(\'super prototype must be an Object or null\');\n    }\n    if (superClass === null)\n      return null;\n    throw new $TypeError(("Super expression must either be null or a function, not " + typeof superClass + "."));\n  }\n  return {get default() {\n      return createClass;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/superConstructor.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/superConstructor.js";\n  function superConstructor(ctor) {\n    return ctor.__proto__;\n  }\n  return {get default() {\n      return superConstructor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/superDescriptor.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/superDescriptor.js";\n  var $__0 = Object,\n      getOwnPropertyDescriptor = $__0.getOwnPropertyDescriptor,\n      getPrototypeOf = $__0.getPrototypeOf;\n  function superDescriptor(homeObject, name) {\n    var proto = getPrototypeOf(homeObject);\n    do {\n      var result = getOwnPropertyDescriptor(proto, name);\n      if (result)\n        return result;\n      proto = getPrototypeOf(proto);\n    } while (proto);\n    return undefined;\n  }\n  return {get default() {\n      return superDescriptor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/superGet.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/superGet.js";\n  var superDescriptor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./superDescriptor.js", "traceur@0.0.111/src/runtime/modules/superGet.js")).default;\n  function superGet(self, homeObject, name) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor) {\n      var value = descriptor.value;\n      if (value)\n        return value;\n      if (!descriptor.get)\n        return value;\n      return descriptor.get.call(self);\n    }\n    return undefined;\n  }\n  return {get default() {\n      return superGet;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/superSet.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/superSet.js";\n  var superDescriptor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./superDescriptor.js", "traceur@0.0.111/src/runtime/modules/superSet.js")).default;\n  var $TypeError = TypeError;\n  function superSet(self, homeObject, name, value) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor && descriptor.set) {\n      descriptor.set.call(self, value);\n      return value;\n    }\n    throw $TypeError(("super has no setter \'" + name + "\'."));\n  }\n  return {get default() {\n      return superSet;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/classes.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/classes.js";\n  var createClass = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createClass.js", "traceur@0.0.111/src/runtime/classes.js")).default;\n  var superConstructor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superConstructor.js", "traceur@0.0.111/src/runtime/classes.js")).default;\n  var superGet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superGet.js", "traceur@0.0.111/src/runtime/classes.js")).default;\n  var superSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superSet.js", "traceur@0.0.111/src/runtime/classes.js")).default;\n  $traceurRuntime.createClass = createClass;\n  $traceurRuntime.superConstructor = superConstructor;\n  $traceurRuntime.superGet = superGet;\n  $traceurRuntime.superSet = superSet;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/exportStar.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/exportStar.js";\n  var $__1 = Object,\n      defineProperty = $__1.defineProperty,\n      getOwnPropertyNames = $__1.getOwnPropertyNames;\n  function exportStar(object) {\n    var $__2 = arguments,\n        $__3 = function(i) {\n          var mod = $__2[i];\n          var names = getOwnPropertyNames(mod);\n          var $__5 = function(j) {\n            var name = names[j];\n            if (name === \'__esModule\' || name === \'default\') {\n              return 0;\n            }\n            defineProperty(object, name, {\n              get: function() {\n                return mod[name];\n              },\n              enumerable: true\n            });\n          },\n              $__6;\n          $__4: for (var j = 0; j < names.length; j++) {\n            $__6 = $__5(j);\n            switch ($__6) {\n              case 0:\n                continue $__4;\n            }\n          }\n        };\n    for (var i = 1; i < arguments.length; i++) {\n      $__3(i);\n    }\n    return object;\n  }\n  return {get default() {\n      return exportStar;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/exportStar.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/exportStar.js";\n  var exportStar = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/exportStar.js", "traceur@0.0.111/src/runtime/exportStar.js")).default;\n  $traceurRuntime.exportStar = exportStar;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/private-symbol.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/private-symbol.js";\n  var newUniqueString = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./new-unique-string.js", "traceur@0.0.111/src/runtime/private-symbol.js")).default;\n  var $Symbol = typeof Symbol === \'function\' ? Symbol : undefined;\n  var $getOwnPropertySymbols = Object.getOwnPropertySymbols;\n  var $create = Object.create;\n  var privateNames = $create(null);\n  function isPrivateSymbol(s) {\n    return privateNames[s];\n  }\n  ;\n  function createPrivateSymbol() {\n    var s = ($Symbol || newUniqueString)();\n    privateNames[s] = true;\n    return s;\n  }\n  ;\n  function hasPrivate(obj, sym) {\n    return hasOwnProperty.call(obj, sym);\n  }\n  ;\n  function deletePrivate(obj, sym) {\n    if (!hasPrivate(obj, sym)) {\n      return false;\n    }\n    delete obj[sym];\n    return true;\n  }\n  ;\n  function setPrivate(obj, sym, val) {\n    obj[sym] = val;\n  }\n  ;\n  function getPrivate(obj, sym) {\n    var val = obj[sym];\n    if (val === undefined)\n      return undefined;\n    return hasOwnProperty.call(obj, sym) ? val : undefined;\n  }\n  ;\n  function init() {\n    if ($getOwnPropertySymbols) {\n      Object.getOwnPropertySymbols = function getOwnPropertySymbols(object) {\n        var rv = [];\n        var symbols = $getOwnPropertySymbols(object);\n        for (var i = 0; i < symbols.length; i++) {\n          var symbol = symbols[i];\n          if (!isPrivateSymbol(symbol)) {\n            rv.push(symbol);\n          }\n        }\n        return rv;\n      };\n    }\n  }\n  return {\n    get isPrivateSymbol() {\n      return isPrivateSymbol;\n    },\n    get createPrivateSymbol() {\n      return createPrivateSymbol;\n    },\n    get hasPrivate() {\n      return hasPrivate;\n    },\n    get deletePrivate() {\n      return deletePrivate;\n    },\n    get setPrivate() {\n      return setPrivate;\n    },\n    get getPrivate() {\n      return getPrivate;\n    },\n    get init() {\n      return init;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/private-weak-map.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/private-weak-map.js";\n  var $WeakMap = typeof WeakMap === \'function\' ? WeakMap : undefined;\n  function isPrivateSymbol(s) {\n    return false;\n  }\n  function createPrivateSymbol() {\n    return new $WeakMap();\n  }\n  function hasPrivate(obj, sym) {\n    return sym.has(obj);\n  }\n  function deletePrivate(obj, sym) {\n    return sym.delete(obj);\n  }\n  function setPrivate(obj, sym, val) {\n    sym.set(obj, val);\n  }\n  function getPrivate(obj, sym) {\n    return sym.get(obj);\n  }\n  function init() {}\n  return {\n    get isPrivateSymbol() {\n      return isPrivateSymbol;\n    },\n    get createPrivateSymbol() {\n      return createPrivateSymbol;\n    },\n    get hasPrivate() {\n      return hasPrivate;\n    },\n    get deletePrivate() {\n      return deletePrivate;\n    },\n    get setPrivate() {\n      return setPrivate;\n    },\n    get getPrivate() {\n      return getPrivate;\n    },\n    get init() {\n      return init;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/private.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/private.js";\n  var sym = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./private-symbol.js", "traceur@0.0.111/src/runtime/private.js"));\n  var weak = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./private-weak-map.js", "traceur@0.0.111/src/runtime/private.js"));\n  var hasWeakMap = typeof WeakMap === \'function\';\n  var m = hasWeakMap ? weak : sym;\n  var isPrivateSymbol = m.isPrivateSymbol;\n  var createPrivateSymbol = m.createPrivateSymbol;\n  var hasPrivate = m.hasPrivate;\n  var deletePrivate = m.deletePrivate;\n  var setPrivate = m.setPrivate;\n  var getPrivate = m.getPrivate;\n  m.init();\n  return {\n    get isPrivateSymbol() {\n      return isPrivateSymbol;\n    },\n    get createPrivateSymbol() {\n      return createPrivateSymbol;\n    },\n    get hasPrivate() {\n      return hasPrivate;\n    },\n    get deletePrivate() {\n      return deletePrivate;\n    },\n    get setPrivate() {\n      return setPrivate;\n    },\n    get getPrivate() {\n      return getPrivate;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/properTailCalls.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/properTailCalls.js";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur@0.0.111/src/runtime/modules/properTailCalls.js")),\n      getPrivate = $__0.getPrivate,\n      setPrivate = $__0.setPrivate,\n      createPrivateSymbol = $__0.createPrivateSymbol;\n  var $apply = Function.prototype.call.bind(Function.prototype.apply);\n  var CONTINUATION_TYPE = Object.create(null);\n  var isTailRecursiveName = null;\n  function createContinuation(operand, thisArg, argsArray) {\n    return [CONTINUATION_TYPE, operand, thisArg, argsArray];\n  }\n  function isContinuation(object) {\n    return object && object[0] === CONTINUATION_TYPE;\n  }\n  function $bind(operand, thisArg, args) {\n    var argArray = [thisArg];\n    for (var i = 0; i < args.length; i++) {\n      argArray[i + 1] = args[i];\n    }\n    var func = $apply(Function.prototype.bind, operand, argArray);\n    return func;\n  }\n  function $construct(func, argArray) {\n    var object = new ($bind(func, null, argArray));\n    return object;\n  }\n  function isTailRecursive(func) {\n    return !!getPrivate(func, isTailRecursiveName);\n  }\n  function tailCall(func, thisArg, argArray) {\n    var continuation = argArray[0];\n    if (isContinuation(continuation)) {\n      continuation = $apply(func, thisArg, continuation[3]);\n      return continuation;\n    }\n    continuation = createContinuation(func, thisArg, argArray);\n    while (true) {\n      if (isTailRecursive(func)) {\n        continuation = $apply(func, continuation[2], [continuation]);\n      } else {\n        continuation = $apply(func, continuation[2], continuation[3]);\n      }\n      if (!isContinuation(continuation)) {\n        return continuation;\n      }\n      func = continuation[1];\n    }\n  }\n  function construct() {\n    var object;\n    if (isTailRecursive(this)) {\n      object = $construct(this, [createContinuation(null, null, arguments)]);\n    } else {\n      object = $construct(this, arguments);\n    }\n    return object;\n  }\n  function setupProperTailCalls() {\n    isTailRecursiveName = createPrivateSymbol();\n    Function.prototype.call = initTailRecursiveFunction(function call(thisArg) {\n      var result = tailCall(function(thisArg) {\n        var argArray = [];\n        for (var i = 1; i < arguments.length; ++i) {\n          argArray[i - 1] = arguments[i];\n        }\n        var continuation = createContinuation(this, thisArg, argArray);\n        return continuation;\n      }, this, arguments);\n      return result;\n    });\n    Function.prototype.apply = initTailRecursiveFunction(function apply(thisArg, argArray) {\n      var result = tailCall(function(thisArg, argArray) {\n        var continuation = createContinuation(this, thisArg, argArray);\n        return continuation;\n      }, this, arguments);\n      return result;\n    });\n  }\n  function initTailRecursiveFunction(func) {\n    if (isTailRecursiveName === null) {\n      setupProperTailCalls();\n    }\n    setPrivate(func, isTailRecursiveName, true);\n    return func;\n  }\n  return {\n    get createContinuation() {\n      return createContinuation;\n    },\n    get tailCall() {\n      return tailCall;\n    },\n    get construct() {\n      return construct;\n    },\n    get initTailRecursiveFunction() {\n      return initTailRecursiveFunction;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/initTailRecursiveFunction.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/initTailRecursiveFunction.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur@0.0.111/src/runtime/modules/initTailRecursiveFunction.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.initTailRecursiveFunction;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/call.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/call.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur@0.0.111/src/runtime/modules/call.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.tailCall;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/continuation.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/continuation.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur@0.0.111/src/runtime/modules/continuation.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.createContinuation;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/construct.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/construct.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur@0.0.111/src/runtime/modules/construct.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.construct;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/properTailCalls.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/properTailCalls.js";\n  var initTailRecursiveFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initTailRecursiveFunction.js", "traceur@0.0.111/src/runtime/properTailCalls.js")).default;\n  var call = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/call.js", "traceur@0.0.111/src/runtime/properTailCalls.js")).default;\n  var continuation = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/continuation.js", "traceur@0.0.111/src/runtime/properTailCalls.js")).default;\n  var construct = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/construct.js", "traceur@0.0.111/src/runtime/properTailCalls.js")).default;\n  $traceurRuntime.initTailRecursiveFunction = initTailRecursiveFunction;\n  $traceurRuntime.call = call;\n  $traceurRuntime.continuation = continuation;\n  $traceurRuntime.construct = construct;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/relativeRequire.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/relativeRequire.js";\n  var path;\n  function relativeRequire(callerPath, requiredPath) {\n    path = path || typeof require !== \'undefined\' && require(\'path\');\n    function isDirectory(path) {\n      return path.slice(-1) === \'/\';\n    }\n    function isAbsolute(path) {\n      return path[0] === \'/\';\n    }\n    function isRelative(path) {\n      return path[0] === \'.\';\n    }\n    if (isDirectory(requiredPath) || isAbsolute(requiredPath))\n      return;\n    return isRelative(requiredPath) ? require(path.resolve(path.dirname(callerPath), requiredPath)) : require(requiredPath);\n  }\n  $traceurRuntime.require = relativeRequire;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/checkObjectCoercible.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/checkObjectCoercible.js";\n  var $TypeError = TypeError;\n  function checkObjectCoercible(v) {\n    if (v === null || v === undefined) {\n      throw new $TypeError(\'Value cannot be converted to an Object\');\n    }\n    return v;\n  }\n  return {get default() {\n      return checkObjectCoercible;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/spread.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/spread.js";\n  var checkObjectCoercible = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../checkObjectCoercible.js", "traceur@0.0.111/src/runtime/modules/spread.js")).default;\n  function spread() {\n    var rv = [],\n        j = 0,\n        iterResult;\n    for (var i = 0; i < arguments.length; i++) {\n      var valueToSpread = checkObjectCoercible(arguments[i]);\n      if (typeof valueToSpread[Symbol.iterator] !== \'function\') {\n        throw new TypeError(\'Cannot spread non-iterable object.\');\n      }\n      var iter = valueToSpread[Symbol.iterator]();\n      while (!(iterResult = iter.next()).done) {\n        rv[j++] = iterResult.value;\n      }\n    }\n    return rv;\n  }\n  return {get default() {\n      return spread;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/spread.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/spread.js";\n  var spread = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spread.js", "traceur@0.0.111/src/runtime/spread.js")).default;\n  $traceurRuntime.spread = spread;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/iteratorToArray.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/iteratorToArray.js";\n  function iteratorToArray(iter) {\n    var rv = [];\n    var i = 0;\n    var tmp;\n    while (!(tmp = iter.next()).done) {\n      rv[i++] = tmp.value;\n    }\n    return rv;\n  }\n  return {get default() {\n      return iteratorToArray;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/destructuring.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/destructuring.js";\n  var iteratorToArray = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/iteratorToArray.js", "traceur@0.0.111/src/runtime/destructuring.js")).default;\n  $traceurRuntime.iteratorToArray = iteratorToArray;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/async.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/async.js";\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur@0.0.111/src/runtime/modules/async.js")),\n      createPrivateSymbol = $__12.createPrivateSymbol,\n      getPrivate = $__12.getPrivate,\n      setPrivate = $__12.setPrivate;\n  var $__11 = Object,\n      create = $__11.create,\n      defineProperty = $__11.defineProperty;\n  var observeName = createPrivateSymbol();\n  function AsyncGeneratorFunction() {}\n  function AsyncGeneratorFunctionPrototype() {}\n  AsyncGeneratorFunction.prototype = AsyncGeneratorFunctionPrototype;\n  AsyncGeneratorFunctionPrototype.constructor = AsyncGeneratorFunction;\n  defineProperty(AsyncGeneratorFunctionPrototype, \'constructor\', {enumerable: false});\n  var AsyncGeneratorContext = function() {\n    function AsyncGeneratorContext(observer) {\n      var $__2 = this;\n      this.decoratedObserver = createDecoratedGenerator(observer, function() {\n        $__2.done = true;\n      });\n      this.done = false;\n      this.inReturn = false;\n    }\n    return ($traceurRuntime.createClass)(AsyncGeneratorContext, {\n      throw: function(error) {\n        if (!this.inReturn) {\n          throw error;\n        }\n      },\n      yield: function(value) {\n        if (this.done) {\n          this.inReturn = true;\n          throw undefined;\n        }\n        var result;\n        try {\n          result = this.decoratedObserver.next(value);\n        } catch (e) {\n          this.done = true;\n          throw e;\n        }\n        if (result === undefined) {\n          return;\n        }\n        if (result.done) {\n          this.done = true;\n          this.inReturn = true;\n          throw undefined;\n        }\n        return result.value;\n      },\n      yieldFor: function(observable) {\n        var ctx = this;\n        return observeForEach(observable[Symbol.observer].bind(observable), function(value) {\n          if (ctx.done) {\n            this.return();\n            return;\n          }\n          var result;\n          try {\n            result = ctx.decoratedObserver.next(value);\n          } catch (e) {\n            ctx.done = true;\n            throw e;\n          }\n          if (result === undefined) {\n            return;\n          }\n          if (result.done) {\n            ctx.done = true;\n          }\n          return result;\n        });\n      }\n    }, {});\n  }();\n  AsyncGeneratorFunctionPrototype.prototype[Symbol.observer] = function(observer) {\n    var observe = getPrivate(this, observeName);\n    var ctx = new AsyncGeneratorContext(observer);\n    schedule(function() {\n      return observe(ctx);\n    }).then(function(value) {\n      if (!ctx.done) {\n        ctx.decoratedObserver.return(value);\n      }\n    }).catch(function(error) {\n      if (!ctx.done) {\n        ctx.decoratedObserver.throw(error);\n      }\n    });\n    return ctx.decoratedObserver;\n  };\n  defineProperty(AsyncGeneratorFunctionPrototype.prototype, Symbol.observer, {enumerable: false});\n  function initAsyncGeneratorFunction(functionObject) {\n    functionObject.prototype = create(AsyncGeneratorFunctionPrototype.prototype);\n    functionObject.__proto__ = AsyncGeneratorFunctionPrototype;\n    return functionObject;\n  }\n  function createAsyncGeneratorInstance(observe, functionObject) {\n    for (var args = [],\n        $__10 = 2; $__10 < arguments.length; $__10++)\n      args[$__10 - 2] = arguments[$__10];\n    var object = create(functionObject.prototype);\n    setPrivate(object, observeName, observe);\n    return object;\n  }\n  function observeForEach(observe, next) {\n    return new Promise(function(resolve, reject) {\n      var generator = observe({\n        next: function(value) {\n          return next.call(generator, value);\n        },\n        throw: function(error) {\n          reject(error);\n        },\n        return: function(value) {\n          resolve(value);\n        }\n      });\n    });\n  }\n  function schedule(asyncF) {\n    return Promise.resolve().then(asyncF);\n  }\n  var generator = Symbol();\n  var onDone = Symbol();\n  var DecoratedGenerator = function() {\n    function DecoratedGenerator(_generator, _onDone) {\n      this[generator] = _generator;\n      this[onDone] = _onDone;\n    }\n    return ($traceurRuntime.createClass)(DecoratedGenerator, {\n      next: function(value) {\n        var result = this[generator].next(value);\n        if (result !== undefined && result.done) {\n          this[onDone].call(this);\n        }\n        return result;\n      },\n      throw: function(error) {\n        this[onDone].call(this);\n        return this[generator].throw(error);\n      },\n      return: function(value) {\n        this[onDone].call(this);\n        return this[generator].return(value);\n      }\n    }, {});\n  }();\n  function createDecoratedGenerator(generator, onDone) {\n    return new DecoratedGenerator(generator, onDone);\n  }\n  Array.prototype[Symbol.observer] = function(observer) {\n    var done = false;\n    var decoratedObserver = createDecoratedGenerator(observer, function() {\n      return done = true;\n    });\n    var $__6 = true;\n    var $__7 = false;\n    var $__8 = undefined;\n    try {\n      for (var $__4 = void 0,\n          $__3 = (this)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {\n        var value = $__4.value;\n        {\n          decoratedObserver.next(value);\n          if (done) {\n            return;\n          }\n        }\n      }\n    } catch ($__9) {\n      $__7 = true;\n      $__8 = $__9;\n    } finally {\n      try {\n        if (!$__6 && $__3.return != null) {\n          $__3.return();\n        }\n      } finally {\n        if ($__7) {\n          throw $__8;\n        }\n      }\n    }\n    decoratedObserver.return();\n    return decoratedObserver;\n  };\n  defineProperty(Array.prototype, Symbol.observer, {enumerable: false});\n  return {\n    get initAsyncGeneratorFunction() {\n      return initAsyncGeneratorFunction;\n    },\n    get createAsyncGeneratorInstance() {\n      return createAsyncGeneratorInstance;\n    },\n    get observeForEach() {\n      return observeForEach;\n    },\n    get schedule() {\n      return schedule;\n    },\n    get createDecoratedGenerator() {\n      return createDecoratedGenerator;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.initAsyncGeneratorFunction;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.createAsyncGeneratorInstance;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/observeForEach.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/observeForEach.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur@0.0.111/src/runtime/modules/observeForEach.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.observeForEach;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/schedule.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/schedule.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur@0.0.111/src/runtime/modules/schedule.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.schedule;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/createDecoratedGenerator.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/createDecoratedGenerator.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur@0.0.111/src/runtime/modules/createDecoratedGenerator.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.createDecoratedGenerator;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/async.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/async.js";\n  var initAsyncGeneratorFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initAsyncGeneratorFunction.js", "traceur@0.0.111/src/runtime/async.js")).default;\n  var createAsyncGeneratorInstance = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createAsyncGeneratorInstance.js", "traceur@0.0.111/src/runtime/async.js")).default;\n  var observeForEach = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/observeForEach.js", "traceur@0.0.111/src/runtime/async.js")).default;\n  var schedule = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/schedule.js", "traceur@0.0.111/src/runtime/async.js")).default;\n  var createDecoratedGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createDecoratedGenerator.js", "traceur@0.0.111/src/runtime/async.js")).default;\n  $traceurRuntime.initAsyncGeneratorFunction = initAsyncGeneratorFunction;\n  $traceurRuntime.createAsyncGeneratorInstance = createAsyncGeneratorInstance;\n  $traceurRuntime.observeForEach = observeForEach;\n  $traceurRuntime.schedule = schedule;\n  $traceurRuntime.createDecoratedGenerator = createDecoratedGenerator;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/generators.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/generators.js";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur@0.0.111/src/runtime/modules/generators.js")),\n      createPrivateSymbol = $__2.createPrivateSymbol,\n      getPrivate = $__2.getPrivate,\n      setPrivate = $__2.setPrivate;\n  var $TypeError = TypeError;\n  var $__1 = Object,\n      create = $__1.create,\n      defineProperties = $__1.defineProperties,\n      defineProperty = $__1.defineProperty;\n  function nonEnum(value) {\n    return {\n      configurable: true,\n      enumerable: false,\n      value: value,\n      writable: true\n    };\n  }\n  var ST_NEWBORN = 0;\n  var ST_EXECUTING = 1;\n  var ST_SUSPENDED = 2;\n  var ST_CLOSED = 3;\n  var END_STATE = -2;\n  var RETHROW_STATE = -3;\n  function getInternalError(state) {\n    return new Error(\'Traceur compiler bug: invalid state in state machine: \' + state);\n  }\n  var RETURN_SENTINEL = {};\n  function GeneratorContext() {\n    this.state = 0;\n    this.GState = ST_NEWBORN;\n    this.storedException = undefined;\n    this.finallyFallThrough = undefined;\n    this.sent_ = undefined;\n    this.returnValue = undefined;\n    this.oldReturnValue = undefined;\n    this.tryStack_ = [];\n  }\n  GeneratorContext.prototype = {\n    pushTry: function(catchState, finallyState) {\n      if (finallyState !== null) {\n        var finallyFallThrough = null;\n        for (var i = this.tryStack_.length - 1; i >= 0; i--) {\n          if (this.tryStack_[i].catch !== undefined) {\n            finallyFallThrough = this.tryStack_[i].catch;\n            break;\n          }\n        }\n        if (finallyFallThrough === null)\n          finallyFallThrough = RETHROW_STATE;\n        this.tryStack_.push({\n          finally: finallyState,\n          finallyFallThrough: finallyFallThrough\n        });\n      }\n      if (catchState !== null) {\n        this.tryStack_.push({catch: catchState});\n      }\n    },\n    popTry: function() {\n      this.tryStack_.pop();\n    },\n    maybeUncatchable: function() {\n      if (this.storedException === RETURN_SENTINEL) {\n        throw RETURN_SENTINEL;\n      }\n    },\n    get sent() {\n      this.maybeThrow();\n      return this.sent_;\n    },\n    set sent(v) {\n      this.sent_ = v;\n    },\n    get sentIgnoreThrow() {\n      return this.sent_;\n    },\n    maybeThrow: function() {\n      if (this.action === \'throw\') {\n        this.action = \'next\';\n        throw this.sent_;\n      }\n    },\n    end: function() {\n      switch (this.state) {\n        case END_STATE:\n          return this;\n        case RETHROW_STATE:\n          throw this.storedException;\n        default:\n          throw getInternalError(this.state);\n      }\n    },\n    handleException: function(ex) {\n      this.GState = ST_CLOSED;\n      this.state = END_STATE;\n      throw ex;\n    },\n    wrapYieldStar: function(iterator) {\n      var ctx = this;\n      return {\n        next: function(v) {\n          return iterator.next(v);\n        },\n        throw: function(e) {\n          var result;\n          if (e === RETURN_SENTINEL) {\n            if (iterator.return) {\n              result = iterator.return(ctx.returnValue);\n              if (!result.done) {\n                ctx.returnValue = ctx.oldReturnValue;\n                return result;\n              }\n              ctx.returnValue = result.value;\n            }\n            throw e;\n          }\n          if (iterator.throw) {\n            return iterator.throw(e);\n          }\n          iterator.return && iterator.return();\n          throw $TypeError(\'Inner iterator does not have a throw method\');\n        }\n      };\n    }\n  };\n  function nextOrThrow(ctx, moveNext, action, x) {\n    switch (ctx.GState) {\n      case ST_EXECUTING:\n        throw new Error(("\\"" + action + "\\" on executing generator"));\n      case ST_CLOSED:\n        if (action == \'next\') {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n        if (x === RETURN_SENTINEL) {\n          return {\n            value: ctx.returnValue,\n            done: true\n          };\n        }\n        throw x;\n      case ST_NEWBORN:\n        if (action === \'throw\') {\n          ctx.GState = ST_CLOSED;\n          if (x === RETURN_SENTINEL) {\n            return {\n              value: ctx.returnValue,\n              done: true\n            };\n          }\n          throw x;\n        }\n        if (x !== undefined)\n          throw $TypeError(\'Sent value to newborn generator\');\n      case ST_SUSPENDED:\n        ctx.GState = ST_EXECUTING;\n        ctx.action = action;\n        ctx.sent = x;\n        var value;\n        try {\n          value = moveNext(ctx);\n        } catch (ex) {\n          if (ex === RETURN_SENTINEL) {\n            value = ctx;\n          } else {\n            throw ex;\n          }\n        }\n        var done = value === ctx;\n        if (done)\n          value = ctx.returnValue;\n        ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;\n        return {\n          value: value,\n          done: done\n        };\n    }\n  }\n  var ctxName = createPrivateSymbol();\n  var moveNextName = createPrivateSymbol();\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(GeneratorFunctionPrototype, \'constructor\', nonEnum(GeneratorFunction));\n  GeneratorFunctionPrototype.prototype = {\n    constructor: GeneratorFunctionPrototype,\n    next: function(v) {\n      return nextOrThrow(getPrivate(this, ctxName), getPrivate(this, moveNextName), \'next\', v);\n    },\n    throw: function(v) {\n      return nextOrThrow(getPrivate(this, ctxName), getPrivate(this, moveNextName), \'throw\', v);\n    },\n    return: function(v) {\n      var ctx = getPrivate(this, ctxName);\n      ctx.oldReturnValue = ctx.returnValue;\n      ctx.returnValue = v;\n      return nextOrThrow(ctx, getPrivate(this, moveNextName), \'throw\', RETURN_SENTINEL);\n    }\n  };\n  defineProperties(GeneratorFunctionPrototype.prototype, {\n    constructor: {enumerable: false},\n    next: {enumerable: false},\n    throw: {enumerable: false},\n    return: {enumerable: false}\n  });\n  Object.defineProperty(GeneratorFunctionPrototype.prototype, Symbol.iterator, nonEnum(function() {\n    return this;\n  }));\n  function createGeneratorInstance(innerFunction, functionObject, self) {\n    var moveNext = getMoveNext(innerFunction, self);\n    var ctx = new GeneratorContext();\n    var object = create(functionObject.prototype);\n    setPrivate(object, ctxName, ctx);\n    setPrivate(object, moveNextName, moveNext);\n    return object;\n  }\n  function initGeneratorFunction(functionObject) {\n    functionObject.prototype = create(GeneratorFunctionPrototype.prototype);\n    functionObject.__proto__ = GeneratorFunctionPrototype;\n    return functionObject;\n  }\n  function AsyncFunctionContext() {\n    GeneratorContext.call(this);\n    this.err = undefined;\n    var ctx = this;\n    ctx.result = new Promise(function(resolve, reject) {\n      ctx.resolve = resolve;\n      ctx.reject = reject;\n    });\n  }\n  AsyncFunctionContext.prototype = create(GeneratorContext.prototype);\n  AsyncFunctionContext.prototype.end = function() {\n    switch (this.state) {\n      case END_STATE:\n        this.resolve(this.returnValue);\n        break;\n      case RETHROW_STATE:\n        this.reject(this.storedException);\n        break;\n      default:\n        this.reject(getInternalError(this.state));\n    }\n  };\n  AsyncFunctionContext.prototype.handleException = function() {\n    this.state = RETHROW_STATE;\n  };\n  function asyncWrap(innerFunction, self) {\n    var moveNext = getMoveNext(innerFunction, self);\n    var ctx = new AsyncFunctionContext();\n    ctx.createCallback = function(newState) {\n      return function(value) {\n        ctx.state = newState;\n        ctx.value = value;\n        moveNext(ctx);\n      };\n    };\n    ctx.errback = function(err) {\n      handleCatch(ctx, err);\n      moveNext(ctx);\n    };\n    moveNext(ctx);\n    return ctx.result;\n  }\n  function getMoveNext(innerFunction, self) {\n    return function(ctx) {\n      while (true) {\n        try {\n          return innerFunction.call(self, ctx);\n        } catch (ex) {\n          handleCatch(ctx, ex);\n        }\n      }\n    };\n  }\n  function handleCatch(ctx, ex) {\n    ctx.storedException = ex;\n    var last = ctx.tryStack_[ctx.tryStack_.length - 1];\n    if (!last) {\n      ctx.handleException(ex);\n      return;\n    }\n    ctx.state = last.catch !== undefined ? last.catch : last.finally;\n    if (last.finallyFallThrough !== undefined)\n      ctx.finallyFallThrough = last.finallyFallThrough;\n  }\n  return {\n    get createGeneratorInstance() {\n      return createGeneratorInstance;\n    },\n    get initGeneratorFunction() {\n      return initGeneratorFunction;\n    },\n    get asyncWrap() {\n      return asyncWrap;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/asyncWrap.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/asyncWrap.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur@0.0.111/src/runtime/modules/asyncWrap.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.asyncWrap;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/initGeneratorFunction.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/initGeneratorFunction.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur@0.0.111/src/runtime/modules/initGeneratorFunction.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.initGeneratorFunction;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/createGeneratorInstance.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/createGeneratorInstance.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur@0.0.111/src/runtime/modules/createGeneratorInstance.js"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.createGeneratorInstance;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/generators.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/generators.js";\n  var asyncWrap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/asyncWrap.js", "traceur@0.0.111/src/runtime/generators.js")).default;\n  var initGeneratorFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initGeneratorFunction.js", "traceur@0.0.111/src/runtime/generators.js")).default;\n  var createGeneratorInstance = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createGeneratorInstance.js", "traceur@0.0.111/src/runtime/generators.js")).default;\n  $traceurRuntime.asyncWrap = asyncWrap;\n  $traceurRuntime.initGeneratorFunction = initGeneratorFunction;\n  $traceurRuntime.createGeneratorInstance = createGeneratorInstance;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/spawn.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/spawn.js";\n  function spawn(self, args, gen) {\n    return new Promise(function(resolve, reject) {\n      function fulfill(v) {\n        try {\n          step(gen.next(v));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(v) {\n        try {\n          step(gen.throw(v));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(res) {\n        if (res.done) {\n          resolve(res.value);\n        } else {\n          Promise.resolve(res.value).then(fulfill, rejected);\n        }\n      }\n      step((gen = gen.apply(self, args)).next());\n    });\n  }\n  return {get default() {\n      return spawn;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/spawn.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/spawn.js";\n  var spawn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spawn.js", "traceur@0.0.111/src/runtime/spawn.js")).default;\n  $traceurRuntime.spawn = spawn;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/getTemplateObject.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/getTemplateObject.js";\n  var $__1 = Object,\n      defineProperty = $__1.defineProperty,\n      freeze = $__1.freeze;\n  var slice = Array.prototype.slice;\n  var map = Object.create(null);\n  function getTemplateObject(raw) {\n    var cooked = arguments[1];\n    var key = raw.join(\'${}\');\n    var templateObject = map[key];\n    if (templateObject)\n      return templateObject;\n    if (!cooked) {\n      cooked = slice.call(raw);\n    }\n    return map[key] = freeze(defineProperty(cooked, \'raw\', {value: freeze(raw)}));\n  }\n  return {get default() {\n      return getTemplateObject;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/template.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/template.js";\n  var getTemplateObject = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/getTemplateObject.js", "traceur@0.0.111/src/runtime/template.js")).default;\n  $traceurRuntime.getTemplateObject = getTemplateObject;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/modules/spreadProperties.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/modules/spreadProperties.js";\n  var $__1 = Object,\n      defineProperty = $__1.defineProperty,\n      getOwnPropertyNames = $__1.getOwnPropertyNames,\n      getOwnPropertySymbols = $__1.getOwnPropertySymbols,\n      propertyIsEnumerable = $__1.propertyIsEnumerable;\n  function createDataProperty(o, p, v) {\n    defineProperty(o, p, {\n      configurable: true,\n      enumerable: true,\n      value: v,\n      writable: true\n    });\n  }\n  function copyDataProperties(target, source) {\n    if (source == null) {\n      return;\n    }\n    var copy = function(keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var nextKey = keys[i];\n        if (propertyIsEnumerable.call(source, nextKey)) {\n          var propValue = source[nextKey];\n          createDataProperty(target, nextKey, propValue);\n        }\n      }\n    };\n    copy(getOwnPropertyNames(source));\n    copy(getOwnPropertySymbols(source));\n  }\n  var $__default = function() {\n    var target = arguments[0];\n    for (var i = 1; i < arguments.length; i++) {\n      copyDataProperties(target, arguments[i]);\n    }\n    return target;\n  };\n  return {get default() {\n      return $__default;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/jsx.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/jsx.js";\n  var spreadProperties = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spreadProperties.js", "traceur@0.0.111/src/runtime/jsx.js")).default;\n  $traceurRuntime.spreadProperties = spreadProperties;\n  return {};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/runtime-modules.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/runtime-modules.js";\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./symbols.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./classes.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./exportStar.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./relativeRequire.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./spread.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./destructuring.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./spawn.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./template.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./jsx.js", "traceur@0.0.111/src/runtime/runtime-modules.js"));\n  return {};\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/runtime-modules.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/frozen-data.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/frozen-data.js";\n  function findIndex(arr, key) {\n    for (var i = 0; i < arr.length; i += 2) {\n      if (arr[i] === key) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function setFrozen(arr, key, val) {\n    var i = findIndex(arr, key);\n    if (i === -1) {\n      arr.push(key, val);\n    }\n  }\n  function getFrozen(arr, key) {\n    var i = findIndex(arr, key);\n    if (i !== -1) {\n      return arr[i + 1];\n    }\n    return undefined;\n  }\n  function hasFrozen(arr, key) {\n    return findIndex(arr, key) !== -1;\n  }\n  function deleteFrozen(arr, key) {\n    var i = findIndex(arr, key);\n    if (i !== -1) {\n      arr.splice(i, 2);\n      return true;\n    }\n    return false;\n  }\n  return {\n    get setFrozen() {\n      return setFrozen;\n    },\n    get getFrozen() {\n      return getFrozen;\n    },\n    get hasFrozen() {\n      return hasFrozen;\n    },\n    get deleteFrozen() {\n      return deleteFrozen;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/utils.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/utils.js";\n  var $ceil = Math.ceil;\n  var $floor = Math.floor;\n  var $isFinite = isFinite;\n  var $isNaN = isNaN;\n  var $pow = Math.pow;\n  var $min = Math.min;\n  var $TypeError = TypeError;\n  var $Object = Object;\n  function toObject(x) {\n    if (x == null) {\n      throw $TypeError();\n    }\n    return $Object(x);\n  }\n  function toUint32(x) {\n    return x >>> 0;\n  }\n  function isObject(x) {\n    return x && (typeof x === \'object\' || typeof x === \'function\');\n  }\n  function isCallable(x) {\n    return typeof x === \'function\';\n  }\n  function isNumber(x) {\n    return typeof x === \'number\';\n  }\n  function toInteger(x) {\n    x = +x;\n    if ($isNaN(x))\n      return 0;\n    if (x === 0 || !$isFinite(x))\n      return x;\n    return x > 0 ? $floor(x) : $ceil(x);\n  }\n  var MAX_SAFE_LENGTH = $pow(2, 53) - 1;\n  function toLength(x) {\n    var len = toInteger(x);\n    return len < 0 ? 0 : $min(len, MAX_SAFE_LENGTH);\n  }\n  function checkIterable(x) {\n    return !isObject(x) ? undefined : x[Symbol.iterator];\n  }\n  function isConstructor(x) {\n    return isCallable(x);\n  }\n  function createIteratorResultObject(value, done) {\n    return {\n      value: value,\n      done: done\n    };\n  }\n  function maybeDefine(object, name, descr) {\n    if (!(name in object)) {\n      Object.defineProperty(object, name, descr);\n    }\n  }\n  function maybeDefineMethod(object, name, value) {\n    maybeDefine(object, name, {\n      value: value,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n  }\n  function maybeDefineConst(object, name, value) {\n    maybeDefine(object, name, {\n      value: value,\n      configurable: false,\n      enumerable: false,\n      writable: false\n    });\n  }\n  function maybeAddFunctions(object, functions) {\n    for (var i = 0; i < functions.length; i += 2) {\n      var name = functions[i];\n      var value = functions[i + 1];\n      maybeDefineMethod(object, name, value);\n    }\n  }\n  function maybeAddConsts(object, consts) {\n    for (var i = 0; i < consts.length; i += 2) {\n      var name = consts[i];\n      var value = consts[i + 1];\n      maybeDefineConst(object, name, value);\n    }\n  }\n  function maybeAddIterator(object, func, Symbol) {\n    if (!Symbol || !Symbol.iterator || object[Symbol.iterator])\n      return;\n    if (object[\'@@iterator\'])\n      func = object[\'@@iterator\'];\n    Object.defineProperty(object, Symbol.iterator, {\n      value: func,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n  }\n  var polyfills = [];\n  function registerPolyfill(func) {\n    polyfills.push(func);\n  }\n  function polyfillAll(global) {\n    polyfills.forEach(function(f) {\n      return f(global);\n    });\n  }\n  return {\n    get toObject() {\n      return toObject;\n    },\n    get toUint32() {\n      return toUint32;\n    },\n    get isObject() {\n      return isObject;\n    },\n    get isCallable() {\n      return isCallable;\n    },\n    get isNumber() {\n      return isNumber;\n    },\n    get toInteger() {\n      return toInteger;\n    },\n    get toLength() {\n      return toLength;\n    },\n    get checkIterable() {\n      return checkIterable;\n    },\n    get isConstructor() {\n      return isConstructor;\n    },\n    get createIteratorResultObject() {\n      return createIteratorResultObject;\n    },\n    get maybeDefine() {\n      return maybeDefine;\n    },\n    get maybeDefineMethod() {\n      return maybeDefineMethod;\n    },\n    get maybeDefineConst() {\n      return maybeDefineConst;\n    },\n    get maybeAddFunctions() {\n      return maybeAddFunctions;\n    },\n    get maybeAddConsts() {\n      return maybeAddConsts;\n    },\n    get maybeAddIterator() {\n      return maybeAddIterator;\n    },\n    get registerPolyfill() {\n      return registerPolyfill;\n    },\n    get polyfillAll() {\n      return polyfillAll;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/Map.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/Map.js";\n  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur@0.0.111/src/runtime/polyfills/Map.js")),\n      createPrivateSymbol = $__16.createPrivateSymbol,\n      getPrivate = $__16.getPrivate,\n      setPrivate = $__16.setPrivate;\n  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur@0.0.111/src/runtime/polyfills/Map.js")),\n      deleteFrozen = $__17.deleteFrozen,\n      getFrozen = $__17.getFrozen,\n      setFrozen = $__17.setFrozen;\n  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/Map.js")),\n      isObject = $__18.isObject,\n      registerPolyfill = $__18.registerPolyfill;\n  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur@0.0.111/src/runtime/polyfills/Map.js")).default;\n  var $__9 = Object,\n      defineProperty = $__9.defineProperty,\n      getOwnPropertyDescriptor = $__9.getOwnPropertyDescriptor,\n      hasOwnProperty = $__9.hasOwnProperty,\n      isExtensible = $__9.isExtensible;\n  var deletedSentinel = {};\n  var counter = 1;\n  var hashCodeName = createPrivateSymbol();\n  function getHashCodeForObject(obj) {\n    return getPrivate(obj, hashCodeName);\n  }\n  function getOrSetHashCodeForObject(obj) {\n    var hash = getHashCodeForObject(obj);\n    if (!hash) {\n      hash = counter++;\n      setPrivate(obj, hashCodeName, hash);\n    }\n    return hash;\n  }\n  function lookupIndex(map, key) {\n    if (typeof key === \'string\') {\n      return map.stringIndex_[key];\n    }\n    if (isObject(key)) {\n      if (!isExtensible(key)) {\n        return getFrozen(map.frozenData_, key);\n      }\n      var hc = getHashCodeForObject(key);\n      if (hc === undefined) {\n        return undefined;\n      }\n      return map.objectIndex_[hc];\n    }\n    return map.primitiveIndex_[key];\n  }\n  function initMap(map) {\n    map.entries_ = [];\n    map.objectIndex_ = Object.create(null);\n    map.stringIndex_ = Object.create(null);\n    map.primitiveIndex_ = Object.create(null);\n    map.frozenData_ = [];\n    map.deletedCount_ = 0;\n  }\n  var Map = function() {\n    function Map() {\n      var $__11,\n          $__12;\n      var iterable = arguments[0];\n      if (!isObject(this))\n        throw new TypeError(\'Map called on incompatible type\');\n      if (hasOwnProperty.call(this, \'entries_\')) {\n        throw new TypeError(\'Map can not be reentrantly initialised\');\n      }\n      initMap(this);\n      if (iterable !== null && iterable !== undefined) {\n        var $__5 = true;\n        var $__6 = false;\n        var $__7 = undefined;\n        try {\n          for (var $__3 = void 0,\n              $__2 = (iterable)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {\n            var $__10 = $__3.value,\n                key = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),\n                value = ($__12 = $__11.next()).done ? void 0 : $__12.value;\n            {\n              this.set(key, value);\n            }\n          }\n        } catch ($__8) {\n          $__6 = true;\n          $__7 = $__8;\n        } finally {\n          try {\n            if (!$__5 && $__2.return != null) {\n              $__2.return();\n            }\n          } finally {\n            if ($__6) {\n              throw $__7;\n            }\n          }\n        }\n      }\n    }\n    return ($traceurRuntime.createClass)(Map, {\n      get size() {\n        return this.entries_.length / 2 - this.deletedCount_;\n      },\n      get: function(key) {\n        var index = lookupIndex(this, key);\n        if (index !== undefined) {\n          return this.entries_[index + 1];\n        }\n      },\n      set: function(key, value) {\n        var index = lookupIndex(this, key);\n        if (index !== undefined) {\n          this.entries_[index + 1] = value;\n        } else {\n          index = this.entries_.length;\n          this.entries_[index] = key;\n          this.entries_[index + 1] = value;\n          if (isObject(key)) {\n            if (!isExtensible(key)) {\n              setFrozen(this.frozenData_, key, index);\n            } else {\n              var hash = getOrSetHashCodeForObject(key);\n              this.objectIndex_[hash] = index;\n            }\n          } else if (typeof key === \'string\') {\n            this.stringIndex_[key] = index;\n          } else {\n            this.primitiveIndex_[key] = index;\n          }\n        }\n        return this;\n      },\n      has: function(key) {\n        return lookupIndex(this, key) !== undefined;\n      },\n      delete: function(key) {\n        var index = lookupIndex(this, key);\n        if (index === undefined) {\n          return false;\n        }\n        this.entries_[index] = deletedSentinel;\n        this.entries_[index + 1] = undefined;\n        this.deletedCount_++;\n        if (isObject(key)) {\n          if (!isExtensible(key)) {\n            deleteFrozen(this.frozenData_, key);\n          } else {\n            var hash = getHashCodeForObject(key);\n            delete this.objectIndex_[hash];\n          }\n        } else if (typeof key === \'string\') {\n          delete this.stringIndex_[key];\n        } else {\n          delete this.primitiveIndex_[key];\n        }\n        return true;\n      },\n      clear: function() {\n        initMap(this);\n      },\n      forEach: function(callbackFn) {\n        var thisArg = arguments[1];\n        for (var i = 0; i < this.entries_.length; i += 2) {\n          var key = this.entries_[i];\n          var value = this.entries_[i + 1];\n          if (key === deletedSentinel)\n            continue;\n          callbackFn.call(thisArg, value, key, this);\n        }\n      },\n      entries: $traceurRuntime.initGeneratorFunction(function $__13() {\n        var i,\n            key,\n            value;\n        return $traceurRuntime.createGeneratorInstance(function($ctx) {\n          while (true)\n            switch ($ctx.state) {\n              case 0:\n                i = 0;\n                $ctx.state = 12;\n                break;\n              case 12:\n                $ctx.state = (i < this.entries_.length) ? 8 : -2;\n                break;\n              case 4:\n                i += 2;\n                $ctx.state = 12;\n                break;\n              case 8:\n                key = this.entries_[i];\n                value = this.entries_[i + 1];\n                $ctx.state = 9;\n                break;\n              case 9:\n                $ctx.state = (key === deletedSentinel) ? 4 : 6;\n                break;\n              case 6:\n                $ctx.state = 2;\n                return [key, value];\n              case 2:\n                $ctx.maybeThrow();\n                $ctx.state = 4;\n                break;\n              default:\n                return $ctx.end();\n            }\n        }, $__13, this);\n      }),\n      keys: $traceurRuntime.initGeneratorFunction(function $__14() {\n        var i,\n            key,\n            value;\n        return $traceurRuntime.createGeneratorInstance(function($ctx) {\n          while (true)\n            switch ($ctx.state) {\n              case 0:\n                i = 0;\n                $ctx.state = 12;\n                break;\n              case 12:\n                $ctx.state = (i < this.entries_.length) ? 8 : -2;\n                break;\n              case 4:\n                i += 2;\n                $ctx.state = 12;\n                break;\n              case 8:\n                key = this.entries_[i];\n                value = this.entries_[i + 1];\n                $ctx.state = 9;\n                break;\n              case 9:\n                $ctx.state = (key === deletedSentinel) ? 4 : 6;\n                break;\n              case 6:\n                $ctx.state = 2;\n                return key;\n              case 2:\n                $ctx.maybeThrow();\n                $ctx.state = 4;\n                break;\n              default:\n                return $ctx.end();\n            }\n        }, $__14, this);\n      }),\n      values: $traceurRuntime.initGeneratorFunction(function $__15() {\n        var i,\n            key,\n            value;\n        return $traceurRuntime.createGeneratorInstance(function($ctx) {\n          while (true)\n            switch ($ctx.state) {\n              case 0:\n                i = 0;\n                $ctx.state = 12;\n                break;\n              case 12:\n                $ctx.state = (i < this.entries_.length) ? 8 : -2;\n                break;\n              case 4:\n                i += 2;\n                $ctx.state = 12;\n                break;\n              case 8:\n                key = this.entries_[i];\n                value = this.entries_[i + 1];\n                $ctx.state = 9;\n                break;\n              case 9:\n                $ctx.state = (key === deletedSentinel) ? 4 : 6;\n                break;\n              case 6:\n                $ctx.state = 2;\n                return value;\n              case 2:\n                $ctx.maybeThrow();\n                $ctx.state = 4;\n                break;\n              default:\n                return $ctx.end();\n            }\n        }, $__15, this);\n      })\n    }, {});\n  }();\n  defineProperty(Map.prototype, Symbol.iterator, {\n    configurable: true,\n    writable: true,\n    value: Map.prototype.entries\n  });\n  function needsPolyfill(global) {\n    var $__10 = global,\n        Map = $__10.Map,\n        Symbol = $__10.Symbol;\n    if (!Map || !hasNativeSymbol() || !Map.prototype[Symbol.iterator] || !Map.prototype.entries) {\n      return true;\n    }\n    try {\n      return new Map([[]]).size !== 1;\n    } catch (e) {\n      return false;\n    }\n  }\n  function polyfillMap(global) {\n    if (needsPolyfill(global)) {\n      global.Map = Map;\n    }\n  }\n  registerPolyfill(polyfillMap);\n  return {\n    get Map() {\n      return Map;\n    },\n    get polyfillMap() {\n      return polyfillMap;\n    }\n  };\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/polyfills/Map.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/Set.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/Set.js";\n  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/Set.js")),\n      isObject = $__18.isObject,\n      registerPolyfill = $__18.registerPolyfill;\n  var Map = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Map.js", "traceur@0.0.111/src/runtime/polyfills/Set.js")).Map;\n  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur@0.0.111/src/runtime/polyfills/Set.js")).default;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var Set = function() {\n    function Set() {\n      var iterable = arguments[0];\n      if (!isObject(this))\n        throw new TypeError(\'Set called on incompatible type\');\n      if (hasOwnProperty.call(this, \'map_\')) {\n        throw new TypeError(\'Set can not be reentrantly initialised\');\n      }\n      this.map_ = new Map();\n      if (iterable !== null && iterable !== undefined) {\n        var $__6 = true;\n        var $__7 = false;\n        var $__8 = undefined;\n        try {\n          for (var $__4 = void 0,\n              $__3 = (iterable)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {\n            var item = $__4.value;\n            {\n              this.add(item);\n            }\n          }\n        } catch ($__9) {\n          $__7 = true;\n          $__8 = $__9;\n        } finally {\n          try {\n            if (!$__6 && $__3.return != null) {\n              $__3.return();\n            }\n          } finally {\n            if ($__7) {\n              throw $__8;\n            }\n          }\n        }\n      }\n    }\n    return ($traceurRuntime.createClass)(Set, {\n      get size() {\n        return this.map_.size;\n      },\n      has: function(key) {\n        return this.map_.has(key);\n      },\n      add: function(key) {\n        this.map_.set(key, key);\n        return this;\n      },\n      delete: function(key) {\n        return this.map_.delete(key);\n      },\n      clear: function() {\n        return this.map_.clear();\n      },\n      forEach: function(callbackFn) {\n        var thisArg = arguments[1];\n        var $__2 = this;\n        return this.map_.forEach(function(value, key) {\n          callbackFn.call(thisArg, key, key, $__2);\n        });\n      },\n      values: $traceurRuntime.initGeneratorFunction(function $__12() {\n        var $__13,\n            $__14;\n        return $traceurRuntime.createGeneratorInstance(function($ctx) {\n          while (true)\n            switch ($ctx.state) {\n              case 0:\n                $__13 = $ctx.wrapYieldStar(this.map_.keys()[Symbol.iterator]());\n                $ctx.sent = void 0;\n                $ctx.action = \'next\';\n                $ctx.state = 12;\n                break;\n              case 12:\n                $__14 = $__13[$ctx.action]($ctx.sentIgnoreThrow);\n                $ctx.state = 9;\n                break;\n              case 9:\n                $ctx.state = ($__14.done) ? 3 : 2;\n                break;\n              case 3:\n                $ctx.sent = $__14.value;\n                $ctx.state = -2;\n                break;\n              case 2:\n                $ctx.state = 12;\n                return $__14.value;\n              default:\n                return $ctx.end();\n            }\n        }, $__12, this);\n      }),\n      entries: $traceurRuntime.initGeneratorFunction(function $__15() {\n        var $__16,\n            $__17;\n        return $traceurRuntime.createGeneratorInstance(function($ctx) {\n          while (true)\n            switch ($ctx.state) {\n              case 0:\n                $__16 = $ctx.wrapYieldStar(this.map_.entries()[Symbol.iterator]());\n                $ctx.sent = void 0;\n                $ctx.action = \'next\';\n                $ctx.state = 12;\n                break;\n              case 12:\n                $__17 = $__16[$ctx.action]($ctx.sentIgnoreThrow);\n                $ctx.state = 9;\n                break;\n              case 9:\n                $ctx.state = ($__17.done) ? 3 : 2;\n                break;\n              case 3:\n                $ctx.sent = $__17.value;\n                $ctx.state = -2;\n                break;\n              case 2:\n                $ctx.state = 12;\n                return $__17.value;\n              default:\n                return $ctx.end();\n            }\n        }, $__15, this);\n      })\n    }, {});\n  }();\n  Object.defineProperty(Set.prototype, Symbol.iterator, {\n    configurable: true,\n    writable: true,\n    value: Set.prototype.values\n  });\n  Object.defineProperty(Set.prototype, \'keys\', {\n    configurable: true,\n    writable: true,\n    value: Set.prototype.values\n  });\n  function needsPolyfill(global) {\n    var $__11 = global,\n        Set = $__11.Set,\n        Symbol = $__11.Symbol;\n    if (!Set || !hasNativeSymbol() || !Set.prototype[Symbol.iterator] || !Set.prototype.values) {\n      return true;\n    }\n    try {\n      return new Set([1]).size !== 1;\n    } catch (e) {\n      return false;\n    }\n  }\n  function polyfillSet(global) {\n    if (needsPolyfill(global)) {\n      global.Set = Set;\n    }\n  }\n  registerPolyfill(polyfillSet);\n  return {\n    get Set() {\n      return Set;\n    },\n    get polyfillSet() {\n      return polyfillSet;\n    }\n  };\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/polyfills/Set.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/node_modules/rsvp/lib/rsvp/asap.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/node_modules/rsvp/lib/rsvp/asap.js";\n  var len = 0;\n  var toString = {}.toString;\n  var vertxNext;\n  function asap(callback, arg) {\n    queue[len] = callback;\n    queue[len + 1] = arg;\n    len += 2;\n    if (len === 2) {\n      scheduleFlush();\n    }\n  }\n  var browserWindow = (typeof window !== \'undefined\') ? window : undefined;\n  var browserGlobal = browserWindow || {};\n  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n  var isNode = typeof self === \'undefined\' && typeof process !== \'undefined\' && {}.toString.call(process) === \'[object process]\';\n  var isWorker = typeof Uint8ClampedArray !== \'undefined\' && typeof importScripts !== \'undefined\' && typeof MessageChannel !== \'undefined\';\n  function useNextTick() {\n    var nextTick = process.nextTick;\n    var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n    if (Array.isArray(version) && version[1] === \'0\' && version[2] === \'10\') {\n      nextTick = setImmediate;\n    }\n    return function() {\n      nextTick(flush);\n    };\n  }\n  function useVertxTimer() {\n    return function() {\n      vertxNext(flush);\n    };\n  }\n  function useMutationObserver() {\n    var iterations = 0;\n    var observer = new BrowserMutationObserver(flush);\n    var node = document.createTextNode(\'\');\n    observer.observe(node, {characterData: true});\n    return function() {\n      node.data = (iterations = ++iterations % 2);\n    };\n  }\n  function useMessageChannel() {\n    var channel = new MessageChannel();\n    channel.port1.onmessage = flush;\n    return function() {\n      channel.port2.postMessage(0);\n    };\n  }\n  function useSetTimeout() {\n    return function() {\n      setTimeout(flush, 1);\n    };\n  }\n  var queue = new Array(1000);\n  function flush() {\n    for (var i = 0; i < len; i += 2) {\n      var callback = queue[i];\n      var arg = queue[i + 1];\n      callback(arg);\n      queue[i] = undefined;\n      queue[i + 1] = undefined;\n    }\n    len = 0;\n  }\n  function attemptVertex() {\n    try {\n      var r = require;\n      var vertx = r(\'vertx\');\n      vertxNext = vertx.runOnLoop || vertx.runOnContext;\n      return useVertxTimer();\n    } catch (e) {\n      return useSetTimeout();\n    }\n  }\n  var scheduleFlush;\n  if (isNode) {\n    scheduleFlush = useNextTick();\n  } else if (BrowserMutationObserver) {\n    scheduleFlush = useMutationObserver();\n  } else if (isWorker) {\n    scheduleFlush = useMessageChannel();\n  } else if (browserWindow === undefined && typeof require === \'function\') {\n    scheduleFlush = attemptVertex();\n  } else {\n    scheduleFlush = useSetTimeout();\n  }\n  return {get default() {\n      return asap;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/Promise.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/Promise.js";\n  var async = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../../node_modules/rsvp/lib/rsvp/asap.js", "traceur@0.0.111/src/runtime/polyfills/Promise.js")).default;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/Promise.js")),\n      isObject = $__9.isObject,\n      registerPolyfill = $__9.registerPolyfill;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur@0.0.111/src/runtime/polyfills/Promise.js")),\n      createPrivateSymbol = $__10.createPrivateSymbol,\n      getPrivate = $__10.getPrivate,\n      setPrivate = $__10.setPrivate;\n  var promiseRaw = {};\n  function isPromise(x) {\n    return x && typeof x === \'object\' && x.status_ !== undefined;\n  }\n  function idResolveHandler(x) {\n    return x;\n  }\n  function idRejectHandler(x) {\n    throw x;\n  }\n  function chain(promise) {\n    var onResolve = arguments[1] !== (void 0) ? arguments[1] : idResolveHandler;\n    var onReject = arguments[2] !== (void 0) ? arguments[2] : idRejectHandler;\n    var deferred = getDeferred(promise.constructor);\n    switch (promise.status_) {\n      case undefined:\n        throw TypeError;\n      case 0:\n        promise.onResolve_.push(onResolve, deferred);\n        promise.onReject_.push(onReject, deferred);\n        break;\n      case +1:\n        promiseEnqueue(promise.value_, [onResolve, deferred]);\n        break;\n      case -1:\n        promiseEnqueue(promise.value_, [onReject, deferred]);\n        break;\n    }\n    return deferred.promise;\n  }\n  function getDeferred(C) {\n    if (this === $Promise) {\n      var promise = promiseInit(new $Promise(promiseRaw));\n      return {\n        promise: promise,\n        resolve: function(x) {\n          promiseResolve(promise, x);\n        },\n        reject: function(r) {\n          promiseReject(promise, r);\n        }\n      };\n    } else {\n      var result = {};\n      result.promise = new C(function(resolve, reject) {\n        result.resolve = resolve;\n        result.reject = reject;\n      });\n      return result;\n    }\n  }\n  function promiseSet(promise, status, value, onResolve, onReject) {\n    promise.status_ = status;\n    promise.value_ = value;\n    promise.onResolve_ = onResolve;\n    promise.onReject_ = onReject;\n    return promise;\n  }\n  function promiseInit(promise) {\n    return promiseSet(promise, 0, undefined, [], []);\n  }\n  var Promise = function() {\n    function Promise(resolver) {\n      if (resolver === promiseRaw)\n        return;\n      if (typeof resolver !== \'function\')\n        throw new TypeError;\n      var promise = promiseInit(this);\n      try {\n        resolver(function(x) {\n          promiseResolve(promise, x);\n        }, function(r) {\n          promiseReject(promise, r);\n        });\n      } catch (e) {\n        promiseReject(promise, e);\n      }\n    }\n    return ($traceurRuntime.createClass)(Promise, {\n      catch: function(onReject) {\n        return this.then(undefined, onReject);\n      },\n      then: function(onResolve, onReject) {\n        if (typeof onResolve !== \'function\')\n          onResolve = idResolveHandler;\n        if (typeof onReject !== \'function\')\n          onReject = idRejectHandler;\n        var that = this;\n        var constructor = this.constructor;\n        return chain(this, function(x) {\n          x = promiseCoerce(constructor, x);\n          return x === that ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);\n        }, onReject);\n      }\n    }, {\n      resolve: function(x) {\n        if (this === $Promise) {\n          if (isPromise(x)) {\n            return x;\n          }\n          return promiseSet(new $Promise(promiseRaw), +1, x);\n        } else {\n          return new this(function(resolve, reject) {\n            resolve(x);\n          });\n        }\n      },\n      reject: function(r) {\n        if (this === $Promise) {\n          return promiseSet(new $Promise(promiseRaw), -1, r);\n        } else {\n          return new this(function(resolve, reject) {\n            reject(r);\n          });\n        }\n      },\n      all: function(values) {\n        var deferred = getDeferred(this);\n        var resolutions = [];\n        try {\n          var makeCountdownFunction = function(i) {\n            return function(x) {\n              resolutions[i] = x;\n              if (--count === 0)\n                deferred.resolve(resolutions);\n            };\n          };\n          var count = 0;\n          var i = 0;\n          var $__4 = true;\n          var $__5 = false;\n          var $__6 = undefined;\n          try {\n            for (var $__2 = void 0,\n                $__1 = (values)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {\n              var value = $__2.value;\n              {\n                var countdownFunction = makeCountdownFunction(i);\n                this.resolve(value).then(countdownFunction, function(r) {\n                  deferred.reject(r);\n                });\n                ++i;\n                ++count;\n              }\n            }\n          } catch ($__7) {\n            $__5 = true;\n            $__6 = $__7;\n          } finally {\n            try {\n              if (!$__4 && $__1.return != null) {\n                $__1.return();\n              }\n            } finally {\n              if ($__5) {\n                throw $__6;\n              }\n            }\n          }\n          if (count === 0) {\n            deferred.resolve(resolutions);\n          }\n        } catch (e) {\n          deferred.reject(e);\n        }\n        return deferred.promise;\n      },\n      race: function(values) {\n        var deferred = getDeferred(this);\n        try {\n          for (var i = 0; i < values.length; i++) {\n            this.resolve(values[i]).then(function(x) {\n              deferred.resolve(x);\n            }, function(r) {\n              deferred.reject(r);\n            });\n          }\n        } catch (e) {\n          deferred.reject(e);\n        }\n        return deferred.promise;\n      }\n    });\n  }();\n  var $Promise = Promise;\n  var $PromiseReject = $Promise.reject;\n  function promiseResolve(promise, x) {\n    promiseDone(promise, +1, x, promise.onResolve_);\n  }\n  function promiseReject(promise, r) {\n    promiseDone(promise, -1, r, promise.onReject_);\n  }\n  function promiseDone(promise, status, value, reactions) {\n    if (promise.status_ !== 0)\n      return;\n    promiseEnqueue(value, reactions);\n    promiseSet(promise, status, value);\n  }\n  function promiseEnqueue(value, tasks) {\n    async(function() {\n      for (var i = 0; i < tasks.length; i += 2) {\n        promiseHandle(value, tasks[i], tasks[i + 1]);\n      }\n    });\n  }\n  function promiseHandle(value, handler, deferred) {\n    try {\n      var result = handler(value);\n      if (result === deferred.promise)\n        throw new TypeError;\n      else if (isPromise(result))\n        chain(result, deferred.resolve, deferred.reject);\n      else\n        deferred.resolve(result);\n    } catch (e) {\n      try {\n        deferred.reject(e);\n      } catch (e) {}\n    }\n  }\n  var thenableSymbol = createPrivateSymbol();\n  function promiseCoerce(constructor, x) {\n    if (!isPromise(x) && isObject(x)) {\n      var then;\n      try {\n        then = x.then;\n      } catch (r) {\n        var promise = $PromiseReject.call(constructor, r);\n        setPrivate(x, thenableSymbol, promise);\n        return promise;\n      }\n      if (typeof then === \'function\') {\n        var p = getPrivate(x, thenableSymbol);\n        if (p) {\n          return p;\n        } else {\n          var deferred = getDeferred(constructor);\n          setPrivate(x, thenableSymbol, deferred.promise);\n          try {\n            then.call(x, deferred.resolve, deferred.reject);\n          } catch (r) {\n            deferred.reject(r);\n          }\n          return deferred.promise;\n        }\n      }\n    }\n    return x;\n  }\n  function polyfillPromise(global) {\n    if (!global.Promise)\n      global.Promise = Promise;\n  }\n  registerPolyfill(polyfillPromise);\n  return {\n    get Promise() {\n      return Promise;\n    },\n    get polyfillPromise() {\n      return polyfillPromise;\n    }\n  };\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/polyfills/Promise.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/StringIterator.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/StringIterator.js";\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/StringIterator.js")),\n      createIteratorResultObject = $__3.createIteratorResultObject,\n      isObject = $__3.isObject;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var iteratedString = Symbol(\'iteratedString\');\n  var stringIteratorNextIndex = Symbol(\'stringIteratorNextIndex\');\n  var StringIterator = function() {\n    var $__1;\n    function StringIterator() {}\n    return ($traceurRuntime.createClass)(StringIterator, ($__1 = {}, Object.defineProperty($__1, "next", {\n      value: function() {\n        var o = this;\n        if (!isObject(o) || !hasOwnProperty.call(o, iteratedString)) {\n          throw new TypeError(\'this must be a StringIterator object\');\n        }\n        var s = o[iteratedString];\n        if (s === undefined) {\n          return createIteratorResultObject(undefined, true);\n        }\n        var position = o[stringIteratorNextIndex];\n        var len = s.length;\n        if (position >= len) {\n          o[iteratedString] = undefined;\n          return createIteratorResultObject(undefined, true);\n        }\n        var first = s.charCodeAt(position);\n        var resultString;\n        if (first < 0xD800 || first > 0xDBFF || position + 1 === len) {\n          resultString = String.fromCharCode(first);\n        } else {\n          var second = s.charCodeAt(position + 1);\n          if (second < 0xDC00 || second > 0xDFFF) {\n            resultString = String.fromCharCode(first);\n          } else {\n            resultString = String.fromCharCode(first) + String.fromCharCode(second);\n          }\n        }\n        o[stringIteratorNextIndex] = position + resultString.length;\n        return createIteratorResultObject(resultString, false);\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), Object.defineProperty($__1, Symbol.iterator, {\n      value: function() {\n        return this;\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), $__1), {});\n  }();\n  function createStringIterator(string) {\n    var s = String(string);\n    var iterator = Object.create(StringIterator.prototype);\n    iterator[iteratedString] = s;\n    iterator[stringIteratorNextIndex] = 0;\n    return iterator;\n  }\n  return {get createStringIterator() {\n      return createStringIterator;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/String.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/String.js";\n  var checkObjectCoercible = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../checkObjectCoercible.js", "traceur@0.0.111/src/runtime/polyfills/String.js")).default;\n  var createStringIterator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./StringIterator.js", "traceur@0.0.111/src/runtime/polyfills/String.js")).createStringIterator;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/String.js")),\n      maybeAddFunctions = $__3.maybeAddFunctions,\n      maybeAddIterator = $__3.maybeAddIterator,\n      registerPolyfill = $__3.registerPolyfill;\n  var $toString = Object.prototype.toString;\n  var $indexOf = String.prototype.indexOf;\n  var $lastIndexOf = String.prototype.lastIndexOf;\n  function startsWith(search) {\n    var string = String(this);\n    if (this == null || $toString.call(search) == \'[object RegExp]\') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var position = arguments.length > 1 ? arguments[1] : undefined;\n    var pos = position ? Number(position) : 0;\n    if (isNaN(pos)) {\n      pos = 0;\n    }\n    var start = Math.min(Math.max(pos, 0), stringLength);\n    return $indexOf.call(string, searchString, pos) == start;\n  }\n  function endsWith(search) {\n    var string = String(this);\n    if (this == null || $toString.call(search) == \'[object RegExp]\') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var pos = stringLength;\n    if (arguments.length > 1) {\n      var position = arguments[1];\n      if (position !== undefined) {\n        pos = position ? Number(position) : 0;\n        if (isNaN(pos)) {\n          pos = 0;\n        }\n      }\n    }\n    var end = Math.min(Math.max(pos, 0), stringLength);\n    var start = end - searchLength;\n    if (start < 0) {\n      return false;\n    }\n    return $lastIndexOf.call(string, searchString, start) == start;\n  }\n  function includes(search) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    if (search && $toString.call(search) == \'[object RegExp]\') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var position = arguments.length > 1 ? arguments[1] : undefined;\n    var pos = position ? Number(position) : 0;\n    if (pos != pos) {\n      pos = 0;\n    }\n    var start = Math.min(Math.max(pos, 0), stringLength);\n    if (searchLength + start > stringLength) {\n      return false;\n    }\n    return $indexOf.call(string, searchString, pos) != -1;\n  }\n  function repeat(count) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var n = count ? Number(count) : 0;\n    if (isNaN(n)) {\n      n = 0;\n    }\n    if (n < 0 || n == Infinity) {\n      throw RangeError();\n    }\n    if (n == 0) {\n      return \'\';\n    }\n    var result = \'\';\n    while (n--) {\n      result += string;\n    }\n    return result;\n  }\n  function codePointAt(position) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var size = string.length;\n    var index = position ? Number(position) : 0;\n    if (isNaN(index)) {\n      index = 0;\n    }\n    if (index < 0 || index >= size) {\n      return undefined;\n    }\n    var first = string.charCodeAt(index);\n    var second;\n    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {\n      second = string.charCodeAt(index + 1);\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n    return first;\n  }\n  function raw(callsite) {\n    var raw = callsite.raw;\n    var len = raw.length >>> 0;\n    if (len === 0)\n      return \'\';\n    var s = \'\';\n    var i = 0;\n    while (true) {\n      s += raw[i];\n      if (i + 1 === len)\n        return s;\n      s += arguments[++i];\n    }\n  }\n  function fromCodePoint(_) {\n    var codeUnits = [];\n    var floor = Math.floor;\n    var highSurrogate;\n    var lowSurrogate;\n    var index = -1;\n    var length = arguments.length;\n    if (!length) {\n      return \'\';\n    }\n    while (++index < length) {\n      var codePoint = Number(arguments[index]);\n      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {\n        throw RangeError(\'Invalid code point: \' + codePoint);\n      }\n      if (codePoint <= 0xFFFF) {\n        codeUnits.push(codePoint);\n      } else {\n        codePoint -= 0x10000;\n        highSurrogate = (codePoint >> 10) + 0xD800;\n        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n        codeUnits.push(highSurrogate, lowSurrogate);\n      }\n    }\n    return String.fromCharCode.apply(null, codeUnits);\n  }\n  function stringPrototypeIterator() {\n    var o = checkObjectCoercible(this);\n    var s = String(o);\n    return createStringIterator(s);\n  }\n  function polyfillString(global) {\n    var String = global.String;\n    maybeAddFunctions(String.prototype, [\'codePointAt\', codePointAt, \'endsWith\', endsWith, \'includes\', includes, \'repeat\', repeat, \'startsWith\', startsWith]);\n    maybeAddFunctions(String, [\'fromCodePoint\', fromCodePoint, \'raw\', raw]);\n    maybeAddIterator(String.prototype, stringPrototypeIterator, Symbol);\n  }\n  registerPolyfill(polyfillString);\n  return {\n    get startsWith() {\n      return startsWith;\n    },\n    get endsWith() {\n      return endsWith;\n    },\n    get includes() {\n      return includes;\n    },\n    get repeat() {\n      return repeat;\n    },\n    get codePointAt() {\n      return codePointAt;\n    },\n    get raw() {\n      return raw;\n    },\n    get fromCodePoint() {\n      return fromCodePoint;\n    },\n    get stringPrototypeIterator() {\n      return stringPrototypeIterator;\n    },\n    get polyfillString() {\n      return polyfillString;\n    }\n  };\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/polyfills/String.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/ArrayIterator.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/ArrayIterator.js";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/ArrayIterator.js")),\n      toObject = $__2.toObject,\n      toUint32 = $__2.toUint32,\n      createIteratorResultObject = $__2.createIteratorResultObject;\n  var ARRAY_ITERATOR_KIND_KEYS = 1;\n  var ARRAY_ITERATOR_KIND_VALUES = 2;\n  var ARRAY_ITERATOR_KIND_ENTRIES = 3;\n  var ArrayIterator = function() {\n    var $__1;\n    function ArrayIterator() {}\n    return ($traceurRuntime.createClass)(ArrayIterator, ($__1 = {}, Object.defineProperty($__1, "next", {\n      value: function() {\n        var iterator = toObject(this);\n        var array = iterator.iteratorObject_;\n        if (!array) {\n          throw new TypeError(\'Object is not an ArrayIterator\');\n        }\n        var index = iterator.arrayIteratorNextIndex_;\n        var itemKind = iterator.arrayIterationKind_;\n        var length = toUint32(array.length);\n        if (index >= length) {\n          iterator.arrayIteratorNextIndex_ = Infinity;\n          return createIteratorResultObject(undefined, true);\n        }\n        iterator.arrayIteratorNextIndex_ = index + 1;\n        if (itemKind == ARRAY_ITERATOR_KIND_VALUES)\n          return createIteratorResultObject(array[index], false);\n        if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)\n          return createIteratorResultObject([index, array[index]], false);\n        return createIteratorResultObject(index, false);\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), Object.defineProperty($__1, Symbol.iterator, {\n      value: function() {\n        return this;\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), $__1), {});\n  }();\n  function createArrayIterator(array, kind) {\n    var object = toObject(array);\n    var iterator = new ArrayIterator;\n    iterator.iteratorObject_ = object;\n    iterator.arrayIteratorNextIndex_ = 0;\n    iterator.arrayIterationKind_ = kind;\n    return iterator;\n  }\n  function entries() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);\n  }\n  function keys() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);\n  }\n  function values() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);\n  }\n  return {\n    get entries() {\n      return entries;\n    },\n    get keys() {\n      return keys;\n    },\n    get values() {\n      return values;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/Array.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/Array.js";\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ArrayIterator.js", "traceur@0.0.111/src/runtime/polyfills/Array.js")),\n      entries = $__9.entries,\n      keys = $__9.keys,\n      jsValues = $__9.values;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/Array.js")),\n      checkIterable = $__10.checkIterable,\n      isCallable = $__10.isCallable,\n      isConstructor = $__10.isConstructor,\n      maybeAddFunctions = $__10.maybeAddFunctions,\n      maybeAddIterator = $__10.maybeAddIterator,\n      registerPolyfill = $__10.registerPolyfill,\n      toInteger = $__10.toInteger,\n      toLength = $__10.toLength,\n      toObject = $__10.toObject;\n  function from(arrLike) {\n    var mapFn = arguments[1];\n    var thisArg = arguments[2];\n    var C = this;\n    var items = toObject(arrLike);\n    var mapping = mapFn !== undefined;\n    var k = 0;\n    var arr,\n        len;\n    if (mapping && !isCallable(mapFn)) {\n      throw TypeError();\n    }\n    if (checkIterable(items)) {\n      arr = isConstructor(C) ? new C() : [];\n      var $__3 = true;\n      var $__4 = false;\n      var $__5 = undefined;\n      try {\n        for (var $__1 = void 0,\n            $__0 = (items)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {\n          var item = $__1.value;\n          {\n            if (mapping) {\n              arr[k] = mapFn.call(thisArg, item, k);\n            } else {\n              arr[k] = item;\n            }\n            k++;\n          }\n        }\n      } catch ($__6) {\n        $__4 = true;\n        $__5 = $__6;\n      } finally {\n        try {\n          if (!$__3 && $__0.return != null) {\n            $__0.return();\n          }\n        } finally {\n          if ($__4) {\n            throw $__5;\n          }\n        }\n      }\n      arr.length = k;\n      return arr;\n    }\n    len = toLength(items.length);\n    arr = isConstructor(C) ? new C(len) : new Array(len);\n    for (; k < len; k++) {\n      if (mapping) {\n        arr[k] = typeof thisArg === \'undefined\' ? mapFn(items[k], k) : mapFn.call(thisArg, items[k], k);\n      } else {\n        arr[k] = items[k];\n      }\n    }\n    arr.length = len;\n    return arr;\n  }\n  function of() {\n    for (var items = [],\n        $__7 = 0; $__7 < arguments.length; $__7++)\n      items[$__7] = arguments[$__7];\n    var C = this;\n    var len = items.length;\n    var arr = isConstructor(C) ? new C(len) : new Array(len);\n    for (var k = 0; k < len; k++) {\n      arr[k] = items[k];\n    }\n    arr.length = len;\n    return arr;\n  }\n  function fill(value) {\n    var start = arguments[1] !== (void 0) ? arguments[1] : 0;\n    var end = arguments[2];\n    var object = toObject(this);\n    var len = toLength(object.length);\n    var fillStart = toInteger(start);\n    var fillEnd = end !== undefined ? toInteger(end) : len;\n    fillStart = fillStart < 0 ? Math.max(len + fillStart, 0) : Math.min(fillStart, len);\n    fillEnd = fillEnd < 0 ? Math.max(len + fillEnd, 0) : Math.min(fillEnd, len);\n    while (fillStart < fillEnd) {\n      object[fillStart] = value;\n      fillStart++;\n    }\n    return object;\n  }\n  function find(predicate) {\n    var thisArg = arguments[1];\n    return findHelper(this, predicate, thisArg);\n  }\n  function findIndex(predicate) {\n    var thisArg = arguments[1];\n    return findHelper(this, predicate, thisArg, true);\n  }\n  function findHelper(self, predicate) {\n    var thisArg = arguments[2];\n    var returnIndex = arguments[3] !== (void 0) ? arguments[3] : false;\n    var object = toObject(self);\n    var len = toLength(object.length);\n    if (!isCallable(predicate)) {\n      throw TypeError();\n    }\n    for (var i = 0; i < len; i++) {\n      var value = object[i];\n      if (predicate.call(thisArg, value, i, object)) {\n        return returnIndex ? i : value;\n      }\n    }\n    return returnIndex ? -1 : undefined;\n  }\n  function polyfillArray(global) {\n    var $__8 = global,\n        Array = $__8.Array,\n        Object = $__8.Object,\n        Symbol = $__8.Symbol;\n    var values = jsValues;\n    if (Symbol && Symbol.iterator && Array.prototype[Symbol.iterator]) {\n      values = Array.prototype[Symbol.iterator];\n    }\n    maybeAddFunctions(Array.prototype, [\'entries\', entries, \'keys\', keys, \'values\', values, \'fill\', fill, \'find\', find, \'findIndex\', findIndex]);\n    maybeAddFunctions(Array, [\'from\', from, \'of\', of]);\n    maybeAddIterator(Array.prototype, values, Symbol);\n    maybeAddIterator(Object.getPrototypeOf([].values()), function() {\n      return this;\n    }, Symbol);\n  }\n  registerPolyfill(polyfillArray);\n  return {\n    get from() {\n      return from;\n    },\n    get of() {\n      return of;\n    },\n    get fill() {\n      return fill;\n    },\n    get find() {\n      return find;\n    },\n    get findIndex() {\n      return findIndex;\n    },\n    get polyfillArray() {\n      return polyfillArray;\n    }\n  };\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/polyfills/Array.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/assign.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/assign.js";\n  var keys = Object.keys;\n  function assign(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      var props = source == null ? [] : keys(source);\n      var p = void 0,\n          length = props.length;\n      for (p = 0; p < length; p++) {\n        var name = props[p];\n        target[name] = source[name];\n      }\n    }\n    return target;\n  }\n  return {get default() {\n      return assign;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/Object.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/Object.js";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/Object.js")),\n      maybeAddFunctions = $__2.maybeAddFunctions,\n      registerPolyfill = $__2.registerPolyfill;\n  var assign = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./assign.js", "traceur@0.0.111/src/runtime/polyfills/Object.js")).default;\n  var $__0 = Object,\n      defineProperty = $__0.defineProperty,\n      getOwnPropertyDescriptor = $__0.getOwnPropertyDescriptor,\n      getOwnPropertyNames = $__0.getOwnPropertyNames;\n  function is(left, right) {\n    if (left === right)\n      return left !== 0 || 1 / left === 1 / right;\n    return left !== left && right !== right;\n  }\n  function mixin(target, source) {\n    var props = getOwnPropertyNames(source);\n    var p,\n        descriptor,\n        length = props.length;\n    for (p = 0; p < length; p++) {\n      var name = props[p];\n      descriptor = getOwnPropertyDescriptor(source, props[p]);\n      defineProperty(target, props[p], descriptor);\n    }\n    return target;\n  }\n  function polyfillObject(global) {\n    var Object = global.Object;\n    maybeAddFunctions(Object, [\'assign\', assign, \'is\', is, \'mixin\', mixin]);\n  }\n  registerPolyfill(polyfillObject);\n  return {\n    get assign() {\n      return assign;\n    },\n    get is() {\n      return is;\n    },\n    get mixin() {\n      return mixin;\n    },\n    get polyfillObject() {\n      return polyfillObject;\n    }\n  };\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/polyfills/Object.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/Number.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/Number.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/Number.js")),\n      isNumber = $__1.isNumber,\n      maybeAddConsts = $__1.maybeAddConsts,\n      maybeAddFunctions = $__1.maybeAddFunctions,\n      registerPolyfill = $__1.registerPolyfill,\n      toInteger = $__1.toInteger;\n  var $abs = Math.abs;\n  var $isFinite = isFinite;\n  var $isNaN = isNaN;\n  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n  var MIN_SAFE_INTEGER = -Math.pow(2, 53) + 1;\n  var EPSILON = Math.pow(2, -52);\n  function NumberIsFinite(number) {\n    return isNumber(number) && $isFinite(number);\n  }\n  function isInteger(number) {\n    return NumberIsFinite(number) && toInteger(number) === number;\n  }\n  function NumberIsNaN(number) {\n    return isNumber(number) && $isNaN(number);\n  }\n  function isSafeInteger(number) {\n    if (NumberIsFinite(number)) {\n      var integral = toInteger(number);\n      if (integral === number)\n        return $abs(integral) <= MAX_SAFE_INTEGER;\n    }\n    return false;\n  }\n  function polyfillNumber(global) {\n    var Number = global.Number;\n    maybeAddConsts(Number, [\'MAX_SAFE_INTEGER\', MAX_SAFE_INTEGER, \'MIN_SAFE_INTEGER\', MIN_SAFE_INTEGER, \'EPSILON\', EPSILON]);\n    maybeAddFunctions(Number, [\'isFinite\', NumberIsFinite, \'isInteger\', isInteger, \'isNaN\', NumberIsNaN, \'isSafeInteger\', isSafeInteger]);\n  }\n  registerPolyfill(polyfillNumber);\n  return {\n    get MAX_SAFE_INTEGER() {\n      return MAX_SAFE_INTEGER;\n    },\n    get MIN_SAFE_INTEGER() {\n      return MIN_SAFE_INTEGER;\n    },\n    get EPSILON() {\n      return EPSILON;\n    },\n    get isFinite() {\n      return NumberIsFinite;\n    },\n    get isInteger() {\n      return isInteger;\n    },\n    get isNaN() {\n      return NumberIsNaN;\n    },\n    get isSafeInteger() {\n      return isSafeInteger;\n    },\n    get polyfillNumber() {\n      return polyfillNumber;\n    }\n  };\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/polyfills/Number.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/fround.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/fround.js";\n  var $isFinite = isFinite;\n  var $isNaN = isNaN;\n  var $__0 = Math,\n      LN2 = $__0.LN2,\n      abs = $__0.abs,\n      floor = $__0.floor,\n      log = $__0.log,\n      min = $__0.min,\n      pow = $__0.pow;\n  function packIEEE754(v, ebits, fbits) {\n    var bias = (1 << (ebits - 1)) - 1,\n        s,\n        e,\n        f,\n        ln,\n        i,\n        bits,\n        str,\n        bytes;\n    function roundToEven(n) {\n      var w = floor(n),\n          f = n - w;\n      if (f < 0.5)\n        return w;\n      if (f > 0.5)\n        return w + 1;\n      return w % 2 ? w + 1 : w;\n    }\n    if (v !== v) {\n      e = (1 << ebits) - 1;\n      f = pow(2, fbits - 1);\n      s = 0;\n    } else if (v === Infinity || v === -Infinity) {\n      e = (1 << ebits) - 1;\n      f = 0;\n      s = (v < 0) ? 1 : 0;\n    } else if (v === 0) {\n      e = 0;\n      f = 0;\n      s = (1 / v === -Infinity) ? 1 : 0;\n    } else {\n      s = v < 0;\n      v = abs(v);\n      if (v >= pow(2, 1 - bias)) {\n        e = min(floor(log(v) / LN2), 1023);\n        f = roundToEven(v / pow(2, e) * pow(2, fbits));\n        if (f / pow(2, fbits) >= 2) {\n          e = e + 1;\n          f = 1;\n        }\n        if (e > bias) {\n          e = (1 << ebits) - 1;\n          f = 0;\n        } else {\n          e = e + bias;\n          f = f - pow(2, fbits);\n        }\n      } else {\n        e = 0;\n        f = roundToEven(v / pow(2, 1 - bias - fbits));\n      }\n    }\n    bits = [];\n    for (i = fbits; i; i -= 1) {\n      bits.push(f % 2 ? 1 : 0);\n      f = floor(f / 2);\n    }\n    for (i = ebits; i; i -= 1) {\n      bits.push(e % 2 ? 1 : 0);\n      e = floor(e / 2);\n    }\n    bits.push(s ? 1 : 0);\n    bits.reverse();\n    str = bits.join(\'\');\n    bytes = [];\n    while (str.length) {\n      bytes.push(parseInt(str.substring(0, 8), 2));\n      str = str.substring(8);\n    }\n    return bytes;\n  }\n  function unpackIEEE754(bytes, ebits, fbits) {\n    var bits = [],\n        i,\n        j,\n        b,\n        str,\n        bias,\n        s,\n        e,\n        f;\n    for (i = bytes.length; i; i -= 1) {\n      b = bytes[i - 1];\n      for (j = 8; j; j -= 1) {\n        bits.push(b % 2 ? 1 : 0);\n        b = b >> 1;\n      }\n    }\n    bits.reverse();\n    str = bits.join(\'\');\n    bias = (1 << (ebits - 1)) - 1;\n    s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n    e = parseInt(str.substring(1, 1 + ebits), 2);\n    f = parseInt(str.substring(1 + ebits), 2);\n    if (e === (1 << ebits) - 1) {\n      return f !== 0 ? NaN : s * Infinity;\n    } else if (e > 0) {\n      return s * pow(2, e - bias) * (1 + f / pow(2, fbits));\n    } else if (f !== 0) {\n      return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));\n    } else {\n      return s < 0 ? -0 : 0;\n    }\n  }\n  function unpackF32(b) {\n    return unpackIEEE754(b, 8, 23);\n  }\n  function packF32(v) {\n    return packIEEE754(v, 8, 23);\n  }\n  function fround(x) {\n    if (x === 0 || !$isFinite(x) || $isNaN(x)) {\n      return x;\n    }\n    return unpackF32(packF32(Number(x)));\n  }\n  return {get fround() {\n      return fround;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/Math.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/Math.js";\n  var jsFround = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./fround.js", "traceur@0.0.111/src/runtime/polyfills/Math.js")).fround;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/Math.js")),\n      maybeAddFunctions = $__3.maybeAddFunctions,\n      registerPolyfill = $__3.registerPolyfill,\n      toUint32 = $__3.toUint32;\n  var $isFinite = isFinite;\n  var $isNaN = isNaN;\n  var $__0 = Math,\n      abs = $__0.abs,\n      ceil = $__0.ceil,\n      exp = $__0.exp,\n      floor = $__0.floor,\n      log = $__0.log,\n      pow = $__0.pow,\n      sqrt = $__0.sqrt;\n  function clz32(x) {\n    x = toUint32(+x);\n    if (x == 0)\n      return 32;\n    var result = 0;\n    if ((x & 0xFFFF0000) === 0) {\n      x <<= 16;\n      result += 16;\n    }\n    ;\n    if ((x & 0xFF000000) === 0) {\n      x <<= 8;\n      result += 8;\n    }\n    ;\n    if ((x & 0xF0000000) === 0) {\n      x <<= 4;\n      result += 4;\n    }\n    ;\n    if ((x & 0xC0000000) === 0) {\n      x <<= 2;\n      result += 2;\n    }\n    ;\n    if ((x & 0x80000000) === 0) {\n      x <<= 1;\n      result += 1;\n    }\n    ;\n    return result;\n  }\n  function imul(x, y) {\n    x = toUint32(+x);\n    y = toUint32(+y);\n    var xh = (x >>> 16) & 0xffff;\n    var xl = x & 0xffff;\n    var yh = (y >>> 16) & 0xffff;\n    var yl = y & 0xffff;\n    return xl * yl + (((xh * yl + xl * yh) << 16) >>> 0) | 0;\n  }\n  function sign(x) {\n    x = +x;\n    if (x > 0)\n      return 1;\n    if (x < 0)\n      return -1;\n    return x;\n  }\n  function log10(x) {\n    return log(x) * 0.434294481903251828;\n  }\n  function log2(x) {\n    return log(x) * 1.442695040888963407;\n  }\n  function log1p(x) {\n    x = +x;\n    if (x < -1 || $isNaN(x)) {\n      return NaN;\n    }\n    if (x === 0 || x === Infinity) {\n      return x;\n    }\n    if (x === -1) {\n      return -Infinity;\n    }\n    var result = 0;\n    var n = 50;\n    if (x < 0 || x > 1) {\n      return log(1 + x);\n    }\n    for (var i = 1; i < n; i++) {\n      if ((i % 2) === 0) {\n        result -= pow(x, i) / i;\n      } else {\n        result += pow(x, i) / i;\n      }\n    }\n    return result;\n  }\n  function expm1(x) {\n    x = +x;\n    if (x === -Infinity) {\n      return -1;\n    }\n    if (!$isFinite(x) || x === 0) {\n      return x;\n    }\n    return exp(x) - 1;\n  }\n  function cosh(x) {\n    x = +x;\n    if (x === 0) {\n      return 1;\n    }\n    if ($isNaN(x)) {\n      return NaN;\n    }\n    if (!$isFinite(x)) {\n      return Infinity;\n    }\n    if (x < 0) {\n      x = -x;\n    }\n    if (x > 21) {\n      return exp(x) / 2;\n    }\n    return (exp(x) + exp(-x)) / 2;\n  }\n  function sinh(x) {\n    x = +x;\n    if (!$isFinite(x) || x === 0) {\n      return x;\n    }\n    return (exp(x) - exp(-x)) / 2;\n  }\n  function tanh(x) {\n    x = +x;\n    if (x === 0)\n      return x;\n    if (!$isFinite(x))\n      return sign(x);\n    var exp1 = exp(x);\n    var exp2 = exp(-x);\n    return (exp1 - exp2) / (exp1 + exp2);\n  }\n  function acosh(x) {\n    x = +x;\n    if (x < 1)\n      return NaN;\n    if (!$isFinite(x))\n      return x;\n    return log(x + sqrt(x + 1) * sqrt(x - 1));\n  }\n  function asinh(x) {\n    x = +x;\n    if (x === 0 || !$isFinite(x))\n      return x;\n    if (x > 0)\n      return log(x + sqrt(x * x + 1));\n    return -log(-x + sqrt(x * x + 1));\n  }\n  function atanh(x) {\n    x = +x;\n    if (x === -1) {\n      return -Infinity;\n    }\n    if (x === 1) {\n      return Infinity;\n    }\n    if (x === 0) {\n      return x;\n    }\n    if ($isNaN(x) || x < -1 || x > 1) {\n      return NaN;\n    }\n    return 0.5 * log((1 + x) / (1 - x));\n  }\n  function hypot(x, y) {\n    var length = arguments.length;\n    var args = new Array(length);\n    var max = 0;\n    for (var i = 0; i < length; i++) {\n      var n = arguments[i];\n      n = +n;\n      if (n === Infinity || n === -Infinity)\n        return Infinity;\n      n = abs(n);\n      if (n > max)\n        max = n;\n      args[i] = n;\n    }\n    if (max === 0)\n      max = 1;\n    var sum = 0;\n    var compensation = 0;\n    for (var i = 0; i < length; i++) {\n      var n = args[i] / max;\n      var summand = n * n - compensation;\n      var preliminary = sum + summand;\n      compensation = (preliminary - sum) - summand;\n      sum = preliminary;\n    }\n    return sqrt(sum) * max;\n  }\n  function trunc(x) {\n    x = +x;\n    if (x > 0)\n      return floor(x);\n    if (x < 0)\n      return ceil(x);\n    return x;\n  }\n  var fround,\n      f32;\n  if (typeof Float32Array === \'function\') {\n    f32 = new Float32Array(1);\n    fround = function(x) {\n      f32[0] = Number(x);\n      return f32[0];\n    };\n  } else {\n    fround = jsFround;\n  }\n  function cbrt(x) {\n    x = +x;\n    if (x === 0)\n      return x;\n    var negate = x < 0;\n    if (negate)\n      x = -x;\n    var result = pow(x, 1 / 3);\n    return negate ? -result : result;\n  }\n  function polyfillMath(global) {\n    var Math = global.Math;\n    maybeAddFunctions(Math, [\'acosh\', acosh, \'asinh\', asinh, \'atanh\', atanh, \'cbrt\', cbrt, \'clz32\', clz32, \'cosh\', cosh, \'expm1\', expm1, \'fround\', fround, \'hypot\', hypot, \'imul\', imul, \'log10\', log10, \'log1p\', log1p, \'log2\', log2, \'sign\', sign, \'sinh\', sinh, \'tanh\', tanh, \'trunc\', trunc]);\n  }\n  registerPolyfill(polyfillMath);\n  return {\n    get clz32() {\n      return clz32;\n    },\n    get imul() {\n      return imul;\n    },\n    get sign() {\n      return sign;\n    },\n    get log10() {\n      return log10;\n    },\n    get log2() {\n      return log2;\n    },\n    get log1p() {\n      return log1p;\n    },\n    get expm1() {\n      return expm1;\n    },\n    get cosh() {\n      return cosh;\n    },\n    get sinh() {\n      return sinh;\n    },\n    get tanh() {\n      return tanh;\n    },\n    get acosh() {\n      return acosh;\n    },\n    get asinh() {\n      return asinh;\n    },\n    get atanh() {\n      return atanh;\n    },\n    get hypot() {\n      return hypot;\n    },\n    get trunc() {\n      return trunc;\n    },\n    get fround() {\n      return fround;\n    },\n    get cbrt() {\n      return cbrt;\n    },\n    get polyfillMath() {\n      return polyfillMath;\n    }\n  };\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/polyfills/Math.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/WeakMap.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/WeakMap.js";\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur@0.0.111/src/runtime/polyfills/WeakMap.js")),\n      createPrivateSymbol = $__5.createPrivateSymbol,\n      deletePrivate = $__5.deletePrivate,\n      getPrivate = $__5.getPrivate,\n      hasPrivate = $__5.hasPrivate,\n      setPrivate = $__5.setPrivate;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur@0.0.111/src/runtime/polyfills/WeakMap.js")),\n      deleteFrozen = $__6.deleteFrozen,\n      getFrozen = $__6.getFrozen,\n      hasFrozen = $__6.hasFrozen,\n      setFrozen = $__6.setFrozen;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/WeakMap.js")),\n      isObject = $__7.isObject,\n      registerPolyfill = $__7.registerPolyfill;\n  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur@0.0.111/src/runtime/polyfills/WeakMap.js")).default;\n  var $__2 = Object,\n      defineProperty = $__2.defineProperty,\n      getOwnPropertyDescriptor = $__2.getOwnPropertyDescriptor,\n      isExtensible = $__2.isExtensible;\n  var $TypeError = TypeError;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var sentinel = {};\n  var WeakMap = function() {\n    function WeakMap() {\n      this.name_ = createPrivateSymbol();\n      this.frozenData_ = [];\n    }\n    return ($traceurRuntime.createClass)(WeakMap, {\n      set: function(key, value) {\n        if (!isObject(key))\n          throw new $TypeError(\'key must be an object\');\n        if (!isExtensible(key)) {\n          setFrozen(this.frozenData_, key, value);\n        } else {\n          setPrivate(key, this.name_, value);\n        }\n        return this;\n      },\n      get: function(key) {\n        if (!isObject(key))\n          return undefined;\n        if (!isExtensible(key)) {\n          return getFrozen(this.frozenData_, key);\n        }\n        return getPrivate(key, this.name_);\n      },\n      delete: function(key) {\n        if (!isObject(key))\n          return false;\n        if (!isExtensible(key)) {\n          return deleteFrozen(this.frozenData_, key);\n        }\n        return deletePrivate(key, this.name_);\n      },\n      has: function(key) {\n        if (!isObject(key))\n          return false;\n        if (!isExtensible(key)) {\n          return hasFrozen(this.frozenData_, key);\n        }\n        return hasPrivate(key, this.name_);\n      }\n    }, {});\n  }();\n  function needsPolyfill(global) {\n    var $__4 = global,\n        WeakMap = $__4.WeakMap,\n        Symbol = $__4.Symbol;\n    if (!WeakMap || !hasNativeSymbol()) {\n      return true;\n    }\n    try {\n      var o = {};\n      var wm = new WeakMap([[o, false]]);\n      return wm.get(o);\n    } catch (e) {\n      return false;\n    }\n  }\n  function polyfillWeakMap(global) {\n    if (needsPolyfill(global)) {\n      global.WeakMap = WeakMap;\n    }\n  }\n  registerPolyfill(polyfillWeakMap);\n  return {\n    get WeakMap() {\n      return WeakMap;\n    },\n    get polyfillWeakMap() {\n      return polyfillWeakMap;\n    }\n  };\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/polyfills/WeakMap.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/WeakSet.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/WeakSet.js";\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur@0.0.111/src/runtime/polyfills/WeakSet.js")),\n      createPrivateSymbol = $__5.createPrivateSymbol,\n      deletePrivate = $__5.deletePrivate,\n      getPrivate = $__5.getPrivate,\n      hasPrivate = $__5.hasPrivate,\n      setPrivate = $__5.setPrivate;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur@0.0.111/src/runtime/polyfills/WeakSet.js")),\n      deleteFrozen = $__6.deleteFrozen,\n      getFrozen = $__6.getFrozen,\n      setFrozen = $__6.setFrozen;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/WeakSet.js")),\n      isObject = $__7.isObject,\n      registerPolyfill = $__7.registerPolyfill;\n  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur@0.0.111/src/runtime/polyfills/WeakSet.js")).default;\n  var $__2 = Object,\n      defineProperty = $__2.defineProperty,\n      isExtensible = $__2.isExtensible;\n  var $TypeError = TypeError;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var WeakSet = function() {\n    function WeakSet() {\n      this.name_ = createPrivateSymbol();\n      this.frozenData_ = [];\n    }\n    return ($traceurRuntime.createClass)(WeakSet, {\n      add: function(value) {\n        if (!isObject(value))\n          throw new $TypeError(\'value must be an object\');\n        if (!isExtensible(value)) {\n          setFrozen(this.frozenData_, value, value);\n        } else {\n          setPrivate(value, this.name_, true);\n        }\n        return this;\n      },\n      delete: function(value) {\n        if (!isObject(value))\n          return false;\n        if (!isExtensible(value)) {\n          return deleteFrozen(this.frozenData_, value);\n        }\n        return deletePrivate(value, this.name_);\n      },\n      has: function(value) {\n        if (!isObject(value))\n          return false;\n        if (!isExtensible(value)) {\n          return getFrozen(this.frozenData_, value) === value;\n        }\n        return hasPrivate(value, this.name_);\n      }\n    }, {});\n  }();\n  function needsPolyfill(global) {\n    var $__4 = global,\n        WeakSet = $__4.WeakSet,\n        Symbol = $__4.Symbol;\n    if (!WeakSet || !hasNativeSymbol()) {\n      return true;\n    }\n    try {\n      var o = {};\n      var wm = new WeakSet([[o]]);\n      return !wm.has(o);\n    } catch (e) {\n      return false;\n    }\n  }\n  function polyfillWeakSet(global) {\n    if (needsPolyfill(global)) {\n      global.WeakSet = WeakSet;\n    }\n  }\n  registerPolyfill(polyfillWeakSet);\n  return {\n    get WeakSet() {\n      return WeakSet;\n    },\n    get polyfillWeakSet() {\n      return polyfillWeakSet;\n    }\n  };\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/polyfills/WeakSet.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/src/runtime/polyfills/polyfills.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/runtime/polyfills/polyfills.js";\n  var polyfillAll = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur@0.0.111/src/runtime/polyfills/polyfills.js")).polyfillAll;\n  polyfillAll(Reflect.global);\n  var setupGlobals = $traceurRuntime.setupGlobals;\n  $traceurRuntime.setupGlobals = function(global) {\n    setupGlobals(global);\n    polyfillAll(global);\n  };\n  return {};\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/runtime/polyfills/polyfills.js" + \'\');\n$traceurRuntime.registerModule("traceur@0.0.111/src/util/SourceRange.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util/SourceRange.js";\n  var SourceRange = function() {\n    function SourceRange(start, end) {\n      this.start = start;\n      this.end = end;\n    }\n    return ($traceurRuntime.createClass)(SourceRange, {toString: function() {\n        var str = this.start.source.contents;\n        return str.slice(this.start.offset, this.end.offset);\n      }}, {});\n  }();\n  return {get SourceRange() {\n      return SourceRange;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/util/ErrorReporter.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util/ErrorReporter.js";\n  var SourceRange = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SourceRange.js", "traceur@0.0.111/src/util/ErrorReporter.js")).SourceRange;\n  var ErrorReporter = function() {\n    function ErrorReporter() {\n      this.hadError_ = false;\n    }\n    return ($traceurRuntime.createClass)(ErrorReporter, {\n      reportError: function(location, message) {\n        this.hadError_ = true;\n        this.reportMessageInternal(location, message);\n      },\n      reportMessageInternal: function(location, message) {\n        if (location)\n          message = (location.start + ": " + message);\n        console.error(message);\n      },\n      hadError: function() {\n        return this.hadError_;\n      },\n      clearError: function() {\n        this.hadError_ = false;\n      }\n    }, {});\n  }();\n  function format(location, text) {\n    var args = arguments[2];\n    var i = 0;\n    text = text.replace(/%./g, function(s) {\n      switch (s) {\n        case \'%s\':\n          return args && args[i++];\n        case \'%%\':\n          return \'%\';\n      }\n      return s;\n    });\n    if (location)\n      text = (location + ": " + text);\n    return text;\n  }\n  ;\n  ErrorReporter.format = format;\n  return {\n    get ErrorReporter() {\n      return ErrorReporter;\n    },\n    get format() {\n      return format;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/util/MutedErrorReporter.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util/MutedErrorReporter.js";\n  var ErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ErrorReporter.js", "traceur@0.0.111/src/util/MutedErrorReporter.js")).ErrorReporter;\n  var MutedErrorReporter = function($__super) {\n    function MutedErrorReporter() {\n      $traceurRuntime.superConstructor(MutedErrorReporter).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(MutedErrorReporter, {reportMessageInternal: function(location, format, args) {}}, {}, $__super);\n  }(ErrorReporter);\n  return {get MutedErrorReporter() {\n      return MutedErrorReporter;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/Options.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/Options.js";\n  function enumerableOnlyObject(obj) {\n    var result = Object.create(null);\n    Object.keys(obj).forEach(function(key) {\n      Object.defineProperty(result, key, {\n        enumerable: true,\n        value: obj[key]\n      });\n    });\n    return result;\n  }\n  var optionsV01 = enumerableOnlyObject({\n    annotations: false,\n    arrayComprehension: false,\n    arrowFunctions: true,\n    asyncFunctions: false,\n    asyncGenerators: false,\n    blockBinding: true,\n    classes: true,\n    commentCallback: false,\n    computedPropertyNames: true,\n    debug: false,\n    debugNames: false,\n    defaultParameters: true,\n    destructuring: true,\n    exponentiation: false,\n    exportFromExtended: false,\n    forOf: true,\n    forOn: false,\n    freeVariableChecker: false,\n    generatorComprehension: false,\n    generators: true,\n    importRuntime: false,\n    inputSourceMap: false,\n    jsx: false,\n    lowResolutionSourceMap: false,\n    memberVariables: false,\n    moduleName: \'default\',\n    modules: \'bootstrap\',\n    numericLiterals: true,\n    outputLanguage: \'es5\',\n    properTailCalls: false,\n    propertyMethods: true,\n    propertyNameShorthand: true,\n    referrer: \'\',\n    require: false,\n    restParameters: true,\n    script: false,\n    sourceMaps: false,\n    sourceRoot: false,\n    spread: true,\n    spreadProperties: false,\n    symbols: true,\n    templateLiterals: true,\n    types: false,\n    unicodeEscapeSequences: true,\n    unicodeExpressions: true,\n    validate: false\n  });\n  var versionLockedOptions = optionsV01;\n  var defaultValues = Object.create(null);\n  var featureOptions = Object.create(null);\n  var experimentalOptions = Object.create(null);\n  var moduleOptions = [\'amd\', \'commonjs\', \'closure\', \'instantiate\', \'inline\', \'bootstrap\', \'parse\'];\n  var EXPERIMENTAL = 0;\n  var ON_BY_DEFAULT = 1;\n  function addFeatureOption(name, kind) {\n    featureOptions[name] = true;\n    if (kind === EXPERIMENTAL)\n      experimentalOptions[name] = true;\n    var defaultValue = kind === ON_BY_DEFAULT;\n    defaultValues[name] = defaultValue;\n  }\n  function addBoolOption(name) {\n    defaultValues[name] = false;\n  }\n  addFeatureOption(\'arrowFunctions\', ON_BY_DEFAULT);\n  addFeatureOption(\'blockBinding\', ON_BY_DEFAULT);\n  addFeatureOption(\'classes\', ON_BY_DEFAULT);\n  addFeatureOption(\'computedPropertyNames\', ON_BY_DEFAULT);\n  addFeatureOption(\'defaultParameters\', ON_BY_DEFAULT);\n  addFeatureOption(\'destructuring\', ON_BY_DEFAULT);\n  addFeatureOption(\'forOf\', ON_BY_DEFAULT);\n  addFeatureOption(\'generators\', ON_BY_DEFAULT);\n  addFeatureOption(\'modules\', \'SPECIAL\');\n  addFeatureOption(\'numericLiterals\', ON_BY_DEFAULT);\n  addFeatureOption(\'propertyMethods\', ON_BY_DEFAULT);\n  addFeatureOption(\'propertyNameShorthand\', ON_BY_DEFAULT);\n  addFeatureOption(\'restParameters\', ON_BY_DEFAULT);\n  addFeatureOption(\'sourceMaps\', \'SPECIAL\');\n  addFeatureOption(\'spread\', ON_BY_DEFAULT);\n  addFeatureOption(\'symbols\', ON_BY_DEFAULT);\n  addFeatureOption(\'templateLiterals\', ON_BY_DEFAULT);\n  addFeatureOption(\'unicodeEscapeSequences\', ON_BY_DEFAULT);\n  addFeatureOption(\'unicodeExpressions\', ON_BY_DEFAULT);\n  addFeatureOption(\'properTailCalls\', EXPERIMENTAL);\n  addFeatureOption(\'annotations\', EXPERIMENTAL);\n  addFeatureOption(\'arrayComprehension\', EXPERIMENTAL);\n  addFeatureOption(\'asyncFunctions\', EXPERIMENTAL);\n  addFeatureOption(\'asyncGenerators\', EXPERIMENTAL);\n  addFeatureOption(\'exponentiation\', EXPERIMENTAL);\n  addFeatureOption(\'exportFromExtended\', EXPERIMENTAL);\n  addFeatureOption(\'forOn\', EXPERIMENTAL);\n  addFeatureOption(\'generatorComprehension\', EXPERIMENTAL);\n  addFeatureOption(\'importRuntime\', EXPERIMENTAL);\n  addFeatureOption(\'jsx\', EXPERIMENTAL);\n  addFeatureOption(\'memberVariables\', EXPERIMENTAL);\n  addFeatureOption(\'require\', EXPERIMENTAL);\n  addFeatureOption(\'spreadProperties\', EXPERIMENTAL);\n  addFeatureOption(\'types\', EXPERIMENTAL);\n  var transformOptionsPrototype = {};\n  Object.keys(featureOptions).forEach(function(name) {\n    Object.defineProperty(transformOptionsPrototype, name, {\n      get: function() {\n        var v = this.proxiedOptions_[name];\n        if (v === \'parse\')\n          return false;\n        return v;\n      },\n      enumerable: true\n    });\n  });\n  var parseOptionsPrototype = {};\n  Object.keys(featureOptions).forEach(function(name) {\n    Object.defineProperty(parseOptionsPrototype, name, {\n      get: function() {\n        return !!this.proxiedOptions_[name];\n      },\n      enumerable: true\n    });\n  });\n  addBoolOption(\'commentCallback\');\n  addBoolOption(\'debug\');\n  addBoolOption(\'debugNames\');\n  addBoolOption(\'freeVariableChecker\');\n  addBoolOption(\'script\');\n  addBoolOption(\'validate\');\n  var Options = function() {\n    function Options() {\n      var options = arguments[0] !== (void 0) ? arguments[0] : Object.create(null);\n      this.reset();\n      Object.defineProperties(this, {\n        modules_: {\n          value: versionLockedOptions.modules,\n          writable: true,\n          enumerable: false\n        },\n        sourceMaps_: {\n          value: versionLockedOptions.sourceMaps,\n          writable: true,\n          enumerable: false\n        },\n        sourceRoot_: {\n          value: versionLockedOptions.sourceRoot,\n          writable: true,\n          enumerable: false\n        },\n        transformOptions: {\n          value: Object.create(transformOptionsPrototype, {proxiedOptions_: {\n              value: this,\n              enumerable: false\n            }}),\n          enumerable: false\n        },\n        parseOptions: {\n          value: Object.create(parseOptionsPrototype, {proxiedOptions_: {\n              value: this,\n              enumerable: false\n            }}),\n          enumerable: false\n        }\n      });\n      this.setFromObject(options);\n    }\n    return ($traceurRuntime.createClass)(Options, {\n      set experimental(v) {\n        var $__2 = this;\n        v = coerceOptionValue(v);\n        Object.keys(experimentalOptions).forEach(function(name) {\n          $__2[name] = v;\n        });\n      },\n      get experimental() {\n        var $__2 = this;\n        var value;\n        Object.keys(experimentalOptions).every(function(name) {\n          var currentValue = $__2[name];\n          if (value === undefined) {\n            value = currentValue;\n            return true;\n          }\n          if (currentValue !== value) {\n            value = null;\n            return false;\n          }\n          return true;\n        });\n        return value;\n      },\n      get atscript() {\n        return this.types && this.annotations && this.memberVariables;\n      },\n      set atscript(value) {\n        this.types = value;\n        this.annotations = value;\n        this.memberVariables = value;\n      },\n      get modules() {\n        return this.modules_;\n      },\n      set modules(value) {\n        if (typeof value === \'boolean\' && !value)\n          value = \'bootstrap\';\n        if (moduleOptions.indexOf(value) === -1) {\n          throw new Error(\'Invalid \\\'modules\\\' option \\\'\' + value + \'\\\', not in \' + moduleOptions.join(\', \'));\n        }\n        this.modules_ = value;\n      },\n      get sourceMaps() {\n        return this.sourceMaps_;\n      },\n      set sourceMaps(value) {\n        if (value === null || typeof value === \'boolean\') {\n          this.sourceMaps_ = value ? \'file\' : false;\n          return;\n        }\n        if (value === \'file\' || value === \'inline\' || value === \'memory\') {\n          this.sourceMaps_ = value;\n        } else {\n          throw new Error(\'Option sourceMaps should be \' + \'[false|inline|file|memory], not \' + value);\n        }\n      },\n      reset: function() {\n        var allOff = arguments[0];\n        var $__2 = this;\n        var useDefault = allOff === undefined;\n        Object.keys(defaultValues).forEach(function(name) {\n          $__2[name] = useDefault && defaultValues[name];\n        });\n        this.setDefaults();\n      },\n      setDefaults: function() {\n        this.modules = \'bootstrap\';\n        this.moduleName = \'default\';\n        this.outputLanguage = \'es5\';\n        this.referrer = \'\';\n        this.sourceMaps = false;\n        this.sourceRoot = false;\n        this.lowResolutionSourceMap = false;\n        this.inputSourceMap = false;\n      },\n      setFromObject: function(object) {\n        var $__2 = this;\n        Object.keys(this).forEach(function(name) {\n          if (name in object)\n            $__2.setOption(name, object[name]);\n        });\n        this.modules = object.modules || this.modules;\n        if (typeof object.sourceMaps === \'boolean\' || typeof object.sourceMaps === \'string\') {\n          this.sourceMaps = object.sourceMaps;\n        }\n        if (object.sourceRoot !== undefined)\n          this.sourceRoot = object.sourceRoot;\n        return this;\n      },\n      setOption: function(name, value) {\n        name = toCamelCase(name);\n        if (name in this) {\n          this[name] = value;\n        } else {\n          throw Error(\'Unknown option: \' + name);\n        }\n      },\n      diff: function(ref) {\n        var $__2 = this;\n        var mismatches = [];\n        Object.keys(this).forEach(function(key) {\n          if ($__2[key] !== ref[key]) {\n            mismatches.push({\n              key: key,\n              now: $traceurRuntime.options[key],\n              v01: ref[key]\n            });\n          }\n        });\n        return mismatches;\n      }\n    }, {\n      experimental: function() {\n        return new Options(experimentalOptions);\n      },\n      atscript: function() {\n        return new Options({\n          types: true,\n          annotations: true,\n          memberVariables: true\n        });\n      },\n      listUnknownOptions: function(obj) {\n        var unknowns = [];\n        Object.keys(obj).forEach(function(propName) {\n          if (!(propName in optionsV01)) {\n            unknowns.push(propName);\n          }\n        });\n        return unknowns;\n      }\n    });\n  }();\n  ;\n  var descriptions = {\n    experimental: \'Turns on all experimental features\',\n    require: \'Generate require function argument for node when modules=register\',\n    sourceMaps: \'Generate source map and (\\\'file\\\') write to .map\' + \' or (\\\'inline\\\') append data URL\'\n  };\n  var CommandOptions = function($__super) {\n    function CommandOptions() {\n      $traceurRuntime.superConstructor(CommandOptions).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(CommandOptions, {\n      parseCommand: function(s) {\n        var re = /--([^=]+)(?:=(.+))?/;\n        var m = re.exec(s);\n        if (m)\n          this.setOptionCoerced(m[1], m[2]);\n      },\n      setOptionCoerced: function(name, value) {\n        if (typeof value !== \'undefined\' && value !== null)\n          value = coerceOptionValue(value);\n        else\n          value = true;\n        this.setOption(name, value);\n      }\n    }, {\n      fromString: function(s) {\n        return CommandOptions.fromArgv(s.split(/\\s+/));\n      },\n      fromArgv: function(args) {\n        var options = new CommandOptions();\n        args.forEach(function(arg) {\n          return options.parseCommand(arg);\n        });\n        return options;\n      }\n    }, $__super);\n  }(Options);\n  function coerceOptionValue(v) {\n    switch (v) {\n      case \'false\':\n        return false;\n      case \'true\':\n      case true:\n        return true;\n      default:\n        return !!v && String(v);\n    }\n  }\n  function toCamelCase(s) {\n    return s.replace(/-\\w/g, function(ch) {\n      return ch[1].toUpperCase();\n    });\n  }\n  function toDashCase(s) {\n    return s.replace(/[A-Z]/g, function(ch) {\n      return \'-\' + ch.toLowerCase();\n    });\n  }\n  function addOptions(flags, commandOptions) {\n    flags.option(\'--referrer <name>\', \'Bracket output code with System.referrerName=<name>\', function(name) {\n      commandOptions.setOption(\'referrer\', name);\n      System.map = System.semverMap(name);\n      return name;\n    });\n    flags.option(\'--modules <\' + moduleOptions.join(\', \') + \'>\', \'select the output format for modules\', function(moduleFormat) {\n      commandOptions.modules = moduleFormat;\n    });\n    flags.option(\'--moduleName [true|false|default]\', \'true for named, false for anonymous modules; default depends on --modules\', function(moduleName) {\n      if (moduleName === \'true\')\n        moduleName = true;\n      else if (moduleName === \'false\')\n        moduleName = false;\n      else\n        moduleName = \'default\';\n      commandOptions.moduleName = moduleName;\n    });\n    flags.option(\'--outputLanguage <es6|es5>\', \'compilation target language\', function(outputLanguage) {\n      if (outputLanguage === \'es6\' || outputLanguage === \'es5\')\n        commandOptions.outputLanguage = outputLanguage;\n      else\n        throw new Error(\'outputLanguage must be one of es5, es6\');\n    });\n    flags.option(\'--source-maps [file|inline|memory]\', \'sourceMaps generated to file or inline with data: URL\', function(to) {\n      return commandOptions.sourceMaps = to;\n    });\n    flags.option(\'--source-root <true|false|string>\', \'sourcemap sourceRoot value. false to omit, \' + \'true for directory of output file.\', function(to) {\n      if (to === \'false\')\n        to = false;\n      else if (to === \'true\')\n        to = true;\n      return commandOptions.sourceRoot = to;\n    });\n    flags.option(\'--low-resolution-source-maps\', \'Lower sourceMaps granularity to one mapping per output line\', function() {\n      return commandOptions.lowResolutionSourceMap = true;\n    });\n    flags.option(\'--experimental\', \'Turns on all experimental features\', function() {\n      commandOptions.experimental = true;\n    });\n    flags.option(\'--atscript\', \'Turns on all AtScript features\', function() {\n      commandOptions.atscript = true;\n    });\n    Object.keys(commandOptions).forEach(function(name) {\n      var dashedName = toDashCase(name);\n      if (flags.optionFor(\'--\' + name) || flags.optionFor(\'--\' + dashedName)) {\n        return;\n      } else if (name in featureOptions) {\n        flags.option(\'--\' + dashedName + \' [true|false|parse]\', descriptions[name]);\n        flags.on(dashedName, function(value) {\n          return commandOptions.setOptionCoerced(dashedName, value);\n        });\n      } else if (commandOptions[name] !== null) {\n        flags.option(\'--\' + dashedName, descriptions[name]);\n        flags.on(dashedName, function() {\n          return commandOptions.setOption(dashedName, true);\n        });\n      } else {\n        throw new Error(\'Unexpected null commandOption \' + name);\n      }\n    });\n    commandOptions.setDefaults();\n  }\n  return {\n    get optionsV01() {\n      return optionsV01;\n    },\n    get versionLockedOptions() {\n      return versionLockedOptions;\n    },\n    get Options() {\n      return Options;\n    },\n    get CommandOptions() {\n      return CommandOptions;\n    },\n    get toDashCase() {\n      return toDashCase;\n    },\n    get addOptions() {\n      return addOptions;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/loader/webLoader.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/loader/webLoader.js";\n  var webLoader = {load: function(url, callback, errback) {\n      var xhr = new XMLHttpRequest();\n      xhr.onload = function() {\n        if (xhr.status == 200 || xhr.status == 0) {\n          callback(xhr.responseText);\n        } else {\n          var err;\n          if (xhr.status === 404)\n            err = \'File not found \\\'\' + url + \'\\\'\';\n          else\n            err = xhr.status + xhr.statusText;\n          errback(err);\n        }\n        xhr = null;\n      };\n      xhr.onerror = function(err) {\n        errback(err);\n      };\n      xhr.open(\'GET\', url, true);\n      xhr.send();\n      return function() {\n        xhr && xhr.abort();\n      };\n    }};\n  return {get webLoader() {\n      return webLoader;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/WebPageTranscoder.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/WebPageTranscoder.js";\n  var ErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./util/ErrorReporter.js", "traceur@0.0.111/src/WebPageTranscoder.js")).ErrorReporter;\n  var CommandOptions = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Options.js", "traceur@0.0.111/src/WebPageTranscoder.js")).CommandOptions;\n  var webLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./loader/webLoader.js", "traceur@0.0.111/src/WebPageTranscoder.js")).webLoader;\n  var scriptSelector = \'script[type="module"],script[type="text/traceur"]\';\n  var WebPageTranscoder = function() {\n    function WebPageTranscoder() {\n      var url = arguments[0] !== (void 0) ? arguments[0] : document.location.href;\n      var traceurOptions = arguments[1] !== (void 0) ? arguments[1] : new Options();\n      this.url = url;\n      this.numPending_ = 0;\n      this.numberInlined_ = 0;\n      this.traceurOptions_ = traceurOptions;\n    }\n    return ($traceurRuntime.createClass)(WebPageTranscoder, {\n      asyncLoad_: function(url, fncOfContent, onScriptsReady) {\n        var $__3 = this;\n        this.numPending_++;\n        webLoader.load(url, function(content) {\n          if (content)\n            fncOfContent(content);\n          else\n            console.warn(\'Failed to load\', url);\n          if (--$__3.numPending_ <= 0)\n            onScriptsReady();\n        }, function(error) {\n          console.error(\'WebPageTranscoder FAILED to load \' + url, error.stack || error);\n        });\n      },\n      addFileFromScriptElement: function(scriptElement, name, content) {\n        var options = this.traceurOptions_;\n        var elementOptionString = scriptElement.getAttribute(\'traceurOptions\');\n        if (elementOptionString) {\n          options = CommandOptions.fromString(elementOptionString);\n        }\n        var nameInfo = {\n          address: name,\n          referrerName: window.location.href,\n          name: name,\n          metadata: {traceurOptions: options}\n        };\n        var loadingResult;\n        if (scriptElement.type === \'module\')\n          loadingResult = System.module(content, nameInfo);\n        else\n          loadingResult = System.script(content, nameInfo);\n        loadingResult.catch(function(error) {\n          console.error(error.stack || error);\n        });\n      },\n      nextInlineScriptName_: function() {\n        this.numberInlined_ += 1;\n        if (!this.inlineScriptNameBase_) {\n          var segments = this.url.split(\'.\');\n          segments.pop();\n          this.inlineScriptNameBase_ = segments.join(\'.\');\n        }\n        return this.inlineScriptNameBase_ + \'_inline_script_\' + this.numberInlined_ + \'.js\';\n      },\n      addFilesFromScriptElements: function(scriptElements, onScriptsReady) {\n        for (var i = 0,\n            length = scriptElements.length; i < length; i++) {\n          var scriptElement = scriptElements[i];\n          if (!scriptElement.src) {\n            var name = this.nextInlineScriptName_();\n            var content = scriptElement.textContent;\n            this.addFileFromScriptElement(scriptElement, name, content);\n          } else {\n            var name$__4 = scriptElement.src;\n            this.asyncLoad_(name$__4, this.addFileFromScriptElement.bind(this, scriptElement, name$__4), onScriptsReady);\n          }\n        }\n        if (this.numPending_ <= 0)\n          onScriptsReady();\n      },\n      get reporter() {\n        if (!this.reporter_) {\n          this.reporter_ = new ErrorReporter();\n        }\n        return this.reporter_;\n      },\n      putFile: function(file) {\n        var scriptElement = document.createElement(\'script\');\n        scriptElement.setAttribute(\'data-traceur-src-url\', file.name);\n        scriptElement.textContent = file.generatedSource;\n        var parent = file.scriptElement.parentNode;\n        parent.insertBefore(scriptElement, file.scriptElement || null);\n      },\n      selectAndProcessScripts: function(done) {\n        var selector = scriptSelector;\n        var scripts = document.querySelectorAll(selector);\n        if (!scripts.length) {\n          done();\n          return;\n        }\n        this.addFilesFromScriptElements(scripts, function() {\n          done();\n        });\n      },\n      run: function() {\n        var done = arguments[0] !== (void 0) ? arguments[0] : function() {};\n        var $__3 = this;\n        var ready = document.readyState;\n        if (ready === \'complete\' || ready === \'loaded\') {\n          this.selectAndProcessScripts(done);\n        } else {\n          document.addEventListener(\'DOMContentLoaded\', function() {\n            return $__3.selectAndProcessScripts(done);\n          }, false);\n        }\n      }\n    }, {});\n  }();\n  return {\n    get scriptSelector() {\n      return scriptSelector;\n    },\n    get WebPageTranscoder() {\n      return WebPageTranscoder;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/util/StringSet.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util/StringSet.js";\n  function assertString(value) {\n    if (typeof value !== \'string\')\n      throw new TypeError();\n  }\n  var StringSet = function() {\n    function StringSet() {\n      this.storage_ = Object.create(null);\n    }\n    return ($traceurRuntime.createClass)(StringSet, {\n      add: function(value) {\n        assertString(value);\n        this.storage_[value] = true;\n      },\n      has: function(value) {\n        assertString(value);\n        return this.storage_[value] !== undefined;\n      },\n      delete: function(value) {\n        assertString(value);\n        delete this.storage_[value];\n      },\n      isEmpty: function() {\n        for (var _ in this.storage_) {\n          return false;\n        }\n        return true;\n      },\n      valuesAsArray: function() {\n        return Object.keys(this.storage_);\n      },\n      forEach: function(func) {\n        for (var value in this.storage_) {\n          func(value);\n        }\n      }\n    }, {});\n  }();\n  return {get StringSet() {\n      return StringSet;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/util/StringMap.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util/StringMap.js";\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./StringSet.js", "traceur@0.0.111/src/util/StringMap.js")).StringSet;\n  function assertString(value) {\n    if (typeof value !== \'string\')\n      throw new TypeError();\n  }\n  var StringMap = function() {\n    function StringMap() {\n      this.storage_ = Object.create(null);\n    }\n    return ($traceurRuntime.createClass)(StringMap, {\n      set: function(key, value) {\n        assertString(key);\n        this.storage_[key] = value;\n      },\n      get: function(key) {\n        assertString(key);\n        return this.storage_[key];\n      },\n      delete: function(key) {\n        assertString(key);\n        delete this.storage_[key];\n      },\n      has: function(key) {\n        assertString(key);\n        return this.storage_[key] !== undefined;\n      },\n      keysAsArray: function() {\n        return Object.keys(this.storage_);\n      },\n      keysAsSet: function() {\n        var set = new StringSet();\n        this.forEach(function(key) {\n          return set.add(key);\n        });\n        return set;\n      },\n      forEach: function(func) {\n        for (var key in this.storage_) {\n          func(key, this.storage_[key]);\n        }\n      }\n    }, {});\n  }();\n  return {get StringMap() {\n      return StringMap;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/HTMLImportTranscoder.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/HTMLImportTranscoder.js";\n  var StringMap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./util/StringMap.js", "traceur@0.0.111/src/HTMLImportTranscoder.js")).StringMap;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WebPageTranscoder.js", "traceur@0.0.111/src/HTMLImportTranscoder.js")),\n      WebPageTranscoder = $__4.WebPageTranscoder,\n      scriptSelector = $__4.scriptSelector;\n  var importSelector = \'link[rel=import][href]\';\n  var HTMLImportTranscoder = function() {\n    function HTMLImportTranscoder() {\n      this.importsToProcess_ = [];\n    }\n    return ($traceurRuntime.createClass)(HTMLImportTranscoder, {\n      findAllChildrenHTMLImports_: function(parentImportNodes) {\n        var foundImportNodes = [];\n        for (var parentIndex = 0; parentIndex < parentImportNodes.length; parentIndex++) {\n          var parentLink = parentImportNodes[parentIndex];\n          var childImportNodes = parentLink.import.querySelectorAll(importSelector);\n          if (childImportNodes.length > 0)\n            this.findAllChildrenHTMLImports_(childImportNodes);\n          this.importsToProcess_.push(parentLink);\n        }\n      },\n      filterHTMLImports_: function(importNodes) {\n        this.findAllChildrenHTMLImports_(importNodes);\n        var importsToParse = [];\n        var dupFilterMap = new StringMap();\n        for (var index = 0; index < this.importsToProcess_.length; index++) {\n          var processLink = this.importsToProcess_[index];\n          if (!dupFilterMap.has(processLink.href)) {\n            dupFilterMap.set(processLink.href, 0);\n            var scripts = processLink.import.querySelectorAll(scriptSelector);\n            if (scripts.length > 0)\n              importsToParse.push({\n                href: processLink.href,\n                scripts: scripts\n              });\n          }\n        }\n        this.importsToProcess_ = [];\n        return importsToParse;\n      },\n      selectAndProcessHTMLImports: function(importNodes, done) {\n        var importInfoList = this.filterHTMLImports_(importNodes);\n        if (importInfoList.length === 0)\n          done();\n        var processCount = importInfoList.length;\n        importInfoList.forEach(function(importInfo) {\n          var transcoder = new WebPageTranscoder(importInfo.href);\n          transcoder.addFilesFromScriptElements(importInfo.scripts, function() {\n            processCount--;\n            if (processCount === 0 && done)\n              done();\n          });\n        });\n      },\n      run: function() {\n        var done = arguments[0] !== (void 0) ? arguments[0] : function() {};\n        var $__2 = this;\n        var ready = document.readyState;\n        if (ready === \'complete\' || ready === \'loaded\') {\n          var importNodes = document.querySelectorAll(importSelector);\n          if (importNodes.length > 0)\n            this.selectAndProcessHTMLImports(importNodes, done);\n        } else {\n          document.addEventListener(\'HTMLImportsLoaded\', function(event) {\n            var importNodes = event.detail && event.detail.allImports ? event.detail.allImports : document.querySelectorAll(importSelector);\n            if (importNodes.length > 0)\n              $__2.selectAndProcessHTMLImports(importNodes, done);\n          });\n        }\n      }\n    }, {});\n  }();\n  return {get HTMLImportTranscoder() {\n      return HTMLImportTranscoder;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/util/CollectingErrorReporter.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util/CollectingErrorReporter.js";\n  var ErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/ErrorReporter.js", "traceur@0.0.111/src/util/CollectingErrorReporter.js")).ErrorReporter;\n  var MultipleErrors = function($__super) {\n    function MultipleErrors(errors) {\n      $traceurRuntime.superConstructor(MultipleErrors).call(this);\n      this.message = errors ? errors.join(\'\\n\') : \'\';\n      this.name = \'MultipleErrors\';\n      this.errors = errors;\n    }\n    return ($traceurRuntime.createClass)(MultipleErrors, {}, {}, $__super);\n  }(Error);\n  var CollectingErrorReporter = function($__super) {\n    function CollectingErrorReporter() {\n      $traceurRuntime.superConstructor(CollectingErrorReporter).call(this);\n      this.errors = [];\n    }\n    return ($traceurRuntime.createClass)(CollectingErrorReporter, {\n      reportMessageInternal: function(location, message) {\n        this.errors.push((location.start + ": " + message));\n      },\n      errorsAsString: function() {\n        return this.toError().message;\n      },\n      toError: function() {\n        return new MultipleErrors(this.errors);\n      }\n    }, {}, $__super);\n  }(ErrorReporter);\n  return {\n    get MultipleErrors() {\n      return MultipleErrors;\n    },\n    get CollectingErrorReporter() {\n      return CollectingErrorReporter;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/util-imports.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util-imports.js";\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./util/MutedErrorReporter.js", "traceur@0.0.111/src/util-imports.js"));\n  var $__traceur_64_0_46_0_46_111_47_src_47_WebPageTranscoder_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./WebPageTranscoder.js", "traceur@0.0.111/src/util-imports.js"));\n  var $__traceur_64_0_46_0_46_111_47_src_47_HTMLImportTranscoder_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./HTMLImportTranscoder.js", "traceur@0.0.111/src/util-imports.js"));\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Options.js", "traceur@0.0.111/src/util-imports.js")),\n      addOptions = $__1.addOptions,\n      CommandOptions = $__1.CommandOptions,\n      Options = $__1.Options;\n  var ErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./util/ErrorReporter.js", "traceur@0.0.111/src/util-imports.js")).ErrorReporter;\n  var CollectingErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./util/CollectingErrorReporter.js", "traceur@0.0.111/src/util-imports.js")).CollectingErrorReporter;\n  var util = {\n    addOptions: addOptions,\n    CommandOptions: CommandOptions,\n    CollectingErrorReporter: CollectingErrorReporter,\n    ErrorReporter: ErrorReporter,\n    Options: Options\n  };\n  return {\n    get WebPageTranscoder() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_WebPageTranscoder_46_js__.WebPageTranscoder;\n    },\n    get HTMLImportTranscoder() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_HTMLImportTranscoder_46_js__.HTMLImportTranscoder;\n    },\n    get util() {\n      return util;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/trees/ParseTreeType.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/trees/ParseTreeType.js";\n  var ANNOTATION = \'ANNOTATION\';\n  var ANON_BLOCK = \'ANON_BLOCK\';\n  var ARGUMENT_LIST = \'ARGUMENT_LIST\';\n  var ARRAY_COMPREHENSION = \'ARRAY_COMPREHENSION\';\n  var ARRAY_LITERAL = \'ARRAY_LITERAL\';\n  var ARRAY_PATTERN = \'ARRAY_PATTERN\';\n  var ARRAY_TYPE = \'ARRAY_TYPE\';\n  var ARROW_FUNCTION = \'ARROW_FUNCTION\';\n  var ASSIGNMENT_ELEMENT = \'ASSIGNMENT_ELEMENT\';\n  var AWAIT_EXPRESSION = \'AWAIT_EXPRESSION\';\n  var BINARY_EXPRESSION = \'BINARY_EXPRESSION\';\n  var BINDING_ELEMENT = \'BINDING_ELEMENT\';\n  var BINDING_IDENTIFIER = \'BINDING_IDENTIFIER\';\n  var BLOCK = \'BLOCK\';\n  var BREAK_STATEMENT = \'BREAK_STATEMENT\';\n  var CALL_EXPRESSION = \'CALL_EXPRESSION\';\n  var CALL_SIGNATURE = \'CALL_SIGNATURE\';\n  var CASE_CLAUSE = \'CASE_CLAUSE\';\n  var CATCH = \'CATCH\';\n  var CLASS_DECLARATION = \'CLASS_DECLARATION\';\n  var CLASS_EXPRESSION = \'CLASS_EXPRESSION\';\n  var COMMA_EXPRESSION = \'COMMA_EXPRESSION\';\n  var COMPREHENSION_FOR = \'COMPREHENSION_FOR\';\n  var COMPREHENSION_IF = \'COMPREHENSION_IF\';\n  var COMPUTED_PROPERTY_NAME = \'COMPUTED_PROPERTY_NAME\';\n  var CONDITIONAL_EXPRESSION = \'CONDITIONAL_EXPRESSION\';\n  var CONSTRUCT_SIGNATURE = \'CONSTRUCT_SIGNATURE\';\n  var CONSTRUCTOR_TYPE = \'CONSTRUCTOR_TYPE\';\n  var CONTINUE_STATEMENT = \'CONTINUE_STATEMENT\';\n  var COVER_FORMALS = \'COVER_FORMALS\';\n  var COVER_INITIALIZED_NAME = \'COVER_INITIALIZED_NAME\';\n  var DEBUGGER_STATEMENT = \'DEBUGGER_STATEMENT\';\n  var DEFAULT_CLAUSE = \'DEFAULT_CLAUSE\';\n  var DO_WHILE_STATEMENT = \'DO_WHILE_STATEMENT\';\n  var EMPTY_STATEMENT = \'EMPTY_STATEMENT\';\n  var EXPORT_DECLARATION = \'EXPORT_DECLARATION\';\n  var EXPORT_DEFAULT = \'EXPORT_DEFAULT\';\n  var EXPORT_SPECIFIER = \'EXPORT_SPECIFIER\';\n  var EXPORT_SPECIFIER_SET = \'EXPORT_SPECIFIER_SET\';\n  var EXPORT_STAR = \'EXPORT_STAR\';\n  var EXPRESSION_STATEMENT = \'EXPRESSION_STATEMENT\';\n  var FINALLY = \'FINALLY\';\n  var FOR_IN_STATEMENT = \'FOR_IN_STATEMENT\';\n  var FOR_OF_STATEMENT = \'FOR_OF_STATEMENT\';\n  var FOR_ON_STATEMENT = \'FOR_ON_STATEMENT\';\n  var FOR_STATEMENT = \'FOR_STATEMENT\';\n  var FORMAL_PARAMETER = \'FORMAL_PARAMETER\';\n  var FORMAL_PARAMETER_LIST = \'FORMAL_PARAMETER_LIST\';\n  var FORWARD_DEFAULT_EXPORT = \'FORWARD_DEFAULT_EXPORT\';\n  var FUNCTION_BODY = \'FUNCTION_BODY\';\n  var FUNCTION_DECLARATION = \'FUNCTION_DECLARATION\';\n  var FUNCTION_EXPRESSION = \'FUNCTION_EXPRESSION\';\n  var FUNCTION_TYPE = \'FUNCTION_TYPE\';\n  var GENERATOR_COMPREHENSION = \'GENERATOR_COMPREHENSION\';\n  var GET_ACCESSOR = \'GET_ACCESSOR\';\n  var IDENTIFIER_EXPRESSION = \'IDENTIFIER_EXPRESSION\';\n  var IF_STATEMENT = \'IF_STATEMENT\';\n  var IMPORT_CLAUSE_PAIR = \'IMPORT_CLAUSE_PAIR\';\n  var IMPORT_DECLARATION = \'IMPORT_DECLARATION\';\n  var IMPORT_SPECIFIER = \'IMPORT_SPECIFIER\';\n  var IMPORT_SPECIFIER_SET = \'IMPORT_SPECIFIER_SET\';\n  var IMPORT_TYPE_CLAUSE = \'IMPORT_TYPE_CLAUSE\';\n  var IMPORTED_BINDING = \'IMPORTED_BINDING\';\n  var INDEX_SIGNATURE = \'INDEX_SIGNATURE\';\n  var INTERFACE_DECLARATION = \'INTERFACE_DECLARATION\';\n  var JSX_ATTRIBUTE = \'JSX_ATTRIBUTE\';\n  var JSX_ELEMENT = \'JSX_ELEMENT\';\n  var JSX_ELEMENT_NAME = \'JSX_ELEMENT_NAME\';\n  var JSX_PLACEHOLDER = \'JSX_PLACEHOLDER\';\n  var JSX_SPREAD_ATTRIBUTE = \'JSX_SPREAD_ATTRIBUTE\';\n  var JSX_TEXT = \'JSX_TEXT\';\n  var LABELLED_STATEMENT = \'LABELLED_STATEMENT\';\n  var LITERAL_EXPRESSION = \'LITERAL_EXPRESSION\';\n  var LITERAL_PROPERTY_NAME = \'LITERAL_PROPERTY_NAME\';\n  var MEMBER_EXPRESSION = \'MEMBER_EXPRESSION\';\n  var MEMBER_LOOKUP_EXPRESSION = \'MEMBER_LOOKUP_EXPRESSION\';\n  var METHOD = \'METHOD\';\n  var METHOD_SIGNATURE = \'METHOD_SIGNATURE\';\n  var MODULE = \'MODULE\';\n  var MODULE_SPECIFIER = \'MODULE_SPECIFIER\';\n  var NAME_SPACE_EXPORT = \'NAME_SPACE_EXPORT\';\n  var NAME_SPACE_IMPORT = \'NAME_SPACE_IMPORT\';\n  var NAMED_EXPORT = \'NAMED_EXPORT\';\n  var NEW_EXPRESSION = \'NEW_EXPRESSION\';\n  var OBJECT_LITERAL = \'OBJECT_LITERAL\';\n  var OBJECT_PATTERN = \'OBJECT_PATTERN\';\n  var OBJECT_PATTERN_FIELD = \'OBJECT_PATTERN_FIELD\';\n  var OBJECT_TYPE = \'OBJECT_TYPE\';\n  var PAREN_EXPRESSION = \'PAREN_EXPRESSION\';\n  var POSTFIX_EXPRESSION = \'POSTFIX_EXPRESSION\';\n  var PREDEFINED_TYPE = \'PREDEFINED_TYPE\';\n  var PROPERTY_NAME_ASSIGNMENT = \'PROPERTY_NAME_ASSIGNMENT\';\n  var PROPERTY_NAME_SHORTHAND = \'PROPERTY_NAME_SHORTHAND\';\n  var PROPERTY_SIGNATURE = \'PROPERTY_SIGNATURE\';\n  var PROPERTY_VARIABLE_DECLARATION = \'PROPERTY_VARIABLE_DECLARATION\';\n  var REST_PARAMETER = \'REST_PARAMETER\';\n  var RETURN_STATEMENT = \'RETURN_STATEMENT\';\n  var SCRIPT = \'SCRIPT\';\n  var SET_ACCESSOR = \'SET_ACCESSOR\';\n  var SPREAD_EXPRESSION = \'SPREAD_EXPRESSION\';\n  var SPREAD_PATTERN_ELEMENT = \'SPREAD_PATTERN_ELEMENT\';\n  var STATE_MACHINE = \'STATE_MACHINE\';\n  var SUPER_EXPRESSION = \'SUPER_EXPRESSION\';\n  var SWITCH_STATEMENT = \'SWITCH_STATEMENT\';\n  var SYNTAX_ERROR_TREE = \'SYNTAX_ERROR_TREE\';\n  var TEMPLATE_LITERAL_EXPRESSION = \'TEMPLATE_LITERAL_EXPRESSION\';\n  var TEMPLATE_LITERAL_PORTION = \'TEMPLATE_LITERAL_PORTION\';\n  var TEMPLATE_SUBSTITUTION = \'TEMPLATE_SUBSTITUTION\';\n  var THIS_EXPRESSION = \'THIS_EXPRESSION\';\n  var THROW_STATEMENT = \'THROW_STATEMENT\';\n  var TRY_STATEMENT = \'TRY_STATEMENT\';\n  var TYPE_ALIAS_DECLARATION = \'TYPE_ALIAS_DECLARATION\';\n  var TYPE_ARGUMENTS = \'TYPE_ARGUMENTS\';\n  var TYPE_NAME = \'TYPE_NAME\';\n  var TYPE_PARAMETER = \'TYPE_PARAMETER\';\n  var TYPE_PARAMETERS = \'TYPE_PARAMETERS\';\n  var TYPE_REFERENCE = \'TYPE_REFERENCE\';\n  var UNARY_EXPRESSION = \'UNARY_EXPRESSION\';\n  var UNION_TYPE = \'UNION_TYPE\';\n  var VARIABLE_DECLARATION = \'VARIABLE_DECLARATION\';\n  var VARIABLE_DECLARATION_LIST = \'VARIABLE_DECLARATION_LIST\';\n  var VARIABLE_STATEMENT = \'VARIABLE_STATEMENT\';\n  var WHILE_STATEMENT = \'WHILE_STATEMENT\';\n  var WITH_STATEMENT = \'WITH_STATEMENT\';\n  var YIELD_EXPRESSION = \'YIELD_EXPRESSION\';\n  return {\n    get ANNOTATION() {\n      return ANNOTATION;\n    },\n    get ANON_BLOCK() {\n      return ANON_BLOCK;\n    },\n    get ARGUMENT_LIST() {\n      return ARGUMENT_LIST;\n    },\n    get ARRAY_COMPREHENSION() {\n      return ARRAY_COMPREHENSION;\n    },\n    get ARRAY_LITERAL() {\n      return ARRAY_LITERAL;\n    },\n    get ARRAY_PATTERN() {\n      return ARRAY_PATTERN;\n    },\n    get ARRAY_TYPE() {\n      return ARRAY_TYPE;\n    },\n    get ARROW_FUNCTION() {\n      return ARROW_FUNCTION;\n    },\n    get ASSIGNMENT_ELEMENT() {\n      return ASSIGNMENT_ELEMENT;\n    },\n    get AWAIT_EXPRESSION() {\n      return AWAIT_EXPRESSION;\n    },\n    get BINARY_EXPRESSION() {\n      return BINARY_EXPRESSION;\n    },\n    get BINDING_ELEMENT() {\n      return BINDING_ELEMENT;\n    },\n    get BINDING_IDENTIFIER() {\n      return BINDING_IDENTIFIER;\n    },\n    get BLOCK() {\n      return BLOCK;\n    },\n    get BREAK_STATEMENT() {\n      return BREAK_STATEMENT;\n    },\n    get CALL_EXPRESSION() {\n      return CALL_EXPRESSION;\n    },\n    get CALL_SIGNATURE() {\n      return CALL_SIGNATURE;\n    },\n    get CASE_CLAUSE() {\n      return CASE_CLAUSE;\n    },\n    get CATCH() {\n      return CATCH;\n    },\n    get CLASS_DECLARATION() {\n      return CLASS_DECLARATION;\n    },\n    get CLASS_EXPRESSION() {\n      return CLASS_EXPRESSION;\n    },\n    get COMMA_EXPRESSION() {\n      return COMMA_EXPRESSION;\n    },\n    get COMPREHENSION_FOR() {\n      return COMPREHENSION_FOR;\n    },\n    get COMPREHENSION_IF() {\n      return COMPREHENSION_IF;\n    },\n    get COMPUTED_PROPERTY_NAME() {\n      return COMPUTED_PROPERTY_NAME;\n    },\n    get CONDITIONAL_EXPRESSION() {\n      return CONDITIONAL_EXPRESSION;\n    },\n    get CONSTRUCT_SIGNATURE() {\n      return CONSTRUCT_SIGNATURE;\n    },\n    get CONSTRUCTOR_TYPE() {\n      return CONSTRUCTOR_TYPE;\n    },\n    get CONTINUE_STATEMENT() {\n      return CONTINUE_STATEMENT;\n    },\n    get COVER_FORMALS() {\n      return COVER_FORMALS;\n    },\n    get COVER_INITIALIZED_NAME() {\n      return COVER_INITIALIZED_NAME;\n    },\n    get DEBUGGER_STATEMENT() {\n      return DEBUGGER_STATEMENT;\n    },\n    get DEFAULT_CLAUSE() {\n      return DEFAULT_CLAUSE;\n    },\n    get DO_WHILE_STATEMENT() {\n      return DO_WHILE_STATEMENT;\n    },\n    get EMPTY_STATEMENT() {\n      return EMPTY_STATEMENT;\n    },\n    get EXPORT_DECLARATION() {\n      return EXPORT_DECLARATION;\n    },\n    get EXPORT_DEFAULT() {\n      return EXPORT_DEFAULT;\n    },\n    get EXPORT_SPECIFIER() {\n      return EXPORT_SPECIFIER;\n    },\n    get EXPORT_SPECIFIER_SET() {\n      return EXPORT_SPECIFIER_SET;\n    },\n    get EXPORT_STAR() {\n      return EXPORT_STAR;\n    },\n    get EXPRESSION_STATEMENT() {\n      return EXPRESSION_STATEMENT;\n    },\n    get FINALLY() {\n      return FINALLY;\n    },\n    get FOR_IN_STATEMENT() {\n      return FOR_IN_STATEMENT;\n    },\n    get FOR_OF_STATEMENT() {\n      return FOR_OF_STATEMENT;\n    },\n    get FOR_ON_STATEMENT() {\n      return FOR_ON_STATEMENT;\n    },\n    get FOR_STATEMENT() {\n      return FOR_STATEMENT;\n    },\n    get FORMAL_PARAMETER() {\n      return FORMAL_PARAMETER;\n    },\n    get FORMAL_PARAMETER_LIST() {\n      return FORMAL_PARAMETER_LIST;\n    },\n    get FORWARD_DEFAULT_EXPORT() {\n      return FORWARD_DEFAULT_EXPORT;\n    },\n    get FUNCTION_BODY() {\n      return FUNCTION_BODY;\n    },\n    get FUNCTION_DECLARATION() {\n      return FUNCTION_DECLARATION;\n    },\n    get FUNCTION_EXPRESSION() {\n      return FUNCTION_EXPRESSION;\n    },\n    get FUNCTION_TYPE() {\n      return FUNCTION_TYPE;\n    },\n    get GENERATOR_COMPREHENSION() {\n      return GENERATOR_COMPREHENSION;\n    },\n    get GET_ACCESSOR() {\n      return GET_ACCESSOR;\n    },\n    get IDENTIFIER_EXPRESSION() {\n      return IDENTIFIER_EXPRESSION;\n    },\n    get IF_STATEMENT() {\n      return IF_STATEMENT;\n    },\n    get IMPORT_CLAUSE_PAIR() {\n      return IMPORT_CLAUSE_PAIR;\n    },\n    get IMPORT_DECLARATION() {\n      return IMPORT_DECLARATION;\n    },\n    get IMPORT_SPECIFIER() {\n      return IMPORT_SPECIFIER;\n    },\n    get IMPORT_SPECIFIER_SET() {\n      return IMPORT_SPECIFIER_SET;\n    },\n    get IMPORT_TYPE_CLAUSE() {\n      return IMPORT_TYPE_CLAUSE;\n    },\n    get IMPORTED_BINDING() {\n      return IMPORTED_BINDING;\n    },\n    get INDEX_SIGNATURE() {\n      return INDEX_SIGNATURE;\n    },\n    get INTERFACE_DECLARATION() {\n      return INTERFACE_DECLARATION;\n    },\n    get JSX_ATTRIBUTE() {\n      return JSX_ATTRIBUTE;\n    },\n    get JSX_ELEMENT() {\n      return JSX_ELEMENT;\n    },\n    get JSX_ELEMENT_NAME() {\n      return JSX_ELEMENT_NAME;\n    },\n    get JSX_PLACEHOLDER() {\n      return JSX_PLACEHOLDER;\n    },\n    get JSX_SPREAD_ATTRIBUTE() {\n      return JSX_SPREAD_ATTRIBUTE;\n    },\n    get JSX_TEXT() {\n      return JSX_TEXT;\n    },\n    get LABELLED_STATEMENT() {\n      return LABELLED_STATEMENT;\n    },\n    get LITERAL_EXPRESSION() {\n      return LITERAL_EXPRESSION;\n    },\n    get LITERAL_PROPERTY_NAME() {\n      return LITERAL_PROPERTY_NAME;\n    },\n    get MEMBER_EXPRESSION() {\n      return MEMBER_EXPRESSION;\n    },\n    get MEMBER_LOOKUP_EXPRESSION() {\n      return MEMBER_LOOKUP_EXPRESSION;\n    },\n    get METHOD() {\n      return METHOD;\n    },\n    get METHOD_SIGNATURE() {\n      return METHOD_SIGNATURE;\n    },\n    get MODULE() {\n      return MODULE;\n    },\n    get MODULE_SPECIFIER() {\n      return MODULE_SPECIFIER;\n    },\n    get NAME_SPACE_EXPORT() {\n      return NAME_SPACE_EXPORT;\n    },\n    get NAME_SPACE_IMPORT() {\n      return NAME_SPACE_IMPORT;\n    },\n    get NAMED_EXPORT() {\n      return NAMED_EXPORT;\n    },\n    get NEW_EXPRESSION() {\n      return NEW_EXPRESSION;\n    },\n    get OBJECT_LITERAL() {\n      return OBJECT_LITERAL;\n    },\n    get OBJECT_PATTERN() {\n      return OBJECT_PATTERN;\n    },\n    get OBJECT_PATTERN_FIELD() {\n      return OBJECT_PATTERN_FIELD;\n    },\n    get OBJECT_TYPE() {\n      return OBJECT_TYPE;\n    },\n    get PAREN_EXPRESSION() {\n      return PAREN_EXPRESSION;\n    },\n    get POSTFIX_EXPRESSION() {\n      return POSTFIX_EXPRESSION;\n    },\n    get PREDEFINED_TYPE() {\n      return PREDEFINED_TYPE;\n    },\n    get PROPERTY_NAME_ASSIGNMENT() {\n      return PROPERTY_NAME_ASSIGNMENT;\n    },\n    get PROPERTY_NAME_SHORTHAND() {\n      return PROPERTY_NAME_SHORTHAND;\n    },\n    get PROPERTY_SIGNATURE() {\n      return PROPERTY_SIGNATURE;\n    },\n    get PROPERTY_VARIABLE_DECLARATION() {\n      return PROPERTY_VARIABLE_DECLARATION;\n    },\n    get REST_PARAMETER() {\n      return REST_PARAMETER;\n    },\n    get RETURN_STATEMENT() {\n      return RETURN_STATEMENT;\n    },\n    get SCRIPT() {\n      return SCRIPT;\n    },\n    get SET_ACCESSOR() {\n      return SET_ACCESSOR;\n    },\n    get SPREAD_EXPRESSION() {\n      return SPREAD_EXPRESSION;\n    },\n    get SPREAD_PATTERN_ELEMENT() {\n      return SPREAD_PATTERN_ELEMENT;\n    },\n    get STATE_MACHINE() {\n      return STATE_MACHINE;\n    },\n    get SUPER_EXPRESSION() {\n      return SUPER_EXPRESSION;\n    },\n    get SWITCH_STATEMENT() {\n      return SWITCH_STATEMENT;\n    },\n    get SYNTAX_ERROR_TREE() {\n      return SYNTAX_ERROR_TREE;\n    },\n    get TEMPLATE_LITERAL_EXPRESSION() {\n      return TEMPLATE_LITERAL_EXPRESSION;\n    },\n    get TEMPLATE_LITERAL_PORTION() {\n      return TEMPLATE_LITERAL_PORTION;\n    },\n    get TEMPLATE_SUBSTITUTION() {\n      return TEMPLATE_SUBSTITUTION;\n    },\n    get THIS_EXPRESSION() {\n      return THIS_EXPRESSION;\n    },\n    get THROW_STATEMENT() {\n      return THROW_STATEMENT;\n    },\n    get TRY_STATEMENT() {\n      return TRY_STATEMENT;\n    },\n    get TYPE_ALIAS_DECLARATION() {\n      return TYPE_ALIAS_DECLARATION;\n    },\n    get TYPE_ARGUMENTS() {\n      return TYPE_ARGUMENTS;\n    },\n    get TYPE_NAME() {\n      return TYPE_NAME;\n    },\n    get TYPE_PARAMETER() {\n      return TYPE_PARAMETER;\n    },\n    get TYPE_PARAMETERS() {\n      return TYPE_PARAMETERS;\n    },\n    get TYPE_REFERENCE() {\n      return TYPE_REFERENCE;\n    },\n    get UNARY_EXPRESSION() {\n      return UNARY_EXPRESSION;\n    },\n    get UNION_TYPE() {\n      return UNION_TYPE;\n    },\n    get VARIABLE_DECLARATION() {\n      return VARIABLE_DECLARATION;\n    },\n    get VARIABLE_DECLARATION_LIST() {\n      return VARIABLE_DECLARATION_LIST;\n    },\n    get VARIABLE_STATEMENT() {\n      return VARIABLE_STATEMENT;\n    },\n    get WHILE_STATEMENT() {\n      return WHILE_STATEMENT;\n    },\n    get WITH_STATEMENT() {\n      return WITH_STATEMENT;\n    },\n    get YIELD_EXPRESSION() {\n      return YIELD_EXPRESSION;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/TokenType.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/TokenType.js";\n  var AMPERSAND = \'&\';\n  var AMPERSAND_EQUAL = \'&=\';\n  var AND = \'&&\';\n  var ARROW = \'=>\';\n  var AT = \'@\';\n  var BACK_QUOTE = \'`\';\n  var BANG = \'!\';\n  var BAR = \'|\';\n  var BAR_EQUAL = \'|=\';\n  var BREAK = \'break\';\n  var CARET = \'^\';\n  var CARET_EQUAL = \'^=\';\n  var CASE = \'case\';\n  var CATCH = \'catch\';\n  var CLASS = \'class\';\n  var CLOSE_ANGLE = \'>\';\n  var CLOSE_CURLY = \'}\';\n  var CLOSE_PAREN = \')\';\n  var CLOSE_SQUARE = \']\';\n  var COLON = \':\';\n  var COMMA = \',\';\n  var CONST = \'const\';\n  var CONTINUE = \'continue\';\n  var DEBUGGER = \'debugger\';\n  var DEFAULT = \'default\';\n  var DELETE = \'delete\';\n  var DO = \'do\';\n  var DOT_DOT_DOT = \'...\';\n  var ELSE = \'else\';\n  var END_OF_FILE = \'End of File\';\n  var ENUM = \'enum\';\n  var EQUAL = \'=\';\n  var EQUAL_EQUAL = \'==\';\n  var EQUAL_EQUAL_EQUAL = \'===\';\n  var ERROR = \'error\';\n  var EXPORT = \'export\';\n  var EXTENDS = \'extends\';\n  var FALSE = \'false\';\n  var FINALLY = \'finally\';\n  var FOR = \'for\';\n  var FUNCTION = \'function\';\n  var GREATER_EQUAL = \'>=\';\n  var IDENTIFIER = \'identifier\';\n  var IF = \'if\';\n  var IMPLEMENTS = \'implements\';\n  var IMPORT = \'import\';\n  var IN = \'in\';\n  var INSTANCEOF = \'instanceof\';\n  var INTERFACE = \'interface\';\n  var JSX_IDENTIFIER = \'jsx identifier\';\n  var LEFT_SHIFT = \'<<\';\n  var LEFT_SHIFT_EQUAL = \'<<=\';\n  var LESS_EQUAL = \'<=\';\n  var LET = \'let\';\n  var MINUS = \'-\';\n  var MINUS_EQUAL = \'-=\';\n  var MINUS_MINUS = \'--\';\n  var NEW = \'new\';\n  var NO_SUBSTITUTION_TEMPLATE = \'no substitution template\';\n  var NOT_EQUAL = \'!=\';\n  var NOT_EQUAL_EQUAL = \'!==\';\n  var NULL = \'null\';\n  var NUMBER = \'number literal\';\n  var OPEN_ANGLE = \'<\';\n  var OPEN_CURLY = \'{\';\n  var OPEN_PAREN = \'(\';\n  var OPEN_SQUARE = \'[\';\n  var OR = \'||\';\n  var PACKAGE = \'package\';\n  var PERCENT = \'%\';\n  var PERCENT_EQUAL = \'%=\';\n  var PERIOD = \'.\';\n  var PLUS = \'+\';\n  var PLUS_EQUAL = \'+=\';\n  var PLUS_PLUS = \'++\';\n  var PRIVATE = \'private\';\n  var PROTECTED = \'protected\';\n  var PUBLIC = \'public\';\n  var QUESTION = \'?\';\n  var REGULAR_EXPRESSION = \'regular expression literal\';\n  var RETURN = \'return\';\n  var RIGHT_SHIFT = \'>>\';\n  var RIGHT_SHIFT_EQUAL = \'>>=\';\n  var SEMI_COLON = \';\';\n  var SLASH = \'/\';\n  var SLASH_EQUAL = \'/=\';\n  var STAR = \'*\';\n  var STAR_EQUAL = \'*=\';\n  var STAR_STAR = \'**\';\n  var STAR_STAR_EQUAL = \'**=\';\n  var STATIC = \'static\';\n  var STRING = \'string literal\';\n  var SUPER = \'super\';\n  var SWITCH = \'switch\';\n  var TEMPLATE_HEAD = \'template head\';\n  var TEMPLATE_MIDDLE = \'template middle\';\n  var TEMPLATE_TAIL = \'template tail\';\n  var THIS = \'this\';\n  var THROW = \'throw\';\n  var TILDE = \'~\';\n  var TRUE = \'true\';\n  var TRY = \'try\';\n  var TYPEOF = \'typeof\';\n  var UNSIGNED_RIGHT_SHIFT = \'>>>\';\n  var UNSIGNED_RIGHT_SHIFT_EQUAL = \'>>>=\';\n  var VAR = \'var\';\n  var VOID = \'void\';\n  var WHILE = \'while\';\n  var WITH = \'with\';\n  var YIELD = \'yield\';\n  return {\n    get AMPERSAND() {\n      return AMPERSAND;\n    },\n    get AMPERSAND_EQUAL() {\n      return AMPERSAND_EQUAL;\n    },\n    get AND() {\n      return AND;\n    },\n    get ARROW() {\n      return ARROW;\n    },\n    get AT() {\n      return AT;\n    },\n    get BACK_QUOTE() {\n      return BACK_QUOTE;\n    },\n    get BANG() {\n      return BANG;\n    },\n    get BAR() {\n      return BAR;\n    },\n    get BAR_EQUAL() {\n      return BAR_EQUAL;\n    },\n    get BREAK() {\n      return BREAK;\n    },\n    get CARET() {\n      return CARET;\n    },\n    get CARET_EQUAL() {\n      return CARET_EQUAL;\n    },\n    get CASE() {\n      return CASE;\n    },\n    get CATCH() {\n      return CATCH;\n    },\n    get CLASS() {\n      return CLASS;\n    },\n    get CLOSE_ANGLE() {\n      return CLOSE_ANGLE;\n    },\n    get CLOSE_CURLY() {\n      return CLOSE_CURLY;\n    },\n    get CLOSE_PAREN() {\n      return CLOSE_PAREN;\n    },\n    get CLOSE_SQUARE() {\n      return CLOSE_SQUARE;\n    },\n    get COLON() {\n      return COLON;\n    },\n    get COMMA() {\n      return COMMA;\n    },\n    get CONST() {\n      return CONST;\n    },\n    get CONTINUE() {\n      return CONTINUE;\n    },\n    get DEBUGGER() {\n      return DEBUGGER;\n    },\n    get DEFAULT() {\n      return DEFAULT;\n    },\n    get DELETE() {\n      return DELETE;\n    },\n    get DO() {\n      return DO;\n    },\n    get DOT_DOT_DOT() {\n      return DOT_DOT_DOT;\n    },\n    get ELSE() {\n      return ELSE;\n    },\n    get END_OF_FILE() {\n      return END_OF_FILE;\n    },\n    get ENUM() {\n      return ENUM;\n    },\n    get EQUAL() {\n      return EQUAL;\n    },\n    get EQUAL_EQUAL() {\n      return EQUAL_EQUAL;\n    },\n    get EQUAL_EQUAL_EQUAL() {\n      return EQUAL_EQUAL_EQUAL;\n    },\n    get ERROR() {\n      return ERROR;\n    },\n    get EXPORT() {\n      return EXPORT;\n    },\n    get EXTENDS() {\n      return EXTENDS;\n    },\n    get FALSE() {\n      return FALSE;\n    },\n    get FINALLY() {\n      return FINALLY;\n    },\n    get FOR() {\n      return FOR;\n    },\n    get FUNCTION() {\n      return FUNCTION;\n    },\n    get GREATER_EQUAL() {\n      return GREATER_EQUAL;\n    },\n    get IDENTIFIER() {\n      return IDENTIFIER;\n    },\n    get IF() {\n      return IF;\n    },\n    get IMPLEMENTS() {\n      return IMPLEMENTS;\n    },\n    get IMPORT() {\n      return IMPORT;\n    },\n    get IN() {\n      return IN;\n    },\n    get INSTANCEOF() {\n      return INSTANCEOF;\n    },\n    get INTERFACE() {\n      return INTERFACE;\n    },\n    get JSX_IDENTIFIER() {\n      return JSX_IDENTIFIER;\n    },\n    get LEFT_SHIFT() {\n      return LEFT_SHIFT;\n    },\n    get LEFT_SHIFT_EQUAL() {\n      return LEFT_SHIFT_EQUAL;\n    },\n    get LESS_EQUAL() {\n      return LESS_EQUAL;\n    },\n    get LET() {\n      return LET;\n    },\n    get MINUS() {\n      return MINUS;\n    },\n    get MINUS_EQUAL() {\n      return MINUS_EQUAL;\n    },\n    get MINUS_MINUS() {\n      return MINUS_MINUS;\n    },\n    get NEW() {\n      return NEW;\n    },\n    get NO_SUBSTITUTION_TEMPLATE() {\n      return NO_SUBSTITUTION_TEMPLATE;\n    },\n    get NOT_EQUAL() {\n      return NOT_EQUAL;\n    },\n    get NOT_EQUAL_EQUAL() {\n      return NOT_EQUAL_EQUAL;\n    },\n    get NULL() {\n      return NULL;\n    },\n    get NUMBER() {\n      return NUMBER;\n    },\n    get OPEN_ANGLE() {\n      return OPEN_ANGLE;\n    },\n    get OPEN_CURLY() {\n      return OPEN_CURLY;\n    },\n    get OPEN_PAREN() {\n      return OPEN_PAREN;\n    },\n    get OPEN_SQUARE() {\n      return OPEN_SQUARE;\n    },\n    get OR() {\n      return OR;\n    },\n    get PACKAGE() {\n      return PACKAGE;\n    },\n    get PERCENT() {\n      return PERCENT;\n    },\n    get PERCENT_EQUAL() {\n      return PERCENT_EQUAL;\n    },\n    get PERIOD() {\n      return PERIOD;\n    },\n    get PLUS() {\n      return PLUS;\n    },\n    get PLUS_EQUAL() {\n      return PLUS_EQUAL;\n    },\n    get PLUS_PLUS() {\n      return PLUS_PLUS;\n    },\n    get PRIVATE() {\n      return PRIVATE;\n    },\n    get PROTECTED() {\n      return PROTECTED;\n    },\n    get PUBLIC() {\n      return PUBLIC;\n    },\n    get QUESTION() {\n      return QUESTION;\n    },\n    get REGULAR_EXPRESSION() {\n      return REGULAR_EXPRESSION;\n    },\n    get RETURN() {\n      return RETURN;\n    },\n    get RIGHT_SHIFT() {\n      return RIGHT_SHIFT;\n    },\n    get RIGHT_SHIFT_EQUAL() {\n      return RIGHT_SHIFT_EQUAL;\n    },\n    get SEMI_COLON() {\n      return SEMI_COLON;\n    },\n    get SLASH() {\n      return SLASH;\n    },\n    get SLASH_EQUAL() {\n      return SLASH_EQUAL;\n    },\n    get STAR() {\n      return STAR;\n    },\n    get STAR_EQUAL() {\n      return STAR_EQUAL;\n    },\n    get STAR_STAR() {\n      return STAR_STAR;\n    },\n    get STAR_STAR_EQUAL() {\n      return STAR_STAR_EQUAL;\n    },\n    get STATIC() {\n      return STATIC;\n    },\n    get STRING() {\n      return STRING;\n    },\n    get SUPER() {\n      return SUPER;\n    },\n    get SWITCH() {\n      return SWITCH;\n    },\n    get TEMPLATE_HEAD() {\n      return TEMPLATE_HEAD;\n    },\n    get TEMPLATE_MIDDLE() {\n      return TEMPLATE_MIDDLE;\n    },\n    get TEMPLATE_TAIL() {\n      return TEMPLATE_TAIL;\n    },\n    get THIS() {\n      return THIS;\n    },\n    get THROW() {\n      return THROW;\n    },\n    get TILDE() {\n      return TILDE;\n    },\n    get TRUE() {\n      return TRUE;\n    },\n    get TRY() {\n      return TRY;\n    },\n    get TYPEOF() {\n      return TYPEOF;\n    },\n    get UNSIGNED_RIGHT_SHIFT() {\n      return UNSIGNED_RIGHT_SHIFT;\n    },\n    get UNSIGNED_RIGHT_SHIFT_EQUAL() {\n      return UNSIGNED_RIGHT_SHIFT_EQUAL;\n    },\n    get VAR() {\n      return VAR;\n    },\n    get VOID() {\n      return VOID;\n    },\n    get WHILE() {\n      return WHILE;\n    },\n    get WITH() {\n      return WITH;\n    },\n    get YIELD() {\n      return YIELD;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/Token.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/Token.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TokenType.js", "traceur@0.0.111/src/syntax/Token.js")),\n      AMPERSAND_EQUAL = $__1.AMPERSAND_EQUAL,\n      BAR_EQUAL = $__1.BAR_EQUAL,\n      CARET_EQUAL = $__1.CARET_EQUAL,\n      EQUAL = $__1.EQUAL,\n      LEFT_SHIFT_EQUAL = $__1.LEFT_SHIFT_EQUAL,\n      MINUS_EQUAL = $__1.MINUS_EQUAL,\n      PERCENT_EQUAL = $__1.PERCENT_EQUAL,\n      PLUS_EQUAL = $__1.PLUS_EQUAL,\n      RIGHT_SHIFT_EQUAL = $__1.RIGHT_SHIFT_EQUAL,\n      SLASH_EQUAL = $__1.SLASH_EQUAL,\n      STAR_EQUAL = $__1.STAR_EQUAL,\n      STAR_STAR_EQUAL = $__1.STAR_STAR_EQUAL,\n      UNSIGNED_RIGHT_SHIFT_EQUAL = $__1.UNSIGNED_RIGHT_SHIFT_EQUAL;\n  var Token = function() {\n    function Token(type, location) {\n      this.type = type;\n      this.location = location;\n    }\n    return ($traceurRuntime.createClass)(Token, {\n      toString: function() {\n        return this.type;\n      },\n      isAssignmentOperator: function() {\n        return isAssignmentOperator(this.type);\n      },\n      isKeyword: function() {\n        return false;\n      },\n      isStrictKeyword: function() {\n        return false;\n      }\n    }, {});\n  }();\n  function isAssignmentOperator(type) {\n    switch (type) {\n      case AMPERSAND_EQUAL:\n      case BAR_EQUAL:\n      case CARET_EQUAL:\n      case EQUAL:\n      case LEFT_SHIFT_EQUAL:\n      case MINUS_EQUAL:\n      case PERCENT_EQUAL:\n      case PLUS_EQUAL:\n      case RIGHT_SHIFT_EQUAL:\n      case SLASH_EQUAL:\n      case STAR_EQUAL:\n      case STAR_STAR_EQUAL:\n      case UNSIGNED_RIGHT_SHIFT_EQUAL:\n        return true;\n    }\n    return false;\n  }\n  return {\n    get Token() {\n      return Token;\n    },\n    get isAssignmentOperator() {\n      return isAssignmentOperator;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/util/JSON.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util/JSON.js";\n  function transform(v) {\n    var replacer = arguments[1] !== (void 0) ? arguments[1] : function(k, v) {\n      return v;\n    };\n    return transform_(replacer(\'\', v), replacer);\n  }\n  function transform_(v, replacer) {\n    var rv,\n        tv;\n    if (Array.isArray(v)) {\n      var len = v.length;\n      rv = Array(len);\n      for (var i = 0; i < len; i++) {\n        tv = transform_(replacer(String(i), v[i]), replacer);\n        rv[i] = tv === undefined ? null : tv;\n      }\n      return rv;\n    }\n    if (v instanceof Object) {\n      rv = {};\n      Object.keys(v).forEach(function(k) {\n        tv = transform_(replacer(k, v[k]), replacer);\n        if (tv !== undefined) {\n          rv[k] = tv;\n        }\n      });\n      return rv;\n    }\n    return v;\n  }\n  return {get transform() {\n      return transform;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/PredefinedName.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/PredefinedName.js";\n  var $ARGUMENTS = \'$arguments\';\n  var ANY = \'any\';\n  var APPLY = \'apply\';\n  var ARGUMENTS = \'arguments\';\n  var ARRAY = \'Array\';\n  var AS = \'as\';\n  var ASYNC = \'async\';\n  var ASYNC_STAR = \'async star\';\n  var AWAIT = \'await\';\n  var BIND = \'bind\';\n  var CALL = \'call\';\n  var CONFIGURABLE = \'configurable\';\n  var CONSTRUCTOR = \'constructor\';\n  var CREATE = \'create\';\n  var CURRENT = \'current\';\n  var DEFINE_PROPERTY = \'defineProperty\';\n  var ENUMERABLE = \'enumerable\';\n  var FREEZE = \'freeze\';\n  var FROM = \'from\';\n  var FUNCTION = \'Function\';\n  var GET = \'get\';\n  var HAS = \'has\';\n  var LENGTH = \'length\';\n  var MODULE = \'module\';\n  var NEW = \'new\';\n  var OBJECT = \'Object\';\n  var OBJECT_NAME = \'Object\';\n  var OF = \'of\';\n  var ON = \'on\';\n  var PREVENT_EXTENSIONS = \'preventExtensions\';\n  var PROTOTYPE = \'prototype\';\n  var PUSH = \'push\';\n  var SET = \'set\';\n  var SLICE = \'slice\';\n  var THIS = \'this\';\n  var TRACEUR_RUNTIME = \'$traceurRuntime\';\n  var TYPE = \'type\';\n  var UNDEFINED = \'undefined\';\n  var WRITABLE = \'writable\';\n  return {\n    get $ARGUMENTS() {\n      return $ARGUMENTS;\n    },\n    get ANY() {\n      return ANY;\n    },\n    get APPLY() {\n      return APPLY;\n    },\n    get ARGUMENTS() {\n      return ARGUMENTS;\n    },\n    get ARRAY() {\n      return ARRAY;\n    },\n    get AS() {\n      return AS;\n    },\n    get ASYNC() {\n      return ASYNC;\n    },\n    get ASYNC_STAR() {\n      return ASYNC_STAR;\n    },\n    get AWAIT() {\n      return AWAIT;\n    },\n    get BIND() {\n      return BIND;\n    },\n    get CALL() {\n      return CALL;\n    },\n    get CONFIGURABLE() {\n      return CONFIGURABLE;\n    },\n    get CONSTRUCTOR() {\n      return CONSTRUCTOR;\n    },\n    get CREATE() {\n      return CREATE;\n    },\n    get CURRENT() {\n      return CURRENT;\n    },\n    get DEFINE_PROPERTY() {\n      return DEFINE_PROPERTY;\n    },\n    get ENUMERABLE() {\n      return ENUMERABLE;\n    },\n    get FREEZE() {\n      return FREEZE;\n    },\n    get FROM() {\n      return FROM;\n    },\n    get FUNCTION() {\n      return FUNCTION;\n    },\n    get GET() {\n      return GET;\n    },\n    get HAS() {\n      return HAS;\n    },\n    get LENGTH() {\n      return LENGTH;\n    },\n    get MODULE() {\n      return MODULE;\n    },\n    get NEW() {\n      return NEW;\n    },\n    get OBJECT() {\n      return OBJECT;\n    },\n    get OBJECT_NAME() {\n      return OBJECT_NAME;\n    },\n    get OF() {\n      return OF;\n    },\n    get ON() {\n      return ON;\n    },\n    get PREVENT_EXTENSIONS() {\n      return PREVENT_EXTENSIONS;\n    },\n    get PROTOTYPE() {\n      return PROTOTYPE;\n    },\n    get PUSH() {\n      return PUSH;\n    },\n    get SET() {\n      return SET;\n    },\n    get SLICE() {\n      return SLICE;\n    },\n    get THIS() {\n      return THIS;\n    },\n    get TRACEUR_RUNTIME() {\n      return TRACEUR_RUNTIME;\n    },\n    get TYPE() {\n      return TYPE;\n    },\n    get UNDEFINED() {\n      return UNDEFINED;\n    },\n    get WRITABLE() {\n      return WRITABLE;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/trees/ParseTree.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/trees/ParseTree.js";\n  var ParseTreeType = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeType.js", "traceur@0.0.111/src/syntax/trees/ParseTree.js"));\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TokenType.js", "traceur@0.0.111/src/syntax/trees/ParseTree.js")),\n      IDENTIFIER = $__2.IDENTIFIER,\n      STAR = $__2.STAR,\n      STRING = $__2.STRING,\n      VAR = $__2.VAR;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Token.js", "traceur@0.0.111/src/syntax/trees/ParseTree.js")).Token;\n  var utilJSON = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../util/JSON.js", "traceur@0.0.111/src/syntax/trees/ParseTree.js"));\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../PredefinedName.js", "traceur@0.0.111/src/syntax/trees/ParseTree.js")),\n      ASYNC = $__4.ASYNC,\n      ASYNC_STAR = $__4.ASYNC_STAR;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeType.js", "traceur@0.0.111/src/syntax/trees/ParseTree.js")),\n      ARRAY_COMPREHENSION = $__5.ARRAY_COMPREHENSION,\n      ARRAY_LITERAL = $__5.ARRAY_LITERAL,\n      ARRAY_PATTERN = $__5.ARRAY_PATTERN,\n      ARROW_FUNCTION = $__5.ARROW_FUNCTION,\n      AWAIT_EXPRESSION = $__5.AWAIT_EXPRESSION,\n      BINARY_EXPRESSION = $__5.BINARY_EXPRESSION,\n      BINDING_IDENTIFIER = $__5.BINDING_IDENTIFIER,\n      BLOCK = $__5.BLOCK,\n      BREAK_STATEMENT = $__5.BREAK_STATEMENT,\n      CALL_EXPRESSION = $__5.CALL_EXPRESSION,\n      CLASS_DECLARATION = $__5.CLASS_DECLARATION,\n      CLASS_EXPRESSION = $__5.CLASS_EXPRESSION,\n      COMMA_EXPRESSION = $__5.COMMA_EXPRESSION,\n      CONDITIONAL_EXPRESSION = $__5.CONDITIONAL_EXPRESSION,\n      CONSTRUCTOR_TYPE = $__5.CONSTRUCTOR_TYPE,\n      CONTINUE_STATEMENT = $__5.CONTINUE_STATEMENT,\n      DEBUGGER_STATEMENT = $__5.DEBUGGER_STATEMENT,\n      DO_WHILE_STATEMENT = $__5.DO_WHILE_STATEMENT,\n      EMPTY_STATEMENT = $__5.EMPTY_STATEMENT,\n      EXPORT_DECLARATION = $__5.EXPORT_DECLARATION,\n      EXPRESSION_STATEMENT = $__5.EXPRESSION_STATEMENT,\n      FOR_IN_STATEMENT = $__5.FOR_IN_STATEMENT,\n      FOR_OF_STATEMENT = $__5.FOR_OF_STATEMENT,\n      FOR_ON_STATEMENT = $__5.FOR_ON_STATEMENT,\n      FOR_STATEMENT = $__5.FOR_STATEMENT,\n      FORMAL_PARAMETER = $__5.FORMAL_PARAMETER,\n      FUNCTION_DECLARATION = $__5.FUNCTION_DECLARATION,\n      FUNCTION_EXPRESSION = $__5.FUNCTION_EXPRESSION,\n      FUNCTION_TYPE = $__5.FUNCTION_TYPE,\n      GENERATOR_COMPREHENSION = $__5.GENERATOR_COMPREHENSION,\n      IDENTIFIER_EXPRESSION = $__5.IDENTIFIER_EXPRESSION,\n      IF_STATEMENT = $__5.IF_STATEMENT,\n      IMPORT_DECLARATION = $__5.IMPORT_DECLARATION,\n      IMPORTED_BINDING = $__5.IMPORTED_BINDING,\n      INTERFACE_DECLARATION = $__5.INTERFACE_DECLARATION,\n      JSX_ELEMENT = $__5.JSX_ELEMENT,\n      LABELLED_STATEMENT = $__5.LABELLED_STATEMENT,\n      LITERAL_EXPRESSION = $__5.LITERAL_EXPRESSION,\n      LITERAL_PROPERTY_NAME = $__5.LITERAL_PROPERTY_NAME,\n      MEMBER_EXPRESSION = $__5.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__5.MEMBER_LOOKUP_EXPRESSION,\n      NEW_EXPRESSION = $__5.NEW_EXPRESSION,\n      OBJECT_LITERAL = $__5.OBJECT_LITERAL,\n      OBJECT_PATTERN = $__5.OBJECT_PATTERN,\n      OBJECT_TYPE = $__5.OBJECT_TYPE,\n      PAREN_EXPRESSION = $__5.PAREN_EXPRESSION,\n      POSTFIX_EXPRESSION = $__5.POSTFIX_EXPRESSION,\n      PREDEFINED_TYPE = $__5.PREDEFINED_TYPE,\n      PROPERTY_NAME_SHORTHAND = $__5.PROPERTY_NAME_SHORTHAND,\n      REST_PARAMETER = $__5.REST_PARAMETER,\n      RETURN_STATEMENT = $__5.RETURN_STATEMENT,\n      SPREAD_EXPRESSION = $__5.SPREAD_EXPRESSION,\n      SPREAD_PATTERN_ELEMENT = $__5.SPREAD_PATTERN_ELEMENT,\n      SUPER_EXPRESSION = $__5.SUPER_EXPRESSION,\n      SWITCH_STATEMENT = $__5.SWITCH_STATEMENT,\n      TEMPLATE_LITERAL_EXPRESSION = $__5.TEMPLATE_LITERAL_EXPRESSION,\n      THIS_EXPRESSION = $__5.THIS_EXPRESSION,\n      THROW_STATEMENT = $__5.THROW_STATEMENT,\n      TRY_STATEMENT = $__5.TRY_STATEMENT,\n      TYPE_ALIAS_DECLARATION = $__5.TYPE_ALIAS_DECLARATION,\n      TYPE_NAME = $__5.TYPE_NAME,\n      TYPE_REFERENCE = $__5.TYPE_REFERENCE,\n      UNARY_EXPRESSION = $__5.UNARY_EXPRESSION,\n      VARIABLE_DECLARATION = $__5.VARIABLE_DECLARATION,\n      VARIABLE_STATEMENT = $__5.VARIABLE_STATEMENT,\n      WHILE_STATEMENT = $__5.WHILE_STATEMENT,\n      WITH_STATEMENT = $__5.WITH_STATEMENT,\n      YIELD_EXPRESSION = $__5.YIELD_EXPRESSION;\n  var ParseTree = function() {\n    function ParseTree(location) {\n      this.location = location;\n    }\n    return ($traceurRuntime.createClass)(ParseTree, {\n      isPattern: function() {\n        switch (this.type) {\n          case ARRAY_PATTERN:\n          case OBJECT_PATTERN:\n            return true;\n          default:\n            return false;\n        }\n      },\n      isLeftHandSideExpression: function() {\n        switch (this.type) {\n          case ARRAY_PATTERN:\n          case IDENTIFIER_EXPRESSION:\n          case MEMBER_EXPRESSION:\n          case MEMBER_LOOKUP_EXPRESSION:\n          case OBJECT_PATTERN:\n            return true;\n          case PAREN_EXPRESSION:\n            return this.expression.isLeftHandSideExpression();\n          default:\n            return false;\n        }\n      },\n      isAssignmentExpression: function() {\n        switch (this.type) {\n          case ARRAY_COMPREHENSION:\n          case ARRAY_LITERAL:\n          case ARROW_FUNCTION:\n          case AWAIT_EXPRESSION:\n          case BINARY_EXPRESSION:\n          case CALL_EXPRESSION:\n          case CLASS_EXPRESSION:\n          case CONDITIONAL_EXPRESSION:\n          case FUNCTION_EXPRESSION:\n          case GENERATOR_COMPREHENSION:\n          case IDENTIFIER_EXPRESSION:\n          case JSX_ELEMENT:\n          case LITERAL_EXPRESSION:\n          case MEMBER_EXPRESSION:\n          case MEMBER_LOOKUP_EXPRESSION:\n          case NEW_EXPRESSION:\n          case OBJECT_LITERAL:\n          case PAREN_EXPRESSION:\n          case POSTFIX_EXPRESSION:\n          case TEMPLATE_LITERAL_EXPRESSION:\n          case SUPER_EXPRESSION:\n          case THIS_EXPRESSION:\n          case UNARY_EXPRESSION:\n          case YIELD_EXPRESSION:\n            return true;\n          default:\n            return false;\n        }\n      },\n      isMemberExpression: function() {\n        switch (this.type) {\n          case THIS_EXPRESSION:\n          case CLASS_EXPRESSION:\n          case SUPER_EXPRESSION:\n          case IDENTIFIER_EXPRESSION:\n          case JSX_ELEMENT:\n          case LITERAL_EXPRESSION:\n          case ARRAY_LITERAL:\n          case OBJECT_LITERAL:\n          case PAREN_EXPRESSION:\n          case TEMPLATE_LITERAL_EXPRESSION:\n          case FUNCTION_EXPRESSION:\n          case MEMBER_LOOKUP_EXPRESSION:\n          case MEMBER_EXPRESSION:\n          case CALL_EXPRESSION:\n            return true;\n          case NEW_EXPRESSION:\n            return this.args !== null;\n        }\n        return false;\n      },\n      isExpression: function() {\n        return this.isAssignmentExpression() || this.type === COMMA_EXPRESSION;\n      },\n      isAssignmentOrSpread: function() {\n        return this.isAssignmentExpression() || this.type === SPREAD_EXPRESSION;\n      },\n      isRestParameter: function() {\n        return this.type === REST_PARAMETER || (this.type === FORMAL_PARAMETER && this.parameter.isRestParameter());\n      },\n      isSpreadPatternElement: function() {\n        return this.type === SPREAD_PATTERN_ELEMENT;\n      },\n      isStatementListItem: function() {\n        return this.isStatement() || this.isDeclaration() || this.type === TYPE_ALIAS_DECLARATION;\n      },\n      isStatement: function() {\n        switch (this.type) {\n          case BLOCK:\n          case VARIABLE_STATEMENT:\n          case EMPTY_STATEMENT:\n          case EXPRESSION_STATEMENT:\n          case IF_STATEMENT:\n          case CONTINUE_STATEMENT:\n          case BREAK_STATEMENT:\n          case RETURN_STATEMENT:\n          case WITH_STATEMENT:\n          case LABELLED_STATEMENT:\n          case THROW_STATEMENT:\n          case TRY_STATEMENT:\n          case DEBUGGER_STATEMENT:\n            return true;\n        }\n        return this.isBreakableStatement();\n      },\n      isDeclaration: function() {\n        switch (this.type) {\n          case FUNCTION_DECLARATION:\n          case CLASS_DECLARATION:\n            return true;\n        }\n        return this.isLexicalDeclaration();\n      },\n      isLexicalDeclaration: function() {\n        switch (this.type) {\n          case VARIABLE_STATEMENT:\n            return this.declarations.declarationType !== VAR;\n        }\n        return false;\n      },\n      isBreakableStatement: function() {\n        switch (this.type) {\n          case SWITCH_STATEMENT:\n            return true;\n        }\n        return this.isIterationStatement();\n      },\n      isIterationStatement: function() {\n        switch (this.type) {\n          case DO_WHILE_STATEMENT:\n          case FOR_IN_STATEMENT:\n          case FOR_OF_STATEMENT:\n          case FOR_ON_STATEMENT:\n          case FOR_STATEMENT:\n          case WHILE_STATEMENT:\n            return true;\n        }\n        return false;\n      },\n      isScriptElement: function() {\n        switch (this.type) {\n          case CLASS_DECLARATION:\n          case EXPORT_DECLARATION:\n          case FUNCTION_DECLARATION:\n          case IMPORT_DECLARATION:\n          case INTERFACE_DECLARATION:\n          case VARIABLE_DECLARATION:\n          case TYPE_ALIAS_DECLARATION:\n            return true;\n        }\n        return this.isStatement();\n      },\n      isGenerator: function() {\n        return this.functionKind !== null && this.functionKind.type === STAR;\n      },\n      isAsyncFunction: function() {\n        return this.functionKind !== null && this.functionKind.type === IDENTIFIER && this.functionKind.value === ASYNC;\n      },\n      isAsyncGenerator: function() {\n        return this.functionKind !== null && this.functionKind.type === IDENTIFIER && this.functionKind.value === ASYNC_STAR;\n      },\n      isType: function() {\n        switch (this.type) {\n          case CONSTRUCTOR_TYPE:\n          case FUNCTION_TYPE:\n          case OBJECT_TYPE:\n          case PREDEFINED_TYPE:\n          case TYPE_NAME:\n          case TYPE_REFERENCE:\n            return true;\n        }\n        return false;\n      },\n      getDirectivePrologueStringToken_: function() {\n        var tree = this;\n        if (tree.type !== EXPRESSION_STATEMENT || !(tree = tree.expression))\n          return null;\n        if (tree.type !== LITERAL_EXPRESSION || !(tree = tree.literalToken))\n          return null;\n        if (tree.type !== STRING)\n          return null;\n        return tree;\n      },\n      isDirectivePrologue: function() {\n        return this.getDirectivePrologueStringToken_() !== null;\n      },\n      isUseStrictDirective: function() {\n        var token = this.getDirectivePrologueStringToken_();\n        if (!token)\n          return false;\n        var v = token.value;\n        return v === \'"use strict"\' || v === "\'use strict\'";\n      },\n      toJSON: function() {\n        return utilJSON.transform(this, ParseTree.replacer);\n      },\n      stringify: function() {\n        var indent = arguments[0] !== (void 0) ? arguments[0] : 2;\n        return JSON.stringify(this, ParseTree.replacer, indent);\n      },\n      getStringValue: function() {\n        switch (this.type) {\n          case IDENTIFIER_EXPRESSION:\n          case BINDING_IDENTIFIER:\n            return this.identifierToken.toString();\n          case IMPORTED_BINDING:\n            return this.binding.getStringValue();\n          case PROPERTY_NAME_SHORTHAND:\n            return this.name.toString();\n          case LITERAL_PROPERTY_NAME:\n            return this.literalToken.toString();\n        }\n        throw new Error(\'Not yet implemented\');\n      }\n    }, {\n      stripLocation: function(key, value) {\n        if (key === \'location\') {\n          return undefined;\n        }\n        return value;\n      },\n      replacer: function(k, v) {\n        if (v instanceof ParseTree || v instanceof Token) {\n          var rv = {type: v.type};\n          Object.keys(v).forEach(function(name) {\n            if (name !== \'location\')\n              rv[name] = v[name];\n          });\n          return rv;\n        }\n        return v;\n      }\n    });\n  }();\n  return {\n    get ParseTreeType() {\n      return ParseTreeType;\n    },\n    get ParseTree() {\n      return ParseTree;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/trees/ParseTrees.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/trees/ParseTrees.js";\n  var ParseTree = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTree.js", "traceur@0.0.111/src/syntax/trees/ParseTrees.js")).ParseTree;\n  var ParseTreeType = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeType.js", "traceur@0.0.111/src/syntax/trees/ParseTrees.js"));\n  var ANNOTATION = ParseTreeType.ANNOTATION;\n  var Annotation = function($__super) {\n    function Annotation(location, name, args) {\n      $traceurRuntime.superConstructor(Annotation).call(this, location);\n      this.name = name;\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(Annotation, {\n      transform: function(transformer) {\n        return transformer.transformAnnotation(this);\n      },\n      visit: function(visitor) {\n        visitor.visitAnnotation(this);\n      },\n      get type() {\n        return ANNOTATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ANON_BLOCK = ParseTreeType.ANON_BLOCK;\n  var AnonBlock = function($__super) {\n    function AnonBlock(location, statements) {\n      $traceurRuntime.superConstructor(AnonBlock).call(this, location);\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(AnonBlock, {\n      transform: function(transformer) {\n        return transformer.transformAnonBlock(this);\n      },\n      visit: function(visitor) {\n        visitor.visitAnonBlock(this);\n      },\n      get type() {\n        return ANON_BLOCK;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARGUMENT_LIST = ParseTreeType.ARGUMENT_LIST;\n  var ArgumentList = function($__super) {\n    function ArgumentList(location, args) {\n      $traceurRuntime.superConstructor(ArgumentList).call(this, location);\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(ArgumentList, {\n      transform: function(transformer) {\n        return transformer.transformArgumentList(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArgumentList(this);\n      },\n      get type() {\n        return ARGUMENT_LIST;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARRAY_COMPREHENSION = ParseTreeType.ARRAY_COMPREHENSION;\n  var ArrayComprehension = function($__super) {\n    function ArrayComprehension(location, comprehensionList, expression) {\n      $traceurRuntime.superConstructor(ArrayComprehension).call(this, location);\n      this.comprehensionList = comprehensionList;\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ArrayComprehension, {\n      transform: function(transformer) {\n        return transformer.transformArrayComprehension(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArrayComprehension(this);\n      },\n      get type() {\n        return ARRAY_COMPREHENSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARRAY_LITERAL = ParseTreeType.ARRAY_LITERAL;\n  var ArrayLiteral = function($__super) {\n    function ArrayLiteral(location, elements) {\n      $traceurRuntime.superConstructor(ArrayLiteral).call(this, location);\n      this.elements = elements;\n    }\n    return ($traceurRuntime.createClass)(ArrayLiteral, {\n      transform: function(transformer) {\n        return transformer.transformArrayLiteral(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArrayLiteral(this);\n      },\n      get type() {\n        return ARRAY_LITERAL;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARRAY_PATTERN = ParseTreeType.ARRAY_PATTERN;\n  var ArrayPattern = function($__super) {\n    function ArrayPattern(location, elements) {\n      $traceurRuntime.superConstructor(ArrayPattern).call(this, location);\n      this.elements = elements;\n    }\n    return ($traceurRuntime.createClass)(ArrayPattern, {\n      transform: function(transformer) {\n        return transformer.transformArrayPattern(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArrayPattern(this);\n      },\n      get type() {\n        return ARRAY_PATTERN;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARRAY_TYPE = ParseTreeType.ARRAY_TYPE;\n  var ArrayType = function($__super) {\n    function ArrayType(location, elementType) {\n      $traceurRuntime.superConstructor(ArrayType).call(this, location);\n      this.elementType = elementType;\n    }\n    return ($traceurRuntime.createClass)(ArrayType, {\n      transform: function(transformer) {\n        return transformer.transformArrayType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArrayType(this);\n      },\n      get type() {\n        return ARRAY_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARROW_FUNCTION = ParseTreeType.ARROW_FUNCTION;\n  var ArrowFunction = function($__super) {\n    function ArrowFunction(location, functionKind, parameterList, body) {\n      $traceurRuntime.superConstructor(ArrowFunction).call(this, location);\n      this.functionKind = functionKind;\n      this.parameterList = parameterList;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(ArrowFunction, {\n      transform: function(transformer) {\n        return transformer.transformArrowFunction(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArrowFunction(this);\n      },\n      get type() {\n        return ARROW_FUNCTION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ASSIGNMENT_ELEMENT = ParseTreeType.ASSIGNMENT_ELEMENT;\n  var AssignmentElement = function($__super) {\n    function AssignmentElement(location, assignment, initializer) {\n      $traceurRuntime.superConstructor(AssignmentElement).call(this, location);\n      this.assignment = assignment;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(AssignmentElement, {\n      transform: function(transformer) {\n        return transformer.transformAssignmentElement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitAssignmentElement(this);\n      },\n      get type() {\n        return ASSIGNMENT_ELEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var AWAIT_EXPRESSION = ParseTreeType.AWAIT_EXPRESSION;\n  var AwaitExpression = function($__super) {\n    function AwaitExpression(location, expression) {\n      $traceurRuntime.superConstructor(AwaitExpression).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(AwaitExpression, {\n      transform: function(transformer) {\n        return transformer.transformAwaitExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitAwaitExpression(this);\n      },\n      get type() {\n        return AWAIT_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var BINARY_EXPRESSION = ParseTreeType.BINARY_EXPRESSION;\n  var BinaryExpression = function($__super) {\n    function BinaryExpression(location, left, operator, right) {\n      $traceurRuntime.superConstructor(BinaryExpression).call(this, location);\n      this.left = left;\n      this.operator = operator;\n      this.right = right;\n    }\n    return ($traceurRuntime.createClass)(BinaryExpression, {\n      transform: function(transformer) {\n        return transformer.transformBinaryExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitBinaryExpression(this);\n      },\n      get type() {\n        return BINARY_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var BINDING_ELEMENT = ParseTreeType.BINDING_ELEMENT;\n  var BindingElement = function($__super) {\n    function BindingElement(location, binding, initializer) {\n      $traceurRuntime.superConstructor(BindingElement).call(this, location);\n      this.binding = binding;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(BindingElement, {\n      transform: function(transformer) {\n        return transformer.transformBindingElement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitBindingElement(this);\n      },\n      get type() {\n        return BINDING_ELEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var BINDING_IDENTIFIER = ParseTreeType.BINDING_IDENTIFIER;\n  var BindingIdentifier = function($__super) {\n    function BindingIdentifier(location, identifierToken) {\n      $traceurRuntime.superConstructor(BindingIdentifier).call(this, location);\n      this.identifierToken = identifierToken;\n    }\n    return ($traceurRuntime.createClass)(BindingIdentifier, {\n      transform: function(transformer) {\n        return transformer.transformBindingIdentifier(this);\n      },\n      visit: function(visitor) {\n        visitor.visitBindingIdentifier(this);\n      },\n      get type() {\n        return BINDING_IDENTIFIER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var BLOCK = ParseTreeType.BLOCK;\n  var Block = function($__super) {\n    function Block(location, statements) {\n      $traceurRuntime.superConstructor(Block).call(this, location);\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(Block, {\n      transform: function(transformer) {\n        return transformer.transformBlock(this);\n      },\n      visit: function(visitor) {\n        visitor.visitBlock(this);\n      },\n      get type() {\n        return BLOCK;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var BREAK_STATEMENT = ParseTreeType.BREAK_STATEMENT;\n  var BreakStatement = function($__super) {\n    function BreakStatement(location, name) {\n      $traceurRuntime.superConstructor(BreakStatement).call(this, location);\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(BreakStatement, {\n      transform: function(transformer) {\n        return transformer.transformBreakStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitBreakStatement(this);\n      },\n      get type() {\n        return BREAK_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CALL_EXPRESSION = ParseTreeType.CALL_EXPRESSION;\n  var CallExpression = function($__super) {\n    function CallExpression(location, operand, args) {\n      $traceurRuntime.superConstructor(CallExpression).call(this, location);\n      this.operand = operand;\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(CallExpression, {\n      transform: function(transformer) {\n        return transformer.transformCallExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCallExpression(this);\n      },\n      get type() {\n        return CALL_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CALL_SIGNATURE = ParseTreeType.CALL_SIGNATURE;\n  var CallSignature = function($__super) {\n    function CallSignature(location, typeParameters, parameterList, returnType) {\n      $traceurRuntime.superConstructor(CallSignature).call(this, location);\n      this.typeParameters = typeParameters;\n      this.parameterList = parameterList;\n      this.returnType = returnType;\n    }\n    return ($traceurRuntime.createClass)(CallSignature, {\n      transform: function(transformer) {\n        return transformer.transformCallSignature(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCallSignature(this);\n      },\n      get type() {\n        return CALL_SIGNATURE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CASE_CLAUSE = ParseTreeType.CASE_CLAUSE;\n  var CaseClause = function($__super) {\n    function CaseClause(location, expression, statements) {\n      $traceurRuntime.superConstructor(CaseClause).call(this, location);\n      this.expression = expression;\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(CaseClause, {\n      transform: function(transformer) {\n        return transformer.transformCaseClause(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCaseClause(this);\n      },\n      get type() {\n        return CASE_CLAUSE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CATCH = ParseTreeType.CATCH;\n  var Catch = function($__super) {\n    function Catch(location, binding, catchBody) {\n      $traceurRuntime.superConstructor(Catch).call(this, location);\n      this.binding = binding;\n      this.catchBody = catchBody;\n    }\n    return ($traceurRuntime.createClass)(Catch, {\n      transform: function(transformer) {\n        return transformer.transformCatch(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCatch(this);\n      },\n      get type() {\n        return CATCH;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CLASS_DECLARATION = ParseTreeType.CLASS_DECLARATION;\n  var ClassDeclaration = function($__super) {\n    function ClassDeclaration(location, name, superClass, elements, annotations, typeParameters) {\n      $traceurRuntime.superConstructor(ClassDeclaration).call(this, location);\n      this.name = name;\n      this.superClass = superClass;\n      this.elements = elements;\n      this.annotations = annotations;\n      this.typeParameters = typeParameters;\n    }\n    return ($traceurRuntime.createClass)(ClassDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformClassDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitClassDeclaration(this);\n      },\n      get type() {\n        return CLASS_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CLASS_EXPRESSION = ParseTreeType.CLASS_EXPRESSION;\n  var ClassExpression = function($__super) {\n    function ClassExpression(location, name, superClass, elements, annotations, typeParameters) {\n      $traceurRuntime.superConstructor(ClassExpression).call(this, location);\n      this.name = name;\n      this.superClass = superClass;\n      this.elements = elements;\n      this.annotations = annotations;\n      this.typeParameters = typeParameters;\n    }\n    return ($traceurRuntime.createClass)(ClassExpression, {\n      transform: function(transformer) {\n        return transformer.transformClassExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitClassExpression(this);\n      },\n      get type() {\n        return CLASS_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COMMA_EXPRESSION = ParseTreeType.COMMA_EXPRESSION;\n  var CommaExpression = function($__super) {\n    function CommaExpression(location, expressions) {\n      $traceurRuntime.superConstructor(CommaExpression).call(this, location);\n      this.expressions = expressions;\n    }\n    return ($traceurRuntime.createClass)(CommaExpression, {\n      transform: function(transformer) {\n        return transformer.transformCommaExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCommaExpression(this);\n      },\n      get type() {\n        return COMMA_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COMPREHENSION_FOR = ParseTreeType.COMPREHENSION_FOR;\n  var ComprehensionFor = function($__super) {\n    function ComprehensionFor(location, left, iterator) {\n      $traceurRuntime.superConstructor(ComprehensionFor).call(this, location);\n      this.left = left;\n      this.iterator = iterator;\n    }\n    return ($traceurRuntime.createClass)(ComprehensionFor, {\n      transform: function(transformer) {\n        return transformer.transformComprehensionFor(this);\n      },\n      visit: function(visitor) {\n        visitor.visitComprehensionFor(this);\n      },\n      get type() {\n        return COMPREHENSION_FOR;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COMPREHENSION_IF = ParseTreeType.COMPREHENSION_IF;\n  var ComprehensionIf = function($__super) {\n    function ComprehensionIf(location, expression) {\n      $traceurRuntime.superConstructor(ComprehensionIf).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ComprehensionIf, {\n      transform: function(transformer) {\n        return transformer.transformComprehensionIf(this);\n      },\n      visit: function(visitor) {\n        visitor.visitComprehensionIf(this);\n      },\n      get type() {\n        return COMPREHENSION_IF;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COMPUTED_PROPERTY_NAME = ParseTreeType.COMPUTED_PROPERTY_NAME;\n  var ComputedPropertyName = function($__super) {\n    function ComputedPropertyName(location, expression) {\n      $traceurRuntime.superConstructor(ComputedPropertyName).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ComputedPropertyName, {\n      transform: function(transformer) {\n        return transformer.transformComputedPropertyName(this);\n      },\n      visit: function(visitor) {\n        visitor.visitComputedPropertyName(this);\n      },\n      get type() {\n        return COMPUTED_PROPERTY_NAME;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CONDITIONAL_EXPRESSION = ParseTreeType.CONDITIONAL_EXPRESSION;\n  var ConditionalExpression = function($__super) {\n    function ConditionalExpression(location, condition, left, right) {\n      $traceurRuntime.superConstructor(ConditionalExpression).call(this, location);\n      this.condition = condition;\n      this.left = left;\n      this.right = right;\n    }\n    return ($traceurRuntime.createClass)(ConditionalExpression, {\n      transform: function(transformer) {\n        return transformer.transformConditionalExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitConditionalExpression(this);\n      },\n      get type() {\n        return CONDITIONAL_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CONSTRUCT_SIGNATURE = ParseTreeType.CONSTRUCT_SIGNATURE;\n  var ConstructSignature = function($__super) {\n    function ConstructSignature(location, typeParameters, parameterList, returnType) {\n      $traceurRuntime.superConstructor(ConstructSignature).call(this, location);\n      this.typeParameters = typeParameters;\n      this.parameterList = parameterList;\n      this.returnType = returnType;\n    }\n    return ($traceurRuntime.createClass)(ConstructSignature, {\n      transform: function(transformer) {\n        return transformer.transformConstructSignature(this);\n      },\n      visit: function(visitor) {\n        visitor.visitConstructSignature(this);\n      },\n      get type() {\n        return CONSTRUCT_SIGNATURE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CONSTRUCTOR_TYPE = ParseTreeType.CONSTRUCTOR_TYPE;\n  var ConstructorType = function($__super) {\n    function ConstructorType(location, typeParameters, parameterList, returnType) {\n      $traceurRuntime.superConstructor(ConstructorType).call(this, location);\n      this.typeParameters = typeParameters;\n      this.parameterList = parameterList;\n      this.returnType = returnType;\n    }\n    return ($traceurRuntime.createClass)(ConstructorType, {\n      transform: function(transformer) {\n        return transformer.transformConstructorType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitConstructorType(this);\n      },\n      get type() {\n        return CONSTRUCTOR_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CONTINUE_STATEMENT = ParseTreeType.CONTINUE_STATEMENT;\n  var ContinueStatement = function($__super) {\n    function ContinueStatement(location, name) {\n      $traceurRuntime.superConstructor(ContinueStatement).call(this, location);\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(ContinueStatement, {\n      transform: function(transformer) {\n        return transformer.transformContinueStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitContinueStatement(this);\n      },\n      get type() {\n        return CONTINUE_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COVER_FORMALS = ParseTreeType.COVER_FORMALS;\n  var CoverFormals = function($__super) {\n    function CoverFormals(location, expressions) {\n      $traceurRuntime.superConstructor(CoverFormals).call(this, location);\n      this.expressions = expressions;\n    }\n    return ($traceurRuntime.createClass)(CoverFormals, {\n      transform: function(transformer) {\n        return transformer.transformCoverFormals(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCoverFormals(this);\n      },\n      get type() {\n        return COVER_FORMALS;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COVER_INITIALIZED_NAME = ParseTreeType.COVER_INITIALIZED_NAME;\n  var CoverInitializedName = function($__super) {\n    function CoverInitializedName(location, name, equalToken, initializer) {\n      $traceurRuntime.superConstructor(CoverInitializedName).call(this, location);\n      this.name = name;\n      this.equalToken = equalToken;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(CoverInitializedName, {\n      transform: function(transformer) {\n        return transformer.transformCoverInitializedName(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCoverInitializedName(this);\n      },\n      get type() {\n        return COVER_INITIALIZED_NAME;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var DEBUGGER_STATEMENT = ParseTreeType.DEBUGGER_STATEMENT;\n  var DebuggerStatement = function($__super) {\n    function DebuggerStatement(location) {\n      $traceurRuntime.superConstructor(DebuggerStatement).call(this, location);\n    }\n    return ($traceurRuntime.createClass)(DebuggerStatement, {\n      transform: function(transformer) {\n        return transformer.transformDebuggerStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitDebuggerStatement(this);\n      },\n      get type() {\n        return DEBUGGER_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var DEFAULT_CLAUSE = ParseTreeType.DEFAULT_CLAUSE;\n  var DefaultClause = function($__super) {\n    function DefaultClause(location, statements) {\n      $traceurRuntime.superConstructor(DefaultClause).call(this, location);\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(DefaultClause, {\n      transform: function(transformer) {\n        return transformer.transformDefaultClause(this);\n      },\n      visit: function(visitor) {\n        visitor.visitDefaultClause(this);\n      },\n      get type() {\n        return DEFAULT_CLAUSE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var DO_WHILE_STATEMENT = ParseTreeType.DO_WHILE_STATEMENT;\n  var DoWhileStatement = function($__super) {\n    function DoWhileStatement(location, body, condition) {\n      $traceurRuntime.superConstructor(DoWhileStatement).call(this, location);\n      this.body = body;\n      this.condition = condition;\n    }\n    return ($traceurRuntime.createClass)(DoWhileStatement, {\n      transform: function(transformer) {\n        return transformer.transformDoWhileStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitDoWhileStatement(this);\n      },\n      get type() {\n        return DO_WHILE_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EMPTY_STATEMENT = ParseTreeType.EMPTY_STATEMENT;\n  var EmptyStatement = function($__super) {\n    function EmptyStatement(location) {\n      $traceurRuntime.superConstructor(EmptyStatement).call(this, location);\n    }\n    return ($traceurRuntime.createClass)(EmptyStatement, {\n      transform: function(transformer) {\n        return transformer.transformEmptyStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitEmptyStatement(this);\n      },\n      get type() {\n        return EMPTY_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPORT_DECLARATION = ParseTreeType.EXPORT_DECLARATION;\n  var ExportDeclaration = function($__super) {\n    function ExportDeclaration(location, declaration, annotations) {\n      $traceurRuntime.superConstructor(ExportDeclaration).call(this, location);\n      this.declaration = declaration;\n      this.annotations = annotations;\n    }\n    return ($traceurRuntime.createClass)(ExportDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformExportDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExportDeclaration(this);\n      },\n      get type() {\n        return EXPORT_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPORT_DEFAULT = ParseTreeType.EXPORT_DEFAULT;\n  var ExportDefault = function($__super) {\n    function ExportDefault(location, expression) {\n      $traceurRuntime.superConstructor(ExportDefault).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ExportDefault, {\n      transform: function(transformer) {\n        return transformer.transformExportDefault(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExportDefault(this);\n      },\n      get type() {\n        return EXPORT_DEFAULT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPORT_SPECIFIER = ParseTreeType.EXPORT_SPECIFIER;\n  var ExportSpecifier = function($__super) {\n    function ExportSpecifier(location, lhs, rhs) {\n      $traceurRuntime.superConstructor(ExportSpecifier).call(this, location);\n      this.lhs = lhs;\n      this.rhs = rhs;\n    }\n    return ($traceurRuntime.createClass)(ExportSpecifier, {\n      transform: function(transformer) {\n        return transformer.transformExportSpecifier(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExportSpecifier(this);\n      },\n      get type() {\n        return EXPORT_SPECIFIER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPORT_SPECIFIER_SET = ParseTreeType.EXPORT_SPECIFIER_SET;\n  var ExportSpecifierSet = function($__super) {\n    function ExportSpecifierSet(location, specifiers) {\n      $traceurRuntime.superConstructor(ExportSpecifierSet).call(this, location);\n      this.specifiers = specifiers;\n    }\n    return ($traceurRuntime.createClass)(ExportSpecifierSet, {\n      transform: function(transformer) {\n        return transformer.transformExportSpecifierSet(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExportSpecifierSet(this);\n      },\n      get type() {\n        return EXPORT_SPECIFIER_SET;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPORT_STAR = ParseTreeType.EXPORT_STAR;\n  var ExportStar = function($__super) {\n    function ExportStar(location) {\n      $traceurRuntime.superConstructor(ExportStar).call(this, location);\n    }\n    return ($traceurRuntime.createClass)(ExportStar, {\n      transform: function(transformer) {\n        return transformer.transformExportStar(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExportStar(this);\n      },\n      get type() {\n        return EXPORT_STAR;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPRESSION_STATEMENT = ParseTreeType.EXPRESSION_STATEMENT;\n  var ExpressionStatement = function($__super) {\n    function ExpressionStatement(location, expression) {\n      $traceurRuntime.superConstructor(ExpressionStatement).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ExpressionStatement, {\n      transform: function(transformer) {\n        return transformer.transformExpressionStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExpressionStatement(this);\n      },\n      get type() {\n        return EXPRESSION_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FINALLY = ParseTreeType.FINALLY;\n  var Finally = function($__super) {\n    function Finally(location, block) {\n      $traceurRuntime.superConstructor(Finally).call(this, location);\n      this.block = block;\n    }\n    return ($traceurRuntime.createClass)(Finally, {\n      transform: function(transformer) {\n        return transformer.transformFinally(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFinally(this);\n      },\n      get type() {\n        return FINALLY;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FOR_IN_STATEMENT = ParseTreeType.FOR_IN_STATEMENT;\n  var ForInStatement = function($__super) {\n    function ForInStatement(location, initializer, collection, body) {\n      $traceurRuntime.superConstructor(ForInStatement).call(this, location);\n      this.initializer = initializer;\n      this.collection = collection;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(ForInStatement, {\n      transform: function(transformer) {\n        return transformer.transformForInStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitForInStatement(this);\n      },\n      get type() {\n        return FOR_IN_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FOR_OF_STATEMENT = ParseTreeType.FOR_OF_STATEMENT;\n  var ForOfStatement = function($__super) {\n    function ForOfStatement(location, initializer, collection, body) {\n      $traceurRuntime.superConstructor(ForOfStatement).call(this, location);\n      this.initializer = initializer;\n      this.collection = collection;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(ForOfStatement, {\n      transform: function(transformer) {\n        return transformer.transformForOfStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitForOfStatement(this);\n      },\n      get type() {\n        return FOR_OF_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FOR_ON_STATEMENT = ParseTreeType.FOR_ON_STATEMENT;\n  var ForOnStatement = function($__super) {\n    function ForOnStatement(location, initializer, observable, body) {\n      $traceurRuntime.superConstructor(ForOnStatement).call(this, location);\n      this.initializer = initializer;\n      this.observable = observable;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(ForOnStatement, {\n      transform: function(transformer) {\n        return transformer.transformForOnStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitForOnStatement(this);\n      },\n      get type() {\n        return FOR_ON_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FOR_STATEMENT = ParseTreeType.FOR_STATEMENT;\n  var ForStatement = function($__super) {\n    function ForStatement(location, initializer, condition, increment, body) {\n      $traceurRuntime.superConstructor(ForStatement).call(this, location);\n      this.initializer = initializer;\n      this.condition = condition;\n      this.increment = increment;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(ForStatement, {\n      transform: function(transformer) {\n        return transformer.transformForStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitForStatement(this);\n      },\n      get type() {\n        return FOR_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FORMAL_PARAMETER = ParseTreeType.FORMAL_PARAMETER;\n  var FormalParameter = function($__super) {\n    function FormalParameter(location, parameter, typeAnnotation, annotations) {\n      $traceurRuntime.superConstructor(FormalParameter).call(this, location);\n      this.parameter = parameter;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n    }\n    return ($traceurRuntime.createClass)(FormalParameter, {\n      transform: function(transformer) {\n        return transformer.transformFormalParameter(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFormalParameter(this);\n      },\n      get type() {\n        return FORMAL_PARAMETER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FORMAL_PARAMETER_LIST = ParseTreeType.FORMAL_PARAMETER_LIST;\n  var FormalParameterList = function($__super) {\n    function FormalParameterList(location, parameters) {\n      $traceurRuntime.superConstructor(FormalParameterList).call(this, location);\n      this.parameters = parameters;\n    }\n    return ($traceurRuntime.createClass)(FormalParameterList, {\n      transform: function(transformer) {\n        return transformer.transformFormalParameterList(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFormalParameterList(this);\n      },\n      get type() {\n        return FORMAL_PARAMETER_LIST;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FORWARD_DEFAULT_EXPORT = ParseTreeType.FORWARD_DEFAULT_EXPORT;\n  var ForwardDefaultExport = function($__super) {\n    function ForwardDefaultExport(location, name) {\n      $traceurRuntime.superConstructor(ForwardDefaultExport).call(this, location);\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(ForwardDefaultExport, {\n      transform: function(transformer) {\n        return transformer.transformForwardDefaultExport(this);\n      },\n      visit: function(visitor) {\n        visitor.visitForwardDefaultExport(this);\n      },\n      get type() {\n        return FORWARD_DEFAULT_EXPORT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FUNCTION_BODY = ParseTreeType.FUNCTION_BODY;\n  var FunctionBody = function($__super) {\n    function FunctionBody(location, statements) {\n      $traceurRuntime.superConstructor(FunctionBody).call(this, location);\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(FunctionBody, {\n      transform: function(transformer) {\n        return transformer.transformFunctionBody(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFunctionBody(this);\n      },\n      get type() {\n        return FUNCTION_BODY;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FUNCTION_DECLARATION = ParseTreeType.FUNCTION_DECLARATION;\n  var FunctionDeclaration = function($__super) {\n    function FunctionDeclaration(location, name, functionKind, parameterList, typeAnnotation, annotations, body) {\n      $traceurRuntime.superConstructor(FunctionDeclaration).call(this, location);\n      this.name = name;\n      this.functionKind = functionKind;\n      this.parameterList = parameterList;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(FunctionDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformFunctionDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFunctionDeclaration(this);\n      },\n      get type() {\n        return FUNCTION_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FUNCTION_EXPRESSION = ParseTreeType.FUNCTION_EXPRESSION;\n  var FunctionExpression = function($__super) {\n    function FunctionExpression(location, name, functionKind, parameterList, typeAnnotation, annotations, body) {\n      $traceurRuntime.superConstructor(FunctionExpression).call(this, location);\n      this.name = name;\n      this.functionKind = functionKind;\n      this.parameterList = parameterList;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(FunctionExpression, {\n      transform: function(transformer) {\n        return transformer.transformFunctionExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFunctionExpression(this);\n      },\n      get type() {\n        return FUNCTION_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FUNCTION_TYPE = ParseTreeType.FUNCTION_TYPE;\n  var FunctionType = function($__super) {\n    function FunctionType(location, typeParameters, parameterList, returnType) {\n      $traceurRuntime.superConstructor(FunctionType).call(this, location);\n      this.typeParameters = typeParameters;\n      this.parameterList = parameterList;\n      this.returnType = returnType;\n    }\n    return ($traceurRuntime.createClass)(FunctionType, {\n      transform: function(transformer) {\n        return transformer.transformFunctionType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFunctionType(this);\n      },\n      get type() {\n        return FUNCTION_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var GENERATOR_COMPREHENSION = ParseTreeType.GENERATOR_COMPREHENSION;\n  var GeneratorComprehension = function($__super) {\n    function GeneratorComprehension(location, comprehensionList, expression) {\n      $traceurRuntime.superConstructor(GeneratorComprehension).call(this, location);\n      this.comprehensionList = comprehensionList;\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(GeneratorComprehension, {\n      transform: function(transformer) {\n        return transformer.transformGeneratorComprehension(this);\n      },\n      visit: function(visitor) {\n        visitor.visitGeneratorComprehension(this);\n      },\n      get type() {\n        return GENERATOR_COMPREHENSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var GET_ACCESSOR = ParseTreeType.GET_ACCESSOR;\n  var GetAccessor = function($__super) {\n    function GetAccessor(location, isStatic, name, typeAnnotation, annotations, body) {\n      $traceurRuntime.superConstructor(GetAccessor).call(this, location);\n      this.isStatic = isStatic;\n      this.name = name;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(GetAccessor, {\n      transform: function(transformer) {\n        return transformer.transformGetAccessor(this);\n      },\n      visit: function(visitor) {\n        visitor.visitGetAccessor(this);\n      },\n      get type() {\n        return GET_ACCESSOR;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IDENTIFIER_EXPRESSION = ParseTreeType.IDENTIFIER_EXPRESSION;\n  var IdentifierExpression = function($__super) {\n    function IdentifierExpression(location, identifierToken) {\n      $traceurRuntime.superConstructor(IdentifierExpression).call(this, location);\n      this.identifierToken = identifierToken;\n    }\n    return ($traceurRuntime.createClass)(IdentifierExpression, {\n      transform: function(transformer) {\n        return transformer.transformIdentifierExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitIdentifierExpression(this);\n      },\n      get type() {\n        return IDENTIFIER_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IF_STATEMENT = ParseTreeType.IF_STATEMENT;\n  var IfStatement = function($__super) {\n    function IfStatement(location, condition, ifClause, elseClause) {\n      $traceurRuntime.superConstructor(IfStatement).call(this, location);\n      this.condition = condition;\n      this.ifClause = ifClause;\n      this.elseClause = elseClause;\n    }\n    return ($traceurRuntime.createClass)(IfStatement, {\n      transform: function(transformer) {\n        return transformer.transformIfStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitIfStatement(this);\n      },\n      get type() {\n        return IF_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORTED_BINDING = ParseTreeType.IMPORTED_BINDING;\n  var ImportedBinding = function($__super) {\n    function ImportedBinding(location, binding) {\n      $traceurRuntime.superConstructor(ImportedBinding).call(this, location);\n      this.binding = binding;\n    }\n    return ($traceurRuntime.createClass)(ImportedBinding, {\n      transform: function(transformer) {\n        return transformer.transformImportedBinding(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportedBinding(this);\n      },\n      get type() {\n        return IMPORTED_BINDING;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORT_CLAUSE_PAIR = ParseTreeType.IMPORT_CLAUSE_PAIR;\n  var ImportClausePair = function($__super) {\n    function ImportClausePair(location, first, second) {\n      $traceurRuntime.superConstructor(ImportClausePair).call(this, location);\n      this.first = first;\n      this.second = second;\n    }\n    return ($traceurRuntime.createClass)(ImportClausePair, {\n      transform: function(transformer) {\n        return transformer.transformImportClausePair(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportClausePair(this);\n      },\n      get type() {\n        return IMPORT_CLAUSE_PAIR;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORT_DECLARATION = ParseTreeType.IMPORT_DECLARATION;\n  var ImportDeclaration = function($__super) {\n    function ImportDeclaration(location, importClause, moduleSpecifier) {\n      $traceurRuntime.superConstructor(ImportDeclaration).call(this, location);\n      this.importClause = importClause;\n      this.moduleSpecifier = moduleSpecifier;\n    }\n    return ($traceurRuntime.createClass)(ImportDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformImportDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportDeclaration(this);\n      },\n      get type() {\n        return IMPORT_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORT_SPECIFIER = ParseTreeType.IMPORT_SPECIFIER;\n  var ImportSpecifier = function($__super) {\n    function ImportSpecifier(location, binding, name) {\n      $traceurRuntime.superConstructor(ImportSpecifier).call(this, location);\n      this.binding = binding;\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(ImportSpecifier, {\n      transform: function(transformer) {\n        return transformer.transformImportSpecifier(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportSpecifier(this);\n      },\n      get type() {\n        return IMPORT_SPECIFIER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORT_SPECIFIER_SET = ParseTreeType.IMPORT_SPECIFIER_SET;\n  var ImportSpecifierSet = function($__super) {\n    function ImportSpecifierSet(location, specifiers) {\n      $traceurRuntime.superConstructor(ImportSpecifierSet).call(this, location);\n      this.specifiers = specifiers;\n    }\n    return ($traceurRuntime.createClass)(ImportSpecifierSet, {\n      transform: function(transformer) {\n        return transformer.transformImportSpecifierSet(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportSpecifierSet(this);\n      },\n      get type() {\n        return IMPORT_SPECIFIER_SET;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORT_TYPE_CLAUSE = ParseTreeType.IMPORT_TYPE_CLAUSE;\n  var ImportTypeClause = function($__super) {\n    function ImportTypeClause(location, clause) {\n      $traceurRuntime.superConstructor(ImportTypeClause).call(this, location);\n      this.clause = clause;\n    }\n    return ($traceurRuntime.createClass)(ImportTypeClause, {\n      transform: function(transformer) {\n        return transformer.transformImportTypeClause(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportTypeClause(this);\n      },\n      get type() {\n        return IMPORT_TYPE_CLAUSE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var INDEX_SIGNATURE = ParseTreeType.INDEX_SIGNATURE;\n  var IndexSignature = function($__super) {\n    function IndexSignature(location, name, indexType, typeAnnotation) {\n      $traceurRuntime.superConstructor(IndexSignature).call(this, location);\n      this.name = name;\n      this.indexType = indexType;\n      this.typeAnnotation = typeAnnotation;\n    }\n    return ($traceurRuntime.createClass)(IndexSignature, {\n      transform: function(transformer) {\n        return transformer.transformIndexSignature(this);\n      },\n      visit: function(visitor) {\n        visitor.visitIndexSignature(this);\n      },\n      get type() {\n        return INDEX_SIGNATURE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var INTERFACE_DECLARATION = ParseTreeType.INTERFACE_DECLARATION;\n  var InterfaceDeclaration = function($__super) {\n    function InterfaceDeclaration(location, name, typeParameters, extendsClause, objectType) {\n      $traceurRuntime.superConstructor(InterfaceDeclaration).call(this, location);\n      this.name = name;\n      this.typeParameters = typeParameters;\n      this.extendsClause = extendsClause;\n      this.objectType = objectType;\n    }\n    return ($traceurRuntime.createClass)(InterfaceDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformInterfaceDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitInterfaceDeclaration(this);\n      },\n      get type() {\n        return INTERFACE_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_ATTRIBUTE = ParseTreeType.JSX_ATTRIBUTE;\n  var JsxAttribute = function($__super) {\n    function JsxAttribute(location, name, value) {\n      $traceurRuntime.superConstructor(JsxAttribute).call(this, location);\n      this.name = name;\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(JsxAttribute, {\n      transform: function(transformer) {\n        return transformer.transformJsxAttribute(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxAttribute(this);\n      },\n      get type() {\n        return JSX_ATTRIBUTE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_ELEMENT = ParseTreeType.JSX_ELEMENT;\n  var JsxElement = function($__super) {\n    function JsxElement(location, name, attributes, children) {\n      $traceurRuntime.superConstructor(JsxElement).call(this, location);\n      this.name = name;\n      this.attributes = attributes;\n      this.children = children;\n    }\n    return ($traceurRuntime.createClass)(JsxElement, {\n      transform: function(transformer) {\n        return transformer.transformJsxElement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxElement(this);\n      },\n      get type() {\n        return JSX_ELEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_ELEMENT_NAME = ParseTreeType.JSX_ELEMENT_NAME;\n  var JsxElementName = function($__super) {\n    function JsxElementName(location, names) {\n      $traceurRuntime.superConstructor(JsxElementName).call(this, location);\n      this.names = names;\n    }\n    return ($traceurRuntime.createClass)(JsxElementName, {\n      transform: function(transformer) {\n        return transformer.transformJsxElementName(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxElementName(this);\n      },\n      get type() {\n        return JSX_ELEMENT_NAME;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_PLACEHOLDER = ParseTreeType.JSX_PLACEHOLDER;\n  var JsxPlaceholder = function($__super) {\n    function JsxPlaceholder(location, expression) {\n      $traceurRuntime.superConstructor(JsxPlaceholder).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(JsxPlaceholder, {\n      transform: function(transformer) {\n        return transformer.transformJsxPlaceholder(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxPlaceholder(this);\n      },\n      get type() {\n        return JSX_PLACEHOLDER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_SPREAD_ATTRIBUTE = ParseTreeType.JSX_SPREAD_ATTRIBUTE;\n  var JsxSpreadAttribute = function($__super) {\n    function JsxSpreadAttribute(location, expression) {\n      $traceurRuntime.superConstructor(JsxSpreadAttribute).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(JsxSpreadAttribute, {\n      transform: function(transformer) {\n        return transformer.transformJsxSpreadAttribute(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxSpreadAttribute(this);\n      },\n      get type() {\n        return JSX_SPREAD_ATTRIBUTE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_TEXT = ParseTreeType.JSX_TEXT;\n  var JsxText = function($__super) {\n    function JsxText(location, value) {\n      $traceurRuntime.superConstructor(JsxText).call(this, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(JsxText, {\n      transform: function(transformer) {\n        return transformer.transformJsxText(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxText(this);\n      },\n      get type() {\n        return JSX_TEXT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var LABELLED_STATEMENT = ParseTreeType.LABELLED_STATEMENT;\n  var LabelledStatement = function($__super) {\n    function LabelledStatement(location, name, statement) {\n      $traceurRuntime.superConstructor(LabelledStatement).call(this, location);\n      this.name = name;\n      this.statement = statement;\n    }\n    return ($traceurRuntime.createClass)(LabelledStatement, {\n      transform: function(transformer) {\n        return transformer.transformLabelledStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitLabelledStatement(this);\n      },\n      get type() {\n        return LABELLED_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var LITERAL_EXPRESSION = ParseTreeType.LITERAL_EXPRESSION;\n  var LiteralExpression = function($__super) {\n    function LiteralExpression(location, literalToken) {\n      $traceurRuntime.superConstructor(LiteralExpression).call(this, location);\n      this.literalToken = literalToken;\n    }\n    return ($traceurRuntime.createClass)(LiteralExpression, {\n      transform: function(transformer) {\n        return transformer.transformLiteralExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitLiteralExpression(this);\n      },\n      get type() {\n        return LITERAL_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var LITERAL_PROPERTY_NAME = ParseTreeType.LITERAL_PROPERTY_NAME;\n  var LiteralPropertyName = function($__super) {\n    function LiteralPropertyName(location, literalToken) {\n      $traceurRuntime.superConstructor(LiteralPropertyName).call(this, location);\n      this.literalToken = literalToken;\n    }\n    return ($traceurRuntime.createClass)(LiteralPropertyName, {\n      transform: function(transformer) {\n        return transformer.transformLiteralPropertyName(this);\n      },\n      visit: function(visitor) {\n        visitor.visitLiteralPropertyName(this);\n      },\n      get type() {\n        return LITERAL_PROPERTY_NAME;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var MEMBER_EXPRESSION = ParseTreeType.MEMBER_EXPRESSION;\n  var MemberExpression = function($__super) {\n    function MemberExpression(location, operand, memberName) {\n      $traceurRuntime.superConstructor(MemberExpression).call(this, location);\n      this.operand = operand;\n      this.memberName = memberName;\n    }\n    return ($traceurRuntime.createClass)(MemberExpression, {\n      transform: function(transformer) {\n        return transformer.transformMemberExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitMemberExpression(this);\n      },\n      get type() {\n        return MEMBER_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var MEMBER_LOOKUP_EXPRESSION = ParseTreeType.MEMBER_LOOKUP_EXPRESSION;\n  var MemberLookupExpression = function($__super) {\n    function MemberLookupExpression(location, operand, memberExpression) {\n      $traceurRuntime.superConstructor(MemberLookupExpression).call(this, location);\n      this.operand = operand;\n      this.memberExpression = memberExpression;\n    }\n    return ($traceurRuntime.createClass)(MemberLookupExpression, {\n      transform: function(transformer) {\n        return transformer.transformMemberLookupExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitMemberLookupExpression(this);\n      },\n      get type() {\n        return MEMBER_LOOKUP_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var METHOD = ParseTreeType.METHOD;\n  var Method = function($__super) {\n    function Method(location, isStatic, functionKind, name, parameterList, typeAnnotation, annotations, body, debugName) {\n      $traceurRuntime.superConstructor(Method).call(this, location);\n      this.isStatic = isStatic;\n      this.functionKind = functionKind;\n      this.name = name;\n      this.parameterList = parameterList;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n      this.body = body;\n      this.debugName = debugName;\n    }\n    return ($traceurRuntime.createClass)(Method, {\n      transform: function(transformer) {\n        return transformer.transformMethod(this);\n      },\n      visit: function(visitor) {\n        visitor.visitMethod(this);\n      },\n      get type() {\n        return METHOD;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var METHOD_SIGNATURE = ParseTreeType.METHOD_SIGNATURE;\n  var MethodSignature = function($__super) {\n    function MethodSignature(location, name, optional, callSignature) {\n      $traceurRuntime.superConstructor(MethodSignature).call(this, location);\n      this.name = name;\n      this.optional = optional;\n      this.callSignature = callSignature;\n    }\n    return ($traceurRuntime.createClass)(MethodSignature, {\n      transform: function(transformer) {\n        return transformer.transformMethodSignature(this);\n      },\n      visit: function(visitor) {\n        visitor.visitMethodSignature(this);\n      },\n      get type() {\n        return METHOD_SIGNATURE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var MODULE = ParseTreeType.MODULE;\n  var Module = function($__super) {\n    function Module(location, scriptItemList, moduleName) {\n      $traceurRuntime.superConstructor(Module).call(this, location);\n      this.scriptItemList = scriptItemList;\n      this.moduleName = moduleName;\n    }\n    return ($traceurRuntime.createClass)(Module, {\n      transform: function(transformer) {\n        return transformer.transformModule(this);\n      },\n      visit: function(visitor) {\n        visitor.visitModule(this);\n      },\n      get type() {\n        return MODULE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var MODULE_SPECIFIER = ParseTreeType.MODULE_SPECIFIER;\n  var ModuleSpecifier = function($__super) {\n    function ModuleSpecifier(location, token) {\n      $traceurRuntime.superConstructor(ModuleSpecifier).call(this, location);\n      this.token = token;\n    }\n    return ($traceurRuntime.createClass)(ModuleSpecifier, {\n      transform: function(transformer) {\n        return transformer.transformModuleSpecifier(this);\n      },\n      visit: function(visitor) {\n        visitor.visitModuleSpecifier(this);\n      },\n      get type() {\n        return MODULE_SPECIFIER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var NAME_SPACE_EXPORT = ParseTreeType.NAME_SPACE_EXPORT;\n  var NameSpaceExport = function($__super) {\n    function NameSpaceExport(location, name) {\n      $traceurRuntime.superConstructor(NameSpaceExport).call(this, location);\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(NameSpaceExport, {\n      transform: function(transformer) {\n        return transformer.transformNameSpaceExport(this);\n      },\n      visit: function(visitor) {\n        visitor.visitNameSpaceExport(this);\n      },\n      get type() {\n        return NAME_SPACE_EXPORT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var NAME_SPACE_IMPORT = ParseTreeType.NAME_SPACE_IMPORT;\n  var NameSpaceImport = function($__super) {\n    function NameSpaceImport(location, binding) {\n      $traceurRuntime.superConstructor(NameSpaceImport).call(this, location);\n      this.binding = binding;\n    }\n    return ($traceurRuntime.createClass)(NameSpaceImport, {\n      transform: function(transformer) {\n        return transformer.transformNameSpaceImport(this);\n      },\n      visit: function(visitor) {\n        visitor.visitNameSpaceImport(this);\n      },\n      get type() {\n        return NAME_SPACE_IMPORT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var NAMED_EXPORT = ParseTreeType.NAMED_EXPORT;\n  var NamedExport = function($__super) {\n    function NamedExport(location, exportClause, moduleSpecifier) {\n      $traceurRuntime.superConstructor(NamedExport).call(this, location);\n      this.exportClause = exportClause;\n      this.moduleSpecifier = moduleSpecifier;\n    }\n    return ($traceurRuntime.createClass)(NamedExport, {\n      transform: function(transformer) {\n        return transformer.transformNamedExport(this);\n      },\n      visit: function(visitor) {\n        visitor.visitNamedExport(this);\n      },\n      get type() {\n        return NAMED_EXPORT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var NEW_EXPRESSION = ParseTreeType.NEW_EXPRESSION;\n  var NewExpression = function($__super) {\n    function NewExpression(location, operand, args) {\n      $traceurRuntime.superConstructor(NewExpression).call(this, location);\n      this.operand = operand;\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(NewExpression, {\n      transform: function(transformer) {\n        return transformer.transformNewExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitNewExpression(this);\n      },\n      get type() {\n        return NEW_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var OBJECT_LITERAL = ParseTreeType.OBJECT_LITERAL;\n  var ObjectLiteral = function($__super) {\n    function ObjectLiteral(location, propertyNameAndValues) {\n      $traceurRuntime.superConstructor(ObjectLiteral).call(this, location);\n      this.propertyNameAndValues = propertyNameAndValues;\n    }\n    return ($traceurRuntime.createClass)(ObjectLiteral, {\n      transform: function(transformer) {\n        return transformer.transformObjectLiteral(this);\n      },\n      visit: function(visitor) {\n        visitor.visitObjectLiteral(this);\n      },\n      get type() {\n        return OBJECT_LITERAL;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var OBJECT_PATTERN = ParseTreeType.OBJECT_PATTERN;\n  var ObjectPattern = function($__super) {\n    function ObjectPattern(location, fields) {\n      $traceurRuntime.superConstructor(ObjectPattern).call(this, location);\n      this.fields = fields;\n    }\n    return ($traceurRuntime.createClass)(ObjectPattern, {\n      transform: function(transformer) {\n        return transformer.transformObjectPattern(this);\n      },\n      visit: function(visitor) {\n        visitor.visitObjectPattern(this);\n      },\n      get type() {\n        return OBJECT_PATTERN;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var OBJECT_PATTERN_FIELD = ParseTreeType.OBJECT_PATTERN_FIELD;\n  var ObjectPatternField = function($__super) {\n    function ObjectPatternField(location, name, element) {\n      $traceurRuntime.superConstructor(ObjectPatternField).call(this, location);\n      this.name = name;\n      this.element = element;\n    }\n    return ($traceurRuntime.createClass)(ObjectPatternField, {\n      transform: function(transformer) {\n        return transformer.transformObjectPatternField(this);\n      },\n      visit: function(visitor) {\n        visitor.visitObjectPatternField(this);\n      },\n      get type() {\n        return OBJECT_PATTERN_FIELD;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var OBJECT_TYPE = ParseTreeType.OBJECT_TYPE;\n  var ObjectType = function($__super) {\n    function ObjectType(location, typeMembers) {\n      $traceurRuntime.superConstructor(ObjectType).call(this, location);\n      this.typeMembers = typeMembers;\n    }\n    return ($traceurRuntime.createClass)(ObjectType, {\n      transform: function(transformer) {\n        return transformer.transformObjectType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitObjectType(this);\n      },\n      get type() {\n        return OBJECT_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PAREN_EXPRESSION = ParseTreeType.PAREN_EXPRESSION;\n  var ParenExpression = function($__super) {\n    function ParenExpression(location, expression) {\n      $traceurRuntime.superConstructor(ParenExpression).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ParenExpression, {\n      transform: function(transformer) {\n        return transformer.transformParenExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitParenExpression(this);\n      },\n      get type() {\n        return PAREN_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var POSTFIX_EXPRESSION = ParseTreeType.POSTFIX_EXPRESSION;\n  var PostfixExpression = function($__super) {\n    function PostfixExpression(location, operand, operator) {\n      $traceurRuntime.superConstructor(PostfixExpression).call(this, location);\n      this.operand = operand;\n      this.operator = operator;\n    }\n    return ($traceurRuntime.createClass)(PostfixExpression, {\n      transform: function(transformer) {\n        return transformer.transformPostfixExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPostfixExpression(this);\n      },\n      get type() {\n        return POSTFIX_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PREDEFINED_TYPE = ParseTreeType.PREDEFINED_TYPE;\n  var PredefinedType = function($__super) {\n    function PredefinedType(location, typeToken) {\n      $traceurRuntime.superConstructor(PredefinedType).call(this, location);\n      this.typeToken = typeToken;\n    }\n    return ($traceurRuntime.createClass)(PredefinedType, {\n      transform: function(transformer) {\n        return transformer.transformPredefinedType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPredefinedType(this);\n      },\n      get type() {\n        return PREDEFINED_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SCRIPT = ParseTreeType.SCRIPT;\n  var Script = function($__super) {\n    function Script(location, scriptItemList, moduleName) {\n      $traceurRuntime.superConstructor(Script).call(this, location);\n      this.scriptItemList = scriptItemList;\n      this.moduleName = moduleName;\n    }\n    return ($traceurRuntime.createClass)(Script, {\n      transform: function(transformer) {\n        return transformer.transformScript(this);\n      },\n      visit: function(visitor) {\n        visitor.visitScript(this);\n      },\n      get type() {\n        return SCRIPT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PROPERTY_NAME_ASSIGNMENT = ParseTreeType.PROPERTY_NAME_ASSIGNMENT;\n  var PropertyNameAssignment = function($__super) {\n    function PropertyNameAssignment(location, name, value) {\n      $traceurRuntime.superConstructor(PropertyNameAssignment).call(this, location);\n      this.name = name;\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(PropertyNameAssignment, {\n      transform: function(transformer) {\n        return transformer.transformPropertyNameAssignment(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPropertyNameAssignment(this);\n      },\n      get type() {\n        return PROPERTY_NAME_ASSIGNMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PROPERTY_NAME_SHORTHAND = ParseTreeType.PROPERTY_NAME_SHORTHAND;\n  var PropertyNameShorthand = function($__super) {\n    function PropertyNameShorthand(location, name) {\n      $traceurRuntime.superConstructor(PropertyNameShorthand).call(this, location);\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(PropertyNameShorthand, {\n      transform: function(transformer) {\n        return transformer.transformPropertyNameShorthand(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPropertyNameShorthand(this);\n      },\n      get type() {\n        return PROPERTY_NAME_SHORTHAND;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PROPERTY_VARIABLE_DECLARATION = ParseTreeType.PROPERTY_VARIABLE_DECLARATION;\n  var PropertyVariableDeclaration = function($__super) {\n    function PropertyVariableDeclaration(location, isStatic, name, typeAnnotation, annotations, initializer) {\n      $traceurRuntime.superConstructor(PropertyVariableDeclaration).call(this, location);\n      this.isStatic = isStatic;\n      this.name = name;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(PropertyVariableDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformPropertyVariableDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPropertyVariableDeclaration(this);\n      },\n      get type() {\n        return PROPERTY_VARIABLE_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PROPERTY_SIGNATURE = ParseTreeType.PROPERTY_SIGNATURE;\n  var PropertySignature = function($__super) {\n    function PropertySignature(location, name, optional, typeAnnotation) {\n      $traceurRuntime.superConstructor(PropertySignature).call(this, location);\n      this.name = name;\n      this.optional = optional;\n      this.typeAnnotation = typeAnnotation;\n    }\n    return ($traceurRuntime.createClass)(PropertySignature, {\n      transform: function(transformer) {\n        return transformer.transformPropertySignature(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPropertySignature(this);\n      },\n      get type() {\n        return PROPERTY_SIGNATURE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var REST_PARAMETER = ParseTreeType.REST_PARAMETER;\n  var RestParameter = function($__super) {\n    function RestParameter(location, identifier) {\n      $traceurRuntime.superConstructor(RestParameter).call(this, location);\n      this.identifier = identifier;\n    }\n    return ($traceurRuntime.createClass)(RestParameter, {\n      transform: function(transformer) {\n        return transformer.transformRestParameter(this);\n      },\n      visit: function(visitor) {\n        visitor.visitRestParameter(this);\n      },\n      get type() {\n        return REST_PARAMETER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var RETURN_STATEMENT = ParseTreeType.RETURN_STATEMENT;\n  var ReturnStatement = function($__super) {\n    function ReturnStatement(location, expression) {\n      $traceurRuntime.superConstructor(ReturnStatement).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ReturnStatement, {\n      transform: function(transformer) {\n        return transformer.transformReturnStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitReturnStatement(this);\n      },\n      get type() {\n        return RETURN_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SET_ACCESSOR = ParseTreeType.SET_ACCESSOR;\n  var SetAccessor = function($__super) {\n    function SetAccessor(location, isStatic, name, parameterList, annotations, body) {\n      $traceurRuntime.superConstructor(SetAccessor).call(this, location);\n      this.isStatic = isStatic;\n      this.name = name;\n      this.parameterList = parameterList;\n      this.annotations = annotations;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(SetAccessor, {\n      transform: function(transformer) {\n        return transformer.transformSetAccessor(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSetAccessor(this);\n      },\n      get type() {\n        return SET_ACCESSOR;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SPREAD_EXPRESSION = ParseTreeType.SPREAD_EXPRESSION;\n  var SpreadExpression = function($__super) {\n    function SpreadExpression(location, expression) {\n      $traceurRuntime.superConstructor(SpreadExpression).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(SpreadExpression, {\n      transform: function(transformer) {\n        return transformer.transformSpreadExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSpreadExpression(this);\n      },\n      get type() {\n        return SPREAD_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SPREAD_PATTERN_ELEMENT = ParseTreeType.SPREAD_PATTERN_ELEMENT;\n  var SpreadPatternElement = function($__super) {\n    function SpreadPatternElement(location, lvalue) {\n      $traceurRuntime.superConstructor(SpreadPatternElement).call(this, location);\n      this.lvalue = lvalue;\n    }\n    return ($traceurRuntime.createClass)(SpreadPatternElement, {\n      transform: function(transformer) {\n        return transformer.transformSpreadPatternElement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSpreadPatternElement(this);\n      },\n      get type() {\n        return SPREAD_PATTERN_ELEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SUPER_EXPRESSION = ParseTreeType.SUPER_EXPRESSION;\n  var SuperExpression = function($__super) {\n    function SuperExpression(location) {\n      $traceurRuntime.superConstructor(SuperExpression).call(this, location);\n    }\n    return ($traceurRuntime.createClass)(SuperExpression, {\n      transform: function(transformer) {\n        return transformer.transformSuperExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSuperExpression(this);\n      },\n      get type() {\n        return SUPER_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SWITCH_STATEMENT = ParseTreeType.SWITCH_STATEMENT;\n  var SwitchStatement = function($__super) {\n    function SwitchStatement(location, expression, caseClauses) {\n      $traceurRuntime.superConstructor(SwitchStatement).call(this, location);\n      this.expression = expression;\n      this.caseClauses = caseClauses;\n    }\n    return ($traceurRuntime.createClass)(SwitchStatement, {\n      transform: function(transformer) {\n        return transformer.transformSwitchStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSwitchStatement(this);\n      },\n      get type() {\n        return SWITCH_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SYNTAX_ERROR_TREE = ParseTreeType.SYNTAX_ERROR_TREE;\n  var SyntaxErrorTree = function($__super) {\n    function SyntaxErrorTree(location, nextToken, message) {\n      $traceurRuntime.superConstructor(SyntaxErrorTree).call(this, location);\n      this.nextToken = nextToken;\n      this.message = message;\n    }\n    return ($traceurRuntime.createClass)(SyntaxErrorTree, {\n      transform: function(transformer) {\n        return transformer.transformSyntaxErrorTree(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSyntaxErrorTree(this);\n      },\n      get type() {\n        return SYNTAX_ERROR_TREE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TEMPLATE_LITERAL_EXPRESSION = ParseTreeType.TEMPLATE_LITERAL_EXPRESSION;\n  var TemplateLiteralExpression = function($__super) {\n    function TemplateLiteralExpression(location, operand, elements) {\n      $traceurRuntime.superConstructor(TemplateLiteralExpression).call(this, location);\n      this.operand = operand;\n      this.elements = elements;\n    }\n    return ($traceurRuntime.createClass)(TemplateLiteralExpression, {\n      transform: function(transformer) {\n        return transformer.transformTemplateLiteralExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTemplateLiteralExpression(this);\n      },\n      get type() {\n        return TEMPLATE_LITERAL_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TEMPLATE_LITERAL_PORTION = ParseTreeType.TEMPLATE_LITERAL_PORTION;\n  var TemplateLiteralPortion = function($__super) {\n    function TemplateLiteralPortion(location, value) {\n      $traceurRuntime.superConstructor(TemplateLiteralPortion).call(this, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(TemplateLiteralPortion, {\n      transform: function(transformer) {\n        return transformer.transformTemplateLiteralPortion(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTemplateLiteralPortion(this);\n      },\n      get type() {\n        return TEMPLATE_LITERAL_PORTION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TEMPLATE_SUBSTITUTION = ParseTreeType.TEMPLATE_SUBSTITUTION;\n  var TemplateSubstitution = function($__super) {\n    function TemplateSubstitution(location, expression) {\n      $traceurRuntime.superConstructor(TemplateSubstitution).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(TemplateSubstitution, {\n      transform: function(transformer) {\n        return transformer.transformTemplateSubstitution(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTemplateSubstitution(this);\n      },\n      get type() {\n        return TEMPLATE_SUBSTITUTION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var THIS_EXPRESSION = ParseTreeType.THIS_EXPRESSION;\n  var ThisExpression = function($__super) {\n    function ThisExpression(location) {\n      $traceurRuntime.superConstructor(ThisExpression).call(this, location);\n    }\n    return ($traceurRuntime.createClass)(ThisExpression, {\n      transform: function(transformer) {\n        return transformer.transformThisExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitThisExpression(this);\n      },\n      get type() {\n        return THIS_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var THROW_STATEMENT = ParseTreeType.THROW_STATEMENT;\n  var ThrowStatement = function($__super) {\n    function ThrowStatement(location, value) {\n      $traceurRuntime.superConstructor(ThrowStatement).call(this, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(ThrowStatement, {\n      transform: function(transformer) {\n        return transformer.transformThrowStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitThrowStatement(this);\n      },\n      get type() {\n        return THROW_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TRY_STATEMENT = ParseTreeType.TRY_STATEMENT;\n  var TryStatement = function($__super) {\n    function TryStatement(location, body, catchBlock, finallyBlock) {\n      $traceurRuntime.superConstructor(TryStatement).call(this, location);\n      this.body = body;\n      this.catchBlock = catchBlock;\n      this.finallyBlock = finallyBlock;\n    }\n    return ($traceurRuntime.createClass)(TryStatement, {\n      transform: function(transformer) {\n        return transformer.transformTryStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTryStatement(this);\n      },\n      get type() {\n        return TRY_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_ALIAS_DECLARATION = ParseTreeType.TYPE_ALIAS_DECLARATION;\n  var TypeAliasDeclaration = function($__super) {\n    function TypeAliasDeclaration(location, name, value) {\n      $traceurRuntime.superConstructor(TypeAliasDeclaration).call(this, location);\n      this.name = name;\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(TypeAliasDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformTypeAliasDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeAliasDeclaration(this);\n      },\n      get type() {\n        return TYPE_ALIAS_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_ARGUMENTS = ParseTreeType.TYPE_ARGUMENTS;\n  var TypeArguments = function($__super) {\n    function TypeArguments(location, args) {\n      $traceurRuntime.superConstructor(TypeArguments).call(this, location);\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(TypeArguments, {\n      transform: function(transformer) {\n        return transformer.transformTypeArguments(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeArguments(this);\n      },\n      get type() {\n        return TYPE_ARGUMENTS;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_NAME = ParseTreeType.TYPE_NAME;\n  var TypeName = function($__super) {\n    function TypeName(location, moduleName, name) {\n      $traceurRuntime.superConstructor(TypeName).call(this, location);\n      this.moduleName = moduleName;\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(TypeName, {\n      transform: function(transformer) {\n        return transformer.transformTypeName(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeName(this);\n      },\n      get type() {\n        return TYPE_NAME;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_PARAMETER = ParseTreeType.TYPE_PARAMETER;\n  var TypeParameter = function($__super) {\n    function TypeParameter(location, identifierToken, extendsType) {\n      $traceurRuntime.superConstructor(TypeParameter).call(this, location);\n      this.identifierToken = identifierToken;\n      this.extendsType = extendsType;\n    }\n    return ($traceurRuntime.createClass)(TypeParameter, {\n      transform: function(transformer) {\n        return transformer.transformTypeParameter(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeParameter(this);\n      },\n      get type() {\n        return TYPE_PARAMETER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_PARAMETERS = ParseTreeType.TYPE_PARAMETERS;\n  var TypeParameters = function($__super) {\n    function TypeParameters(location, parameters) {\n      $traceurRuntime.superConstructor(TypeParameters).call(this, location);\n      this.parameters = parameters;\n    }\n    return ($traceurRuntime.createClass)(TypeParameters, {\n      transform: function(transformer) {\n        return transformer.transformTypeParameters(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeParameters(this);\n      },\n      get type() {\n        return TYPE_PARAMETERS;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_REFERENCE = ParseTreeType.TYPE_REFERENCE;\n  var TypeReference = function($__super) {\n    function TypeReference(location, typeName, args) {\n      $traceurRuntime.superConstructor(TypeReference).call(this, location);\n      this.typeName = typeName;\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(TypeReference, {\n      transform: function(transformer) {\n        return transformer.transformTypeReference(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeReference(this);\n      },\n      get type() {\n        return TYPE_REFERENCE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var UNARY_EXPRESSION = ParseTreeType.UNARY_EXPRESSION;\n  var UnaryExpression = function($__super) {\n    function UnaryExpression(location, operator, operand) {\n      $traceurRuntime.superConstructor(UnaryExpression).call(this, location);\n      this.operator = operator;\n      this.operand = operand;\n    }\n    return ($traceurRuntime.createClass)(UnaryExpression, {\n      transform: function(transformer) {\n        return transformer.transformUnaryExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitUnaryExpression(this);\n      },\n      get type() {\n        return UNARY_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var UNION_TYPE = ParseTreeType.UNION_TYPE;\n  var UnionType = function($__super) {\n    function UnionType(location, types) {\n      $traceurRuntime.superConstructor(UnionType).call(this, location);\n      this.types = types;\n    }\n    return ($traceurRuntime.createClass)(UnionType, {\n      transform: function(transformer) {\n        return transformer.transformUnionType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitUnionType(this);\n      },\n      get type() {\n        return UNION_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var VARIABLE_DECLARATION = ParseTreeType.VARIABLE_DECLARATION;\n  var VariableDeclaration = function($__super) {\n    function VariableDeclaration(location, lvalue, typeAnnotation, initializer) {\n      $traceurRuntime.superConstructor(VariableDeclaration).call(this, location);\n      this.lvalue = lvalue;\n      this.typeAnnotation = typeAnnotation;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(VariableDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformVariableDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitVariableDeclaration(this);\n      },\n      get type() {\n        return VARIABLE_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var VARIABLE_DECLARATION_LIST = ParseTreeType.VARIABLE_DECLARATION_LIST;\n  var VariableDeclarationList = function($__super) {\n    function VariableDeclarationList(location, declarationType, declarations) {\n      $traceurRuntime.superConstructor(VariableDeclarationList).call(this, location);\n      this.declarationType = declarationType;\n      this.declarations = declarations;\n    }\n    return ($traceurRuntime.createClass)(VariableDeclarationList, {\n      transform: function(transformer) {\n        return transformer.transformVariableDeclarationList(this);\n      },\n      visit: function(visitor) {\n        visitor.visitVariableDeclarationList(this);\n      },\n      get type() {\n        return VARIABLE_DECLARATION_LIST;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var VARIABLE_STATEMENT = ParseTreeType.VARIABLE_STATEMENT;\n  var VariableStatement = function($__super) {\n    function VariableStatement(location, declarations) {\n      $traceurRuntime.superConstructor(VariableStatement).call(this, location);\n      this.declarations = declarations;\n    }\n    return ($traceurRuntime.createClass)(VariableStatement, {\n      transform: function(transformer) {\n        return transformer.transformVariableStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitVariableStatement(this);\n      },\n      get type() {\n        return VARIABLE_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var WHILE_STATEMENT = ParseTreeType.WHILE_STATEMENT;\n  var WhileStatement = function($__super) {\n    function WhileStatement(location, condition, body) {\n      $traceurRuntime.superConstructor(WhileStatement).call(this, location);\n      this.condition = condition;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(WhileStatement, {\n      transform: function(transformer) {\n        return transformer.transformWhileStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitWhileStatement(this);\n      },\n      get type() {\n        return WHILE_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var WITH_STATEMENT = ParseTreeType.WITH_STATEMENT;\n  var WithStatement = function($__super) {\n    function WithStatement(location, expression, body) {\n      $traceurRuntime.superConstructor(WithStatement).call(this, location);\n      this.expression = expression;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(WithStatement, {\n      transform: function(transformer) {\n        return transformer.transformWithStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitWithStatement(this);\n      },\n      get type() {\n        return WITH_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var YIELD_EXPRESSION = ParseTreeType.YIELD_EXPRESSION;\n  var YieldExpression = function($__super) {\n    function YieldExpression(location, expression, isYieldFor) {\n      $traceurRuntime.superConstructor(YieldExpression).call(this, location);\n      this.expression = expression;\n      this.isYieldFor = isYieldFor;\n    }\n    return ($traceurRuntime.createClass)(YieldExpression, {\n      transform: function(transformer) {\n        return transformer.transformYieldExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitYieldExpression(this);\n      },\n      get type() {\n        return YIELD_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  return {\n    get Annotation() {\n      return Annotation;\n    },\n    get AnonBlock() {\n      return AnonBlock;\n    },\n    get ArgumentList() {\n      return ArgumentList;\n    },\n    get ArrayComprehension() {\n      return ArrayComprehension;\n    },\n    get ArrayLiteral() {\n      return ArrayLiteral;\n    },\n    get ArrayPattern() {\n      return ArrayPattern;\n    },\n    get ArrayType() {\n      return ArrayType;\n    },\n    get ArrowFunction() {\n      return ArrowFunction;\n    },\n    get AssignmentElement() {\n      return AssignmentElement;\n    },\n    get AwaitExpression() {\n      return AwaitExpression;\n    },\n    get BinaryExpression() {\n      return BinaryExpression;\n    },\n    get BindingElement() {\n      return BindingElement;\n    },\n    get BindingIdentifier() {\n      return BindingIdentifier;\n    },\n    get Block() {\n      return Block;\n    },\n    get BreakStatement() {\n      return BreakStatement;\n    },\n    get CallExpression() {\n      return CallExpression;\n    },\n    get CallSignature() {\n      return CallSignature;\n    },\n    get CaseClause() {\n      return CaseClause;\n    },\n    get Catch() {\n      return Catch;\n    },\n    get ClassDeclaration() {\n      return ClassDeclaration;\n    },\n    get ClassExpression() {\n      return ClassExpression;\n    },\n    get CommaExpression() {\n      return CommaExpression;\n    },\n    get ComprehensionFor() {\n      return ComprehensionFor;\n    },\n    get ComprehensionIf() {\n      return ComprehensionIf;\n    },\n    get ComputedPropertyName() {\n      return ComputedPropertyName;\n    },\n    get ConditionalExpression() {\n      return ConditionalExpression;\n    },\n    get ConstructSignature() {\n      return ConstructSignature;\n    },\n    get ConstructorType() {\n      return ConstructorType;\n    },\n    get ContinueStatement() {\n      return ContinueStatement;\n    },\n    get CoverFormals() {\n      return CoverFormals;\n    },\n    get CoverInitializedName() {\n      return CoverInitializedName;\n    },\n    get DebuggerStatement() {\n      return DebuggerStatement;\n    },\n    get DefaultClause() {\n      return DefaultClause;\n    },\n    get DoWhileStatement() {\n      return DoWhileStatement;\n    },\n    get EmptyStatement() {\n      return EmptyStatement;\n    },\n    get ExportDeclaration() {\n      return ExportDeclaration;\n    },\n    get ExportDefault() {\n      return ExportDefault;\n    },\n    get ExportSpecifier() {\n      return ExportSpecifier;\n    },\n    get ExportSpecifierSet() {\n      return ExportSpecifierSet;\n    },\n    get ExportStar() {\n      return ExportStar;\n    },\n    get ExpressionStatement() {\n      return ExpressionStatement;\n    },\n    get Finally() {\n      return Finally;\n    },\n    get ForInStatement() {\n      return ForInStatement;\n    },\n    get ForOfStatement() {\n      return ForOfStatement;\n    },\n    get ForOnStatement() {\n      return ForOnStatement;\n    },\n    get ForStatement() {\n      return ForStatement;\n    },\n    get FormalParameter() {\n      return FormalParameter;\n    },\n    get FormalParameterList() {\n      return FormalParameterList;\n    },\n    get ForwardDefaultExport() {\n      return ForwardDefaultExport;\n    },\n    get FunctionBody() {\n      return FunctionBody;\n    },\n    get FunctionDeclaration() {\n      return FunctionDeclaration;\n    },\n    get FunctionExpression() {\n      return FunctionExpression;\n    },\n    get FunctionType() {\n      return FunctionType;\n    },\n    get GeneratorComprehension() {\n      return GeneratorComprehension;\n    },\n    get GetAccessor() {\n      return GetAccessor;\n    },\n    get IdentifierExpression() {\n      return IdentifierExpression;\n    },\n    get IfStatement() {\n      return IfStatement;\n    },\n    get ImportedBinding() {\n      return ImportedBinding;\n    },\n    get ImportClausePair() {\n      return ImportClausePair;\n    },\n    get ImportDeclaration() {\n      return ImportDeclaration;\n    },\n    get ImportSpecifier() {\n      return ImportSpecifier;\n    },\n    get ImportSpecifierSet() {\n      return ImportSpecifierSet;\n    },\n    get ImportTypeClause() {\n      return ImportTypeClause;\n    },\n    get IndexSignature() {\n      return IndexSignature;\n    },\n    get InterfaceDeclaration() {\n      return InterfaceDeclaration;\n    },\n    get JsxAttribute() {\n      return JsxAttribute;\n    },\n    get JsxElement() {\n      return JsxElement;\n    },\n    get JsxElementName() {\n      return JsxElementName;\n    },\n    get JsxPlaceholder() {\n      return JsxPlaceholder;\n    },\n    get JsxSpreadAttribute() {\n      return JsxSpreadAttribute;\n    },\n    get JsxText() {\n      return JsxText;\n    },\n    get LabelledStatement() {\n      return LabelledStatement;\n    },\n    get LiteralExpression() {\n      return LiteralExpression;\n    },\n    get LiteralPropertyName() {\n      return LiteralPropertyName;\n    },\n    get MemberExpression() {\n      return MemberExpression;\n    },\n    get MemberLookupExpression() {\n      return MemberLookupExpression;\n    },\n    get Method() {\n      return Method;\n    },\n    get MethodSignature() {\n      return MethodSignature;\n    },\n    get Module() {\n      return Module;\n    },\n    get ModuleSpecifier() {\n      return ModuleSpecifier;\n    },\n    get NameSpaceExport() {\n      return NameSpaceExport;\n    },\n    get NameSpaceImport() {\n      return NameSpaceImport;\n    },\n    get NamedExport() {\n      return NamedExport;\n    },\n    get NewExpression() {\n      return NewExpression;\n    },\n    get ObjectLiteral() {\n      return ObjectLiteral;\n    },\n    get ObjectPattern() {\n      return ObjectPattern;\n    },\n    get ObjectPatternField() {\n      return ObjectPatternField;\n    },\n    get ObjectType() {\n      return ObjectType;\n    },\n    get ParenExpression() {\n      return ParenExpression;\n    },\n    get PostfixExpression() {\n      return PostfixExpression;\n    },\n    get PredefinedType() {\n      return PredefinedType;\n    },\n    get Script() {\n      return Script;\n    },\n    get PropertyNameAssignment() {\n      return PropertyNameAssignment;\n    },\n    get PropertyNameShorthand() {\n      return PropertyNameShorthand;\n    },\n    get PropertyVariableDeclaration() {\n      return PropertyVariableDeclaration;\n    },\n    get PropertySignature() {\n      return PropertySignature;\n    },\n    get RestParameter() {\n      return RestParameter;\n    },\n    get ReturnStatement() {\n      return ReturnStatement;\n    },\n    get SetAccessor() {\n      return SetAccessor;\n    },\n    get SpreadExpression() {\n      return SpreadExpression;\n    },\n    get SpreadPatternElement() {\n      return SpreadPatternElement;\n    },\n    get SuperExpression() {\n      return SuperExpression;\n    },\n    get SwitchStatement() {\n      return SwitchStatement;\n    },\n    get SyntaxErrorTree() {\n      return SyntaxErrorTree;\n    },\n    get TemplateLiteralExpression() {\n      return TemplateLiteralExpression;\n    },\n    get TemplateLiteralPortion() {\n      return TemplateLiteralPortion;\n    },\n    get TemplateSubstitution() {\n      return TemplateSubstitution;\n    },\n    get ThisExpression() {\n      return ThisExpression;\n    },\n    get ThrowStatement() {\n      return ThrowStatement;\n    },\n    get TryStatement() {\n      return TryStatement;\n    },\n    get TypeAliasDeclaration() {\n      return TypeAliasDeclaration;\n    },\n    get TypeArguments() {\n      return TypeArguments;\n    },\n    get TypeName() {\n      return TypeName;\n    },\n    get TypeParameter() {\n      return TypeParameter;\n    },\n    get TypeParameters() {\n      return TypeParameters;\n    },\n    get TypeReference() {\n      return TypeReference;\n    },\n    get UnaryExpression() {\n      return UnaryExpression;\n    },\n    get UnionType() {\n      return UnionType;\n    },\n    get VariableDeclaration() {\n      return VariableDeclaration;\n    },\n    get VariableDeclarationList() {\n      return VariableDeclarationList;\n    },\n    get VariableStatement() {\n      return VariableStatement;\n    },\n    get WhileStatement() {\n      return WhileStatement;\n    },\n    get WithStatement() {\n      return WithStatement;\n    },\n    get YieldExpression() {\n      return YieldExpression;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ParseTreeTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ParseTreeTransformer.js";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ParseTreeTransformer.js")),\n      Annotation = $__2.Annotation,\n      AnonBlock = $__2.AnonBlock,\n      ArgumentList = $__2.ArgumentList,\n      ArrayComprehension = $__2.ArrayComprehension,\n      ArrayLiteral = $__2.ArrayLiteral,\n      ArrayPattern = $__2.ArrayPattern,\n      ArrayType = $__2.ArrayType,\n      ArrowFunction = $__2.ArrowFunction,\n      AssignmentElement = $__2.AssignmentElement,\n      AwaitExpression = $__2.AwaitExpression,\n      BinaryExpression = $__2.BinaryExpression,\n      BindingElement = $__2.BindingElement,\n      BindingIdentifier = $__2.BindingIdentifier,\n      Block = $__2.Block,\n      BreakStatement = $__2.BreakStatement,\n      CallExpression = $__2.CallExpression,\n      CallSignature = $__2.CallSignature,\n      CaseClause = $__2.CaseClause,\n      Catch = $__2.Catch,\n      ClassDeclaration = $__2.ClassDeclaration,\n      ClassExpression = $__2.ClassExpression,\n      CommaExpression = $__2.CommaExpression,\n      ComprehensionFor = $__2.ComprehensionFor,\n      ComprehensionIf = $__2.ComprehensionIf,\n      ComputedPropertyName = $__2.ComputedPropertyName,\n      ConditionalExpression = $__2.ConditionalExpression,\n      ConstructSignature = $__2.ConstructSignature,\n      ConstructorType = $__2.ConstructorType,\n      ContinueStatement = $__2.ContinueStatement,\n      CoverFormals = $__2.CoverFormals,\n      CoverInitializedName = $__2.CoverInitializedName,\n      DebuggerStatement = $__2.DebuggerStatement,\n      DefaultClause = $__2.DefaultClause,\n      DoWhileStatement = $__2.DoWhileStatement,\n      EmptyStatement = $__2.EmptyStatement,\n      ExportDeclaration = $__2.ExportDeclaration,\n      ExportDefault = $__2.ExportDefault,\n      ExportSpecifier = $__2.ExportSpecifier,\n      ExportSpecifierSet = $__2.ExportSpecifierSet,\n      ExportStar = $__2.ExportStar,\n      ExpressionStatement = $__2.ExpressionStatement,\n      Finally = $__2.Finally,\n      ForInStatement = $__2.ForInStatement,\n      ForOfStatement = $__2.ForOfStatement,\n      ForOnStatement = $__2.ForOnStatement,\n      ForStatement = $__2.ForStatement,\n      FormalParameter = $__2.FormalParameter,\n      FormalParameterList = $__2.FormalParameterList,\n      ForwardDefaultExport = $__2.ForwardDefaultExport,\n      FunctionBody = $__2.FunctionBody,\n      FunctionDeclaration = $__2.FunctionDeclaration,\n      FunctionExpression = $__2.FunctionExpression,\n      FunctionType = $__2.FunctionType,\n      GeneratorComprehension = $__2.GeneratorComprehension,\n      GetAccessor = $__2.GetAccessor,\n      IdentifierExpression = $__2.IdentifierExpression,\n      IfStatement = $__2.IfStatement,\n      ImportedBinding = $__2.ImportedBinding,\n      ImportClausePair = $__2.ImportClausePair,\n      ImportDeclaration = $__2.ImportDeclaration,\n      ImportSpecifier = $__2.ImportSpecifier,\n      ImportSpecifierSet = $__2.ImportSpecifierSet,\n      ImportTypeClause = $__2.ImportTypeClause,\n      IndexSignature = $__2.IndexSignature,\n      InterfaceDeclaration = $__2.InterfaceDeclaration,\n      JsxAttribute = $__2.JsxAttribute,\n      JsxElement = $__2.JsxElement,\n      JsxElementName = $__2.JsxElementName,\n      JsxPlaceholder = $__2.JsxPlaceholder,\n      JsxSpreadAttribute = $__2.JsxSpreadAttribute,\n      JsxText = $__2.JsxText,\n      LabelledStatement = $__2.LabelledStatement,\n      LiteralExpression = $__2.LiteralExpression,\n      LiteralPropertyName = $__2.LiteralPropertyName,\n      MemberExpression = $__2.MemberExpression,\n      MemberLookupExpression = $__2.MemberLookupExpression,\n      Method = $__2.Method,\n      MethodSignature = $__2.MethodSignature,\n      Module = $__2.Module,\n      ModuleSpecifier = $__2.ModuleSpecifier,\n      NameSpaceExport = $__2.NameSpaceExport,\n      NameSpaceImport = $__2.NameSpaceImport,\n      NamedExport = $__2.NamedExport,\n      NewExpression = $__2.NewExpression,\n      ObjectLiteral = $__2.ObjectLiteral,\n      ObjectPattern = $__2.ObjectPattern,\n      ObjectPatternField = $__2.ObjectPatternField,\n      ObjectType = $__2.ObjectType,\n      ParenExpression = $__2.ParenExpression,\n      PostfixExpression = $__2.PostfixExpression,\n      PredefinedType = $__2.PredefinedType,\n      Script = $__2.Script,\n      PropertyNameAssignment = $__2.PropertyNameAssignment,\n      PropertyNameShorthand = $__2.PropertyNameShorthand,\n      PropertyVariableDeclaration = $__2.PropertyVariableDeclaration,\n      PropertySignature = $__2.PropertySignature,\n      RestParameter = $__2.RestParameter,\n      ReturnStatement = $__2.ReturnStatement,\n      SetAccessor = $__2.SetAccessor,\n      SpreadExpression = $__2.SpreadExpression,\n      SpreadPatternElement = $__2.SpreadPatternElement,\n      SuperExpression = $__2.SuperExpression,\n      SwitchStatement = $__2.SwitchStatement,\n      SyntaxErrorTree = $__2.SyntaxErrorTree,\n      TemplateLiteralExpression = $__2.TemplateLiteralExpression,\n      TemplateLiteralPortion = $__2.TemplateLiteralPortion,\n      TemplateSubstitution = $__2.TemplateSubstitution,\n      ThisExpression = $__2.ThisExpression,\n      ThrowStatement = $__2.ThrowStatement,\n      TryStatement = $__2.TryStatement,\n      TypeAliasDeclaration = $__2.TypeAliasDeclaration,\n      TypeArguments = $__2.TypeArguments,\n      TypeName = $__2.TypeName,\n      TypeParameter = $__2.TypeParameter,\n      TypeParameters = $__2.TypeParameters,\n      TypeReference = $__2.TypeReference,\n      UnaryExpression = $__2.UnaryExpression,\n      UnionType = $__2.UnionType,\n      VariableDeclaration = $__2.VariableDeclaration,\n      VariableDeclarationList = $__2.VariableDeclarationList,\n      VariableStatement = $__2.VariableStatement,\n      WhileStatement = $__2.WhileStatement,\n      WithStatement = $__2.WithStatement,\n      YieldExpression = $__2.YieldExpression;\n  var ParseTreeTransformer = function() {\n    function ParseTreeTransformer() {}\n    return ($traceurRuntime.createClass)(ParseTreeTransformer, {\n      transformAny: function(tree) {\n        return tree === null ? null : tree.transform(this);\n      },\n      transformList: function(list) {\n        var $__1;\n        var builder = null;\n        for (var index = 0; index < list.length; index++) {\n          var element = list[index];\n          var transformed = this.transformAny(element);\n          if (builder != null || element != transformed) {\n            if (builder === null) {\n              builder = list.slice(0, index);\n            }\n            if (transformed instanceof AnonBlock)\n              ($__1 = builder).push.apply($__1, $traceurRuntime.spread(transformed.statements));\n            else\n              builder.push(transformed);\n          }\n        }\n        return builder || list;\n      },\n      transformStateMachine: function(tree) {\n        throw Error(\'State machines should not live outside of the GeneratorTransformer.\');\n      },\n      transformToBlockOrStatement: function(tree) {\n        var transformed = this.transformAny(tree);\n        if (transformed instanceof AnonBlock) {\n          return new Block(transformed.location, transformed.statements);\n        }\n        return transformed;\n      },\n      transformAnnotation: function(tree) {\n        var name = this.transformAny(tree.name);\n        var args = this.transformAny(tree.args);\n        if (name === tree.name && args === tree.args) {\n          return tree;\n        }\n        return new Annotation(tree.location, name, args);\n      },\n      transformAnonBlock: function(tree) {\n        var statements = this.transformList(tree.statements);\n        if (statements === tree.statements) {\n          return tree;\n        }\n        return new AnonBlock(tree.location, statements);\n      },\n      transformArgumentList: function(tree) {\n        var args = this.transformList(tree.args);\n        if (args === tree.args) {\n          return tree;\n        }\n        return new ArgumentList(tree.location, args);\n      },\n      transformArrayComprehension: function(tree) {\n        var comprehensionList = this.transformList(tree.comprehensionList);\n        var expression = this.transformAny(tree.expression);\n        if (comprehensionList === tree.comprehensionList && expression === tree.expression) {\n          return tree;\n        }\n        return new ArrayComprehension(tree.location, comprehensionList, expression);\n      },\n      transformArrayLiteral: function(tree) {\n        var elements = this.transformList(tree.elements);\n        if (elements === tree.elements) {\n          return tree;\n        }\n        return new ArrayLiteral(tree.location, elements);\n      },\n      transformArrayPattern: function(tree) {\n        var elements = this.transformList(tree.elements);\n        if (elements === tree.elements) {\n          return tree;\n        }\n        return new ArrayPattern(tree.location, elements);\n      },\n      transformArrayType: function(tree) {\n        var elementType = this.transformAny(tree.elementType);\n        if (elementType === tree.elementType) {\n          return tree;\n        }\n        return new ArrayType(tree.location, elementType);\n      },\n      transformArrowFunction: function(tree) {\n        var parameterList = this.transformAny(tree.parameterList);\n        var body = this.transformAny(tree.body);\n        if (parameterList === tree.parameterList && body === tree.body) {\n          return tree;\n        }\n        return new ArrowFunction(tree.location, tree.functionKind, parameterList, body);\n      },\n      transformAssignmentElement: function(tree) {\n        var assignment = this.transformAny(tree.assignment);\n        var initializer = this.transformAny(tree.initializer);\n        if (assignment === tree.assignment && initializer === tree.initializer) {\n          return tree;\n        }\n        return new AssignmentElement(tree.location, assignment, initializer);\n      },\n      transformAwaitExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new AwaitExpression(tree.location, expression);\n      },\n      transformBinaryExpression: function(tree) {\n        var left = this.transformAny(tree.left);\n        var right = this.transformAny(tree.right);\n        if (left === tree.left && right === tree.right) {\n          return tree;\n        }\n        return new BinaryExpression(tree.location, left, tree.operator, right);\n      },\n      transformBindingElement: function(tree) {\n        var binding = this.transformAny(tree.binding);\n        var initializer = this.transformAny(tree.initializer);\n        if (binding === tree.binding && initializer === tree.initializer) {\n          return tree;\n        }\n        return new BindingElement(tree.location, binding, initializer);\n      },\n      transformBindingIdentifier: function(tree) {\n        return tree;\n      },\n      transformBlock: function(tree) {\n        var statements = this.transformList(tree.statements);\n        if (statements === tree.statements) {\n          return tree;\n        }\n        return new Block(tree.location, statements);\n      },\n      transformBreakStatement: function(tree) {\n        return tree;\n      },\n      transformCallExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var args = this.transformAny(tree.args);\n        if (operand === tree.operand && args === tree.args) {\n          return tree;\n        }\n        return new CallExpression(tree.location, operand, args);\n      },\n      transformCallSignature: function(tree) {\n        var typeParameters = this.transformAny(tree.typeParameters);\n        var parameterList = this.transformAny(tree.parameterList);\n        var returnType = this.transformAny(tree.returnType);\n        if (typeParameters === tree.typeParameters && parameterList === tree.parameterList && returnType === tree.returnType) {\n          return tree;\n        }\n        return new CallSignature(tree.location, typeParameters, parameterList, returnType);\n      },\n      transformCaseClause: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        var statements = this.transformList(tree.statements);\n        if (expression === tree.expression && statements === tree.statements) {\n          return tree;\n        }\n        return new CaseClause(tree.location, expression, statements);\n      },\n      transformCatch: function(tree) {\n        var binding = this.transformAny(tree.binding);\n        var catchBody = this.transformAny(tree.catchBody);\n        if (binding === tree.binding && catchBody === tree.catchBody) {\n          return tree;\n        }\n        return new Catch(tree.location, binding, catchBody);\n      },\n      transformClassDeclaration: function(tree) {\n        var name = this.transformAny(tree.name);\n        var superClass = this.transformAny(tree.superClass);\n        var elements = this.transformList(tree.elements);\n        var annotations = this.transformList(tree.annotations);\n        var typeParameters = this.transformAny(tree.typeParameters);\n        if (name === tree.name && superClass === tree.superClass && elements === tree.elements && annotations === tree.annotations && typeParameters === tree.typeParameters) {\n          return tree;\n        }\n        return new ClassDeclaration(tree.location, name, superClass, elements, annotations, typeParameters);\n      },\n      transformClassExpression: function(tree) {\n        var name = this.transformAny(tree.name);\n        var superClass = this.transformAny(tree.superClass);\n        var elements = this.transformList(tree.elements);\n        var annotations = this.transformList(tree.annotations);\n        var typeParameters = this.transformAny(tree.typeParameters);\n        if (name === tree.name && superClass === tree.superClass && elements === tree.elements && annotations === tree.annotations && typeParameters === tree.typeParameters) {\n          return tree;\n        }\n        return new ClassExpression(tree.location, name, superClass, elements, annotations, typeParameters);\n      },\n      transformCommaExpression: function(tree) {\n        var expressions = this.transformList(tree.expressions);\n        if (expressions === tree.expressions) {\n          return tree;\n        }\n        return new CommaExpression(tree.location, expressions);\n      },\n      transformComprehensionFor: function(tree) {\n        var left = this.transformAny(tree.left);\n        var iterator = this.transformAny(tree.iterator);\n        if (left === tree.left && iterator === tree.iterator) {\n          return tree;\n        }\n        return new ComprehensionFor(tree.location, left, iterator);\n      },\n      transformComprehensionIf: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ComprehensionIf(tree.location, expression);\n      },\n      transformComputedPropertyName: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ComputedPropertyName(tree.location, expression);\n      },\n      transformConditionalExpression: function(tree) {\n        var condition = this.transformAny(tree.condition);\n        var left = this.transformAny(tree.left);\n        var right = this.transformAny(tree.right);\n        if (condition === tree.condition && left === tree.left && right === tree.right) {\n          return tree;\n        }\n        return new ConditionalExpression(tree.location, condition, left, right);\n      },\n      transformConstructSignature: function(tree) {\n        var typeParameters = this.transformAny(tree.typeParameters);\n        var parameterList = this.transformAny(tree.parameterList);\n        var returnType = this.transformAny(tree.returnType);\n        if (typeParameters === tree.typeParameters && parameterList === tree.parameterList && returnType === tree.returnType) {\n          return tree;\n        }\n        return new ConstructSignature(tree.location, typeParameters, parameterList, returnType);\n      },\n      transformConstructorType: function(tree) {\n        var typeParameters = this.transformAny(tree.typeParameters);\n        var parameterList = this.transformAny(tree.parameterList);\n        var returnType = this.transformAny(tree.returnType);\n        if (typeParameters === tree.typeParameters && parameterList === tree.parameterList && returnType === tree.returnType) {\n          return tree;\n        }\n        return new ConstructorType(tree.location, typeParameters, parameterList, returnType);\n      },\n      transformContinueStatement: function(tree) {\n        return tree;\n      },\n      transformCoverFormals: function(tree) {\n        var expressions = this.transformList(tree.expressions);\n        if (expressions === tree.expressions) {\n          return tree;\n        }\n        return new CoverFormals(tree.location, expressions);\n      },\n      transformCoverInitializedName: function(tree) {\n        var initializer = this.transformAny(tree.initializer);\n        if (initializer === tree.initializer) {\n          return tree;\n        }\n        return new CoverInitializedName(tree.location, tree.name, tree.equalToken, initializer);\n      },\n      transformDebuggerStatement: function(tree) {\n        return tree;\n      },\n      transformDefaultClause: function(tree) {\n        var statements = this.transformList(tree.statements);\n        if (statements === tree.statements) {\n          return tree;\n        }\n        return new DefaultClause(tree.location, statements);\n      },\n      transformDoWhileStatement: function(tree) {\n        var body = this.transformToBlockOrStatement(tree.body);\n        var condition = this.transformAny(tree.condition);\n        if (body === tree.body && condition === tree.condition) {\n          return tree;\n        }\n        return new DoWhileStatement(tree.location, body, condition);\n      },\n      transformEmptyStatement: function(tree) {\n        return tree;\n      },\n      transformExportDeclaration: function(tree) {\n        var declaration = this.transformAny(tree.declaration);\n        var annotations = this.transformList(tree.annotations);\n        if (declaration === tree.declaration && annotations === tree.annotations) {\n          return tree;\n        }\n        return new ExportDeclaration(tree.location, declaration, annotations);\n      },\n      transformExportDefault: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ExportDefault(tree.location, expression);\n      },\n      transformExportSpecifier: function(tree) {\n        return tree;\n      },\n      transformExportSpecifierSet: function(tree) {\n        var specifiers = this.transformList(tree.specifiers);\n        if (specifiers === tree.specifiers) {\n          return tree;\n        }\n        return new ExportSpecifierSet(tree.location, specifiers);\n      },\n      transformExportStar: function(tree) {\n        return tree;\n      },\n      transformExpressionStatement: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ExpressionStatement(tree.location, expression);\n      },\n      transformFinally: function(tree) {\n        var block = this.transformAny(tree.block);\n        if (block === tree.block) {\n          return tree;\n        }\n        return new Finally(tree.location, block);\n      },\n      transformForInStatement: function(tree) {\n        var initializer = this.transformAny(tree.initializer);\n        var collection = this.transformAny(tree.collection);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (initializer === tree.initializer && collection === tree.collection && body === tree.body) {\n          return tree;\n        }\n        return new ForInStatement(tree.location, initializer, collection, body);\n      },\n      transformForOfStatement: function(tree) {\n        var initializer = this.transformAny(tree.initializer);\n        var collection = this.transformAny(tree.collection);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (initializer === tree.initializer && collection === tree.collection && body === tree.body) {\n          return tree;\n        }\n        return new ForOfStatement(tree.location, initializer, collection, body);\n      },\n      transformForOnStatement: function(tree) {\n        var initializer = this.transformAny(tree.initializer);\n        var observable = this.transformAny(tree.observable);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (initializer === tree.initializer && observable === tree.observable && body === tree.body) {\n          return tree;\n        }\n        return new ForOnStatement(tree.location, initializer, observable, body);\n      },\n      transformForStatement: function(tree) {\n        var initializer = this.transformAny(tree.initializer);\n        var condition = this.transformAny(tree.condition);\n        var increment = this.transformAny(tree.increment);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (initializer === tree.initializer && condition === tree.condition && increment === tree.increment && body === tree.body) {\n          return tree;\n        }\n        return new ForStatement(tree.location, initializer, condition, increment, body);\n      },\n      transformFormalParameter: function(tree) {\n        var parameter = this.transformAny(tree.parameter);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        if (parameter === tree.parameter && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations) {\n          return tree;\n        }\n        return new FormalParameter(tree.location, parameter, typeAnnotation, annotations);\n      },\n      transformFormalParameterList: function(tree) {\n        var parameters = this.transformList(tree.parameters);\n        if (parameters === tree.parameters) {\n          return tree;\n        }\n        return new FormalParameterList(tree.location, parameters);\n      },\n      transformForwardDefaultExport: function(tree) {\n        return tree;\n      },\n      transformFunctionBody: function(tree) {\n        var statements = this.transformList(tree.statements);\n        if (statements === tree.statements) {\n          return tree;\n        }\n        return new FunctionBody(tree.location, statements);\n      },\n      transformFunctionDeclaration: function(tree) {\n        var name = this.transformAny(tree.name);\n        var parameterList = this.transformAny(tree.parameterList);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAny(tree.body);\n        if (name === tree.name && parameterList === tree.parameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new FunctionDeclaration(tree.location, name, tree.functionKind, parameterList, typeAnnotation, annotations, body);\n      },\n      transformFunctionExpression: function(tree) {\n        var name = this.transformAny(tree.name);\n        var parameterList = this.transformAny(tree.parameterList);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAny(tree.body);\n        if (name === tree.name && parameterList === tree.parameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new FunctionExpression(tree.location, name, tree.functionKind, parameterList, typeAnnotation, annotations, body);\n      },\n      transformFunctionType: function(tree) {\n        var typeParameters = this.transformAny(tree.typeParameters);\n        var parameterList = this.transformAny(tree.parameterList);\n        var returnType = this.transformAny(tree.returnType);\n        if (typeParameters === tree.typeParameters && parameterList === tree.parameterList && returnType === tree.returnType) {\n          return tree;\n        }\n        return new FunctionType(tree.location, typeParameters, parameterList, returnType);\n      },\n      transformGeneratorComprehension: function(tree) {\n        var comprehensionList = this.transformList(tree.comprehensionList);\n        var expression = this.transformAny(tree.expression);\n        if (comprehensionList === tree.comprehensionList && expression === tree.expression) {\n          return tree;\n        }\n        return new GeneratorComprehension(tree.location, comprehensionList, expression);\n      },\n      transformGetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAny(tree.body);\n        if (name === tree.name && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new GetAccessor(tree.location, tree.isStatic, name, typeAnnotation, annotations, body);\n      },\n      transformIdentifierExpression: function(tree) {\n        return tree;\n      },\n      transformIfStatement: function(tree) {\n        var condition = this.transformAny(tree.condition);\n        var ifClause = this.transformToBlockOrStatement(tree.ifClause);\n        var elseClause = this.transformToBlockOrStatement(tree.elseClause);\n        if (condition === tree.condition && ifClause === tree.ifClause && elseClause === tree.elseClause) {\n          return tree;\n        }\n        return new IfStatement(tree.location, condition, ifClause, elseClause);\n      },\n      transformImportedBinding: function(tree) {\n        var binding = this.transformAny(tree.binding);\n        if (binding === tree.binding) {\n          return tree;\n        }\n        return new ImportedBinding(tree.location, binding);\n      },\n      transformImportClausePair: function(tree) {\n        var first = this.transformAny(tree.first);\n        var second = this.transformAny(tree.second);\n        if (first === tree.first && second === tree.second) {\n          return tree;\n        }\n        return new ImportClausePair(tree.location, first, second);\n      },\n      transformImportDeclaration: function(tree) {\n        var importClause = this.transformAny(tree.importClause);\n        var moduleSpecifier = this.transformAny(tree.moduleSpecifier);\n        if (importClause === tree.importClause && moduleSpecifier === tree.moduleSpecifier) {\n          return tree;\n        }\n        return new ImportDeclaration(tree.location, importClause, moduleSpecifier);\n      },\n      transformImportSpecifier: function(tree) {\n        var binding = this.transformAny(tree.binding);\n        if (binding === tree.binding) {\n          return tree;\n        }\n        return new ImportSpecifier(tree.location, binding, tree.name);\n      },\n      transformImportSpecifierSet: function(tree) {\n        var specifiers = this.transformList(tree.specifiers);\n        if (specifiers === tree.specifiers) {\n          return tree;\n        }\n        return new ImportSpecifierSet(tree.location, specifiers);\n      },\n      transformImportTypeClause: function(tree) {\n        var clause = this.transformAny(tree.clause);\n        if (clause === tree.clause) {\n          return tree;\n        }\n        return new ImportTypeClause(tree.location, clause);\n      },\n      transformIndexSignature: function(tree) {\n        var indexType = this.transformAny(tree.indexType);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        if (indexType === tree.indexType && typeAnnotation === tree.typeAnnotation) {\n          return tree;\n        }\n        return new IndexSignature(tree.location, tree.name, indexType, typeAnnotation);\n      },\n      transformInterfaceDeclaration: function(tree) {\n        var typeParameters = this.transformAny(tree.typeParameters);\n        var objectType = this.transformAny(tree.objectType);\n        if (typeParameters === tree.typeParameters && objectType === tree.objectType) {\n          return tree;\n        }\n        return new InterfaceDeclaration(tree.location, tree.name, typeParameters, tree.extendsClause, objectType);\n      },\n      transformJsxAttribute: function(tree) {\n        var value = this.transformAny(tree.value);\n        if (value === tree.value) {\n          return tree;\n        }\n        return new JsxAttribute(tree.location, tree.name, value);\n      },\n      transformJsxElement: function(tree) {\n        var name = this.transformAny(tree.name);\n        var attributes = this.transformList(tree.attributes);\n        var children = this.transformList(tree.children);\n        if (name === tree.name && attributes === tree.attributes && children === tree.children) {\n          return tree;\n        }\n        return new JsxElement(tree.location, name, attributes, children);\n      },\n      transformJsxElementName: function(tree) {\n        return tree;\n      },\n      transformJsxPlaceholder: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new JsxPlaceholder(tree.location, expression);\n      },\n      transformJsxSpreadAttribute: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new JsxSpreadAttribute(tree.location, expression);\n      },\n      transformJsxText: function(tree) {\n        return tree;\n      },\n      transformLabelledStatement: function(tree) {\n        var statement = this.transformAny(tree.statement);\n        if (statement === tree.statement) {\n          return tree;\n        }\n        return new LabelledStatement(tree.location, tree.name, statement);\n      },\n      transformLiteralExpression: function(tree) {\n        return tree;\n      },\n      transformLiteralPropertyName: function(tree) {\n        return tree;\n      },\n      transformMemberExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        if (operand === tree.operand) {\n          return tree;\n        }\n        return new MemberExpression(tree.location, operand, tree.memberName);\n      },\n      transformMemberLookupExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var memberExpression = this.transformAny(tree.memberExpression);\n        if (operand === tree.operand && memberExpression === tree.memberExpression) {\n          return tree;\n        }\n        return new MemberLookupExpression(tree.location, operand, memberExpression);\n      },\n      transformMethod: function(tree) {\n        var name = this.transformAny(tree.name);\n        var parameterList = this.transformAny(tree.parameterList);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAny(tree.body);\n        var debugName = this.transformAny(tree.debugName);\n        if (name === tree.name && parameterList === tree.parameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body && debugName === tree.debugName) {\n          return tree;\n        }\n        return new Method(tree.location, tree.isStatic, tree.functionKind, name, parameterList, typeAnnotation, annotations, body, debugName);\n      },\n      transformMethodSignature: function(tree) {\n        var name = this.transformAny(tree.name);\n        var callSignature = this.transformAny(tree.callSignature);\n        if (name === tree.name && callSignature === tree.callSignature) {\n          return tree;\n        }\n        return new MethodSignature(tree.location, name, tree.optional, callSignature);\n      },\n      transformModule: function(tree) {\n        var scriptItemList = this.transformList(tree.scriptItemList);\n        if (scriptItemList === tree.scriptItemList) {\n          return tree;\n        }\n        return new Module(tree.location, scriptItemList, tree.moduleName);\n      },\n      transformModuleSpecifier: function(tree) {\n        return tree;\n      },\n      transformNameSpaceExport: function(tree) {\n        return tree;\n      },\n      transformNameSpaceImport: function(tree) {\n        var binding = this.transformAny(tree.binding);\n        if (binding === tree.binding) {\n          return tree;\n        }\n        return new NameSpaceImport(tree.location, binding);\n      },\n      transformNamedExport: function(tree) {\n        var exportClause = this.transformAny(tree.exportClause);\n        var moduleSpecifier = this.transformAny(tree.moduleSpecifier);\n        if (exportClause === tree.exportClause && moduleSpecifier === tree.moduleSpecifier) {\n          return tree;\n        }\n        return new NamedExport(tree.location, exportClause, moduleSpecifier);\n      },\n      transformNewExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var args = this.transformAny(tree.args);\n        if (operand === tree.operand && args === tree.args) {\n          return tree;\n        }\n        return new NewExpression(tree.location, operand, args);\n      },\n      transformObjectLiteral: function(tree) {\n        var propertyNameAndValues = this.transformList(tree.propertyNameAndValues);\n        if (propertyNameAndValues === tree.propertyNameAndValues) {\n          return tree;\n        }\n        return new ObjectLiteral(tree.location, propertyNameAndValues);\n      },\n      transformObjectPattern: function(tree) {\n        var fields = this.transformList(tree.fields);\n        if (fields === tree.fields) {\n          return tree;\n        }\n        return new ObjectPattern(tree.location, fields);\n      },\n      transformObjectPatternField: function(tree) {\n        var name = this.transformAny(tree.name);\n        var element = this.transformAny(tree.element);\n        if (name === tree.name && element === tree.element) {\n          return tree;\n        }\n        return new ObjectPatternField(tree.location, name, element);\n      },\n      transformObjectType: function(tree) {\n        var typeMembers = this.transformList(tree.typeMembers);\n        if (typeMembers === tree.typeMembers) {\n          return tree;\n        }\n        return new ObjectType(tree.location, typeMembers);\n      },\n      transformParenExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ParenExpression(tree.location, expression);\n      },\n      transformPostfixExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        if (operand === tree.operand) {\n          return tree;\n        }\n        return new PostfixExpression(tree.location, operand, tree.operator);\n      },\n      transformPredefinedType: function(tree) {\n        return tree;\n      },\n      transformScript: function(tree) {\n        var scriptItemList = this.transformList(tree.scriptItemList);\n        if (scriptItemList === tree.scriptItemList) {\n          return tree;\n        }\n        return new Script(tree.location, scriptItemList, tree.moduleName);\n      },\n      transformPropertyNameAssignment: function(tree) {\n        var name = this.transformAny(tree.name);\n        var value = this.transformAny(tree.value);\n        if (name === tree.name && value === tree.value) {\n          return tree;\n        }\n        return new PropertyNameAssignment(tree.location, name, value);\n      },\n      transformPropertyNameShorthand: function(tree) {\n        return tree;\n      },\n      transformPropertyVariableDeclaration: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var initializer = this.transformAny(tree.initializer);\n        if (name === tree.name && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && initializer === tree.initializer) {\n          return tree;\n        }\n        return new PropertyVariableDeclaration(tree.location, tree.isStatic, name, typeAnnotation, annotations, initializer);\n      },\n      transformPropertySignature: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        if (name === tree.name && typeAnnotation === tree.typeAnnotation) {\n          return tree;\n        }\n        return new PropertySignature(tree.location, name, tree.optional, typeAnnotation);\n      },\n      transformRestParameter: function(tree) {\n        var identifier = this.transformAny(tree.identifier);\n        if (identifier === tree.identifier) {\n          return tree;\n        }\n        return new RestParameter(tree.location, identifier);\n      },\n      transformReturnStatement: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ReturnStatement(tree.location, expression);\n      },\n      transformSetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var parameterList = this.transformAny(tree.parameterList);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAny(tree.body);\n        if (name === tree.name && parameterList === tree.parameterList && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new SetAccessor(tree.location, tree.isStatic, name, parameterList, annotations, body);\n      },\n      transformSpreadExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new SpreadExpression(tree.location, expression);\n      },\n      transformSpreadPatternElement: function(tree) {\n        var lvalue = this.transformAny(tree.lvalue);\n        if (lvalue === tree.lvalue) {\n          return tree;\n        }\n        return new SpreadPatternElement(tree.location, lvalue);\n      },\n      transformSuperExpression: function(tree) {\n        return tree;\n      },\n      transformSwitchStatement: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        var caseClauses = this.transformList(tree.caseClauses);\n        if (expression === tree.expression && caseClauses === tree.caseClauses) {\n          return tree;\n        }\n        return new SwitchStatement(tree.location, expression, caseClauses);\n      },\n      transformSyntaxErrorTree: function(tree) {\n        return tree;\n      },\n      transformTemplateLiteralExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var elements = this.transformList(tree.elements);\n        if (operand === tree.operand && elements === tree.elements) {\n          return tree;\n        }\n        return new TemplateLiteralExpression(tree.location, operand, elements);\n      },\n      transformTemplateLiteralPortion: function(tree) {\n        return tree;\n      },\n      transformTemplateSubstitution: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new TemplateSubstitution(tree.location, expression);\n      },\n      transformThisExpression: function(tree) {\n        return tree;\n      },\n      transformThrowStatement: function(tree) {\n        var value = this.transformAny(tree.value);\n        if (value === tree.value) {\n          return tree;\n        }\n        return new ThrowStatement(tree.location, value);\n      },\n      transformTryStatement: function(tree) {\n        var body = this.transformAny(tree.body);\n        var catchBlock = this.transformAny(tree.catchBlock);\n        var finallyBlock = this.transformAny(tree.finallyBlock);\n        if (body === tree.body && catchBlock === tree.catchBlock && finallyBlock === tree.finallyBlock) {\n          return tree;\n        }\n        return new TryStatement(tree.location, body, catchBlock, finallyBlock);\n      },\n      transformTypeAliasDeclaration: function(tree) {\n        var value = this.transformAny(tree.value);\n        if (value === tree.value) {\n          return tree;\n        }\n        return new TypeAliasDeclaration(tree.location, tree.name, value);\n      },\n      transformTypeArguments: function(tree) {\n        var args = this.transformList(tree.args);\n        if (args === tree.args) {\n          return tree;\n        }\n        return new TypeArguments(tree.location, args);\n      },\n      transformTypeName: function(tree) {\n        var moduleName = this.transformAny(tree.moduleName);\n        if (moduleName === tree.moduleName) {\n          return tree;\n        }\n        return new TypeName(tree.location, moduleName, tree.name);\n      },\n      transformTypeParameter: function(tree) {\n        var extendsType = this.transformAny(tree.extendsType);\n        if (extendsType === tree.extendsType) {\n          return tree;\n        }\n        return new TypeParameter(tree.location, tree.identifierToken, extendsType);\n      },\n      transformTypeParameters: function(tree) {\n        var parameters = this.transformList(tree.parameters);\n        if (parameters === tree.parameters) {\n          return tree;\n        }\n        return new TypeParameters(tree.location, parameters);\n      },\n      transformTypeReference: function(tree) {\n        var typeName = this.transformAny(tree.typeName);\n        var args = this.transformAny(tree.args);\n        if (typeName === tree.typeName && args === tree.args) {\n          return tree;\n        }\n        return new TypeReference(tree.location, typeName, args);\n      },\n      transformUnaryExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        if (operand === tree.operand) {\n          return tree;\n        }\n        return new UnaryExpression(tree.location, tree.operator, operand);\n      },\n      transformUnionType: function(tree) {\n        var types = this.transformList(tree.types);\n        if (types === tree.types) {\n          return tree;\n        }\n        return new UnionType(tree.location, types);\n      },\n      transformVariableDeclaration: function(tree) {\n        var lvalue = this.transformAny(tree.lvalue);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var initializer = this.transformAny(tree.initializer);\n        if (lvalue === tree.lvalue && typeAnnotation === tree.typeAnnotation && initializer === tree.initializer) {\n          return tree;\n        }\n        return new VariableDeclaration(tree.location, lvalue, typeAnnotation, initializer);\n      },\n      transformVariableDeclarationList: function(tree) {\n        var declarations = this.transformList(tree.declarations);\n        if (declarations === tree.declarations) {\n          return tree;\n        }\n        return new VariableDeclarationList(tree.location, tree.declarationType, declarations);\n      },\n      transformVariableStatement: function(tree) {\n        var declarations = this.transformAny(tree.declarations);\n        if (declarations === tree.declarations) {\n          return tree;\n        }\n        return new VariableStatement(tree.location, declarations);\n      },\n      transformWhileStatement: function(tree) {\n        var condition = this.transformAny(tree.condition);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (condition === tree.condition && body === tree.body) {\n          return tree;\n        }\n        return new WhileStatement(tree.location, condition, body);\n      },\n      transformWithStatement: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (expression === tree.expression && body === tree.body) {\n          return tree;\n        }\n        return new WithStatement(tree.location, expression, body);\n      },\n      transformYieldExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new YieldExpression(tree.location, expression, tree.isYieldFor);\n      }\n    }, {});\n  }();\n  return {get ParseTreeTransformer() {\n      return ParseTreeTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/module/AttachModuleNameTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/module/AttachModuleNameTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/module/AttachModuleNameTransformer.js")).ParseTreeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/module/AttachModuleNameTransformer.js")),\n      Module = $__2.Module,\n      Script = $__2.Script;\n  var AttachModuleNameTransformer = function($__super) {\n    function AttachModuleNameTransformer(moduleName) {\n      $traceurRuntime.superConstructor(AttachModuleNameTransformer).call(this);\n      this.moduleName_ = moduleName;\n    }\n    return ($traceurRuntime.createClass)(AttachModuleNameTransformer, {\n      transformModule: function(tree) {\n        return new Module(tree.location, tree.scriptItemList, this.moduleName_);\n      },\n      transformScript: function(tree) {\n        return new Script(tree.location, tree.scriptItemList, this.moduleName_);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get AttachModuleNameTransformer() {\n      return AttachModuleNameTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/IdentifierToken.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/IdentifierToken.js";\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Token.js", "traceur@0.0.111/src/syntax/IdentifierToken.js")).Token;\n  var IDENTIFIER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TokenType.js", "traceur@0.0.111/src/syntax/IdentifierToken.js")).IDENTIFIER;\n  var IdentifierToken = function($__super) {\n    function IdentifierToken(location, value) {\n      $traceurRuntime.superConstructor(IdentifierToken).call(this, IDENTIFIER, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(IdentifierToken, {toString: function() {\n        return this.value;\n      }}, {}, $__super);\n  }(Token);\n  return {get IdentifierToken() {\n      return IdentifierToken;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/LiteralToken.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/LiteralToken.js";\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Token.js", "traceur@0.0.111/src/syntax/LiteralToken.js")).Token;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TokenType.js", "traceur@0.0.111/src/syntax/LiteralToken.js")),\n      NULL = $__11.NULL,\n      NUMBER = $__11.NUMBER,\n      STRING = $__11.STRING;\n  var StringParser = function() {\n    var $__2;\n    function StringParser(value) {\n      this.value = value;\n      this.index = 0;\n    }\n    return ($traceurRuntime.createClass)(StringParser, ($__2 = {}, Object.defineProperty($__2, Symbol.iterator, {\n      value: function() {\n        return this;\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), Object.defineProperty($__2, "next", {\n      value: function() {\n        if (++this.index >= this.value.length - 1)\n          return {\n            value: undefined,\n            done: true\n          };\n        return {\n          value: this.value[this.index],\n          done: false\n        };\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), Object.defineProperty($__2, "parse", {\n      value: function() {\n        if (this.value.indexOf(\'\\\\\') === -1)\n          return this.value.slice(1, -1);\n        var result = \'\';\n        var $__6 = true;\n        var $__7 = false;\n        var $__8 = undefined;\n        try {\n          for (var $__4 = void 0,\n              $__3 = (this)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {\n            var ch = $__4.value;\n            {\n              result += ch === \'\\\\\' ? this.parseEscapeSequence() : ch;\n            }\n          }\n        } catch ($__9) {\n          $__7 = true;\n          $__8 = $__9;\n        } finally {\n          try {\n            if (!$__6 && $__3.return != null) {\n              $__3.return();\n            }\n          } finally {\n            if ($__7) {\n              throw $__8;\n            }\n          }\n        }\n        return result;\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), Object.defineProperty($__2, "parseEscapeSequence", {\n      value: function() {\n        var ch = this.next().value;\n        switch (ch) {\n          case \'\\n\':\n          case \'\\r\':\n          case \'\\u2028\':\n          case \'\\u2029\':\n            return \'\';\n          case \'0\':\n            return \'\\0\';\n          case \'b\':\n            return \'\\b\';\n          case \'f\':\n            return \'\\f\';\n          case \'n\':\n            return \'\\n\';\n          case \'r\':\n            return \'\\r\';\n          case \'t\':\n            return \'\\t\';\n          case \'v\':\n            return \'\\v\';\n          case \'x\':\n            return String.fromCharCode(parseInt(this.next().value + this.next().value, 16));\n          case \'u\':\n            {\n              var nextValue = this.next().value;\n              if (nextValue === \'{\') {\n                var hexDigits = \'\';\n                while ((nextValue = this.next().value) !== \'}\') {\n                  hexDigits += nextValue;\n                }\n                var codePoint = parseInt(hexDigits, 16);\n                if (codePoint <= 0xFFFF) {\n                  return String.fromCharCode(codePoint);\n                }\n                var high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;\n                var low = (codePoint - 0x10000) % 0x400 + 0xDC00;\n                return String.fromCharCode(high, low);\n              }\n              return String.fromCharCode(parseInt(nextValue + this.next().value + this.next().value + this.next().value, 16));\n            }\n          default:\n            if (Number(ch) < 8)\n              throw new Error(\'Octal literals are not supported\');\n            return ch;\n        }\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), $__2), {});\n  }();\n  var LiteralToken = function($__super) {\n    function LiteralToken(type, value, location) {\n      $traceurRuntime.superConstructor(LiteralToken).call(this, type, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(LiteralToken, {\n      toString: function() {\n        return this.value;\n      },\n      get processedValue() {\n        switch (this.type) {\n          case NULL:\n            return null;\n          case NUMBER:\n            {\n              var value = this.value;\n              if (value.charCodeAt(0) === 48) {\n                switch (value.charCodeAt(1)) {\n                  case 66:\n                  case 98:\n                    return parseInt(this.value.slice(2), 2);\n                  case 79:\n                  case 111:\n                    return parseInt(this.value.slice(2), 8);\n                }\n              }\n              return Number(this.value);\n            }\n          case STRING:\n            {\n              var parser = new StringParser(this.value);\n              return parser.parse();\n            }\n          default:\n            throw new Error(\'Not implemented\');\n        }\n      }\n    }, {}, $__super);\n  }(Token);\n  return {get LiteralToken() {\n      return LiteralToken;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/util/assert.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util/assert.js";\n  function assert(b) {\n    if (!b && $traceurRuntime.options.debug)\n      throw Error(\'Assertion failed\');\n  }\n  return {get assert() {\n      return assert;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ParseTreeFactory.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ParseTreeFactory.js";\n  var IdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/IdentifierToken.js", "traceur@0.0.111/src/codegeneration/ParseTreeFactory.js")).IdentifierToken;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/LiteralToken.js", "traceur@0.0.111/src/codegeneration/ParseTreeFactory.js")).LiteralToken;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTree.js", "traceur@0.0.111/src/codegeneration/ParseTreeFactory.js")),\n      ParseTree = $__3.ParseTree,\n      ParseTreeType = $__3.ParseTreeType;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/ParseTreeFactory.js")),\n      CALL = $__4.CALL,\n      CREATE = $__4.CREATE,\n      DEFINE_PROPERTY = $__4.DEFINE_PROPERTY,\n      FREEZE = $__4.FREEZE,\n      OBJECT = $__4.OBJECT,\n      UNDEFINED = $__4.UNDEFINED;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/Token.js", "traceur@0.0.111/src/codegeneration/ParseTreeFactory.js")).Token;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/ParseTreeFactory.js")),\n      EQUAL = $__6.EQUAL,\n      FALSE = $__6.FALSE,\n      NULL = $__6.NULL,\n      NUMBER = $__6.NUMBER,\n      STRING = $__6.STRING,\n      TRUE = $__6.TRUE,\n      VOID = $__6.VOID;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/assert.js", "traceur@0.0.111/src/codegeneration/ParseTreeFactory.js")).assert;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ParseTreeFactory.js")),\n      ArgumentList = $__8.ArgumentList,\n      ArrayLiteral = $__8.ArrayLiteral,\n      BindingElement = $__8.BindingElement,\n      BinaryExpression = $__8.BinaryExpression,\n      BindingIdentifier = $__8.BindingIdentifier,\n      Block = $__8.Block,\n      BreakStatement = $__8.BreakStatement,\n      CallExpression = $__8.CallExpression,\n      CaseClause = $__8.CaseClause,\n      Catch = $__8.Catch,\n      ClassDeclaration = $__8.ClassDeclaration,\n      CommaExpression = $__8.CommaExpression,\n      ConditionalExpression = $__8.ConditionalExpression,\n      ContinueStatement = $__8.ContinueStatement,\n      DefaultClause = $__8.DefaultClause,\n      DoWhileStatement = $__8.DoWhileStatement,\n      EmptyStatement = $__8.EmptyStatement,\n      ExpressionStatement = $__8.ExpressionStatement,\n      Finally = $__8.Finally,\n      ForInStatement = $__8.ForInStatement,\n      ForOfStatement = $__8.ForOfStatement,\n      ForStatement = $__8.ForStatement,\n      FormalParameter = $__8.FormalParameter,\n      FormalParameterList = $__8.FormalParameterList,\n      FunctionBody = $__8.FunctionBody,\n      FunctionExpression = $__8.FunctionExpression,\n      IdentifierExpression = $__8.IdentifierExpression,\n      IfStatement = $__8.IfStatement,\n      ImportedBinding = $__8.ImportedBinding,\n      LiteralExpression = $__8.LiteralExpression,\n      LiteralPropertyName = $__8.LiteralPropertyName,\n      MemberExpression = $__8.MemberExpression,\n      MemberLookupExpression = $__8.MemberLookupExpression,\n      NewExpression = $__8.NewExpression,\n      ObjectLiteral = $__8.ObjectLiteral,\n      ParenExpression = $__8.ParenExpression,\n      PostfixExpression = $__8.PostfixExpression,\n      Script = $__8.Script,\n      PropertyNameAssignment = $__8.PropertyNameAssignment,\n      RestParameter = $__8.RestParameter,\n      ReturnStatement = $__8.ReturnStatement,\n      SpreadExpression = $__8.SpreadExpression,\n      SwitchStatement = $__8.SwitchStatement,\n      ThisExpression = $__8.ThisExpression,\n      ThrowStatement = $__8.ThrowStatement,\n      TryStatement = $__8.TryStatement,\n      UnaryExpression = $__8.UnaryExpression,\n      VariableDeclaration = $__8.VariableDeclaration,\n      VariableDeclarationList = $__8.VariableDeclarationList,\n      VariableStatement = $__8.VariableStatement,\n      WhileStatement = $__8.WhileStatement,\n      WithStatement = $__8.WithStatement;\n  var slice = Array.prototype.slice.call.bind(Array.prototype.slice);\n  var map = Array.prototype.map.call.bind(Array.prototype.map);\n  function createOperatorToken(operator) {\n    return new Token(operator, null);\n  }\n  function createIdentifierToken(identifier) {\n    return new IdentifierToken(null, identifier);\n  }\n  function createStringLiteralToken(value) {\n    return new LiteralToken(STRING, JSON.stringify(value), null);\n  }\n  function createBooleanLiteralToken(value) {\n    return new Token(value ? TRUE : FALSE, null);\n  }\n  function createNullLiteralToken() {\n    return new LiteralToken(NULL, \'null\', null);\n  }\n  function createNumberLiteralToken(value) {\n    return new LiteralToken(NUMBER, String(value), null);\n  }\n  function createEmptyParameterList() {\n    return new FormalParameterList(null, []);\n  }\n  function createFormalParameter(name) {\n    var bindingIdentifier = createBindingIdentifier(name);\n    return new FormalParameter(null, new BindingElement(null, bindingIdentifier, null), null, []);\n  }\n  function createArgumentList(list) {\n    return new ArgumentList(null, list);\n  }\n  function createEmptyArgumentList() {\n    return createArgumentList([]);\n  }\n  function createArrayLiteral(list) {\n    return new ArrayLiteral(null, list);\n  }\n  function createEmptyArrayLiteral() {\n    return createArrayLiteral([]);\n  }\n  function createAssignmentExpression(lhs, rhs) {\n    return new BinaryExpression(null, lhs, createOperatorToken(EQUAL), rhs);\n  }\n  function createBinaryExpression(left, operator, right) {\n    return new BinaryExpression(null, left, operator, right);\n  }\n  function createBindingIdentifier(identifier) {\n    if (typeof identifier === \'string\')\n      identifier = createIdentifierToken(identifier);\n    else if (identifier.type === ParseTreeType.BINDING_IDENTIFIER)\n      return identifier;\n    else if (identifier.type === ParseTreeType.IDENTIFIER_EXPRESSION)\n      return new BindingIdentifier(identifier.location, identifier.identifierToken);\n    return new BindingIdentifier(null, identifier);\n  }\n  function createImportedBinding(name) {\n    var bindingIdentifier = createBindingIdentifier(name);\n    return new ImportedBinding(bindingIdentifier.location, bindingIdentifier);\n  }\n  function createEmptyStatement() {\n    return new EmptyStatement(null);\n  }\n  function createEmptyBlock() {\n    return createBlock([]);\n  }\n  function createBlock(statements) {\n    return new Block(null, statements);\n  }\n  function createFunctionBody(statements) {\n    return new FunctionBody(null, statements);\n  }\n  function createScopedExpression(body, scope) {\n    assert(body.type === \'FUNCTION_BODY\');\n    return createCallCall(createParenExpression(createFunctionExpression(createEmptyParameterList(), body)), scope);\n  }\n  function createImmediatelyInvokedFunctionExpression(body) {\n    assert(body.type === \'FUNCTION_BODY\');\n    return createCallExpression(createParenExpression(createFunctionExpression(createEmptyParameterList(), body)));\n  }\n  function createCallExpression(operand) {\n    var args = arguments[1] !== (void 0) ? arguments[1] : createEmptyArgumentList();\n    return new CallExpression(null, operand, args);\n  }\n  function createBreakStatement() {\n    var name = arguments[0] !== (void 0) ? arguments[0] : null;\n    return new BreakStatement(null, name);\n  }\n  function createCallCall(func, thisExpression) {\n    return createCallExpression(createMemberExpression(func, CALL), createArgumentList([thisExpression]));\n  }\n  function createCaseClause(expression, statements) {\n    return new CaseClause(null, expression, statements);\n  }\n  function createCatch(identifier, catchBody) {\n    identifier = createBindingIdentifier(identifier);\n    return new Catch(null, identifier, catchBody);\n  }\n  function createClassDeclaration(name, superClass, elements) {\n    return new ClassDeclaration(null, name, superClass, elements, []);\n  }\n  function createCommaExpression(expressions) {\n    return new CommaExpression(null, expressions);\n  }\n  function createConditionalExpression(condition, left, right) {\n    return new ConditionalExpression(null, condition, left, right);\n  }\n  function createContinueStatement() {\n    var name = arguments[0] !== (void 0) ? arguments[0] : null;\n    return new ContinueStatement(null, name);\n  }\n  function createDefaultClause(statements) {\n    return new DefaultClause(null, statements);\n  }\n  function createDoWhileStatement(body, condition) {\n    return new DoWhileStatement(null, body, condition);\n  }\n  function createAssignmentStatement(lhs, rhs) {\n    return createExpressionStatement(createAssignmentExpression(lhs, rhs));\n  }\n  function createCallStatement(operand) {\n    var args = arguments[1];\n    return createExpressionStatement(createCallExpression(operand, args));\n  }\n  function createExpressionStatement(expression) {\n    return new ExpressionStatement(null, expression);\n  }\n  function createFinally(block) {\n    return new Finally(null, block);\n  }\n  function createForOfStatement(initializer, collection, body) {\n    return new ForOfStatement(null, initializer, collection, body);\n  }\n  function createForInStatement(initializer, collection, body) {\n    return new ForInStatement(null, initializer, collection, body);\n  }\n  function createForStatement(variables, condition, increment, body) {\n    return new ForStatement(null, variables, condition, increment, body);\n  }\n  function createFunctionExpression(parameterList, body) {\n    assert(body.type === \'FUNCTION_BODY\');\n    return new FunctionExpression(null, null, false, parameterList, null, [], body);\n  }\n  function createIdentifierExpression(identifier) {\n    if (typeof identifier === \'string\')\n      identifier = createIdentifierToken(identifier);\n    else if (identifier instanceof BindingIdentifier)\n      identifier = identifier.identifierToken;\n    return new IdentifierExpression(null, identifier);\n  }\n  function createUndefinedExpression() {\n    return createIdentifierExpression(UNDEFINED);\n  }\n  function createIfStatement(condition, ifClause) {\n    var elseClause = arguments[2] !== (void 0) ? arguments[2] : null;\n    return new IfStatement(null, condition, ifClause, elseClause);\n  }\n  function createStringLiteral(value) {\n    return new LiteralExpression(null, createStringLiteralToken(value));\n  }\n  function createBooleanLiteral(value) {\n    return new LiteralExpression(null, createBooleanLiteralToken(value));\n  }\n  function createTrueLiteral() {\n    return createBooleanLiteral(true);\n  }\n  function createFalseLiteral() {\n    return createBooleanLiteral(false);\n  }\n  function createNullLiteral() {\n    return new LiteralExpression(null, createNullLiteralToken());\n  }\n  function createNumberLiteral(value) {\n    return new LiteralExpression(null, createNumberLiteralToken(value));\n  }\n  function createMemberExpression(operand, memberName) {\n    for (var memberNames = [],\n        $__0 = 2; $__0 < arguments.length; $__0++)\n      memberNames[$__0 - 2] = arguments[$__0];\n    if (typeof operand === \'string\' || operand instanceof IdentifierToken)\n      operand = createIdentifierExpression(operand);\n    if (typeof memberName === \'string\')\n      memberName = createIdentifierToken(memberName);\n    if (memberName instanceof LiteralToken)\n      memberName = new LiteralExpression(null, memberName);\n    var tree = memberName instanceof LiteralExpression ? new MemberLookupExpression(null, operand, memberName) : new MemberExpression(null, operand, memberName);\n    for (var i = 0; i < memberNames.length; i++) {\n      tree = createMemberExpression(tree, memberNames[i]);\n    }\n    return tree;\n  }\n  function createMemberLookupExpression(operand, memberExpression) {\n    return new MemberLookupExpression(null, operand, memberExpression);\n  }\n  function createThisExpression() {\n    return new ThisExpression(null);\n  }\n  function createNewExpression(operand, args) {\n    return new NewExpression(null, operand, args);\n  }\n  function createObjectFreeze(value) {\n    return createCallExpression(createMemberExpression(OBJECT, FREEZE), createArgumentList([value]));\n  }\n  function createObjectCreate(protoExpression) {\n    var descriptors = arguments[1];\n    var argumentList = [protoExpression];\n    if (descriptors)\n      argumentList.push(descriptors);\n    return createCallExpression(createMemberExpression(OBJECT, CREATE), createArgumentList(argumentList));\n  }\n  function createObjectLiteralForDescriptor(descr) {\n    var propertyNameAndValues = Object.keys(descr).map(function(name) {\n      var value = descr[name];\n      if (!(value instanceof ParseTree))\n        value = createBooleanLiteral(!!value);\n      return createPropertyNameAssignment(name, value);\n    });\n    return createObjectLiteral(propertyNameAndValues);\n  }\n  function createDefineProperty(tree, name, descr) {\n    if (typeof name === \'string\')\n      name = createStringLiteral(name);\n    return createCallExpression(createMemberExpression(OBJECT, DEFINE_PROPERTY), createArgumentList([tree, name, createObjectLiteralForDescriptor(descr)]));\n  }\n  function createObjectLiteral(propertyNameAndValues) {\n    return new ObjectLiteral(null, propertyNameAndValues);\n  }\n  function createParenExpression(expression) {\n    return new ParenExpression(null, expression);\n  }\n  function createPostfixExpression(operand, operator) {\n    return new PostfixExpression(null, operand, operator);\n  }\n  function createScript(scriptItemList) {\n    return new Script(null, scriptItemList, null);\n  }\n  function createPropertyNameAssignment(identifier, value) {\n    if (typeof identifier === \'string\')\n      identifier = createLiteralPropertyName(identifier);\n    return new PropertyNameAssignment(null, identifier, value);\n  }\n  function createLiteralPropertyName(name) {\n    return new LiteralPropertyName(null, createIdentifierToken(name));\n  }\n  function createRestParameter(identifier) {\n    var rest = new RestParameter(null, createBindingIdentifier(identifier));\n    return new FormalParameter(null, rest, null, []);\n  }\n  function createReturnStatement(expression) {\n    return new ReturnStatement(null, expression);\n  }\n  function createSpreadExpression(expression) {\n    return new SpreadExpression(null, expression);\n  }\n  function createSwitchStatement(expression, caseClauses) {\n    return new SwitchStatement(null, expression, caseClauses);\n  }\n  function createThrowStatement(value) {\n    return new ThrowStatement(null, value);\n  }\n  function createTryStatement(body, catchBlock) {\n    var finallyBlock = arguments[2] !== (void 0) ? arguments[2] : null;\n    return new TryStatement(null, body, catchBlock, finallyBlock);\n  }\n  function createUnaryExpression(operator, operand) {\n    return new UnaryExpression(null, operator, operand);\n  }\n  function createUseStrictDirective() {\n    return createExpressionStatement(createStringLiteral(\'use strict\'));\n  }\n  function createVariableDeclarationList(binding, identifierOrDeclarations) {\n    var initializer = arguments[2];\n    if (identifierOrDeclarations instanceof Array) {\n      var declarations = identifierOrDeclarations;\n      return new VariableDeclarationList(null, binding, declarations);\n    }\n    var identifier = identifierOrDeclarations;\n    return createVariableDeclarationList(binding, [createVariableDeclaration(identifier, initializer)]);\n  }\n  function createVariableDeclaration(identifier, initializer) {\n    if (!(identifier instanceof ParseTree) || identifier.type !== ParseTreeType.BINDING_IDENTIFIER && identifier.type !== ParseTreeType.OBJECT_PATTERN && identifier.type !== ParseTreeType.ARRAY_PATTERN) {\n      identifier = createBindingIdentifier(identifier);\n    }\n    return new VariableDeclaration(null, identifier, null, initializer);\n  }\n  function createVariableStatement(listOrBinding) {\n    var identifier = arguments[1];\n    var initializer = arguments[2];\n    if (listOrBinding instanceof VariableDeclarationList)\n      return new VariableStatement(null, listOrBinding);\n    var binding = listOrBinding;\n    var list = createVariableDeclarationList(binding, identifier, initializer);\n    return createVariableStatement(list);\n  }\n  function createVoid0() {\n    return createParenExpression(createUnaryExpression(createOperatorToken(VOID), createNumberLiteral(0)));\n  }\n  function createWhileStatement(condition, body) {\n    return new WhileStatement(null, condition, body);\n  }\n  function createWithStatement(expression, body) {\n    return new WithStatement(null, expression, body);\n  }\n  function createAssignStateStatement(state) {\n    return createAssignmentStatement(createMemberExpression(\'$ctx\', \'state\'), createNumberLiteral(state));\n  }\n  return {\n    get createOperatorToken() {\n      return createOperatorToken;\n    },\n    get createIdentifierToken() {\n      return createIdentifierToken;\n    },\n    get createStringLiteralToken() {\n      return createStringLiteralToken;\n    },\n    get createBooleanLiteralToken() {\n      return createBooleanLiteralToken;\n    },\n    get createNullLiteralToken() {\n      return createNullLiteralToken;\n    },\n    get createNumberLiteralToken() {\n      return createNumberLiteralToken;\n    },\n    get createEmptyParameterList() {\n      return createEmptyParameterList;\n    },\n    get createFormalParameter() {\n      return createFormalParameter;\n    },\n    get createArgumentList() {\n      return createArgumentList;\n    },\n    get createEmptyArgumentList() {\n      return createEmptyArgumentList;\n    },\n    get createArrayLiteral() {\n      return createArrayLiteral;\n    },\n    get createEmptyArrayLiteral() {\n      return createEmptyArrayLiteral;\n    },\n    get createAssignmentExpression() {\n      return createAssignmentExpression;\n    },\n    get createBinaryExpression() {\n      return createBinaryExpression;\n    },\n    get createBindingIdentifier() {\n      return createBindingIdentifier;\n    },\n    get createImportedBinding() {\n      return createImportedBinding;\n    },\n    get createEmptyStatement() {\n      return createEmptyStatement;\n    },\n    get createEmptyBlock() {\n      return createEmptyBlock;\n    },\n    get createBlock() {\n      return createBlock;\n    },\n    get createFunctionBody() {\n      return createFunctionBody;\n    },\n    get createScopedExpression() {\n      return createScopedExpression;\n    },\n    get createImmediatelyInvokedFunctionExpression() {\n      return createImmediatelyInvokedFunctionExpression;\n    },\n    get createCallExpression() {\n      return createCallExpression;\n    },\n    get createBreakStatement() {\n      return createBreakStatement;\n    },\n    get createCaseClause() {\n      return createCaseClause;\n    },\n    get createCatch() {\n      return createCatch;\n    },\n    get createClassDeclaration() {\n      return createClassDeclaration;\n    },\n    get createCommaExpression() {\n      return createCommaExpression;\n    },\n    get createConditionalExpression() {\n      return createConditionalExpression;\n    },\n    get createContinueStatement() {\n      return createContinueStatement;\n    },\n    get createDefaultClause() {\n      return createDefaultClause;\n    },\n    get createDoWhileStatement() {\n      return createDoWhileStatement;\n    },\n    get createAssignmentStatement() {\n      return createAssignmentStatement;\n    },\n    get createCallStatement() {\n      return createCallStatement;\n    },\n    get createExpressionStatement() {\n      return createExpressionStatement;\n    },\n    get createFinally() {\n      return createFinally;\n    },\n    get createForOfStatement() {\n      return createForOfStatement;\n    },\n    get createForInStatement() {\n      return createForInStatement;\n    },\n    get createForStatement() {\n      return createForStatement;\n    },\n    get createFunctionExpression() {\n      return createFunctionExpression;\n    },\n    get createIdentifierExpression() {\n      return createIdentifierExpression;\n    },\n    get createUndefinedExpression() {\n      return createUndefinedExpression;\n    },\n    get createIfStatement() {\n      return createIfStatement;\n    },\n    get createStringLiteral() {\n      return createStringLiteral;\n    },\n    get createBooleanLiteral() {\n      return createBooleanLiteral;\n    },\n    get createTrueLiteral() {\n      return createTrueLiteral;\n    },\n    get createFalseLiteral() {\n      return createFalseLiteral;\n    },\n    get createNullLiteral() {\n      return createNullLiteral;\n    },\n    get createNumberLiteral() {\n      return createNumberLiteral;\n    },\n    get createMemberExpression() {\n      return createMemberExpression;\n    },\n    get createMemberLookupExpression() {\n      return createMemberLookupExpression;\n    },\n    get createThisExpression() {\n      return createThisExpression;\n    },\n    get createNewExpression() {\n      return createNewExpression;\n    },\n    get createObjectFreeze() {\n      return createObjectFreeze;\n    },\n    get createObjectCreate() {\n      return createObjectCreate;\n    },\n    get createObjectLiteralForDescriptor() {\n      return createObjectLiteralForDescriptor;\n    },\n    get createDefineProperty() {\n      return createDefineProperty;\n    },\n    get createObjectLiteral() {\n      return createObjectLiteral;\n    },\n    get createParenExpression() {\n      return createParenExpression;\n    },\n    get createPostfixExpression() {\n      return createPostfixExpression;\n    },\n    get createScript() {\n      return createScript;\n    },\n    get createPropertyNameAssignment() {\n      return createPropertyNameAssignment;\n    },\n    get createLiteralPropertyName() {\n      return createLiteralPropertyName;\n    },\n    get createRestParameter() {\n      return createRestParameter;\n    },\n    get createReturnStatement() {\n      return createReturnStatement;\n    },\n    get createSwitchStatement() {\n      return createSwitchStatement;\n    },\n    get createThrowStatement() {\n      return createThrowStatement;\n    },\n    get createTryStatement() {\n      return createTryStatement;\n    },\n    get createUnaryExpression() {\n      return createUnaryExpression;\n    },\n    get createUseStrictDirective() {\n      return createUseStrictDirective;\n    },\n    get createVariableDeclarationList() {\n      return createVariableDeclarationList;\n    },\n    get createVariableDeclaration() {\n      return createVariableDeclaration;\n    },\n    get createVariableStatement() {\n      return createVariableStatement;\n    },\n    get createVoid0() {\n      return createVoid0;\n    },\n    get createWhileStatement() {\n      return createWhileStatement;\n    },\n    get createWithStatement() {\n      return createWithStatement;\n    },\n    get createAssignStateStatement() {\n      return createAssignStateStatement;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/ParseTreeVisitor.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/ParseTreeVisitor.js";\n  var ParseTreeVisitor = function() {\n    function ParseTreeVisitor() {}\n    return ($traceurRuntime.createClass)(ParseTreeVisitor, {\n      visitAny: function(tree) {\n        tree !== null && tree.visit(this);\n      },\n      visit: function(tree) {\n        this.visitAny(tree);\n      },\n      visitList: function(list) {\n        if (list) {\n          for (var i = 0; i < list.length; i++) {\n            this.visitAny(list[i]);\n          }\n        }\n      },\n      visitStateMachine: function(tree) {\n        throw Error(\'State machines should not live outside of the GeneratorTransformer.\');\n      },\n      visitAnnotation: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.args);\n      },\n      visitAnonBlock: function(tree) {\n        this.visitList(tree.statements);\n      },\n      visitArgumentList: function(tree) {\n        this.visitList(tree.args);\n      },\n      visitArrayComprehension: function(tree) {\n        this.visitList(tree.comprehensionList);\n        this.visitAny(tree.expression);\n      },\n      visitArrayLiteral: function(tree) {\n        this.visitList(tree.elements);\n      },\n      visitArrayPattern: function(tree) {\n        this.visitList(tree.elements);\n      },\n      visitArrayType: function(tree) {\n        this.visitAny(tree.elementType);\n      },\n      visitArrowFunction: function(tree) {\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.body);\n      },\n      visitAssignmentElement: function(tree) {\n        this.visitAny(tree.assignment);\n        this.visitAny(tree.initializer);\n      },\n      visitAwaitExpression: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitBinaryExpression: function(tree) {\n        this.visitAny(tree.left);\n        this.visitAny(tree.right);\n      },\n      visitBindingElement: function(tree) {\n        this.visitAny(tree.binding);\n        this.visitAny(tree.initializer);\n      },\n      visitBindingIdentifier: function(tree) {},\n      visitBlock: function(tree) {\n        this.visitList(tree.statements);\n      },\n      visitBreakStatement: function(tree) {},\n      visitCallExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.visitAny(tree.args);\n      },\n      visitCallSignature: function(tree) {\n        this.visitAny(tree.typeParameters);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.returnType);\n      },\n      visitCaseClause: function(tree) {\n        this.visitAny(tree.expression);\n        this.visitList(tree.statements);\n      },\n      visitCatch: function(tree) {\n        this.visitAny(tree.binding);\n        this.visitAny(tree.catchBody);\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.superClass);\n        this.visitList(tree.elements);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.typeParameters);\n      },\n      visitClassExpression: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.superClass);\n        this.visitList(tree.elements);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.typeParameters);\n      },\n      visitCommaExpression: function(tree) {\n        this.visitList(tree.expressions);\n      },\n      visitComprehensionFor: function(tree) {\n        this.visitAny(tree.left);\n        this.visitAny(tree.iterator);\n      },\n      visitComprehensionIf: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitComputedPropertyName: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitConditionalExpression: function(tree) {\n        this.visitAny(tree.condition);\n        this.visitAny(tree.left);\n        this.visitAny(tree.right);\n      },\n      visitConstructSignature: function(tree) {\n        this.visitAny(tree.typeParameters);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.returnType);\n      },\n      visitConstructorType: function(tree) {\n        this.visitAny(tree.typeParameters);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.returnType);\n      },\n      visitContinueStatement: function(tree) {},\n      visitCoverFormals: function(tree) {\n        this.visitList(tree.expressions);\n      },\n      visitCoverInitializedName: function(tree) {\n        this.visitAny(tree.initializer);\n      },\n      visitDebuggerStatement: function(tree) {},\n      visitDefaultClause: function(tree) {\n        this.visitList(tree.statements);\n      },\n      visitDoWhileStatement: function(tree) {\n        this.visitAny(tree.body);\n        this.visitAny(tree.condition);\n      },\n      visitEmptyStatement: function(tree) {},\n      visitExportDeclaration: function(tree) {\n        this.visitAny(tree.declaration);\n        this.visitList(tree.annotations);\n      },\n      visitExportDefault: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitExportSpecifier: function(tree) {},\n      visitExportSpecifierSet: function(tree) {\n        this.visitList(tree.specifiers);\n      },\n      visitExportStar: function(tree) {},\n      visitExpressionStatement: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitFinally: function(tree) {\n        this.visitAny(tree.block);\n      },\n      visitForInStatement: function(tree) {\n        this.visitAny(tree.initializer);\n        this.visitAny(tree.collection);\n        this.visitAny(tree.body);\n      },\n      visitForOfStatement: function(tree) {\n        this.visitAny(tree.initializer);\n        this.visitAny(tree.collection);\n        this.visitAny(tree.body);\n      },\n      visitForOnStatement: function(tree) {\n        this.visitAny(tree.initializer);\n        this.visitAny(tree.observable);\n        this.visitAny(tree.body);\n      },\n      visitForStatement: function(tree) {\n        this.visitAny(tree.initializer);\n        this.visitAny(tree.condition);\n        this.visitAny(tree.increment);\n        this.visitAny(tree.body);\n      },\n      visitFormalParameter: function(tree) {\n        this.visitAny(tree.parameter);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n      },\n      visitFormalParameterList: function(tree) {\n        this.visitList(tree.parameters);\n      },\n      visitForwardDefaultExport: function(tree) {},\n      visitFunctionBody: function(tree) {\n        this.visitList(tree.statements);\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.body);\n      },\n      visitFunctionExpression: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.body);\n      },\n      visitFunctionType: function(tree) {\n        this.visitAny(tree.typeParameters);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.returnType);\n      },\n      visitGeneratorComprehension: function(tree) {\n        this.visitList(tree.comprehensionList);\n        this.visitAny(tree.expression);\n      },\n      visitGetAccessor: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.body);\n      },\n      visitIdentifierExpression: function(tree) {},\n      visitIfStatement: function(tree) {\n        this.visitAny(tree.condition);\n        this.visitAny(tree.ifClause);\n        this.visitAny(tree.elseClause);\n      },\n      visitImportedBinding: function(tree) {\n        this.visitAny(tree.binding);\n      },\n      visitImportClausePair: function(tree) {\n        this.visitAny(tree.first);\n        this.visitAny(tree.second);\n      },\n      visitImportDeclaration: function(tree) {\n        this.visitAny(tree.importClause);\n        this.visitAny(tree.moduleSpecifier);\n      },\n      visitImportSpecifier: function(tree) {\n        this.visitAny(tree.binding);\n      },\n      visitImportSpecifierSet: function(tree) {\n        this.visitList(tree.specifiers);\n      },\n      visitImportTypeClause: function(tree) {\n        this.visitAny(tree.clause);\n      },\n      visitIndexSignature: function(tree) {\n        this.visitAny(tree.indexType);\n        this.visitAny(tree.typeAnnotation);\n      },\n      visitInterfaceDeclaration: function(tree) {\n        this.visitAny(tree.typeParameters);\n        this.visitAny(tree.objectType);\n      },\n      visitJsxAttribute: function(tree) {\n        this.visitAny(tree.value);\n      },\n      visitJsxElement: function(tree) {\n        this.visitAny(tree.name);\n        this.visitList(tree.attributes);\n        this.visitList(tree.children);\n      },\n      visitJsxElementName: function(tree) {},\n      visitJsxPlaceholder: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitJsxSpreadAttribute: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitJsxText: function(tree) {},\n      visitLabelledStatement: function(tree) {\n        this.visitAny(tree.statement);\n      },\n      visitLiteralExpression: function(tree) {},\n      visitLiteralPropertyName: function(tree) {},\n      visitMemberExpression: function(tree) {\n        this.visitAny(tree.operand);\n      },\n      visitMemberLookupExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.visitAny(tree.memberExpression);\n      },\n      visitMethod: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.body);\n        this.visitAny(tree.debugName);\n      },\n      visitMethodSignature: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.callSignature);\n      },\n      visitModule: function(tree) {\n        this.visitList(tree.scriptItemList);\n      },\n      visitModuleSpecifier: function(tree) {},\n      visitNameSpaceExport: function(tree) {},\n      visitNameSpaceImport: function(tree) {\n        this.visitAny(tree.binding);\n      },\n      visitNamedExport: function(tree) {\n        this.visitAny(tree.exportClause);\n        this.visitAny(tree.moduleSpecifier);\n      },\n      visitNewExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.visitAny(tree.args);\n      },\n      visitObjectLiteral: function(tree) {\n        this.visitList(tree.propertyNameAndValues);\n      },\n      visitObjectPattern: function(tree) {\n        this.visitList(tree.fields);\n      },\n      visitObjectPatternField: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.element);\n      },\n      visitObjectType: function(tree) {\n        this.visitList(tree.typeMembers);\n      },\n      visitParenExpression: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitPostfixExpression: function(tree) {\n        this.visitAny(tree.operand);\n      },\n      visitPredefinedType: function(tree) {},\n      visitScript: function(tree) {\n        this.visitList(tree.scriptItemList);\n      },\n      visitPropertyNameAssignment: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.value);\n      },\n      visitPropertyNameShorthand: function(tree) {},\n      visitPropertyVariableDeclaration: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.initializer);\n      },\n      visitPropertySignature: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.typeAnnotation);\n      },\n      visitRestParameter: function(tree) {\n        this.visitAny(tree.identifier);\n      },\n      visitReturnStatement: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitSetAccessor: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.parameterList);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.body);\n      },\n      visitSpreadExpression: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitSpreadPatternElement: function(tree) {\n        this.visitAny(tree.lvalue);\n      },\n      visitSuperExpression: function(tree) {},\n      visitSwitchStatement: function(tree) {\n        this.visitAny(tree.expression);\n        this.visitList(tree.caseClauses);\n      },\n      visitSyntaxErrorTree: function(tree) {},\n      visitTemplateLiteralExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.visitList(tree.elements);\n      },\n      visitTemplateLiteralPortion: function(tree) {},\n      visitTemplateSubstitution: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitThisExpression: function(tree) {},\n      visitThrowStatement: function(tree) {\n        this.visitAny(tree.value);\n      },\n      visitTryStatement: function(tree) {\n        this.visitAny(tree.body);\n        this.visitAny(tree.catchBlock);\n        this.visitAny(tree.finallyBlock);\n      },\n      visitTypeAliasDeclaration: function(tree) {\n        this.visitAny(tree.value);\n      },\n      visitTypeArguments: function(tree) {\n        this.visitList(tree.args);\n      },\n      visitTypeName: function(tree) {\n        this.visitAny(tree.moduleName);\n      },\n      visitTypeParameter: function(tree) {\n        this.visitAny(tree.extendsType);\n      },\n      visitTypeParameters: function(tree) {\n        this.visitList(tree.parameters);\n      },\n      visitTypeReference: function(tree) {\n        this.visitAny(tree.typeName);\n        this.visitAny(tree.args);\n      },\n      visitUnaryExpression: function(tree) {\n        this.visitAny(tree.operand);\n      },\n      visitUnionType: function(tree) {\n        this.visitList(tree.types);\n      },\n      visitVariableDeclaration: function(tree) {\n        this.visitAny(tree.lvalue);\n        this.visitAny(tree.typeAnnotation);\n        this.visitAny(tree.initializer);\n      },\n      visitVariableDeclarationList: function(tree) {\n        this.visitList(tree.declarations);\n      },\n      visitVariableStatement: function(tree) {\n        this.visitAny(tree.declarations);\n      },\n      visitWhileStatement: function(tree) {\n        this.visitAny(tree.condition);\n        this.visitAny(tree.body);\n      },\n      visitWithStatement: function(tree) {\n        this.visitAny(tree.expression);\n        this.visitAny(tree.body);\n      },\n      visitYieldExpression: function(tree) {\n        this.visitAny(tree.expression);\n      }\n    }, {});\n  }();\n  return {get ParseTreeVisitor() {\n      return ParseTreeVisitor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/FindVisitor.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/FindVisitor.js";\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/ParseTreeVisitor.js", "traceur@0.0.111/src/codegeneration/FindVisitor.js")).ParseTreeVisitor;\n  var FindVisitor = function($__super) {\n    function FindVisitor() {\n      var keepOnGoing = arguments[0];\n      $traceurRuntime.superConstructor(FindVisitor).call(this);\n      this.found_ = false;\n      this.shouldContinue_ = true;\n      this.keepOnGoing_ = keepOnGoing;\n    }\n    return ($traceurRuntime.createClass)(FindVisitor, {\n      get found() {\n        return this.found_;\n      },\n      set found(v) {\n        if (v) {\n          this.found_ = true;\n          if (!this.keepOnGoing_)\n            this.shouldContinue_ = false;\n        }\n      },\n      visitAny: function(tree) {\n        this.shouldContinue_ && tree && tree.visit(this);\n      },\n      visitList: function(list) {\n        if (list) {\n          for (var i = 0; this.shouldContinue_ && i < list.length; i++) {\n            this.visitAny(list[i]);\n          }\n        }\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  return {get FindVisitor() {\n      return FindVisitor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/util/SyntaxErrorReporter.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util/SyntaxErrorReporter.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ErrorReporter.js", "traceur@0.0.111/src/util/SyntaxErrorReporter.js")),\n      ErrorReporter = $__1.ErrorReporter,\n      format = $__1.format;\n  var SyntaxErrorReporter = function($__super) {\n    function SyntaxErrorReporter() {\n      $traceurRuntime.superConstructor(SyntaxErrorReporter).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(SyntaxErrorReporter, {reportMessageInternal: function(location, message) {\n        var s = format(location, message);\n        throw new SyntaxError(s);\n      }}, {}, $__super);\n  }(ErrorReporter);\n  return {get SyntaxErrorReporter() {\n      return SyntaxErrorReporter;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/JsxIdentifierToken.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/JsxIdentifierToken.js";\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Token.js", "traceur@0.0.111/src/syntax/JsxIdentifierToken.js")).Token;\n  var JSX_IDENTIFIER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TokenType.js", "traceur@0.0.111/src/syntax/JsxIdentifierToken.js")).JSX_IDENTIFIER;\n  var JsxIdentifierToken = function($__super) {\n    function JsxIdentifierToken(location, value) {\n      $traceurRuntime.superConstructor(JsxIdentifierToken).call(this, JSX_IDENTIFIER, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(JsxIdentifierToken, {toString: function() {\n        return this.value;\n      }}, {}, $__super);\n  }(Token);\n  return {get JsxIdentifierToken() {\n      return JsxIdentifierToken;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/Keywords.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/Keywords.js";\n  var keywords = [\'break\', \'case\', \'catch\', \'class\', \'const\', \'continue\', \'debugger\', \'default\', \'delete\', \'do\', \'else\', \'export\', \'finally\', \'for\', \'function\', \'if\', \'import\', \'in\', \'instanceof\', \'let\', \'new\', \'return\', \'super\', \'switch\', \'this\', \'throw\', \'try\', \'typeof\', \'var\', \'void\', \'while\', \'with\', \'enum\', \'extends\', \'null\', \'true\', \'false\'];\n  var strictKeywords = [\'implements\', \'interface\', \'package\', \'private\', \'protected\', \'public\', \'static\', \'yield\'];\n  var keywordsByName = Object.create(null);\n  var NORMAL_KEYWORD = 1;\n  var STRICT_KEYWORD = 2;\n  keywords.forEach(function(value) {\n    keywordsByName[value] = NORMAL_KEYWORD;\n  });\n  strictKeywords.forEach(function(value) {\n    keywordsByName[value] = STRICT_KEYWORD;\n  });\n  function getKeywordType(value) {\n    return keywordsByName[value];\n  }\n  function isStrictKeyword(value) {\n    return getKeywordType(value) === STRICT_KEYWORD;\n  }\n  return {\n    get NORMAL_KEYWORD() {\n      return NORMAL_KEYWORD;\n    },\n    get STRICT_KEYWORD() {\n      return STRICT_KEYWORD;\n    },\n    get getKeywordType() {\n      return getKeywordType;\n    },\n    get isStrictKeyword() {\n      return isStrictKeyword;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/KeywordToken.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/KeywordToken.js";\n  var STRICT_KEYWORD = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Keywords.js", "traceur@0.0.111/src/syntax/KeywordToken.js")).STRICT_KEYWORD;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Token.js", "traceur@0.0.111/src/syntax/KeywordToken.js")).Token;\n  var KeywordToken = function($__super) {\n    function KeywordToken(type, keywordType, location) {\n      $traceurRuntime.superConstructor(KeywordToken).call(this, type, location);\n      this.isStrictKeyword_ = keywordType === STRICT_KEYWORD;\n    }\n    return ($traceurRuntime.createClass)(KeywordToken, {\n      isKeyword: function() {\n        return true;\n      },\n      isStrictKeyword: function() {\n        return this.isStrictKeyword_;\n      }\n    }, {}, $__super);\n  }(Token);\n  return {get KeywordToken() {\n      return KeywordToken;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/unicode-tables.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/unicode-tables.js";\n  var idStartTable = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 442, 443, 443, 444, 447, 448, 451, 452, 659, 660, 660, 661, 687, 688, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 883, 884, 884, 886, 887, 890, 890, 891, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1327, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1599, 1600, 1600, 1601, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2226, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2417, 2418, 2432, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3653, 3654, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4348, 4349, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5873, 5880, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6210, 6211, 6211, 6212, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6430, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7287, 7288, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7467, 7468, 7530, 7531, 7543, 7544, 7544, 7545, 7578, 7579, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8472, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8494, 8494, 8495, 8500, 8501, 8504, 8505, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8578, 8579, 8580, 8581, 8584, 11264, 11310, 11312, 11358, 11360, 11387, 11388, 11389, 11390, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 12293, 12293, 12294, 12294, 12295, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12347, 12347, 12348, 12348, 12353, 12438, 12443, 12444, 12445, 12446, 12447, 12447, 12449, 12538, 12540, 12542, 12543, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 40980, 40981, 40981, 40982, 42124, 42192, 42231, 42232, 42237, 42240, 42507, 42508, 42508, 42512, 42527, 42538, 42539, 42560, 42605, 42606, 42606, 42623, 42623, 42624, 42651, 42652, 42653, 42656, 42725, 42726, 42735, 42775, 42783, 42786, 42863, 42864, 42864, 42865, 42887, 42888, 42888, 42891, 42894, 42896, 42925, 42928, 42929, 42999, 42999, 43000, 43001, 43002, 43002, 43003, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43488, 43492, 43494, 43494, 43495, 43503, 43514, 43518, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43631, 43632, 43632, 43633, 43638, 43642, 43642, 43646, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43740, 43741, 43741, 43744, 43754, 43762, 43762, 43763, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43871, 43876, 43877, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65391, 65392, 65392, 65393, 65437, 65438, 65439, 65440, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66335, 66352, 66368, 66369, 66369, 66370, 66377, 66378, 66378, 66384, 66421, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66639, 66640, 66717, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68147, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68324, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 69635, 69687, 69763, 69807, 69840, 69864, 69891, 69926, 69968, 70002, 70006, 70006, 70019, 70066, 70081, 70084, 70106, 70106, 70144, 70161, 70163, 70187, 70320, 70366, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70461, 70461, 70493, 70497, 70784, 70831, 70852, 70853, 70855, 70855, 71040, 71086, 71168, 71215, 71236, 71236, 71296, 71338, 71840, 71903, 71935, 71935, 72384, 72440, 73728, 74648, 74752, 74862, 77824, 78894, 92160, 92728, 92736, 92766, 92880, 92909, 92928, 92975, 92992, 92995, 93027, 93047, 93053, 93071, 93952, 94020, 94032, 94032, 94099, 94111, 110592, 110593, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 124928, 125124, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 194560, 195101];\n  var idContinueTable = [183, 183, 768, 879, 903, 903, 1155, 1159, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1552, 1562, 1611, 1631, 1632, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 1984, 1993, 2027, 2035, 2070, 2073, 2075, 2083, 2085, 2087, 2089, 2093, 2137, 2139, 2276, 2306, 2307, 2307, 2362, 2362, 2363, 2363, 2364, 2364, 2366, 2368, 2369, 2376, 2377, 2380, 2381, 2381, 2382, 2383, 2385, 2391, 2402, 2403, 2406, 2415, 2433, 2433, 2434, 2435, 2492, 2492, 2494, 2496, 2497, 2500, 2503, 2504, 2507, 2508, 2509, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2561, 2562, 2563, 2563, 2620, 2620, 2622, 2624, 2625, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2662, 2671, 2672, 2673, 2677, 2677, 2689, 2690, 2691, 2691, 2748, 2748, 2750, 2752, 2753, 2757, 2759, 2760, 2761, 2761, 2763, 2764, 2765, 2765, 2786, 2787, 2790, 2799, 2817, 2817, 2818, 2819, 2876, 2876, 2878, 2878, 2879, 2879, 2880, 2880, 2881, 2884, 2887, 2888, 2891, 2892, 2893, 2893, 2902, 2902, 2903, 2903, 2914, 2915, 2918, 2927, 2946, 2946, 3006, 3007, 3008, 3008, 3009, 3010, 3014, 3016, 3018, 3020, 3021, 3021, 3031, 3031, 3046, 3055, 3072, 3072, 3073, 3075, 3134, 3136, 3137, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3170, 3171, 3174, 3183, 3201, 3201, 3202, 3203, 3260, 3260, 3262, 3262, 3263, 3263, 3264, 3268, 3270, 3270, 3271, 3272, 3274, 3275, 3276, 3277, 3285, 3286, 3298, 3299, 3302, 3311, 3329, 3329, 3330, 3331, 3390, 3392, 3393, 3396, 3398, 3400, 3402, 3404, 3405, 3405, 3415, 3415, 3426, 3427, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3537, 3538, 3540, 3542, 3542, 3544, 3551, 3558, 3567, 3570, 3571, 3633, 3633, 3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903, 3953, 3966, 3967, 3967, 3968, 3972, 3974, 3975, 3981, 3991, 3993, 4028, 4038, 4038, 4139, 4140, 4141, 4144, 4145, 4145, 4146, 4151, 4152, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4160, 4169, 4182, 4183, 4184, 4185, 4190, 4192, 4194, 4196, 4199, 4205, 4209, 4212, 4226, 4226, 4227, 4228, 4229, 4230, 4231, 4236, 4237, 4237, 4239, 4239, 4240, 4249, 4250, 4252, 4253, 4253, 4957, 4959, 4969, 4977, 5906, 5908, 5938, 5940, 5970, 5971, 6002, 6003, 6068, 6069, 6070, 6070, 6071, 6077, 6078, 6085, 6086, 6086, 6087, 6088, 6089, 6099, 6109, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6313, 6313, 6432, 6434, 6435, 6438, 6439, 6440, 6441, 6443, 6448, 6449, 6450, 6450, 6451, 6456, 6457, 6459, 6470, 6479, 6576, 6592, 6600, 6601, 6608, 6617, 6618, 6618, 6679, 6680, 6681, 6682, 6683, 6683, 6741, 6741, 6742, 6742, 6743, 6743, 6744, 6750, 6752, 6752, 6753, 6753, 6754, 6754, 6755, 6756, 6757, 6764, 6765, 6770, 6771, 6780, 6783, 6783, 6784, 6793, 6800, 6809, 6832, 6845, 6912, 6915, 6916, 6916, 6964, 6964, 6965, 6965, 6966, 6970, 6971, 6971, 6972, 6972, 6973, 6977, 6978, 6978, 6979, 6980, 6992, 7001, 7019, 7027, 7040, 7041, 7042, 7042, 7073, 7073, 7074, 7077, 7078, 7079, 7080, 7081, 7082, 7082, 7083, 7085, 7088, 7097, 7142, 7142, 7143, 7143, 7144, 7145, 7146, 7148, 7149, 7149, 7150, 7150, 7151, 7153, 7154, 7155, 7204, 7211, 7212, 7219, 7220, 7221, 7222, 7223, 7232, 7241, 7248, 7257, 7376, 7378, 7380, 7392, 7393, 7393, 7394, 7400, 7405, 7405, 7410, 7411, 7412, 7412, 7416, 7417, 7616, 7669, 7676, 7679, 8255, 8256, 8276, 8276, 8400, 8412, 8417, 8417, 8421, 8432, 11503, 11505, 11647, 11647, 11744, 11775, 12330, 12333, 12334, 12335, 12441, 12442, 42528, 42537, 42607, 42607, 42612, 42621, 42655, 42655, 42736, 42737, 43010, 43010, 43014, 43014, 43019, 43019, 43043, 43044, 43045, 43046, 43047, 43047, 43136, 43137, 43188, 43203, 43204, 43204, 43216, 43225, 43232, 43249, 43264, 43273, 43302, 43309, 43335, 43345, 43346, 43347, 43392, 43394, 43395, 43395, 43443, 43443, 43444, 43445, 43446, 43449, 43450, 43451, 43452, 43452, 43453, 43456, 43472, 43481, 43493, 43493, 43504, 43513, 43561, 43566, 43567, 43568, 43569, 43570, 43571, 43572, 43573, 43574, 43587, 43587, 43596, 43596, 43597, 43597, 43600, 43609, 43643, 43643, 43644, 43644, 43645, 43645, 43696, 43696, 43698, 43700, 43703, 43704, 43710, 43711, 43713, 43713, 43755, 43755, 43756, 43757, 43758, 43759, 43765, 43765, 43766, 43766, 44003, 44004, 44005, 44005, 44006, 44007, 44008, 44008, 44009, 44010, 44012, 44012, 44013, 44013, 44016, 44025, 64286, 64286, 65024, 65039, 65056, 65069, 65075, 65076, 65101, 65103, 65296, 65305, 65343, 65343, 66045, 66045, 66272, 66272, 66422, 66426, 66720, 66729, 68097, 68099, 68101, 68102, 68108, 68111, 68152, 68154, 68159, 68159, 68325, 68326, 69632, 69632, 69633, 69633, 69634, 69634, 69688, 69702, 69734, 69743, 69759, 69761, 69762, 69762, 69808, 69810, 69811, 69814, 69815, 69816, 69817, 69818, 69872, 69881, 69888, 69890, 69927, 69931, 69932, 69932, 69933, 69940, 69942, 69951, 70003, 70003, 70016, 70017, 70018, 70018, 70067, 70069, 70070, 70078, 70079, 70080, 70096, 70105, 70188, 70190, 70191, 70193, 70194, 70195, 70196, 70196, 70197, 70197, 70198, 70199, 70367, 70367, 70368, 70370, 70371, 70378, 70384, 70393, 70401, 70401, 70402, 70403, 70460, 70460, 70462, 70463, 70464, 70464, 70465, 70468, 70471, 70472, 70475, 70477, 70487, 70487, 70498, 70499, 70502, 70508, 70512, 70516, 70832, 70834, 70835, 70840, 70841, 70841, 70842, 70842, 70843, 70846, 70847, 70848, 70849, 70849, 70850, 70851, 70864, 70873, 71087, 71089, 71090, 71093, 71096, 71099, 71100, 71101, 71102, 71102, 71103, 71104, 71216, 71218, 71219, 71226, 71227, 71228, 71229, 71229, 71230, 71230, 71231, 71232, 71248, 71257, 71339, 71339, 71340, 71340, 71341, 71341, 71342, 71343, 71344, 71349, 71350, 71350, 71351, 71351, 71360, 71369, 71904, 71913, 92768, 92777, 92912, 92916, 92976, 92982, 93008, 93017, 94033, 94078, 94095, 94098, 113821, 113822, 119141, 119142, 119143, 119145, 119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 120782, 120831, 125136, 125142, 917760, 917999];\n  return {\n    get idStartTable() {\n      return idStartTable;\n    },\n    get idContinueTable() {\n      return idContinueTable;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/Scanner.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/Scanner.js";\n  var IdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./IdentifierToken.js", "traceur@0.0.111/src/syntax/Scanner.js")).IdentifierToken;\n  var JsxIdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./JsxIdentifierToken.js", "traceur@0.0.111/src/syntax/Scanner.js")).JsxIdentifierToken;\n  var KeywordToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./KeywordToken.js", "traceur@0.0.111/src/syntax/Scanner.js")).KeywordToken;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./LiteralToken.js", "traceur@0.0.111/src/syntax/Scanner.js")).LiteralToken;\n  var SourceRange = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/SourceRange.js", "traceur@0.0.111/src/syntax/Scanner.js")).SourceRange;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Token.js", "traceur@0.0.111/src/syntax/Scanner.js")).Token;\n  var getKeywordType = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Keywords.js", "traceur@0.0.111/src/syntax/Scanner.js")).getKeywordType;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./unicode-tables.js", "traceur@0.0.111/src/syntax/Scanner.js")),\n      idContinueTable = $__10.idContinueTable,\n      idStartTable = $__10.idStartTable;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TokenType.js", "traceur@0.0.111/src/syntax/Scanner.js")),\n      AMPERSAND = $__11.AMPERSAND,\n      AMPERSAND_EQUAL = $__11.AMPERSAND_EQUAL,\n      AND = $__11.AND,\n      ARROW = $__11.ARROW,\n      AT = $__11.AT,\n      BANG = $__11.BANG,\n      BAR = $__11.BAR,\n      BAR_EQUAL = $__11.BAR_EQUAL,\n      CARET = $__11.CARET,\n      CARET_EQUAL = $__11.CARET_EQUAL,\n      CLOSE_ANGLE = $__11.CLOSE_ANGLE,\n      CLOSE_CURLY = $__11.CLOSE_CURLY,\n      CLOSE_PAREN = $__11.CLOSE_PAREN,\n      CLOSE_SQUARE = $__11.CLOSE_SQUARE,\n      COLON = $__11.COLON,\n      COMMA = $__11.COMMA,\n      DOT_DOT_DOT = $__11.DOT_DOT_DOT,\n      END_OF_FILE = $__11.END_OF_FILE,\n      EQUAL = $__11.EQUAL,\n      EQUAL_EQUAL = $__11.EQUAL_EQUAL,\n      EQUAL_EQUAL_EQUAL = $__11.EQUAL_EQUAL_EQUAL,\n      ERROR = $__11.ERROR,\n      GREATER_EQUAL = $__11.GREATER_EQUAL,\n      LEFT_SHIFT = $__11.LEFT_SHIFT,\n      LEFT_SHIFT_EQUAL = $__11.LEFT_SHIFT_EQUAL,\n      LESS_EQUAL = $__11.LESS_EQUAL,\n      MINUS = $__11.MINUS,\n      MINUS_EQUAL = $__11.MINUS_EQUAL,\n      MINUS_MINUS = $__11.MINUS_MINUS,\n      NO_SUBSTITUTION_TEMPLATE = $__11.NO_SUBSTITUTION_TEMPLATE,\n      NOT_EQUAL = $__11.NOT_EQUAL,\n      NOT_EQUAL_EQUAL = $__11.NOT_EQUAL_EQUAL,\n      NUMBER = $__11.NUMBER,\n      OPEN_ANGLE = $__11.OPEN_ANGLE,\n      OPEN_CURLY = $__11.OPEN_CURLY,\n      OPEN_PAREN = $__11.OPEN_PAREN,\n      OPEN_SQUARE = $__11.OPEN_SQUARE,\n      OR = $__11.OR,\n      PERCENT = $__11.PERCENT,\n      PERCENT_EQUAL = $__11.PERCENT_EQUAL,\n      PERIOD = $__11.PERIOD,\n      PLUS = $__11.PLUS,\n      PLUS_EQUAL = $__11.PLUS_EQUAL,\n      PLUS_PLUS = $__11.PLUS_PLUS,\n      QUESTION = $__11.QUESTION,\n      REGULAR_EXPRESSION = $__11.REGULAR_EXPRESSION,\n      RIGHT_SHIFT = $__11.RIGHT_SHIFT,\n      RIGHT_SHIFT_EQUAL = $__11.RIGHT_SHIFT_EQUAL,\n      SEMI_COLON = $__11.SEMI_COLON,\n      SLASH = $__11.SLASH,\n      SLASH_EQUAL = $__11.SLASH_EQUAL,\n      STAR = $__11.STAR,\n      STAR_EQUAL = $__11.STAR_EQUAL,\n      STAR_STAR = $__11.STAR_STAR,\n      STAR_STAR_EQUAL = $__11.STAR_STAR_EQUAL,\n      STRING = $__11.STRING,\n      TEMPLATE_HEAD = $__11.TEMPLATE_HEAD,\n      TEMPLATE_MIDDLE = $__11.TEMPLATE_MIDDLE,\n      TEMPLATE_TAIL = $__11.TEMPLATE_TAIL,\n      TILDE = $__11.TILDE,\n      UNSIGNED_RIGHT_SHIFT = $__11.UNSIGNED_RIGHT_SHIFT,\n      UNSIGNED_RIGHT_SHIFT_EQUAL = $__11.UNSIGNED_RIGHT_SHIFT_EQUAL;\n  var isWhitespaceArray = [];\n  for (var i = 0; i < 128; i++) {\n    isWhitespaceArray[i] = i >= 9 && i <= 13 || i === 0x20;\n  }\n  function isWhitespace(code) {\n    if (code < 128)\n      return isWhitespaceArray[code];\n    switch (code) {\n      case 0xA0:\n      case 0xFEFF:\n      case 0x2028:\n      case 0x2029:\n        return true;\n    }\n    return false;\n  }\n  function isLineTerminator(code) {\n    switch (code) {\n      case 10:\n      case 13:\n      case 0x2028:\n      case 0x2029:\n        return true;\n    }\n    return false;\n  }\n  function isDecimalDigit(code) {\n    return code >= 48 && code <= 57;\n  }\n  var isHexDigitArray = [];\n  for (var i$__0 = 0; i$__0 < 128; i$__0++) {\n    isHexDigitArray[i$__0] = i$__0 >= 48 && i$__0 <= 57 || i$__0 >= 65 && i$__0 <= 70 || i$__0 >= 97 && i$__0 <= 102;\n  }\n  function isHexDigit(code) {\n    return code < 128 && isHexDigitArray[code];\n  }\n  function isBinaryDigit(code) {\n    return code === 48 || code === 49;\n  }\n  function isOctalDigit(code) {\n    return code >= 48 && code <= 55;\n  }\n  var isIdentifierStartArray = [];\n  for (var i$__1 = 0; i$__1 < 128; i$__1++) {\n    isIdentifierStartArray[i$__1] = i$__1 === 36 || i$__1 >= 65 && i$__1 <= 90 || i$__1 === 95 || i$__1 >= 97 && i$__1 <= 122;\n  }\n  function isIdentifierStart(code) {\n    return code < 128 ? isIdentifierStartArray[code] : inTable(idStartTable, code);\n  }\n  var isIdentifierPartArray = [];\n  for (var i$__2 = 0; i$__2 < 128; i$__2++) {\n    isIdentifierPartArray[i$__2] = isIdentifierStart(i$__2) || isDecimalDigit(i$__2);\n  }\n  function isIdentifierPart(code) {\n    return code < 128 ? isIdentifierPartArray[code] : inTable(idStartTable, code) || inTable(idContinueTable, code) || code === 8204 || code === 8205;\n  }\n  function inTable(table, code) {\n    for (var i = 0; i < table.length; ) {\n      if (code < table[i++])\n        return false;\n      if (code <= table[i++])\n        return true;\n    }\n    return false;\n  }\n  function isRegularExpressionChar(code) {\n    switch (code) {\n      case 47:\n        return false;\n      case 91:\n      case 92:\n        return true;\n    }\n    return !isLineTerminator(code);\n  }\n  function isRegularExpressionFirstChar(code) {\n    return isRegularExpressionChar(code) && code !== 42;\n  }\n  var index,\n      input,\n      length,\n      token,\n      lastToken,\n      lookaheadToken,\n      currentCharCode,\n      lineNumberTable,\n      errorReporter,\n      currentParser,\n      options;\n  function init(reporter, file, parser, traceurOptions) {\n    errorReporter = reporter;\n    lineNumberTable = file.lineNumberTable;\n    input = file.contents;\n    length = file.contents.length;\n    setIndex(0);\n    currentParser = parser;\n    options = traceurOptions;\n  }\n  function getLastToken() {\n    return lastToken;\n  }\n  function nextRegularExpressionLiteralToken() {\n    lastToken = nextRegularExpressionLiteralToken2();\n    token = scanToken();\n    return lastToken;\n  }\n  function nextTemplateLiteralToken() {\n    var t = nextTemplateLiteralToken2();\n    token = scanToken();\n    return t;\n  }\n  function setIndex(i) {\n    index = i;\n    lastToken = null;\n    token = null;\n    lookaheadToken = null;\n    updateCurrentCharCode();\n  }\n  function getPosition() {\n    return getPositionByOffset(getOffset());\n  }\n  function getPositionByOffset(offset) {\n    return lineNumberTable.getSourcePosition(offset);\n  }\n  function nextCloseAngle() {\n    switch (token.type) {\n      case GREATER_EQUAL:\n      case RIGHT_SHIFT:\n      case RIGHT_SHIFT_EQUAL:\n      case UNSIGNED_RIGHT_SHIFT:\n      case UNSIGNED_RIGHT_SHIFT_EQUAL:\n        setIndex(index - token.type.length + 1);\n        lastToken = createToken(CLOSE_ANGLE, index);\n        token = scanToken();\n        return lastToken;\n    }\n    return nextToken();\n  }\n  function getTokenRange(startOffset) {\n    return lineNumberTable.getSourceRange(startOffset, index);\n  }\n  function getOffset() {\n    return token ? token.location.start.offset : index;\n  }\n  function nextRegularExpressionLiteralToken2() {\n    var beginIndex = index - token.toString().length;\n    if (token.type === SLASH_EQUAL) {\n      skipRegularExpressionBodyContinuation();\n    } else {\n      skipRegularExpressionBody(beginIndex);\n    }\n    if (currentCharCode !== 47) {\n      reportError(\'Expected \\\'/\\\' in regular expression literal\', beginIndex);\n      return new LiteralToken(REGULAR_EXPRESSION, getTokenString(beginIndex), getTokenRange(beginIndex));\n    }\n    next();\n    while (isIdentifierPart(currentCharCode)) {\n      next();\n    }\n    return new LiteralToken(REGULAR_EXPRESSION, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function skipRegularExpressionBody(beginIndex) {\n    if (!isRegularExpressionFirstChar(currentCharCode)) {\n      reportError(\'Expected regular expression first char\', beginIndex);\n      return;\n    }\n    skipRegularExpressionBodyContinuation();\n  }\n  function skipRegularExpressionBodyContinuation() {\n    while (!isAtEnd() && isRegularExpressionChar(currentCharCode)) {\n      if (!skipRegularExpressionChar()) {\n        return;\n      }\n    }\n  }\n  function skipRegularExpressionChar() {\n    switch (currentCharCode) {\n      case 92:\n        return skipRegularExpressionBackslashSequence();\n      case 91:\n        return skipRegularExpressionClass();\n      default:\n        next();\n        return true;\n    }\n  }\n  function skipRegularExpressionBackslashSequence() {\n    var beginIndex = index;\n    next();\n    if (isLineTerminator(currentCharCode) || isAtEnd()) {\n      reportError(\'New line not allowed in regular expression literal\', beginIndex, index);\n      return false;\n    }\n    next();\n    return true;\n  }\n  function skipRegularExpressionClass() {\n    var beginIndex = index;\n    next();\n    while (!isAtEnd() && peekRegularExpressionClassChar()) {\n      if (!skipRegularExpressionClassChar()) {\n        return false;\n      }\n    }\n    if (currentCharCode !== 93) {\n      reportError(\'\\\']\\\' expected\', beginIndex, index);\n      return false;\n    }\n    next();\n    return true;\n  }\n  function peekRegularExpressionClassChar() {\n    return currentCharCode !== 93 && !isLineTerminator(currentCharCode);\n  }\n  function skipRegularExpressionClassChar() {\n    if (currentCharCode === 92) {\n      return skipRegularExpressionBackslashSequence();\n    }\n    next();\n    return true;\n  }\n  function skipTemplateCharacter() {\n    while (!isAtEnd()) {\n      switch (currentCharCode) {\n        case 96:\n          return;\n        case 92:\n          skipStringLiteralEscapeSequence();\n          break;\n        case 36:\n          {\n            var code = input.charCodeAt(index + 1);\n            if (code === 123)\n              return;\n            next();\n            break;\n          }\n        default:\n          next();\n      }\n    }\n  }\n  function scanTemplateStart(beginIndex) {\n    if (isAtEnd()) {\n      reportError(\'Unterminated template literal\', beginIndex, index);\n      return lastToken = createToken(END_OF_FILE, beginIndex);\n    }\n    return nextTemplateLiteralTokenShared(NO_SUBSTITUTION_TEMPLATE, TEMPLATE_HEAD);\n  }\n  function nextTemplateLiteralToken2() {\n    if (isAtEnd()) {\n      reportError(\'Expected \\\'}\\\' after expression in template literal\', index, index);\n      return createToken(END_OF_FILE, index);\n    }\n    if (token.type !== CLOSE_CURLY) {\n      reportError(\'Expected \\\'}\\\' after expression in template literal\', index, index);\n      return createToken(ERROR, index);\n    }\n    return nextTemplateLiteralTokenShared(TEMPLATE_TAIL, TEMPLATE_MIDDLE);\n  }\n  function nextTemplateLiteralTokenShared(endType, middleType) {\n    var beginIndex = index;\n    skipTemplateCharacter();\n    if (isAtEnd()) {\n      reportError(\'Unterminated template literal\');\n      return createToken(ERROR, beginIndex);\n    }\n    var value = getTokenString(beginIndex);\n    switch (currentCharCode) {\n      case 96:\n        next();\n        return lastToken = new LiteralToken(endType, value, getTokenRange(beginIndex - 1));\n      case 36:\n        next();\n        next();\n        return lastToken = new LiteralToken(middleType, value, getTokenRange(beginIndex - 1));\n    }\n  }\n  function peekJsxToken() {\n    return token || (token = scanJsxToken());\n  }\n  function nextJsxToken() {\n    lastToken = peekJsxToken();\n    token = null;\n    return lastToken;\n  }\n  function scanJsxToken() {\n    skipComments();\n    var beginIndex = index;\n    switch (currentCharCode) {\n      case 34:\n      case 39:\n        return scanJsxStringLiteral(beginIndex, currentCharCode);\n      case 62:\n        next();\n        return createToken(CLOSE_ANGLE, beginIndex);\n    }\n    if (!isIdentifierStart(currentCharCode)) {\n      return scanToken();\n    }\n    next();\n    while (isIdentifierPart(currentCharCode) || currentCharCode === 45) {\n      next();\n    }\n    var value = input.slice(beginIndex, index);\n    return new JsxIdentifierToken(getTokenRange(beginIndex), value);\n  }\n  function scanJsxStringLiteral(beginIndex, terminator) {\n    next();\n    while (!isAtEnd() && currentCharCode !== terminator) {\n      next();\n    }\n    if (currentCharCode !== terminator) {\n      reportError(\'Unterminated String Literal\', beginIndex);\n    } else {\n      next();\n    }\n    return new LiteralToken(STRING, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function nextJsxTextToken() {\n    lastToken = token || scanJsxTextToken();\n    token = null;\n    return lastToken;\n  }\n  function skipJsxText() {\n    while (!isAtEnd() && peekJsxText()) {\n      next();\n    }\n  }\n  function isJsxTextChar(code) {\n    switch (code) {\n      case 60:\n      case 123:\n        return false;\n    }\n    return true;\n  }\n  function skipJsxText() {\n    while (!isAtEnd() && isJsxTextChar(currentCharCode)) {\n      next();\n    }\n  }\n  function scanJsxTextToken() {\n    var beginIndex = index;\n    if (isAtEnd()) {\n      return createToken(END_OF_FILE, beginIndex);\n    }\n    skipJsxText();\n    if (beginIndex === index) {\n      switch (currentCharCode) {\n        case 60:\n          next();\n          return createToken(OPEN_ANGLE, beginIndex);\n        case 123:\n          next();\n          return createToken(OPEN_CURLY, beginIndex);\n      }\n    }\n    return new LiteralToken(STRING, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function nextToken() {\n    var t = peekToken();\n    token = lookaheadToken || scanToken();\n    lookaheadToken = null;\n    lastToken = t;\n    return t;\n  }\n  function peekTokenNoLineTerminator() {\n    var t = peekToken();\n    var start = lastToken.location.end.offset;\n    var end = t.location.start.offset;\n    for (var i = start; i < end; i++) {\n      if (isLineTerminator(input.charCodeAt(i))) {\n        return null;\n      }\n    }\n    return t;\n  }\n  function peek(expectedType) {\n    return peekToken().type === expectedType;\n  }\n  function peekLookahead(expectedType) {\n    return peekTokenLookahead().type === expectedType;\n  }\n  function peekToken() {\n    return token || (token = scanToken());\n  }\n  function peekType() {\n    return peekToken().type;\n  }\n  function peekLocation() {\n    return peekToken().location;\n  }\n  function peekTokenLookahead() {\n    if (!token)\n      token = scanToken();\n    if (!lookaheadToken)\n      lookaheadToken = scanToken();\n    return lookaheadToken;\n  }\n  function skipWhitespace() {\n    while (!isAtEnd() && peekWhitespace()) {\n      next();\n    }\n  }\n  function peekWhitespace() {\n    return isWhitespace(currentCharCode);\n  }\n  function skipComments() {\n    while (skipComment()) {}\n  }\n  function skipComment() {\n    skipWhitespace();\n    var code = currentCharCode;\n    if (code === 47) {\n      code = input.charCodeAt(index + 1);\n      switch (code) {\n        case 47:\n          skipSingleLineComment();\n          return true;\n        case 42:\n          skipMultiLineComment();\n          return true;\n      }\n    }\n    return false;\n  }\n  function commentCallback(start, index) {\n    if (options.commentCallback)\n      currentParser.handleComment(lineNumberTable.getSourceRange(start, index));\n  }\n  function skipSingleLineComment() {\n    var start = index;\n    index += 2;\n    while (!isAtEnd() && !isLineTerminator(input.charCodeAt(index++))) {}\n    updateCurrentCharCode();\n    commentCallback(start, index);\n  }\n  function skipMultiLineComment() {\n    var start = index;\n    var i = input.indexOf(\'*/\', index + 2);\n    if (i !== -1)\n      index = i + 2;\n    else\n      index = length;\n    updateCurrentCharCode();\n    commentCallback(start, index);\n  }\n  function scanToken() {\n    skipComments();\n    var beginIndex = index;\n    if (isAtEnd())\n      return createToken(END_OF_FILE, beginIndex);\n    var code = currentCharCode;\n    next();\n    switch (code) {\n      case 123:\n        return createToken(OPEN_CURLY, beginIndex);\n      case 125:\n        return createToken(CLOSE_CURLY, beginIndex);\n      case 40:\n        return createToken(OPEN_PAREN, beginIndex);\n      case 41:\n        return createToken(CLOSE_PAREN, beginIndex);\n      case 91:\n        return createToken(OPEN_SQUARE, beginIndex);\n      case 93:\n        return createToken(CLOSE_SQUARE, beginIndex);\n      case 46:\n        switch (currentCharCode) {\n          case 46:\n            if (input.charCodeAt(index + 1) === 46) {\n              next();\n              next();\n              return createToken(DOT_DOT_DOT, beginIndex);\n            }\n            break;\n          default:\n            if (isDecimalDigit(currentCharCode))\n              return scanNumberPostPeriod(beginIndex);\n        }\n        return createToken(PERIOD, beginIndex);\n      case 59:\n        return createToken(SEMI_COLON, beginIndex);\n      case 44:\n        return createToken(COMMA, beginIndex);\n      case 126:\n        return createToken(TILDE, beginIndex);\n      case 63:\n        return createToken(QUESTION, beginIndex);\n      case 58:\n        return createToken(COLON, beginIndex);\n      case 60:\n        switch (currentCharCode) {\n          case 60:\n            next();\n            if (currentCharCode === 61) {\n              next();\n              return createToken(LEFT_SHIFT_EQUAL, beginIndex);\n            }\n            return createToken(LEFT_SHIFT, beginIndex);\n          case 61:\n            next();\n            return createToken(LESS_EQUAL, beginIndex);\n          default:\n            return createToken(OPEN_ANGLE, beginIndex);\n        }\n      case 62:\n        switch (currentCharCode) {\n          case 62:\n            next();\n            switch (currentCharCode) {\n              case 61:\n                next();\n                return createToken(RIGHT_SHIFT_EQUAL, beginIndex);\n              case 62:\n                next();\n                if (currentCharCode === 61) {\n                  next();\n                  return createToken(UNSIGNED_RIGHT_SHIFT_EQUAL, beginIndex);\n                }\n                return createToken(UNSIGNED_RIGHT_SHIFT, beginIndex);\n              default:\n                return createToken(RIGHT_SHIFT, beginIndex);\n            }\n          case 61:\n            next();\n            return createToken(GREATER_EQUAL, beginIndex);\n          default:\n            return createToken(CLOSE_ANGLE, beginIndex);\n        }\n      case 61:\n        if (currentCharCode === 61) {\n          next();\n          if (currentCharCode === 61) {\n            next();\n            return createToken(EQUAL_EQUAL_EQUAL, beginIndex);\n          }\n          return createToken(EQUAL_EQUAL, beginIndex);\n        }\n        if (currentCharCode === 62 && options.arrowFunctions) {\n          next();\n          return createToken(ARROW, beginIndex);\n        }\n        return createToken(EQUAL, beginIndex);\n      case 33:\n        if (currentCharCode === 61) {\n          next();\n          if (currentCharCode === 61) {\n            next();\n            return createToken(NOT_EQUAL_EQUAL, beginIndex);\n          }\n          return createToken(NOT_EQUAL, beginIndex);\n        }\n        return createToken(BANG, beginIndex);\n      case 42:\n        if (currentCharCode === 61) {\n          next();\n          return createToken(STAR_EQUAL, beginIndex);\n        }\n        if (currentCharCode === 42 && options.exponentiation) {\n          next();\n          if (currentCharCode === 61) {\n            next();\n            return createToken(STAR_STAR_EQUAL, beginIndex);\n          }\n          return createToken(STAR_STAR, beginIndex);\n        }\n        return createToken(STAR, beginIndex);\n      case 37:\n        if (currentCharCode === 61) {\n          next();\n          return createToken(PERCENT_EQUAL, beginIndex);\n        }\n        return createToken(PERCENT, beginIndex);\n      case 94:\n        if (currentCharCode === 61) {\n          next();\n          return createToken(CARET_EQUAL, beginIndex);\n        }\n        return createToken(CARET, beginIndex);\n      case 47:\n        if (currentCharCode === 61) {\n          next();\n          return createToken(SLASH_EQUAL, beginIndex);\n        }\n        return createToken(SLASH, beginIndex);\n      case 43:\n        switch (currentCharCode) {\n          case 43:\n            next();\n            return createToken(PLUS_PLUS, beginIndex);\n          case 61:\n            next();\n            return createToken(PLUS_EQUAL, beginIndex);\n          default:\n            return createToken(PLUS, beginIndex);\n        }\n      case 45:\n        switch (currentCharCode) {\n          case 45:\n            next();\n            return createToken(MINUS_MINUS, beginIndex);\n          case 61:\n            next();\n            return createToken(MINUS_EQUAL, beginIndex);\n          default:\n            return createToken(MINUS, beginIndex);\n        }\n      case 38:\n        switch (currentCharCode) {\n          case 38:\n            next();\n            return createToken(AND, beginIndex);\n          case 61:\n            next();\n            return createToken(AMPERSAND_EQUAL, beginIndex);\n          default:\n            return createToken(AMPERSAND, beginIndex);\n        }\n      case 124:\n        switch (currentCharCode) {\n          case 124:\n            next();\n            return createToken(OR, beginIndex);\n          case 61:\n            next();\n            return createToken(BAR_EQUAL, beginIndex);\n          default:\n            return createToken(BAR, beginIndex);\n        }\n      case 96:\n        return scanTemplateStart(beginIndex);\n      case 64:\n        return createToken(AT, beginIndex);\n      case 48:\n        return scanPostZero(beginIndex);\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        return scanPostDigit(beginIndex);\n      case 34:\n      case 39:\n        return scanStringLiteral(beginIndex, code);\n      default:\n        return scanIdentifierOrKeyword(beginIndex, code);\n    }\n  }\n  function scanNumberPostPeriod(beginIndex) {\n    skipDecimalDigits();\n    return scanExponentOfNumericLiteral(beginIndex);\n  }\n  function scanPostDigit(beginIndex) {\n    skipDecimalDigits();\n    return scanFractionalNumericLiteral(beginIndex);\n  }\n  function scanPostZero(beginIndex) {\n    switch (currentCharCode) {\n      case 46:\n        return scanFractionalNumericLiteral(beginIndex);\n      case 88:\n      case 120:\n        next();\n        if (!isHexDigit(currentCharCode)) {\n          reportError(\'Hex Integer Literal must contain at least one digit\', beginIndex);\n        }\n        skipHexDigits();\n        return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));\n      case 66:\n      case 98:\n        if (!options.numericLiterals)\n          break;\n        next();\n        if (!isBinaryDigit(currentCharCode)) {\n          reportError(\'Binary Integer Literal must contain at least one digit\', beginIndex);\n        }\n        skipBinaryDigits();\n        return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));\n      case 79:\n      case 111:\n        if (!options.numericLiterals)\n          break;\n        next();\n        if (!isOctalDigit(currentCharCode)) {\n          reportError(\'Octal Integer Literal must contain at least one digit\', beginIndex);\n        }\n        skipOctalDigits();\n        return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));\n      case 48:\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        return scanPostDigit(beginIndex);\n    }\n    return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function createToken(type, beginIndex) {\n    return new Token(type, getTokenRange(beginIndex));\n  }\n  function readUnicodeEscapeSequence() {\n    var beginIndex = index;\n    if (currentCharCode === 117) {\n      next();\n      if (skipHexDigit() && skipHexDigit() && skipHexDigit() && skipHexDigit()) {\n        return parseInt(getTokenString(beginIndex + 1), 16);\n      }\n    }\n    reportError(\'Invalid unicode escape sequence in identifier\', beginIndex - 1);\n    return 0;\n  }\n  function scanIdentifierOrKeyword(beginIndex, code) {\n    var escapedCharCodes;\n    if (code === 92) {\n      code = readUnicodeEscapeSequence();\n      escapedCharCodes = [code];\n    }\n    if (!isIdentifierStart(code)) {\n      reportError(("Character code \'" + code + "\' is not a valid identifier start char"), beginIndex);\n      return createToken(ERROR, beginIndex);\n    }\n    for (; ; ) {\n      code = currentCharCode;\n      if (isIdentifierPart(code)) {\n        next();\n      } else if (code === 92) {\n        next();\n        code = readUnicodeEscapeSequence();\n        if (!escapedCharCodes)\n          escapedCharCodes = [];\n        escapedCharCodes.push(code);\n        if (!isIdentifierPart(code))\n          return createToken(ERROR, beginIndex);\n      } else {\n        break;\n      }\n    }\n    var value = input.slice(beginIndex, index);\n    var keywordType = getKeywordType(value);\n    if (keywordType)\n      return new KeywordToken(value, keywordType, getTokenRange(beginIndex));\n    if (escapedCharCodes) {\n      var i = 0;\n      value = value.replace(/\\\\u..../g, function(s) {\n        return String.fromCharCode(escapedCharCodes[i++]);\n      });\n    }\n    return new IdentifierToken(getTokenRange(beginIndex), value);\n  }\n  function scanStringLiteral(beginIndex, terminator) {\n    while (peekStringLiteralChar(terminator)) {\n      if (!skipStringLiteralChar()) {\n        return new LiteralToken(STRING, getTokenString(beginIndex), getTokenRange(beginIndex));\n      }\n    }\n    if (currentCharCode !== terminator) {\n      reportError(\'Unterminated String Literal\', beginIndex);\n    } else {\n      next();\n    }\n    return new LiteralToken(STRING, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function getTokenString(beginIndex) {\n    return input.substring(beginIndex, index);\n  }\n  function peekStringLiteralChar(terminator) {\n    return !isAtEnd() && currentCharCode !== terminator && !isLineTerminator(currentCharCode);\n  }\n  function skipStringLiteralChar() {\n    if (currentCharCode === 92) {\n      return skipStringLiteralEscapeSequence();\n    }\n    next();\n    return true;\n  }\n  function skipStringLiteralEscapeSequence() {\n    next();\n    if (isAtEnd()) {\n      reportError(\'Unterminated string literal escape sequence\');\n      return false;\n    }\n    if (isLineTerminator(currentCharCode)) {\n      skipLineTerminator();\n      return true;\n    }\n    var code = currentCharCode;\n    next();\n    switch (code) {\n      case 39:\n      case 34:\n      case 92:\n      case 98:\n      case 102:\n      case 110:\n      case 114:\n      case 116:\n      case 118:\n      case 48:\n        return true;\n      case 120:\n        return skipHexDigit() && skipHexDigit();\n      case 117:\n        return skipUnicodeEscapeSequence();\n      default:\n        return true;\n    }\n  }\n  function skipUnicodeEscapeSequence() {\n    if (currentCharCode === 123 && options.unicodeEscapeSequences) {\n      next();\n      var beginIndex = index;\n      if (!isHexDigit(currentCharCode)) {\n        reportError(\'Hex digit expected\', beginIndex);\n        return false;\n      }\n      skipHexDigits();\n      if (currentCharCode !== 125) {\n        reportError(\'Hex digit expected\', beginIndex);\n        return false;\n      }\n      var codePoint = getTokenString(beginIndex, index);\n      if (parseInt(codePoint, 16) > 0x10FFFF) {\n        reportError(\'The code point in a Unicode escape sequence cannot exceed 10FFFF\', beginIndex);\n        return false;\n      }\n      next();\n      return true;\n    }\n    return skipHexDigit() && skipHexDigit() && skipHexDigit() && skipHexDigit();\n  }\n  function skipHexDigit() {\n    if (!isHexDigit(currentCharCode)) {\n      reportError(\'Hex digit expected\');\n      return false;\n    }\n    next();\n    return true;\n  }\n  function skipLineTerminator() {\n    var first = currentCharCode;\n    next();\n    if (first === 13 && currentCharCode === 10) {\n      next();\n    }\n  }\n  function scanFractionalNumericLiteral(beginIndex) {\n    if (currentCharCode === 46) {\n      next();\n      skipDecimalDigits();\n    }\n    return scanExponentOfNumericLiteral(beginIndex);\n  }\n  function scanExponentOfNumericLiteral(beginIndex) {\n    switch (currentCharCode) {\n      case 101:\n      case 69:\n        next();\n        switch (currentCharCode) {\n          case 43:\n          case 45:\n            next();\n            break;\n        }\n        if (!isDecimalDigit(currentCharCode)) {\n          reportError(\'Exponent part must contain at least one digit\', beginIndex);\n        }\n        skipDecimalDigits();\n        break;\n      default:\n        break;\n    }\n    return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function skipDecimalDigits() {\n    while (isDecimalDigit(currentCharCode)) {\n      next();\n    }\n  }\n  function skipHexDigits() {\n    while (isHexDigit(currentCharCode)) {\n      next();\n    }\n  }\n  function skipBinaryDigits() {\n    while (isBinaryDigit(currentCharCode)) {\n      next();\n    }\n  }\n  function skipOctalDigits() {\n    while (isOctalDigit(currentCharCode)) {\n      next();\n    }\n  }\n  function isAtEnd() {\n    return index === length;\n  }\n  function next() {\n    index++;\n    updateCurrentCharCode();\n  }\n  function updateCurrentCharCode() {\n    currentCharCode = input.charCodeAt(index);\n  }\n  function reportError(message) {\n    var startIndex = arguments[1] !== (void 0) ? arguments[1] : index;\n    var endIndex = arguments[2] !== (void 0) ? arguments[2] : index;\n    var start = getPositionByOffset(startIndex);\n    var end = getPositionByOffset(endIndex);\n    var location = new SourceRange(start, end);\n    errorReporter.reportError(location, message);\n  }\n  return {\n    get isWhitespace() {\n      return isWhitespace;\n    },\n    get isLineTerminator() {\n      return isLineTerminator;\n    },\n    get isIdentifierPart() {\n      return isIdentifierPart;\n    },\n    get init() {\n      return init;\n    },\n    get getLastToken() {\n      return getLastToken;\n    },\n    get nextRegularExpressionLiteralToken() {\n      return nextRegularExpressionLiteralToken;\n    },\n    get nextTemplateLiteralToken() {\n      return nextTemplateLiteralToken;\n    },\n    get setIndex() {\n      return setIndex;\n    },\n    get getPosition() {\n      return getPosition;\n    },\n    get nextCloseAngle() {\n      return nextCloseAngle;\n    },\n    get peekJsxToken() {\n      return peekJsxToken;\n    },\n    get nextJsxToken() {\n      return nextJsxToken;\n    },\n    get nextJsxTextToken() {\n      return nextJsxTextToken;\n    },\n    get nextToken() {\n      return nextToken;\n    },\n    get peekTokenNoLineTerminator() {\n      return peekTokenNoLineTerminator;\n    },\n    get peek() {\n      return peek;\n    },\n    get peekLookahead() {\n      return peekLookahead;\n    },\n    get peekToken() {\n      return peekToken;\n    },\n    get peekType() {\n      return peekType;\n    },\n    get peekLocation() {\n      return peekLocation;\n    },\n    get peekTokenLookahead() {\n      return peekTokenLookahead;\n    },\n    get isAtEnd() {\n      return isAtEnd;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/ConstructorValidator.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/ConstructorValidator.js";\n  var SUPER_EXPRESSION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/semantics/ConstructorValidator.js")).SUPER_EXPRESSION;\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../codegeneration/FindVisitor.js", "traceur@0.0.111/src/semantics/ConstructorValidator.js")).FindVisitor;\n  var ConstructorValidator = function($__super) {\n    function ConstructorValidator(reporter) {\n      $traceurRuntime.superConstructor(ConstructorValidator).call(this);\n      this.reporter_ = reporter;\n      this.hasError = false;\n    }\n    return ($traceurRuntime.createClass)(ConstructorValidator, {\n      visitClassExpression: function(tree) {\n        this.visitAny(tree.superClass);\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitAny(tree.superClass);\n      },\n      visitThisExpression: function(tree) {\n        this.reportError_(tree.location, \'this\');\n      },\n      visitCallExpression: function(tree) {\n        if (tree.operand.type === SUPER_EXPRESSION) {\n          this.visitAny(tree.args);\n          this.found = true;\n          return;\n        }\n        $traceurRuntime.superGet(this, ConstructorValidator.prototype, "visitCallExpression").call(this, tree);\n      },\n      visitSuperExpression: function(tree) {\n        this.reportError_(tree.location, \'super property\');\n      },\n      reportError_: function(location, kind) {\n        this.reporter_.reportError(location, ("\'" + kind + "\' is not allowed before super()"));\n        this.hasError = true;\n        this.found = true;\n      }\n    }, {}, $__super);\n  }(FindVisitor);\n  function validateConstructor(tree, reporter) {\n    var visitor = new ConstructorValidator(reporter);\n    visitor.visitAny(tree);\n    if (visitor.hasError)\n      return false;\n    if (visitor.found)\n      return true;\n    reporter.reportError(tree.location, \'Derived constructor must call super()\');\n    return false;\n  }\n  return {get validateConstructor() {\n      return validateConstructor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/staticsemantics/validateParameters.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/staticsemantics/validateParameters.js";\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/ParseTreeVisitor.js", "traceur@0.0.111/src/staticsemantics/validateParameters.js")).ParseTreeVisitor;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringSet.js", "traceur@0.0.111/src/staticsemantics/validateParameters.js")).StringSet;\n  var isStrictKeyword = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/Keywords.js", "traceur@0.0.111/src/staticsemantics/validateParameters.js")).isStrictKeyword;\n  var ParameterValidationVisitor = function($__super) {\n    function ParameterValidationVisitor(isStrict, reporter) {\n      $traceurRuntime.superConstructor(ParameterValidationVisitor).call(this);\n      this.reporter_ = reporter;\n      this.names_ = new StringSet();\n      this.errors_ = [];\n      this.reportStrictKeywords_ = isStrict;\n      this.reportDuplicates_ = isStrict;\n    }\n    return ($traceurRuntime.createClass)(ParameterValidationVisitor, {\n      visitBindingIdentifier: function(tree) {\n        var name = tree.identifierToken.toString();\n        if (this.reportStrictKeywords_ && (isStrictKeyword(name) || name === \'eval\' || name === \'arguments\')) {\n          this.reporter_.reportError(tree.location, (name + " is a reserved identifier"));\n        }\n        if (this.names_.has(name)) {\n          this.maybeReportDuplicateError_(name, tree.location);\n        }\n        this.names_.add(name);\n      },\n      visitBindingElement: function(tree) {\n        if (tree.initializer !== null) {\n          this.reportEarlierErrors_();\n        }\n        this.visitAny(tree.binding);\n      },\n      visitRestParameter: function(tree) {\n        this.reportEarlierErrors_();\n        this.visitAny(tree.identifier);\n      },\n      visitFormalParameter: function(tree) {\n        this.visitAny(tree.parameter);\n      },\n      visitArrayPattern: function(tree) {\n        this.reportEarlierErrors_();\n        $traceurRuntime.superGet(this, ParameterValidationVisitor.prototype, "visitArrayPattern").call(this, tree);\n      },\n      visitObjectPattern: function(tree) {\n        this.reportEarlierErrors_();\n        $traceurRuntime.superGet(this, ParameterValidationVisitor.prototype, "visitObjectPattern").call(this, tree);\n      },\n      reportDuplicateError_: function(name, location) {\n        this.reporter_.reportError(location, ("Duplicate parameter name " + name));\n      },\n      maybeReportDuplicateError_: function(name, location) {\n        if (this.reportDuplicates_) {\n          this.reportDuplicateError_(name, location);\n        } else {\n          this.errors_.push(name, location);\n        }\n      },\n      reportEarlierErrors_: function() {\n        if (!this.reportDuplicates_) {\n          this.reportDuplicates_ = true;\n          for (var i = 0; i < this.errors_.length; i += 2) {\n            var name = this.errors_[i];\n            var location = this.errors_[i + 1];\n            this.reportDuplicateError_(name, location);\n          }\n        }\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  var $__default = function(tree, isStrict, reporter) {\n    new ParameterValidationVisitor(isStrict, reporter).visitAny(tree);\n  };\n  return {get default() {\n      return $__default;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/staticsemantics/isValidSimpleAssignmentTarget.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/staticsemantics/isValidSimpleAssignmentTarget.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/staticsemantics/isValidSimpleAssignmentTarget.js")),\n      IDENTIFIER_EXPRESSION = $__1.IDENTIFIER_EXPRESSION,\n      MEMBER_EXPRESSION = $__1.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__1.MEMBER_LOOKUP_EXPRESSION,\n      PAREN_EXPRESSION = $__1.PAREN_EXPRESSION;\n  function isValidSimpleAssignmentTarget(tree, isStrict) {\n    switch (tree.type) {\n      case IDENTIFIER_EXPRESSION:\n        {\n          if (!isStrict)\n            return true;\n          var value = tree.identifierToken.value;\n          return value !== \'arguments\' && value !== \'eval\';\n        }\n      case PAREN_EXPRESSION:\n        return isValidSimpleAssignmentTarget(tree.expression, isStrict);\n      case MEMBER_EXPRESSION:\n      case MEMBER_LOOKUP_EXPRESSION:\n        return true;\n      default:\n        return false;\n    }\n  }\n  return {get default() {\n      return isValidSimpleAssignmentTarget;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/Parser.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/Parser.js";\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../codegeneration/FindVisitor.js", "traceur@0.0.111/src/syntax/Parser.js")).FindVisitor;\n  var IdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./IdentifierToken.js", "traceur@0.0.111/src/syntax/Parser.js")).IdentifierToken;\n  var $__25 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./trees/ParseTreeType.js", "traceur@0.0.111/src/syntax/Parser.js")),\n      ARRAY_LITERAL = $__25.ARRAY_LITERAL,\n      BINDING_IDENTIFIER = $__25.BINDING_IDENTIFIER,\n      CALL_EXPRESSION = $__25.CALL_EXPRESSION,\n      COMPUTED_PROPERTY_NAME = $__25.COMPUTED_PROPERTY_NAME,\n      COVER_FORMALS = $__25.COVER_FORMALS,\n      FORMAL_PARAMETER_LIST = $__25.FORMAL_PARAMETER_LIST,\n      IDENTIFIER_EXPRESSION = $__25.IDENTIFIER_EXPRESSION,\n      LITERAL_PROPERTY_NAME = $__25.LITERAL_PROPERTY_NAME,\n      OBJECT_LITERAL = $__25.OBJECT_LITERAL,\n      REST_PARAMETER = $__25.REST_PARAMETER,\n      SYNTAX_ERROR_TREE = $__25.SYNTAX_ERROR_TREE;\n  var Options = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Options.js", "traceur@0.0.111/src/syntax/Parser.js")).Options;\n  var $__27 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PredefinedName.js", "traceur@0.0.111/src/syntax/Parser.js")),\n      AS = $__27.AS,\n      ASYNC = $__27.ASYNC,\n      ASYNC_STAR = $__27.ASYNC_STAR,\n      AWAIT = $__27.AWAIT,\n      CONSTRUCTOR = $__27.CONSTRUCTOR,\n      FROM = $__27.FROM,\n      GET = $__27.GET,\n      OF = $__27.OF,\n      ON = $__27.ON,\n      SET = $__27.SET,\n      TYPE = $__27.TYPE;\n  var SyntaxErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/SyntaxErrorReporter.js", "traceur@0.0.111/src/syntax/Parser.js")).SyntaxErrorReporter;\n  var $__29 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Scanner.js", "traceur@0.0.111/src/syntax/Parser.js")),\n      getLastToken = $__29.getLastToken,\n      getPosition = $__29.getPosition,\n      initScanner = $__29.init,\n      isAtEnd = $__29.isAtEnd,\n      nextCloseAngle = $__29.nextCloseAngle,\n      nextJsxTextToken = $__29.nextJsxTextToken,\n      nextJsxToken = $__29.nextJsxToken,\n      nextRegularExpressionLiteralToken = $__29.nextRegularExpressionLiteralToken,\n      nextTemplateLiteralToken = $__29.nextTemplateLiteralToken,\n      nextToken = $__29.nextToken,\n      peek = $__29.peek,\n      peekJsxToken = $__29.peekJsxToken,\n      peekLocation = $__29.peekLocation,\n      peekLookahead = $__29.peekLookahead,\n      peekToken = $__29.peekToken,\n      peekTokenLookahead = $__29.peekTokenLookahead,\n      peekTokenNoLineTerminator = $__29.peekTokenNoLineTerminator,\n      peekType = $__29.peekType,\n      resetScanner = $__29.setIndex;\n  var SourceRange = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/SourceRange.js", "traceur@0.0.111/src/syntax/Parser.js")).SourceRange;\n  var $__31 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Token.js", "traceur@0.0.111/src/syntax/Parser.js")),\n      Token = $__31.Token,\n      isAssignmentOperator = $__31.isAssignmentOperator;\n  var getKeywordType = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Keywords.js", "traceur@0.0.111/src/syntax/Parser.js")).getKeywordType;\n  var validateConstructor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../semantics/ConstructorValidator.js", "traceur@0.0.111/src/syntax/Parser.js")).validateConstructor;\n  var validateParameters = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../staticsemantics/validateParameters.js", "traceur@0.0.111/src/syntax/Parser.js")).default;\n  var isValidSimpleAssignmentTarget = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../staticsemantics/isValidSimpleAssignmentTarget.js", "traceur@0.0.111/src/syntax/Parser.js")).default;\n  var $__36 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TokenType.js", "traceur@0.0.111/src/syntax/Parser.js")),\n      AMPERSAND = $__36.AMPERSAND,\n      AND = $__36.AND,\n      ARROW = $__36.ARROW,\n      AT = $__36.AT,\n      BANG = $__36.BANG,\n      BAR = $__36.BAR,\n      BREAK = $__36.BREAK,\n      CARET = $__36.CARET,\n      CASE = $__36.CASE,\n      CATCH = $__36.CATCH,\n      CLASS = $__36.CLASS,\n      CLOSE_ANGLE = $__36.CLOSE_ANGLE,\n      CLOSE_CURLY = $__36.CLOSE_CURLY,\n      CLOSE_PAREN = $__36.CLOSE_PAREN,\n      CLOSE_SQUARE = $__36.CLOSE_SQUARE,\n      COLON = $__36.COLON,\n      COMMA = $__36.COMMA,\n      CONST = $__36.CONST,\n      CONTINUE = $__36.CONTINUE,\n      DEBUGGER = $__36.DEBUGGER,\n      DEFAULT = $__36.DEFAULT,\n      DELETE = $__36.DELETE,\n      DO = $__36.DO,\n      DOT_DOT_DOT = $__36.DOT_DOT_DOT,\n      ELSE = $__36.ELSE,\n      END_OF_FILE = $__36.END_OF_FILE,\n      EQUAL = $__36.EQUAL,\n      EQUAL_EQUAL = $__36.EQUAL_EQUAL,\n      EQUAL_EQUAL_EQUAL = $__36.EQUAL_EQUAL_EQUAL,\n      ERROR = $__36.ERROR,\n      EXPORT = $__36.EXPORT,\n      EXTENDS = $__36.EXTENDS,\n      FALSE = $__36.FALSE,\n      FINALLY = $__36.FINALLY,\n      FOR = $__36.FOR,\n      FUNCTION = $__36.FUNCTION,\n      GREATER_EQUAL = $__36.GREATER_EQUAL,\n      IDENTIFIER = $__36.IDENTIFIER,\n      IF = $__36.IF,\n      IMPLEMENTS = $__36.IMPLEMENTS,\n      IMPORT = $__36.IMPORT,\n      IN = $__36.IN,\n      INSTANCEOF = $__36.INSTANCEOF,\n      INTERFACE = $__36.INTERFACE,\n      JSX_IDENTIFIER = $__36.JSX_IDENTIFIER,\n      LEFT_SHIFT = $__36.LEFT_SHIFT,\n      LESS_EQUAL = $__36.LESS_EQUAL,\n      LET = $__36.LET,\n      MINUS = $__36.MINUS,\n      MINUS_MINUS = $__36.MINUS_MINUS,\n      NEW = $__36.NEW,\n      NO_SUBSTITUTION_TEMPLATE = $__36.NO_SUBSTITUTION_TEMPLATE,\n      NOT_EQUAL = $__36.NOT_EQUAL,\n      NOT_EQUAL_EQUAL = $__36.NOT_EQUAL_EQUAL,\n      NULL = $__36.NULL,\n      NUMBER = $__36.NUMBER,\n      OPEN_ANGLE = $__36.OPEN_ANGLE,\n      OPEN_CURLY = $__36.OPEN_CURLY,\n      OPEN_PAREN = $__36.OPEN_PAREN,\n      OPEN_SQUARE = $__36.OPEN_SQUARE,\n      OR = $__36.OR,\n      PACKAGE = $__36.PACKAGE,\n      PERCENT = $__36.PERCENT,\n      PERIOD = $__36.PERIOD,\n      PLUS = $__36.PLUS,\n      PLUS_PLUS = $__36.PLUS_PLUS,\n      PRIVATE = $__36.PRIVATE,\n      PROTECTED = $__36.PROTECTED,\n      PUBLIC = $__36.PUBLIC,\n      QUESTION = $__36.QUESTION,\n      RETURN = $__36.RETURN,\n      RIGHT_SHIFT = $__36.RIGHT_SHIFT,\n      SEMI_COLON = $__36.SEMI_COLON,\n      SLASH = $__36.SLASH,\n      SLASH_EQUAL = $__36.SLASH_EQUAL,\n      STAR = $__36.STAR,\n      STAR_STAR = $__36.STAR_STAR,\n      STATIC = $__36.STATIC,\n      STRING = $__36.STRING,\n      SUPER = $__36.SUPER,\n      SWITCH = $__36.SWITCH,\n      TEMPLATE_HEAD = $__36.TEMPLATE_HEAD,\n      TEMPLATE_TAIL = $__36.TEMPLATE_TAIL,\n      THIS = $__36.THIS,\n      THROW = $__36.THROW,\n      TILDE = $__36.TILDE,\n      TRUE = $__36.TRUE,\n      TRY = $__36.TRY,\n      TYPEOF = $__36.TYPEOF,\n      UNSIGNED_RIGHT_SHIFT = $__36.UNSIGNED_RIGHT_SHIFT,\n      VAR = $__36.VAR,\n      VOID = $__36.VOID,\n      WHILE = $__36.WHILE,\n      WITH = $__36.WITH,\n      YIELD = $__36.YIELD;\n  var $__37 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./trees/ParseTrees.js", "traceur@0.0.111/src/syntax/Parser.js")),\n      ArgumentList = $__37.ArgumentList,\n      ArrayComprehension = $__37.ArrayComprehension,\n      ArrayLiteral = $__37.ArrayLiteral,\n      ArrayPattern = $__37.ArrayPattern,\n      ArrayType = $__37.ArrayType,\n      ArrowFunction = $__37.ArrowFunction,\n      AssignmentElement = $__37.AssignmentElement,\n      AwaitExpression = $__37.AwaitExpression,\n      BinaryExpression = $__37.BinaryExpression,\n      BindingElement = $__37.BindingElement,\n      BindingIdentifier = $__37.BindingIdentifier,\n      Block = $__37.Block,\n      BreakStatement = $__37.BreakStatement,\n      CallExpression = $__37.CallExpression,\n      CallSignature = $__37.CallSignature,\n      CaseClause = $__37.CaseClause,\n      Catch = $__37.Catch,\n      ClassDeclaration = $__37.ClassDeclaration,\n      ClassExpression = $__37.ClassExpression,\n      CommaExpression = $__37.CommaExpression,\n      ComprehensionFor = $__37.ComprehensionFor,\n      ComprehensionIf = $__37.ComprehensionIf,\n      ComputedPropertyName = $__37.ComputedPropertyName,\n      ConditionalExpression = $__37.ConditionalExpression,\n      ConstructSignature = $__37.ConstructSignature,\n      ConstructorType = $__37.ConstructorType,\n      ContinueStatement = $__37.ContinueStatement,\n      CoverFormals = $__37.CoverFormals,\n      CoverInitializedName = $__37.CoverInitializedName,\n      DebuggerStatement = $__37.DebuggerStatement,\n      Annotation = $__37.Annotation,\n      DefaultClause = $__37.DefaultClause,\n      DoWhileStatement = $__37.DoWhileStatement,\n      EmptyStatement = $__37.EmptyStatement,\n      ExportDeclaration = $__37.ExportDeclaration,\n      ExportDefault = $__37.ExportDefault,\n      ExportSpecifier = $__37.ExportSpecifier,\n      ExportSpecifierSet = $__37.ExportSpecifierSet,\n      ExportStar = $__37.ExportStar,\n      ExpressionStatement = $__37.ExpressionStatement,\n      Finally = $__37.Finally,\n      ForInStatement = $__37.ForInStatement,\n      ForOfStatement = $__37.ForOfStatement,\n      ForOnStatement = $__37.ForOnStatement,\n      ForStatement = $__37.ForStatement,\n      FormalParameter = $__37.FormalParameter,\n      FormalParameterList = $__37.FormalParameterList,\n      ForwardDefaultExport = $__37.ForwardDefaultExport,\n      FunctionBody = $__37.FunctionBody,\n      FunctionDeclaration = $__37.FunctionDeclaration,\n      FunctionExpression = $__37.FunctionExpression,\n      FunctionType = $__37.FunctionType,\n      GeneratorComprehension = $__37.GeneratorComprehension,\n      GetAccessor = $__37.GetAccessor,\n      IdentifierExpression = $__37.IdentifierExpression,\n      IfStatement = $__37.IfStatement,\n      ImportClausePair = $__37.ImportClausePair,\n      ImportDeclaration = $__37.ImportDeclaration,\n      ImportSpecifier = $__37.ImportSpecifier,\n      ImportSpecifierSet = $__37.ImportSpecifierSet,\n      ImportedBinding = $__37.ImportedBinding,\n      ImportTypeClause = $__37.ImportTypeClause,\n      IndexSignature = $__37.IndexSignature,\n      InterfaceDeclaration = $__37.InterfaceDeclaration,\n      JsxAttribute = $__37.JsxAttribute,\n      JsxElement = $__37.JsxElement,\n      JsxElementName = $__37.JsxElementName,\n      JsxPlaceholder = $__37.JsxPlaceholder,\n      JsxSpreadAttribute = $__37.JsxSpreadAttribute,\n      JsxText = $__37.JsxText,\n      LabelledStatement = $__37.LabelledStatement,\n      LiteralExpression = $__37.LiteralExpression,\n      LiteralPropertyName = $__37.LiteralPropertyName,\n      MemberExpression = $__37.MemberExpression,\n      MemberLookupExpression = $__37.MemberLookupExpression,\n      Method = $__37.Method,\n      MethodSignature = $__37.MethodSignature,\n      Module = $__37.Module,\n      ModuleSpecifier = $__37.ModuleSpecifier,\n      NameSpaceExport = $__37.NameSpaceExport,\n      NameSpaceImport = $__37.NameSpaceImport,\n      NamedExport = $__37.NamedExport,\n      NewExpression = $__37.NewExpression,\n      ObjectLiteral = $__37.ObjectLiteral,\n      ObjectPattern = $__37.ObjectPattern,\n      ObjectPatternField = $__37.ObjectPatternField,\n      ObjectType = $__37.ObjectType,\n      ParenExpression = $__37.ParenExpression,\n      PostfixExpression = $__37.PostfixExpression,\n      PredefinedType = $__37.PredefinedType,\n      PropertyNameAssignment = $__37.PropertyNameAssignment,\n      PropertyNameShorthand = $__37.PropertyNameShorthand,\n      PropertySignature = $__37.PropertySignature,\n      PropertyVariableDeclaration = $__37.PropertyVariableDeclaration,\n      RestParameter = $__37.RestParameter,\n      ReturnStatement = $__37.ReturnStatement,\n      Script = $__37.Script,\n      SetAccessor = $__37.SetAccessor,\n      SpreadExpression = $__37.SpreadExpression,\n      SpreadPatternElement = $__37.SpreadPatternElement,\n      SuperExpression = $__37.SuperExpression,\n      SwitchStatement = $__37.SwitchStatement,\n      SyntaxErrorTree = $__37.SyntaxErrorTree,\n      TemplateLiteralExpression = $__37.TemplateLiteralExpression,\n      TemplateLiteralPortion = $__37.TemplateLiteralPortion,\n      TemplateSubstitution = $__37.TemplateSubstitution,\n      ThisExpression = $__37.ThisExpression,\n      ThrowStatement = $__37.ThrowStatement,\n      TryStatement = $__37.TryStatement,\n      TypeAliasDeclaration = $__37.TypeAliasDeclaration,\n      TypeArguments = $__37.TypeArguments,\n      TypeName = $__37.TypeName,\n      TypeParameter = $__37.TypeParameter,\n      TypeParameters = $__37.TypeParameters,\n      TypeReference = $__37.TypeReference,\n      UnaryExpression = $__37.UnaryExpression,\n      UnionType = $__37.UnionType,\n      VariableDeclaration = $__37.VariableDeclaration,\n      VariableDeclarationList = $__37.VariableDeclarationList,\n      VariableStatement = $__37.VariableStatement,\n      WhileStatement = $__37.WhileStatement,\n      WithStatement = $__37.WithStatement,\n      YieldExpression = $__37.YieldExpression;\n  var ALLOW_IN = true;\n  var NO_IN = false;\n  var INITIALIZER_REQUIRED = true;\n  var INITIALIZER_OPTIONAL = false;\n  var ValidateObjectLiteral = function($__super) {\n    function ValidateObjectLiteral() {\n      $traceurRuntime.superConstructor(ValidateObjectLiteral).call(this);\n      this.errorToken = null;\n    }\n    return ($traceurRuntime.createClass)(ValidateObjectLiteral, {visitCoverInitializedName: function(tree) {\n        this.errorToken = tree.equalToken;\n        this.found = true;\n      }}, {}, $__super);\n  }(FindVisitor);\n  function containsInitializer(declarations) {\n    return declarations.some(function(v) {\n      return v.initializer;\n    });\n  }\n  var FUNCTION_STATE_SCRIPT = 1;\n  var FUNCTION_STATE_MODULE = 1 << 1;\n  var FUNCTION_STATE_FUNCTION = 1 << 2;\n  var FUNCTION_STATE_ARROW = 1 << 3;\n  var FUNCTION_STATE_METHOD = 1 << 4;\n  var FUNCTION_STATE_DERIVED_CONSTRUCTOR = 1 << 5;\n  var FUNCTION_STATE_GENERATOR = 1 << 6;\n  var FUNCTION_STATE_ASYNC = 1 << 7;\n  var FUNCTION_STATE_LENIENT = FUNCTION_STATE_METHOD | FUNCTION_STATE_GENERATOR | FUNCTION_STATE_ASYNC | FUNCTION_STATE_DERIVED_CONSTRUCTOR;\n  var FunctionState = function() {\n    function FunctionState(outer, kind) {\n      this.outer = outer;\n      this.kind = kind;\n    }\n    return ($traceurRuntime.createClass)(FunctionState, {\n      isTopMost: function() {\n        return this.kind & (FUNCTION_STATE_SCRIPT | FUNCTION_STATE_MODULE);\n      },\n      isMethod: function() {\n        return this.kind & FUNCTION_STATE_METHOD;\n      },\n      isDerivedConstructor: function() {\n        return this.kind & FUNCTION_STATE_DERIVED_CONSTRUCTOR;\n      },\n      isArrowFunction: function() {\n        return this.kind & FUNCTION_STATE_ARROW;\n      },\n      isGenerator: function() {\n        return this.kind & FUNCTION_STATE_GENERATOR;\n      },\n      isAsyncFunction: function() {\n        return this.kind & FUNCTION_STATE_ASYNC;\n      },\n      isAsyncGenerator: function() {\n        return this.isGenerator() && this.isAsyncFunction();\n      }\n    }, {});\n  }();\n  var Parser = function() {\n    function Parser(file) {\n      var errorReporter = arguments[1] !== (void 0) ? arguments[1] : new SyntaxErrorReporter();\n      var options = arguments[2] !== (void 0) ? arguments[2] : new Options();\n      this.errorReporter_ = errorReporter;\n      initScanner(errorReporter, file, this, options);\n      this.options_ = options;\n      this.coverInitializedNameCount_ = 0;\n      this.strictMode_ = false;\n      this.annotations_ = [];\n      this.functionState_ = null;\n    }\n    return ($traceurRuntime.createClass)(Parser, {\n      get allowYield_() {\n        return this.functionState_.isGenerator();\n      },\n      get allowAwait_() {\n        return this.functionState_.isAsyncFunction();\n      },\n      get allowForOn_() {\n        return this.functionState_.isAsyncFunction();\n      },\n      parseScript: function() {\n        this.strictMode_ = false;\n        var start = this.getTreeStartLocation_();\n        var fs = this.pushFunctionState_(FUNCTION_STATE_SCRIPT);\n        var scriptItemList = this.parseStatementList_(true);\n        this.eat_(END_OF_FILE);\n        this.popFunctionState_(fs);\n        return new Script(this.getTreeLocation_(start), scriptItemList, null);\n      },\n      pushFunctionState_: function(kind) {\n        return this.functionState_ = new FunctionState(this.functionState_, kind);\n      },\n      popFunctionState_: function(fs) {\n        if (fs != this.functionState_) {\n          throw new Error(\'Internal error\');\n        }\n        this.functionState_ = this.functionState_.outer;\n      },\n      parseStatementList_: function(checkUseStrictDirective) {\n        var result = [];\n        var type;\n        while ((type = peekType()) !== CLOSE_CURLY && type !== END_OF_FILE) {\n          var statement = this.parseStatementListItem_(type);\n          if (checkUseStrictDirective) {\n            if (!statement.isDirectivePrologue()) {\n              checkUseStrictDirective = false;\n            } else if (statement.isUseStrictDirective()) {\n              this.strictMode_ = true;\n              checkUseStrictDirective = false;\n            }\n          }\n          result.push(statement);\n        }\n        return result;\n      },\n      parseStatementListItem_: function(type) {\n        switch (type) {\n          case LET:\n          case CONST:\n            if (this.options_.blockBinding) {\n              return this.parseVariableStatement_();\n            }\n            break;\n          case CLASS:\n            if (this.options_.classes) {\n              return this.parseClassDeclaration_();\n            }\n            break;\n          case FUNCTION:\n            return this.parseFunctionDeclaration_();\n          case IDENTIFIER:\n            if (this.options_.types && this.peekPredefinedString_(TYPE) && peekLookahead(IDENTIFIER)) {\n              return this.parseTypeAliasDeclaration_();\n            }\n            break;\n        }\n        return this.parseStatementWithType_(type);\n      },\n      parseModule: function() {\n        var start = this.getTreeStartLocation_();\n        var fs = this.pushFunctionState_(FUNCTION_STATE_MODULE);\n        var scriptItemList = this.parseModuleItemList_();\n        this.eat_(END_OF_FILE);\n        this.popFunctionState_(fs);\n        return new Module(this.getTreeLocation_(start), scriptItemList, null);\n      },\n      parseModuleItemList_: function() {\n        this.strictMode_ = true;\n        var result = [];\n        var type;\n        while ((type = peekType()) !== END_OF_FILE) {\n          var statement = this.parseModuleItem_(type);\n          result.push(statement);\n        }\n        return result;\n      },\n      parseModuleItem_: function(type) {\n        switch (type) {\n          case IMPORT:\n            return this.parseImportDeclaration_();\n          case EXPORT:\n            return this.parseExportDeclaration_();\n          case AT:\n            if (this.options_.annotations)\n              return this.parseAnnotatedDeclarations_(true);\n            break;\n        }\n        return this.parseStatementListItem_(type);\n      },\n      parseModuleSpecifier_: function() {\n        var start = this.getTreeStartLocation_();\n        var token = this.eat_(STRING);\n        return new ModuleSpecifier(this.getTreeLocation_(start), token);\n      },\n      parseNameSpaceImport_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(STAR);\n        this.eatId_(AS);\n        var binding = this.parseImportedBinding_();\n        return new NameSpaceImport(this.getTreeLocation_(start), binding);\n      },\n      parseImportDeclaration_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(IMPORT);\n        var importClause = null;\n        if (!peek(STRING)) {\n          importClause = this.parseImportClause_(true, this.options_.types);\n          this.eatId_(FROM);\n        }\n        var moduleSpecifier = this.parseModuleSpecifier_();\n        this.eatPossibleImplicitSemiColon_();\n        return new ImportDeclaration(this.getTreeLocation_(start), importClause, moduleSpecifier);\n      },\n      parseImportClause_: function(allowImportedDefaultBinding, allowType) {\n        switch (peekType()) {\n          case STAR:\n            return this.parseNameSpaceImport_();\n          case OPEN_CURLY:\n            return this.parseImportSpecifierSet_();\n          case IDENTIFIER:\n            if (allowType && this.peekPredefinedString_(TYPE)) {\n              var start = this.getTreeStartLocation_();\n              var t = peekTokenLookahead();\n              if (t.type === OPEN_CURLY || t.type === IDENTIFIER && t.value !== FROM) {\n                this.eatId_(TYPE);\n                var clause = this.parseImportClause_(allowImportedDefaultBinding, false);\n                return new ImportTypeClause(this.getTreeLocation_(start), clause);\n              }\n            }\n            if (allowImportedDefaultBinding) {\n              var start$__4 = this.getTreeStartLocation_();\n              var importedBinding = this.parseImportedBinding_();\n              if (this.eatIf_(COMMA)) {\n                var second = this.parseImportClause_(false, false);\n                return new ImportClausePair(this.getTreeLocation_(start$__4), importedBinding, second);\n              }\n              return importedBinding;\n            }\n            break;\n        }\n        return this.parseUnexpectedToken_();\n      },\n      parseImportSpecifierSet_: function() {\n        var start = this.getTreeStartLocation_();\n        var specifiers = [];\n        this.eat_(OPEN_CURLY);\n        while (!peek(CLOSE_CURLY) && !isAtEnd()) {\n          specifiers.push(this.parseImportSpecifier_());\n          if (!this.eatIf_(COMMA))\n            break;\n        }\n        this.eat_(CLOSE_CURLY);\n        return new ImportSpecifierSet(this.getTreeLocation_(start), specifiers);\n      },\n      parseImportedBinding_: function() {\n        var start = this.getTreeStartLocation_();\n        var binding = this.parseBindingIdentifier_();\n        return new ImportedBinding(this.getTreeLocation_(start), binding);\n      },\n      parseImportSpecifier_: function() {\n        var start = this.getTreeStartLocation_();\n        var token = peekToken();\n        var isKeyword = token.isKeyword();\n        var binding;\n        var name = this.eatIdName_();\n        if (isKeyword || this.peekPredefinedString_(AS)) {\n          this.eatId_(AS);\n          binding = this.parseImportedBinding_();\n        } else {\n          binding = new ImportedBinding(name.location, new BindingIdentifier(name.location, name));\n          name = null;\n        }\n        return new ImportSpecifier(this.getTreeLocation_(start), binding, name);\n      },\n      parseExportDeclaration_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(EXPORT);\n        var exportTree;\n        var annotations = this.popAnnotations_();\n        var type = peekType();\n        switch (type) {\n          case CONST:\n          case LET:\n            if (this.options_.blockBinding) {\n              exportTree = this.parseVariableStatement_();\n              break;\n            }\n            return this.parseUnexpectedToken_();\n          case VAR:\n            exportTree = this.parseVariableStatement_();\n            break;\n          case FUNCTION:\n            exportTree = this.parseFunctionDeclaration_();\n            break;\n          case CLASS:\n            exportTree = this.parseClassDeclaration_();\n            break;\n          case DEFAULT:\n            exportTree = this.parseExportDefault_();\n            break;\n          case OPEN_CURLY:\n          case STAR:\n            exportTree = this.parseNamedExport_();\n            break;\n          case IDENTIFIER:\n            if (this.options_.asyncFunctions && this.peekPredefinedString_(ASYNC)) {\n              var asyncToken = this.eatId_();\n              exportTree = this.parseAsyncFunctionDeclaration_(asyncToken);\n            } else if (this.options_.types && this.peekPredefinedString_(TYPE) && peekLookahead(IDENTIFIER)) {\n              exportTree = this.parseTypeAliasDeclaration_();\n            } else if (this.options_.exportFromExtended) {\n              exportTree = this.parseNamedExport_();\n            } else {\n              return this.parseUnexpectedToken_();\n            }\n            break;\n          default:\n            {\n              var token = peekToken();\n              if (!token.isKeyword()) {\n                return this.parseUnexpectedToken_();\n              }\n              exportTree = this.parseNamedExport_();\n            }\n        }\n        return new ExportDeclaration(this.getTreeLocation_(start), exportTree, annotations);\n      },\n      parseExportDefault_: function() {\n        var start = this.getTreeStartLocation_();\n        var defaultToken = this.eat_(DEFAULT);\n        if (this.options_.exportFromExtended && this.peekPredefinedString_(FROM)) {\n          var idName = new IdentifierToken(defaultToken.location, DEFAULT);\n          var namedExport = new ForwardDefaultExport(this.getTreeLocation_(start), idName);\n          this.eatId_(FROM);\n          var moduleSpecifier = this.parseModuleSpecifier_();\n          return new NamedExport(this.getTreeLocation_(start), namedExport, moduleSpecifier);\n        }\n        var exportValue;\n        switch (peekType()) {\n          case FUNCTION:\n            {\n              var tree = this.parseFunctionExpression_();\n              if (tree.name) {\n                tree = new FunctionDeclaration(tree.location, tree.name, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n              }\n              exportValue = tree;\n              break;\n            }\n          case CLASS:\n            {\n              if (!this.options_.classes) {\n                return this.parseSyntaxError_(\'Unexpected reserved word\');\n              }\n              var tree$__5 = this.parseClassExpression_();\n              if (tree$__5.name) {\n                tree$__5 = new ClassDeclaration(tree$__5.location, tree$__5.name, tree$__5.superClass, tree$__5.elements, tree$__5.annotations, tree$__5.typeParameters);\n              }\n              exportValue = tree$__5;\n              break;\n            }\n          default:\n            exportValue = this.parseAssignmentExpression_(ALLOW_IN);\n            this.eatPossibleImplicitSemiColon_();\n        }\n        return new ExportDefault(this.getTreeLocation_(start), exportValue);\n      },\n      parseNamedExport_: function() {\n        var start = this.getTreeStartLocation_();\n        var exportClause,\n            moduleSpecifier = null;\n        switch (peekType()) {\n          case OPEN_CURLY:\n            exportClause = this.parseExportSpecifierSet_();\n            if (this.peekPredefinedString_(FROM)) {\n              this.eatId_(FROM);\n              moduleSpecifier = this.parseModuleSpecifier_();\n            } else {\n              this.validateExportSpecifierSet_(exportClause);\n            }\n            break;\n          case STAR:\n            exportClause = this.parseExportStar_();\n            this.eatId_(FROM);\n            moduleSpecifier = this.parseModuleSpecifier_();\n            break;\n          default:\n            exportClause = this.parseForwardDefaultExport_();\n            this.eatId_(FROM);\n            moduleSpecifier = this.parseModuleSpecifier_();\n            break;\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new NamedExport(this.getTreeLocation_(start), exportClause, moduleSpecifier);\n      },\n      parseExportStar_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(STAR);\n        if (this.peekPredefinedString_(AS)) {\n          this.eatId_(AS);\n          var name = this.eatIdName_();\n          return new NameSpaceExport(this.getTreeLocation_(start), name);\n        }\n        return new ExportStar(this.getTreeLocation_(start));\n      },\n      parseExportSpecifierSet_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_CURLY);\n        var specifiers = [this.parseExportSpecifier_()];\n        while (this.eatIf_(COMMA)) {\n          if (peek(CLOSE_CURLY))\n            break;\n          specifiers.push(this.parseExportSpecifier_());\n        }\n        this.eat_(CLOSE_CURLY);\n        return new ExportSpecifierSet(this.getTreeLocation_(start), specifiers);\n      },\n      parseExportSpecifier_: function() {\n        var start = this.getTreeStartLocation_();\n        var lhs = this.eatIdName_();\n        var rhs = null;\n        if (this.peekPredefinedString_(AS)) {\n          this.eatId_();\n          rhs = this.eatIdName_();\n        }\n        return new ExportSpecifier(this.getTreeLocation_(start), lhs, rhs);\n      },\n      parseForwardDefaultExport_: function() {\n        var start = this.getTreeStartLocation_();\n        var idName = this.eatIdName_();\n        return new ForwardDefaultExport(this.getTreeLocation_(start), idName);\n      },\n      validateExportSpecifierSet_: function(tree) {\n        for (var i = 0; i < tree.specifiers.length; i++) {\n          var specifier = tree.specifiers[i];\n          if (getKeywordType(specifier.lhs.value)) {\n            this.reportError_(specifier.lhs.location, ("Unexpected token " + specifier.lhs.value));\n          }\n        }\n      },\n      peekId_: function(type) {\n        if (type === IDENTIFIER)\n          return true;\n        if (this.strictMode_)\n          return false;\n        return peekToken().isStrictKeyword();\n      },\n      peekIdName_: function(token) {\n        return token.type === IDENTIFIER || token.isKeyword();\n      },\n      parseClassShared_: function(constr) {\n        var start = this.getTreeStartLocation_();\n        var strictMode = this.strictMode_;\n        this.strictMode_ = true;\n        this.eat_(CLASS);\n        var name = null;\n        var typeParameters = null;\n        var annotations = [];\n        if (constr === ClassDeclaration || !peek(EXTENDS) && !peek(OPEN_CURLY)) {\n          name = this.parseBindingIdentifier_();\n          if (this.options_.types) {\n            typeParameters = this.parseTypeParametersOpt_();\n          }\n          annotations = this.popAnnotations_();\n        }\n        var superClass = null;\n        if (this.eatIf_(EXTENDS)) {\n          superClass = this.parseLeftHandSideExpression_();\n          superClass = this.coverFormalsToParenExpression_(superClass);\n        }\n        this.eat_(OPEN_CURLY);\n        var elements = this.parseClassElements_(superClass);\n        this.eat_(CLOSE_CURLY);\n        this.strictMode_ = strictMode;\n        return new constr(this.getTreeLocation_(start), name, superClass, elements, annotations, typeParameters);\n      },\n      parseClassDeclaration_: function() {\n        return this.parseClassShared_(ClassDeclaration);\n      },\n      parseClassExpression_: function() {\n        return this.parseClassShared_(ClassExpression);\n      },\n      parseClassElements_: function(derivedClass) {\n        var result = [];\n        while (true) {\n          var type = peekType();\n          if (type === SEMI_COLON) {\n            nextToken();\n          } else if (this.peekClassElement_(peekType())) {\n            result.push(this.parseClassElement_(derivedClass));\n          } else {\n            break;\n          }\n        }\n        return result;\n      },\n      peekClassElement_: function(type) {\n        return this.peekPropertyName_(type) || type === STAR && this.options_.generators || type === AT && this.options_.annotations;\n      },\n      parsePropertyName_: function() {\n        if (peek(OPEN_SQUARE))\n          return this.parseComputedPropertyName_();\n        return this.parseLiteralPropertyName_();\n      },\n      parseLiteralPropertyName_: function() {\n        var start = this.getTreeStartLocation_();\n        var token = nextToken();\n        return new LiteralPropertyName(this.getTreeLocation_(start), token);\n      },\n      parseComputedPropertyName_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_SQUARE);\n        var expression = this.parseAssignmentExpression_(ALLOW_IN);\n        this.eat_(CLOSE_SQUARE);\n        return new ComputedPropertyName(this.getTreeLocation_(start), expression);\n      },\n      parseStatement: function() {\n        var fs = this.pushFunctionState_(FUNCTION_STATE_LENIENT);\n        var result = this.parseModuleItem_(peekType());\n        this.popFunctionState_(fs);\n        return result;\n      },\n      parseStatements: function() {\n        var fs = this.pushFunctionState_(FUNCTION_STATE_LENIENT);\n        var result = this.parseModuleItemList_();\n        this.popFunctionState_(fs);\n        return result;\n      },\n      parseStatement_: function() {\n        return this.parseStatementWithType_(peekType());\n      },\n      parseStatementWithType_: function(type) {\n        switch (type) {\n          case RETURN:\n            return this.parseReturnStatement_();\n          case VAR:\n            return this.parseVariableStatement_();\n          case IF:\n            return this.parseIfStatement_();\n          case FOR:\n            return this.parseForStatement_();\n          case BREAK:\n            return this.parseBreakStatement_();\n          case SWITCH:\n            return this.parseSwitchStatement_();\n          case THROW:\n            return this.parseThrowStatement_();\n          case WHILE:\n            return this.parseWhileStatement_();\n          case AT:\n            if (this.options_.annotations)\n              return this.parseAnnotatedDeclarations_(false);\n            break;\n          case CONTINUE:\n            return this.parseContinueStatement_();\n          case DEBUGGER:\n            return this.parseDebuggerStatement_();\n          case DO:\n            return this.parseDoWhileStatement_();\n          case OPEN_CURLY:\n            return this.parseBlock_();\n          case SEMI_COLON:\n            return this.parseEmptyStatement_();\n          case TRY:\n            return this.parseTryStatement_();\n          case WITH:\n            return this.parseWithStatement_();\n          case INTERFACE:\n            if (this.options_.types) {\n              return this.parseInterfaceDeclaration_();\n            }\n        }\n        return this.parseFallThroughStatement_();\n      },\n      parseFunctionDeclaration_: function() {\n        return this.parseFunction_(FunctionDeclaration);\n      },\n      parseFunctionExpression_: function() {\n        return this.parseFunction_(FunctionExpression);\n      },\n      parseAsyncFunctionDeclaration_: function(asyncToken) {\n        return this.parseAsyncFunction_(asyncToken, FunctionDeclaration);\n      },\n      parseAsyncFunctionExpression_: function(asyncToken) {\n        return this.parseAsyncFunction_(asyncToken, FunctionExpression);\n      },\n      peekAsyncStar_: function() {\n        return this.options_.asyncGenerators && peek(STAR);\n      },\n      parseAsyncFunction_: function(asyncToken, ctor) {\n        var start = asyncToken.location.start;\n        this.eat_(FUNCTION);\n        var kind = FUNCTION_STATE_FUNCTION | FUNCTION_STATE_ASYNC;\n        if (this.peekAsyncStar_()) {\n          kind |= FUNCTION_STATE_GENERATOR;\n          this.eat_(STAR);\n          asyncToken = new IdentifierToken(asyncToken.location, ASYNC_STAR);\n        }\n        var fs = this.pushFunctionState_(kind);\n        var f = this.parseFunction2_(start, asyncToken, ctor);\n        this.popFunctionState_(fs);\n        return f;\n      },\n      parseFunction_: function(ctor) {\n        var start = this.getTreeStartLocation_();\n        this.eat_(FUNCTION);\n        var functionKind = null;\n        var kind = FUNCTION_STATE_FUNCTION;\n        if (this.options_.generators && peek(STAR)) {\n          functionKind = this.eat_(STAR);\n          kind |= FUNCTION_STATE_GENERATOR;\n        }\n        var fs = this.pushFunctionState_(kind);\n        var f = this.parseFunction2_(start, functionKind, ctor);\n        this.popFunctionState_(fs);\n        return f;\n      },\n      parseFunction2_: function(start, functionKind, ctor) {\n        var name = null;\n        var annotations = [];\n        if (ctor === FunctionDeclaration || this.peekBindingIdentifier_(peekType())) {\n          name = this.parseBindingIdentifier_();\n          annotations = this.popAnnotations_();\n        }\n        this.eat_(OPEN_PAREN);\n        var parameters = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var body = this.parseFunctionBody_(parameters);\n        return new ctor(this.getTreeLocation_(start), name, functionKind, parameters, typeAnnotation, annotations, body);\n      },\n      peekRest_: function(type) {\n        return type === DOT_DOT_DOT && this.options_.restParameters;\n      },\n      parseFormalParameters_: function() {\n        var start = this.getTreeStartLocation_();\n        var formals = [];\n        this.pushAnnotations_();\n        var type = peekType();\n        if (this.peekRest_(type)) {\n          formals.push(this.parseFormalRestParameter_());\n        } else {\n          if (this.peekFormalParameter_(peekType()))\n            formals.push(this.parseFormalParameter_(INITIALIZER_OPTIONAL));\n          while (this.eatIf_(COMMA)) {\n            this.pushAnnotations_();\n            if (this.peekRest_(peekType())) {\n              formals.push(this.parseFormalRestParameter_());\n              break;\n            }\n            formals.push(this.parseFormalParameter_(INITIALIZER_OPTIONAL));\n          }\n        }\n        return new FormalParameterList(this.getTreeLocation_(start), formals);\n      },\n      peekFormalParameter_: function(type) {\n        return this.peekBindingElement_(type);\n      },\n      parseFormalParameter_: function(initializerAllowed) {\n        var start = this.getTreeStartLocation_();\n        var binding = this.parseBindingElementBinding_();\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var initializer = this.parseBindingElementInitializer_(initializerAllowed);\n        return new FormalParameter(this.getTreeLocation_(start), new BindingElement(this.getTreeLocation_(start), binding, initializer), typeAnnotation, this.popAnnotations_());\n      },\n      parseFormalRestParameter_: function() {\n        var start = this.getTreeStartLocation_();\n        var restParameter = this.parseRestParameter_();\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        return new FormalParameter(this.getTreeLocation_(start), restParameter, typeAnnotation, this.popAnnotations_());\n      },\n      parseRestParameter_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DOT_DOT_DOT);\n        var id = this.parseBindingIdentifier_();\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        return new RestParameter(this.getTreeLocation_(start), id, typeAnnotation);\n      },\n      parseFunctionBody_: function(params) {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_CURLY);\n        var strictMode = this.strictMode_;\n        var result = this.parseStatementList_(!strictMode);\n        validateParameters(params, this.strictMode_, this.errorReporter_);\n        this.strictMode_ = strictMode;\n        this.eat_(CLOSE_CURLY);\n        return new FunctionBody(this.getTreeLocation_(start), result);\n      },\n      parseSpreadExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DOT_DOT_DOT);\n        var operand = this.parseAssignmentExpression_(ALLOW_IN);\n        return new SpreadExpression(this.getTreeLocation_(start), operand);\n      },\n      parseBlock_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_CURLY);\n        var result = this.parseStatementList_(false);\n        this.eat_(CLOSE_CURLY);\n        return new Block(this.getTreeLocation_(start), result);\n      },\n      parseVariableStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        var declarations = this.parseVariableDeclarationList_(ALLOW_IN, INITIALIZER_REQUIRED);\n        this.checkInitializers_(declarations);\n        this.eatPossibleImplicitSemiColon_();\n        return new VariableStatement(this.getTreeLocation_(start), declarations);\n      },\n      parseVariableDeclarationList_: function(allowIn, initializerRequired) {\n        var type = peekType();\n        switch (type) {\n          case CONST:\n          case LET:\n          case VAR:\n            nextToken();\n            break;\n          default:\n            throw Error(\'unreachable\');\n        }\n        var start = this.getTreeStartLocation_();\n        var declarations = [];\n        declarations.push(this.parseVariableDeclaration_(type, allowIn, initializerRequired));\n        while (this.eatIf_(COMMA)) {\n          declarations.push(this.parseVariableDeclaration_(type, allowIn, initializerRequired));\n        }\n        return new VariableDeclarationList(this.getTreeLocation_(start), type, declarations);\n      },\n      parseVariableDeclaration_: function(binding, noIn, initializerRequired) {\n        var initRequired = initializerRequired !== INITIALIZER_OPTIONAL;\n        var start = this.getTreeStartLocation_();\n        var lvalue;\n        var typeAnnotation;\n        if (this.peekPattern_(peekType())) {\n          lvalue = this.parseBindingPattern_();\n          typeAnnotation = null;\n        } else {\n          lvalue = this.parseBindingIdentifier_();\n          typeAnnotation = this.parseTypeAnnotationOpt_();\n        }\n        var init = null;\n        if (peek(EQUAL)) {\n          init = this.parseInitializer_(noIn);\n        } else if (lvalue.isPattern() && initRequired) {\n          this.reportError_(lvalue.location, \'destructuring must have an initializer\');\n        }\n        return new VariableDeclaration(this.getTreeLocation_(start), lvalue, typeAnnotation, init);\n      },\n      parseInitializer_: function(allowIn) {\n        this.eat_(EQUAL);\n        return this.parseAssignmentExpression_(allowIn);\n      },\n      parseInitializerOpt_: function(allowIn) {\n        if (this.eatIf_(EQUAL))\n          return this.parseAssignmentExpression_(allowIn);\n        return null;\n      },\n      parseEmptyStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(SEMI_COLON);\n        return new EmptyStatement(this.getTreeLocation_(start));\n      },\n      parseFallThroughStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        var expression;\n        switch (peekType()) {\n          case OPEN_CURLY:\n            return this.parseUnexpectedToken_();\n          case FUNCTION:\n          case CLASS:\n            return this.parseUnexpectedReservedWord_(peekToken());\n          case LET:\n            {\n              var token = peekLookahead(OPEN_SQUARE);\n              if (token) {\n                return this.parseSyntaxError_("A statement cannot start with \'let [\'");\n              }\n            }\n        }\n        if (this.options_.asyncFunctions && this.peekPredefinedString_(ASYNC) && peekLookahead(FUNCTION)) {\n          var asyncToken = this.eatId_();\n          var functionToken = peekTokenNoLineTerminator();\n          if (functionToken !== null)\n            return this.parseAsyncFunctionDeclaration_(asyncToken);\n          expression = new IdentifierExpression(this.getTreeLocation_(start), asyncToken);\n        } else {\n          expression = this.parseExpression_(ALLOW_IN);\n        }\n        if (expression.type === IDENTIFIER_EXPRESSION) {\n          if (this.eatIf_(COLON)) {\n            var nameToken = expression.identifierToken;\n            var statement = this.parseStatement_();\n            return new LabelledStatement(this.getTreeLocation_(start), nameToken, statement);\n          }\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new ExpressionStatement(this.getTreeLocation_(start), expression);\n      },\n      parseIfStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(IF);\n        this.eat_(OPEN_PAREN);\n        var condition = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var ifClause = this.parseStatement_();\n        var elseClause = null;\n        if (this.eatIf_(ELSE)) {\n          elseClause = this.parseStatement_();\n        }\n        return new IfStatement(this.getTreeLocation_(start), condition, ifClause, elseClause);\n      },\n      parseDoWhileStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DO);\n        var body = this.parseStatement_();\n        this.eat_(WHILE);\n        this.eat_(OPEN_PAREN);\n        var condition = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        this.eatPossibleImplicitSemiColon_();\n        return new DoWhileStatement(this.getTreeLocation_(start), body, condition);\n      },\n      parseWhileStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(WHILE);\n        this.eat_(OPEN_PAREN);\n        var condition = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new WhileStatement(this.getTreeLocation_(start), condition, body);\n      },\n      parseForStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(FOR);\n        this.eat_(OPEN_PAREN);\n        var type = peekType();\n        if (this.peekVariableDeclarationList_(type)) {\n          var variables = this.parseVariableDeclarationList_(NO_IN, INITIALIZER_OPTIONAL);\n          var declarations = variables.declarations;\n          if (declarations.length > 1 || containsInitializer(declarations)) {\n            return this.parseForStatement2_(start, variables);\n          }\n          type = peekType();\n          if (type === IN) {\n            return this.parseForInStatement_(start, variables);\n          } else if (this.peekOf_()) {\n            return this.parseForOfStatement_(start, variables);\n          } else if (this.allowForOn_ && this.peekOn_()) {\n            return this.parseForOnStatement_(start, variables);\n          } else {\n            this.checkInitializers_(variables);\n            return this.parseForStatement2_(start, variables);\n          }\n        }\n        if (type === SEMI_COLON) {\n          return this.parseForStatement2_(start, null);\n        }\n        var coverInitializedNameCount = this.coverInitializedNameCount_;\n        var initializer = this.parseExpressionAllowPattern_(NO_IN);\n        type = peekType();\n        if ((type === IN || this.peekOf_() || this.allowForOn_ && this.peekOn_())) {\n          initializer = this.transformLeftHandSideExpression_(initializer);\n          this.validateAssignmentTarget_(initializer, \'assignment\');\n          if (this.peekOf_()) {\n            return this.parseForOfStatement_(start, initializer);\n          } else if (this.allowForOn_ && this.peekOn_()) {\n            return this.parseForOnStatement_(start, initializer);\n          }\n          return this.parseForInStatement_(start, initializer);\n        }\n        this.ensureNoCoverInitializedNames_(initializer, coverInitializedNameCount);\n        return this.parseForStatement2_(start, initializer);\n      },\n      peekOf_: function() {\n        return this.options_.forOf && this.peekPredefinedString_(OF);\n      },\n      peekOn_: function() {\n        return this.options_.forOn && this.peekPredefinedString_(ON);\n      },\n      parseForOfStatement_: function(start, initializer) {\n        this.eatId_();\n        var collection = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new ForOfStatement(this.getTreeLocation_(start), initializer, collection, body);\n      },\n      parseForOnStatement_: function(start, initializer) {\n        this.eatId_();\n        var observable = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new ForOnStatement(this.getTreeLocation_(start), initializer, observable, body);\n      },\n      checkInitializers_: function(variables) {\n        if (this.options_.blockBinding && variables.declarationType === CONST) {\n          var type = variables.declarationType;\n          for (var i = 0; i < variables.declarations.length; i++) {\n            if (!this.checkInitializer_(type, variables.declarations[i])) {\n              break;\n            }\n          }\n        }\n      },\n      checkInitializer_: function(type, declaration) {\n        if (this.options_.blockBinding && type === CONST && declaration.initializer === null) {\n          this.reportError_(declaration.location, \'const variables must have an initializer\');\n          return false;\n        }\n        return true;\n      },\n      peekVariableDeclarationList_: function(type) {\n        switch (type) {\n          case VAR:\n            return true;\n          case CONST:\n          case LET:\n            return this.options_.blockBinding;\n          default:\n            return false;\n        }\n      },\n      parseForStatement2_: function(start, initializer) {\n        this.eat_(SEMI_COLON);\n        var condition = null;\n        if (!peek(SEMI_COLON)) {\n          condition = this.parseExpression_(ALLOW_IN);\n        }\n        this.eat_(SEMI_COLON);\n        var increment = null;\n        if (!peek(CLOSE_PAREN)) {\n          increment = this.parseExpression_(ALLOW_IN);\n        }\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new ForStatement(this.getTreeLocation_(start), initializer, condition, increment, body);\n      },\n      parseForInStatement_: function(start, initializer) {\n        this.eat_(IN);\n        var collection = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new ForInStatement(this.getTreeLocation_(start), initializer, collection, body);\n      },\n      parseContinueStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(CONTINUE);\n        var name = null;\n        if (!this.peekImplicitSemiColon_()) {\n          name = this.eatIdOpt_();\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new ContinueStatement(this.getTreeLocation_(start), name);\n      },\n      parseBreakStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(BREAK);\n        var name = null;\n        if (!this.peekImplicitSemiColon_()) {\n          name = this.eatIdOpt_();\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new BreakStatement(this.getTreeLocation_(start), name);\n      },\n      parseReturnStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        var returnToken = this.eat_(RETURN);\n        if (this.functionState_.isTopMost()) {\n          this.reportError_(returnToken.location, \'Illegal return statement\');\n        }\n        var expression = null;\n        if (!this.peekImplicitSemiColon_()) {\n          expression = this.parseExpression_(ALLOW_IN);\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new ReturnStatement(this.getTreeLocation_(start), expression);\n      },\n      parseYieldExpression_: function(allowIn) {\n        var start = this.getTreeStartLocation_();\n        this.eat_(YIELD);\n        var expression = null;\n        var isYieldFor = false;\n        var token = peekTokenNoLineTerminator();\n        if (token !== null) {\n          switch (token.type) {\n            case CLOSE_CURLY:\n            case CLOSE_PAREN:\n            case CLOSE_SQUARE:\n            case COLON:\n            case COMMA:\n            case END_OF_FILE:\n            case SEMI_COLON:\n              break;\n            default:\n              isYieldFor = this.eatIf_(STAR);\n              expression = this.parseAssignmentExpression_(allowIn);\n          }\n        }\n        return new YieldExpression(this.getTreeLocation_(start), expression, isYieldFor);\n      },\n      parseWithStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        var withToken = this.eat_(WITH);\n        if (this.strictMode_) {\n          this.reportError_(withToken.location, \'Strict mode code may not include a with statement\');\n        }\n        this.eat_(OPEN_PAREN);\n        var expression = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new WithStatement(this.getTreeLocation_(start), expression, body);\n      },\n      parseSwitchStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(SWITCH);\n        this.eat_(OPEN_PAREN);\n        var expression = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        this.eat_(OPEN_CURLY);\n        var caseClauses = this.parseCaseClauses_();\n        this.eat_(CLOSE_CURLY);\n        return new SwitchStatement(this.getTreeLocation_(start), expression, caseClauses);\n      },\n      parseCaseClauses_: function() {\n        var foundDefaultClause = false;\n        var result = [];\n        while (true) {\n          var start = this.getTreeStartLocation_();\n          switch (peekType()) {\n            case CASE:\n              {\n                nextToken();\n                var expression = this.parseExpression_(ALLOW_IN);\n                this.eat_(COLON);\n                var statements = this.parseCaseStatementsOpt_();\n                result.push(new CaseClause(this.getTreeLocation_(start), expression, statements));\n                break;\n              }\n            case DEFAULT:\n              {\n                var defaultToken = nextToken();\n                if (foundDefaultClause) {\n                  this.reportError_(defaultToken.location, \'Switch statements may have at most one \\\'default\\\' clause\');\n                } else {\n                  foundDefaultClause = true;\n                }\n                this.eat_(COLON);\n                result.push(new DefaultClause(this.getTreeLocation_(start), this.parseCaseStatementsOpt_()));\n                break;\n              }\n            default:\n              return result;\n          }\n        }\n      },\n      parseCaseStatementsOpt_: function() {\n        var result = [];\n        var type;\n        while (true) {\n          switch (type = peekType()) {\n            case CASE:\n            case DEFAULT:\n            case CLOSE_CURLY:\n            case END_OF_FILE:\n              return result;\n          }\n          result.push(this.parseStatementListItem_(type));\n        }\n      },\n      parseThrowStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(THROW);\n        var value = null;\n        if (!this.peekImplicitSemiColon_()) {\n          value = this.parseExpression_(ALLOW_IN);\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new ThrowStatement(this.getTreeLocation_(start), value);\n      },\n      parseTryStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(TRY);\n        var body = this.parseBlock_();\n        var catchBlock = null;\n        if (peek(CATCH)) {\n          catchBlock = this.parseCatch_();\n        }\n        var finallyBlock = null;\n        if (peek(FINALLY)) {\n          finallyBlock = this.parseFinallyBlock_();\n        }\n        if (catchBlock === null && finallyBlock === null) {\n          var token = peekToken();\n          this.reportError_(token.location, "\'catch\' or \'finally\' expected.");\n        }\n        return new TryStatement(this.getTreeLocation_(start), body, catchBlock, finallyBlock);\n      },\n      parseCatch_: function() {\n        var start = this.getTreeStartLocation_();\n        var catchBlock;\n        this.eat_(CATCH);\n        this.eat_(OPEN_PAREN);\n        var binding;\n        if (this.peekPattern_(peekType()))\n          binding = this.parseBindingPattern_();\n        else\n          binding = this.parseBindingIdentifier_();\n        this.eat_(CLOSE_PAREN);\n        var catchBody = this.parseBlock_();\n        catchBlock = new Catch(this.getTreeLocation_(start), binding, catchBody);\n        return catchBlock;\n      },\n      parseFinallyBlock_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(FINALLY);\n        var finallyBlock = this.parseBlock_();\n        return new Finally(this.getTreeLocation_(start), finallyBlock);\n      },\n      parseDebuggerStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DEBUGGER);\n        this.eatPossibleImplicitSemiColon_();\n        return new DebuggerStatement(this.getTreeLocation_(start));\n      },\n      parsePrimaryExpression_: function() {\n        switch (peekType()) {\n          case CLASS:\n            return this.options_.classes ? this.parseClassExpression_() : this.parseUnexpectedReservedWord_(peekToken());\n          case THIS:\n            return this.parseThisExpression_();\n          case IDENTIFIER:\n            {\n              var identifier = this.parseIdentifierExpression_();\n              if (this.options_.asyncFunctions && identifier.identifierToken.value === ASYNC) {\n                var token$__6 = peekTokenNoLineTerminator();\n                if (token$__6 && token$__6.type === FUNCTION) {\n                  var asyncToken = identifier.identifierToken;\n                  return this.parseAsyncFunctionExpression_(asyncToken);\n                }\n              }\n              return identifier;\n            }\n          case NUMBER:\n          case STRING:\n          case TRUE:\n          case FALSE:\n          case NULL:\n            return this.parseLiteralExpression_();\n          case OPEN_SQUARE:\n            return this.parseArrayLiteral_();\n          case OPEN_CURLY:\n            return this.parseObjectLiteral_();\n          case OPEN_PAREN:\n            return this.parsePrimaryExpressionStartingWithParen_();\n          case SLASH:\n          case SLASH_EQUAL:\n            return this.parseRegularExpressionLiteral_();\n          case NO_SUBSTITUTION_TEMPLATE:\n          case TEMPLATE_HEAD:\n            if (this.options_.templateLiterals) {\n              return this.parseTemplateLiteral_(null);\n            }\n            break;\n          case IMPLEMENTS:\n          case INTERFACE:\n          case PACKAGE:\n          case PRIVATE:\n          case PROTECTED:\n          case PUBLIC:\n          case STATIC:\n          case YIELD:\n            if (this.strictMode_) {\n              this.reportReservedIdentifier_(nextToken());\n            }\n            return this.parseIdentifierExpression_();\n          case OPEN_ANGLE:\n            if (this.options_.jsx) {\n              return this.parseJsxElement_();\n            }\n            break;\n          case END_OF_FILE:\n            return this.parseSyntaxError_(\'Unexpected end of input\');\n        }\n        var token = peekToken();\n        if (token.isKeyword()) {\n          return this.parseUnexpectedReservedWord_(token);\n        }\n        return this.parseUnexpectedToken_(token);\n      },\n      parseSuperExpression_: function(isNew) {\n        var start = this.getTreeStartLocation_();\n        var fs = this.functionState_;\n        while (fs && fs.isArrowFunction()) {\n          fs = fs.outer;\n        }\n        var superToken = this.eat_(SUPER);\n        if (!fs || !fs.isMethod()) {\n          this.reportError_(superToken.location, \'super is only allowed in methods\');\n        }\n        var operand = new SuperExpression(this.getTreeLocation_(start));\n        var type = peekType();\n        if (isNew) {\n          if (type === OPEN_SQUARE) {\n            return this.parseMemberLookupExpression_(start, operand);\n          }\n          return this.parseMemberExpression_(start, operand);\n        }\n        switch (type) {\n          case OPEN_SQUARE:\n            return this.parseMemberLookupExpression_(start, operand);\n          case PERIOD:\n            return this.parseMemberExpression_(start, operand);\n          case OPEN_PAREN:\n            {\n              var superCall = this.parseCallExpression_(start, operand);\n              if (!fs.isDerivedConstructor()) {\n                this.reportError_(superToken.location, \'super call is only allowed in derived constructor\');\n              }\n              return superCall;\n            }\n        }\n        return this.parseUnexpectedToken_();\n      },\n      parseThisExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(THIS);\n        return new ThisExpression(this.getTreeLocation_(start));\n      },\n      peekBindingIdentifier_: function(type) {\n        return this.peekId_(type);\n      },\n      parseBindingIdentifier_: function() {\n        var start = this.getTreeStartLocation_();\n        var identifier = this.eatId_();\n        return new BindingIdentifier(this.getTreeLocation_(start), identifier);\n      },\n      parseIdentifierExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        var identifier = this.eatId_();\n        return new IdentifierExpression(this.getTreeLocation_(start), identifier);\n      },\n      parseIdentifierNameExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        var identifier = this.eatIdName_();\n        return new IdentifierExpression(this.getTreeLocation_(start), identifier);\n      },\n      parseLiteralExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        var literal = this.nextLiteralToken_();\n        return new LiteralExpression(this.getTreeLocation_(start), literal);\n      },\n      nextLiteralToken_: function() {\n        return nextToken();\n      },\n      parseRegularExpressionLiteral_: function() {\n        var start = this.getTreeStartLocation_();\n        var literal = nextRegularExpressionLiteralToken();\n        return new LiteralExpression(this.getTreeLocation_(start), literal);\n      },\n      peekSpread_: function(type) {\n        return type === DOT_DOT_DOT && this.options_.spread;\n      },\n      parseArrayLiteral_: function() {\n        var start = this.getTreeStartLocation_();\n        var expression;\n        var elements = [];\n        this.eat_(OPEN_SQUARE);\n        var type = peekType();\n        if (type === FOR && this.options_.arrayComprehension)\n          return this.parseArrayComprehension_(start);\n        while (true) {\n          type = peekType();\n          if (type === COMMA) {\n            expression = null;\n          } else if (this.peekSpread_(type)) {\n            expression = this.parseSpreadExpression_();\n          } else if (type === CLOSE_SQUARE || type === END_OF_FILE) {\n            break;\n          } else {\n            expression = this.parseAssignmentExpression_(ALLOW_IN);\n          }\n          elements.push(expression);\n          type = peekType();\n          if (type !== CLOSE_SQUARE)\n            this.eat_(COMMA);\n        }\n        this.eat_(CLOSE_SQUARE);\n        return new ArrayLiteral(this.getTreeLocation_(start), elements);\n      },\n      parseArrayComprehension_: function(start) {\n        var list = this.parseComprehensionList_();\n        var expression = this.parseAssignmentExpression_(ALLOW_IN);\n        this.eat_(CLOSE_SQUARE);\n        return new ArrayComprehension(this.getTreeLocation_(start), list, expression);\n      },\n      parseComprehensionList_: function() {\n        var list = [this.parseComprehensionFor_()];\n        while (true) {\n          var type = peekType();\n          switch (type) {\n            case FOR:\n              list.push(this.parseComprehensionFor_());\n              break;\n            case IF:\n              list.push(this.parseComprehensionIf_());\n              break;\n            default:\n              return list;\n          }\n        }\n      },\n      parseComprehensionFor_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(FOR);\n        this.eat_(OPEN_PAREN);\n        var left = this.parseForBinding_();\n        this.eatId_(OF);\n        var iterator = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        return new ComprehensionFor(this.getTreeLocation_(start), left, iterator);\n      },\n      parseComprehensionIf_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(IF);\n        this.eat_(OPEN_PAREN);\n        var expression = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        return new ComprehensionIf(this.getTreeLocation_(start), expression);\n      },\n      parseObjectLiteral_: function() {\n        var start = this.getTreeStartLocation_();\n        var result = [];\n        this.eat_(OPEN_CURLY);\n        while (this.peekPropertyDefinition_(peekType())) {\n          var propertyDefinition = this.parsePropertyDefinition_();\n          result.push(propertyDefinition);\n          if (!this.eatIf_(COMMA))\n            break;\n        }\n        this.eat_(CLOSE_CURLY);\n        return new ObjectLiteral(this.getTreeLocation_(start), result);\n      },\n      parsePropertyDefinition: function() {\n        var fs = this.pushFunctionState_(FUNCTION_STATE_SCRIPT);\n        var result = this.parsePropertyDefinition_();\n        this.popFunctionState_(fs);\n        return result;\n      },\n      parsePropertyDefinition_: function() {\n        var start = this.getTreeStartLocation_();\n        var functionKind = null;\n        var isStatic = false;\n        if (this.options_.generators && this.options_.propertyMethods && peek(STAR)) {\n          var fs = this.pushFunctionState_(FUNCTION_STATE_METHOD | FUNCTION_STATE_GENERATOR);\n          var m = this.parseGeneratorMethod_(start, isStatic, []);\n          this.popFunctionState_(fs);\n          return m;\n        }\n        if (this.options_.spreadProperties && peek(DOT_DOT_DOT)) {\n          return this.parseSpreadExpression_();\n        }\n        var token = peekToken();\n        var name = this.parsePropertyName_();\n        if (this.options_.propertyMethods && peek(OPEN_PAREN)) {\n          var fs$__7 = this.pushFunctionState_(FUNCTION_STATE_METHOD);\n          var m$__8 = this.parseMethod_(start, isStatic, functionKind, name, []);\n          this.popFunctionState_(fs$__7);\n          return m$__8;\n        }\n        if (this.eatIf_(COLON)) {\n          var value = this.parseAssignmentExpression_(ALLOW_IN);\n          return new PropertyNameAssignment(this.getTreeLocation_(start), name, value);\n        }\n        var type = peekType();\n        if (name.type === LITERAL_PROPERTY_NAME) {\n          var nameLiteral = name.literalToken;\n          if (nameLiteral.value === GET && this.peekPropertyName_(type)) {\n            return this.parseGetAccessor_(start, isStatic, []);\n          }\n          if (nameLiteral.value === SET && this.peekPropertyName_(type)) {\n            return this.parseSetAccessor_(start, isStatic, []);\n          }\n          if (this.options_.asyncFunctions && nameLiteral.value === ASYNC && (this.peekPropertyName_(type) || this.peekAsyncStar_())) {\n            var async = nameLiteral;\n            var kind = FUNCTION_STATE_METHOD | FUNCTION_STATE_ASYNC;\n            if (this.peekAsyncStar_()) {\n              kind |= FUNCTION_STATE_GENERATOR;\n              this.eat_(STAR);\n              async = new IdentifierToken(async.location, ASYNC_STAR);\n            }\n            var name$__9 = this.parsePropertyName_();\n            var fs$__10 = this.pushFunctionState_(kind);\n            var m$__11 = this.parseMethod_(start, isStatic, async, name$__9, []);\n            this.popFunctionState_(fs$__10);\n            return m$__11;\n          }\n          if (this.options_.propertyNameShorthand && (nameLiteral.type === IDENTIFIER || nameLiteral.isStrictKeyword() && !this.strictMode_ || nameLiteral.type === YIELD && this.allowYield_)) {\n            if (peek(EQUAL)) {\n              token = nextToken();\n              var coverInitializedNameCount = this.coverInitializedNameCount_;\n              var expr = this.parseAssignmentExpression_(ALLOW_IN);\n              this.ensureNoCoverInitializedNames_(expr, coverInitializedNameCount);\n              this.coverInitializedNameCount_++;\n              return new CoverInitializedName(this.getTreeLocation_(start), nameLiteral, token, expr);\n            }\n            return new PropertyNameShorthand(this.getTreeLocation_(start), nameLiteral);\n          }\n          if (this.strictMode_ && nameLiteral.isStrictKeyword())\n            this.reportReservedIdentifier_(nameLiteral);\n        }\n        if (name.type === COMPUTED_PROPERTY_NAME)\n          token = peekToken();\n        return this.parseUnexpectedToken_(token);\n      },\n      parseClassElement_: function(derivedClass) {\n        var start = this.getTreeStartLocation_();\n        var annotations = this.parseAnnotations_();\n        var type = peekType();\n        var isStatic = false,\n            functionKind = null;\n        switch (type) {\n          case STATIC:\n            {\n              var staticToken = nextToken();\n              type = peekType();\n              switch (type) {\n                case OPEN_PAREN:\n                  {\n                    var location = this.getTreeLocation_(start);\n                    var name = new LiteralPropertyName(location, staticToken);\n                    var fs = this.pushFunctionState_(FUNCTION_STATE_METHOD);\n                    var m = this.parseMethod_(start, isStatic, functionKind, name, annotations);\n                    this.popFunctionState_(fs);\n                    return m;\n                  }\n                default:\n                  isStatic = true;\n                  if (type === STAR && this.options_.generators)\n                    return this.parseGeneratorMethod_(start, true, annotations);\n                  return this.parseClassElement2_(start, isStatic, annotations, derivedClass);\n              }\n              break;\n            }\n          case STAR:\n            return this.parseGeneratorMethod_(start, isStatic, annotations);\n          default:\n            return this.parseClassElement2_(start, isStatic, annotations, derivedClass);\n        }\n      },\n      parseGeneratorMethod_: function(start, isStatic, annotations) {\n        var functionKind = this.eat_(STAR);\n        var name = this.parsePropertyName_();\n        var fs = this.pushFunctionState_(FUNCTION_STATE_METHOD | FUNCTION_STATE_GENERATOR);\n        var m = this.parseMethod_(start, isStatic, functionKind, name, annotations);\n        this.popFunctionState_(fs);\n        return m;\n      },\n      parseMethod_: function(start, isStatic, functionKind, name, annotations) {\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var body = this.parseFunctionBody_(parameterList);\n        return new Method(this.getTreeLocation_(start), isStatic, functionKind, name, parameterList, typeAnnotation, annotations, body, null);\n      },\n      parsePropertyVariableDeclaration_: function(start, isStatic, name, annotations) {\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var initializer = this.parseInitializerOpt_(ALLOW_IN);\n        this.eat_(SEMI_COLON);\n        return new PropertyVariableDeclaration(this.getTreeLocation_(start), isStatic, name, typeAnnotation, annotations, initializer);\n      },\n      parseClassElement2_: function(start, isStatic, annotations, derivedClass) {\n        var functionKind = null;\n        var name = this.parsePropertyName_();\n        var type = peekType();\n        if (name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === GET && this.peekPropertyName_(type)) {\n          return this.parseGetAccessor_(start, isStatic, annotations);\n        }\n        if (name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === SET && this.peekPropertyName_(type)) {\n          return this.parseSetAccessor_(start, isStatic, annotations);\n        }\n        if (this.options_.asyncFunctions && name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === ASYNC && (this.peekPropertyName_(type) || this.peekAsyncStar_())) {\n          var async = name.literalToken;\n          var kind = FUNCTION_STATE_METHOD | FUNCTION_STATE_ASYNC;\n          if (this.peekAsyncStar_()) {\n            kind |= FUNCTION_STATE_GENERATOR;\n            this.eat_(STAR);\n            async = new IdentifierToken(async.location, ASYNC_STAR);\n          }\n          name = this.parsePropertyName_();\n          var fs = this.pushFunctionState_(kind);\n          var m = this.parseMethod_(start, isStatic, async, name, annotations);\n          this.popFunctionState_(fs);\n          return m;\n        }\n        if (!this.options_.memberVariables || type === OPEN_PAREN) {\n          var kind$__12 = FUNCTION_STATE_METHOD;\n          var isDerivedConstructor = derivedClass && !isStatic && functionKind === null && name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === CONSTRUCTOR;\n          if (isDerivedConstructor) {\n            kind$__12 |= FUNCTION_STATE_DERIVED_CONSTRUCTOR;\n          }\n          var fs$__13 = this.pushFunctionState_(kind$__12);\n          var m$__14 = this.parseMethod_(start, isStatic, functionKind, name, annotations);\n          this.popFunctionState_(fs$__13);\n          if (isDerivedConstructor) {\n            validateConstructor(m$__14, this.errorReporter_);\n          }\n          return m$__14;\n        }\n        return this.parsePropertyVariableDeclaration_(start, isStatic, name, annotations);\n      },\n      parseGetAccessor_: function(start, isStatic, annotations) {\n        var name = this.parsePropertyName_();\n        var fs = this.pushFunctionState_(FUNCTION_STATE_METHOD);\n        this.eat_(OPEN_PAREN);\n        this.eat_(CLOSE_PAREN);\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var body = this.parseFunctionBody_(null);\n        this.popFunctionState_(fs);\n        return new GetAccessor(this.getTreeLocation_(start), isStatic, name, typeAnnotation, annotations, body);\n      },\n      parseSetAccessor_: function(start, isStatic, annotations) {\n        var name = this.parsePropertyName_();\n        var fs = this.pushFunctionState_(FUNCTION_STATE_METHOD);\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parsePropertySetParameterList_();\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseFunctionBody_(parameterList);\n        this.popFunctionState_(fs);\n        return new SetAccessor(this.getTreeLocation_(start), isStatic, name, parameterList, annotations, body);\n      },\n      peekPropertyDefinition_: function(type) {\n        return this.peekPropertyName_(type) || type === STAR && this.options_.propertyMethods && this.options_.generators || type === DOT_DOT_DOT && this.options_.spreadProperties;\n      },\n      peekPropertyName_: function(type) {\n        switch (type) {\n          case IDENTIFIER:\n          case STRING:\n          case NUMBER:\n            return true;\n          case OPEN_SQUARE:\n            return this.options_.computedPropertyNames;\n          default:\n            return peekToken().isKeyword();\n        }\n      },\n      peekPredefinedString_: function(string) {\n        var token = peekToken();\n        return token.type === IDENTIFIER && token.value === string;\n      },\n      parsePropertySetParameterList_: function() {\n        var start = this.getTreeStartLocation_();\n        var binding;\n        this.pushAnnotations_();\n        if (this.peekPattern_(peekType()))\n          binding = this.parseBindingPattern_();\n        else\n          binding = this.parseBindingIdentifier_();\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var parameter = new FormalParameter(this.getTreeLocation_(start), new BindingElement(this.getTreeLocation_(start), binding, null), typeAnnotation, this.popAnnotations_());\n        return new FormalParameterList(parameter.location, [parameter]);\n      },\n      parsePrimaryExpressionStartingWithParen_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_PAREN);\n        if (peek(FOR) && this.options_.generatorComprehension)\n          return this.parseGeneratorComprehension_(start);\n        return this.parseCoverFormals_(start);\n      },\n      parseSyntaxError_: function(message) {\n        var token = nextToken();\n        this.reportError_(token.location, message);\n        return new SyntaxErrorTree(token.location, token, message);\n      },\n      parseUnexpectedToken_: function() {\n        var token = arguments[0] !== (void 0) ? arguments[0] : peekToken();\n        if (token.type === NO_SUBSTITUTION_TEMPLATE) {\n          return this.parseSyntaxError_(\'Unexpected token `\');\n        }\n        return this.parseSyntaxError_(("Unexpected token " + token));\n      },\n      parseUnexpectedReservedWord_: function(token) {\n        return this.parseSyntaxError_(("Unexpected reserved word " + token));\n      },\n      parseExpression_: function(allowIn) {\n        var coverInitializedNameCount = this.coverInitializedNameCount_;\n        var expression = this.parseExpressionAllowPattern_(allowIn);\n        this.ensureNoCoverInitializedNames_(expression, coverInitializedNameCount);\n        return expression;\n      },\n      parseExpression: function() {\n        var fs = this.pushFunctionState_(FUNCTION_STATE_LENIENT);\n        var expression = this.parseExpression_(ALLOW_IN);\n        this.popFunctionState_(fs);\n        return expression;\n      },\n      parseExpressionAllowPattern_: function(allowIn) {\n        var start = this.getTreeStartLocation_();\n        var expression = this.parseAssignmentExpression_(allowIn);\n        if (peek(COMMA)) {\n          var expressions = [expression];\n          while (this.eatIf_(COMMA)) {\n            expressions.push(this.parseAssignmentExpression_(allowIn));\n          }\n          return new CommaExpression(this.getTreeLocation_(start), expressions);\n        }\n        return expression;\n      },\n      parseAssignmentExpression_: function(allowIn) {\n        if (this.allowYield_ && peek(YIELD))\n          return this.parseYieldExpression_(allowIn);\n        var start = this.getTreeStartLocation_();\n        var validAsyncParen = false;\n        if (this.options_.asyncFunctions && this.peekPredefinedString_(ASYNC)) {\n          var asyncToken = peekToken();\n          var maybeOpenParenToken = peekTokenLookahead();\n          validAsyncParen = maybeOpenParenToken.type === OPEN_PAREN && asyncToken.location.end.line === maybeOpenParenToken.location.start.line;\n        }\n        var left = this.parseConditional_(allowIn);\n        var type = peekType();\n        if (this.options_.asyncFunctions && left.type === IDENTIFIER_EXPRESSION && left.identifierToken.value === ASYNC && type === IDENTIFIER) {\n          if (peekTokenNoLineTerminator() !== null) {\n            var bindingIdentifier = this.parseBindingIdentifier_();\n            var asyncToken$__15 = left.identifierToken;\n            return this.parseArrowFunction_(start, bindingIdentifier, asyncToken$__15);\n          }\n        }\n        if (type === ARROW && peekTokenNoLineTerminator() !== null) {\n          if (left.type === COVER_FORMALS || left.type === IDENTIFIER_EXPRESSION)\n            return this.parseArrowFunction_(start, left, null);\n          if (validAsyncParen && left.type === CALL_EXPRESSION) {\n            var asyncToken$__16 = left.operand.identifierToken;\n            return this.parseArrowFunction_(start, left.args, asyncToken$__16);\n          }\n        }\n        left = this.coverFormalsToParenExpression_(left);\n        if (this.peekAssignmentOperator_(type)) {\n          if (type === EQUAL)\n            left = this.transformLeftHandSideExpression_(left);\n          this.validateAssignmentTarget_(left, \'assignment\');\n          var operator = nextToken();\n          var right = this.parseAssignmentExpression_(allowIn);\n          return new BinaryExpression(this.getTreeLocation_(start), left, operator, right);\n        }\n        return left;\n      },\n      transformLeftHandSideExpression_: function(tree) {\n        switch (tree.type) {\n          case ARRAY_LITERAL:\n          case OBJECT_LITERAL:\n            resetScanner(tree.location.start.offset);\n            return this.parseAssignmentPattern_();\n        }\n        return tree;\n      },\n      peekAssignmentOperator_: function(type) {\n        return isAssignmentOperator(type);\n      },\n      parseConditional_: function(allowIn) {\n        var start = this.getTreeStartLocation_();\n        var condition = this.parseBinaryExpression_(allowIn);\n        if (this.eatIf_(QUESTION)) {\n          condition = this.toPrimaryExpression_(condition);\n          var left = this.parseAssignmentExpression_(ALLOW_IN);\n          this.eat_(COLON);\n          var right = this.parseAssignmentExpression_(allowIn);\n          return new ConditionalExpression(this.getTreeLocation_(start), condition, left, right);\n        }\n        return condition;\n      },\n      getPrecedence_: function(type, allowIn) {\n        switch (type) {\n          case OR:\n            return 1;\n          case AND:\n            return 2;\n          case BAR:\n            return 3;\n          case CARET:\n            return 4;\n          case AMPERSAND:\n            return 5;\n          case EQUAL_EQUAL:\n          case EQUAL_EQUAL_EQUAL:\n          case NOT_EQUAL:\n          case NOT_EQUAL_EQUAL:\n            return 6;\n          case CLOSE_ANGLE:\n          case GREATER_EQUAL:\n          case INSTANCEOF:\n          case LESS_EQUAL:\n          case OPEN_ANGLE:\n            return 7;\n          case IN:\n            return allowIn ? 7 : 0;\n          case LEFT_SHIFT:\n          case RIGHT_SHIFT:\n          case UNSIGNED_RIGHT_SHIFT:\n            return 8;\n          case MINUS:\n          case PLUS:\n            return 9;\n          case SLASH:\n          case STAR:\n          case PERCENT:\n            return 10;\n          case STAR_STAR:\n            return this.options_.exponentiation ? 11 : 0;\n          default:\n            return 0;\n        }\n      },\n      parseBinaryExpression_: function(allowIn) {\n        var start = this.getTreeStartLocation_();\n        var left = this.parseUnaryExpression_();\n        return this.parseBinaryExpressionHelper_(start, left, -1, allowIn);\n      },\n      parseBinaryExpressionHelper_: function(start, left, minPrec, allowIn) {\n        var type = peekType();\n        var prec = this.getPrecedence_(type, allowIn);\n        if (prec === 0) {\n          return left;\n        }\n        var leftToRight = type !== STAR_STAR;\n        if (leftToRight ? prec > minPrec : prec >= minPrec) {\n          var token = nextToken();\n          var rightStart = this.getTreeStartLocation_();\n          var rightUnary = this.parseUnaryExpression_();\n          var right = this.parseBinaryExpressionHelper_(rightStart, rightUnary, prec, allowIn);\n          left = this.toPrimaryExpression_(left);\n          right = this.toPrimaryExpression_(right);\n          var node = new BinaryExpression(this.getTreeLocation_(start), left, token, right);\n          return this.parseBinaryExpressionHelper_(start, node, minPrec, allowIn);\n        }\n        return left;\n      },\n      parseUnaryExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        if (this.allowAwait_ && this.peekPredefinedString_(AWAIT)) {\n          this.eatId_();\n          var operand;\n          if (this.allowYield_ && peek(YIELD)) {\n            operand = this.parseYieldExpression_(ALLOW_IN);\n          } else {\n            operand = this.parseUnaryExpression_();\n            operand = this.toPrimaryExpression_(operand);\n          }\n          return new AwaitExpression(this.getTreeLocation_(start), operand);\n        }\n        if (this.peekUnaryOperator_(peekType())) {\n          var operator = nextToken();\n          var operand$__17 = this.parseUnaryExpression_();\n          operand$__17 = this.toPrimaryExpression_(operand$__17);\n          if (operand$__17.type !== SYNTAX_ERROR_TREE) {\n            switch (operator.type) {\n              case PLUS_PLUS:\n              case MINUS_MINUS:\n                this.validateAssignmentTarget_(operand$__17, \'prefix operation\');\n            }\n          }\n          return new UnaryExpression(this.getTreeLocation_(start), operator, operand$__17);\n        }\n        return this.parsePostfixExpression_();\n      },\n      peekUnaryOperator_: function(type) {\n        switch (type) {\n          case DELETE:\n          case VOID:\n          case TYPEOF:\n          case PLUS_PLUS:\n          case MINUS_MINUS:\n          case PLUS:\n          case MINUS:\n          case TILDE:\n          case BANG:\n            return true;\n          default:\n            return false;\n        }\n      },\n      parsePostfixExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        var operand = this.parseLeftHandSideExpression_();\n        while (this.peekPostfixOperator_(peekType())) {\n          operand = this.toPrimaryExpression_(operand);\n          var operator = nextToken();\n          this.validateAssignmentTarget_(operand, \'postfix operation\');\n          operand = new PostfixExpression(this.getTreeLocation_(start), operand, operator);\n        }\n        return operand;\n      },\n      peekPostfixOperator_: function(type) {\n        switch (type) {\n          case PLUS_PLUS:\n          case MINUS_MINUS:\n            {\n              var token = peekTokenNoLineTerminator();\n              return token !== null;\n            }\n        }\n        return false;\n      },\n      parseLeftHandSideExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        var operand = this.parseNewExpression_();\n        if (!(operand instanceof NewExpression) || operand.args !== null) {\n          loop: while (true) {\n            switch (peekType()) {\n              case OPEN_PAREN:\n                operand = this.toPrimaryExpression_(operand);\n                operand = this.parseCallExpression_(start, operand);\n                break;\n              case OPEN_SQUARE:\n                operand = this.toPrimaryExpression_(operand);\n                operand = this.parseMemberLookupExpression_(start, operand);\n                break;\n              case PERIOD:\n                operand = this.toPrimaryExpression_(operand);\n                operand = this.parseMemberExpression_(start, operand);\n                break;\n              case NO_SUBSTITUTION_TEMPLATE:\n              case TEMPLATE_HEAD:\n                if (!this.options_.templateLiterals)\n                  break loop;\n                operand = this.toPrimaryExpression_(operand);\n                if (this.options_.templateLiterals) {\n                  operand = this.parseTemplateLiteral_(operand);\n                }\n                break;\n              default:\n                break loop;\n            }\n          }\n        }\n        return operand;\n      },\n      parseMemberExpressionNoNew_: function() {\n        var start = this.getTreeStartLocation_();\n        var operand;\n        if (peekType() === FUNCTION) {\n          operand = this.parseFunctionExpression_();\n        } else {\n          operand = this.parsePrimaryExpression_();\n        }\n        loop: while (true) {\n          switch (peekType()) {\n            case OPEN_SQUARE:\n              operand = this.toPrimaryExpression_(operand);\n              operand = this.parseMemberLookupExpression_(start, operand);\n              break;\n            case PERIOD:\n              operand = this.toPrimaryExpression_(operand);\n              operand = this.parseMemberExpression_(start, operand);\n              break;\n            case NO_SUBSTITUTION_TEMPLATE:\n            case TEMPLATE_HEAD:\n              if (!this.options_.templateLiterals)\n                break loop;\n              operand = this.toPrimaryExpression_(operand);\n              operand = this.parseTemplateLiteral_(operand);\n              break;\n            default:\n              break loop;\n          }\n        }\n        return operand;\n      },\n      parseMemberExpression_: function(start, operand) {\n        this.eat_(PERIOD);\n        var name = this.eatIdName_();\n        return new MemberExpression(this.getTreeLocation_(start), operand, name);\n      },\n      parseMemberLookupExpression_: function(start, operand) {\n        this.eat_(OPEN_SQUARE);\n        var member = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_SQUARE);\n        return new MemberLookupExpression(this.getTreeLocation_(start), operand, member);\n      },\n      parseCallExpression_: function(start, operand) {\n        var args = this.parseArguments_();\n        return new CallExpression(this.getTreeLocation_(start), operand, args);\n      },\n      parseNewExpression_: function() {\n        var operand,\n            start;\n        switch (peekType()) {\n          case NEW:\n            {\n              start = this.getTreeStartLocation_();\n              this.eat_(NEW);\n              if (peek(SUPER)) {\n                operand = this.parseSuperExpression_(true);\n              } else {\n                operand = this.toPrimaryExpression_(this.parseNewExpression_());\n              }\n              var args = null;\n              if (peek(OPEN_PAREN)) {\n                args = this.parseArguments_();\n              }\n              return new NewExpression(this.getTreeLocation_(start), operand, args);\n            }\n          case SUPER:\n            return this.parseSuperExpression_(false);\n          default:\n            return this.parseMemberExpressionNoNew_();\n        }\n      },\n      parseArguments_: function() {\n        var start = this.getTreeStartLocation_();\n        var args = [];\n        this.eat_(OPEN_PAREN);\n        if (!peek(CLOSE_PAREN)) {\n          args.push(this.parseArgument_());\n          while (this.eatIf_(COMMA)) {\n            args.push(this.parseArgument_());\n          }\n        }\n        this.eat_(CLOSE_PAREN);\n        return new ArgumentList(this.getTreeLocation_(start), args);\n      },\n      parseArgument_: function() {\n        if (this.peekSpread_(peekType()))\n          return this.parseSpreadExpression_();\n        return this.parseAssignmentExpression_(ALLOW_IN);\n      },\n      parseArrowFunction_: function(start, tree, asyncToken) {\n        var $__3 = this;\n        var formals;\n        var kind = FUNCTION_STATE_ARROW;\n        if (asyncToken && asyncToken.value === ASYNC) {\n          kind |= FUNCTION_STATE_ASYNC;\n        }\n        var fs = this.pushFunctionState_(kind);\n        var makeFormals = function(tree) {\n          return new FormalParameterList($__3.getTreeLocation_(start), [new FormalParameter(tree.location, new BindingElement(tree.location, tree, null), null, [])]);\n        };\n        switch (tree.type) {\n          case IDENTIFIER_EXPRESSION:\n            formals = makeFormals(new BindingIdentifier(tree.location, tree.identifierToken));\n            break;\n          case BINDING_IDENTIFIER:\n            formals = makeFormals(tree);\n            break;\n          case FORMAL_PARAMETER_LIST:\n            formals = tree;\n            break;\n          default:\n            formals = this.toFormalParameters_(start, tree, asyncToken);\n        }\n        this.eat_(ARROW);\n        var body = this.parseConciseBody_(formals);\n        this.popFunctionState_(fs);\n        return new ArrowFunction(this.getTreeLocation_(start), asyncToken, formals, body);\n      },\n      parseCoverFormals_: function(start) {\n        var expressions = [];\n        if (!peek(CLOSE_PAREN)) {\n          do {\n            var type = peekType();\n            if (this.peekRest_(type)) {\n              expressions.push(this.parseRestParameter_());\n              break;\n            } else {\n              expressions.push(this.parseAssignmentExpression_(ALLOW_IN));\n            }\n            if (this.eatIf_(COMMA))\n              continue;\n          } while (!peek(CLOSE_PAREN) && !isAtEnd());\n        }\n        this.eat_(CLOSE_PAREN);\n        return new CoverFormals(this.getTreeLocation_(start), expressions);\n      },\n      ensureNoCoverInitializedNames_: function(tree, coverInitializedNameCount) {\n        if (coverInitializedNameCount === this.coverInitializedNameCount_)\n          return;\n        var finder = new ValidateObjectLiteral();\n        finder.visitAny(tree);\n        if (finder.found) {\n          var token = finder.errorToken;\n          this.reportError_(token.location, ("Unexpected token " + token));\n        }\n      },\n      toPrimaryExpression_: function(tree) {\n        if (tree.type === COVER_FORMALS)\n          return this.coverFormalsToParenExpression_(tree);\n        return tree;\n      },\n      validateCoverFormalsAsParenExpression_: function(tree) {\n        for (var i = 0; i < tree.expressions.length; i++) {\n          if (tree.expressions[i].type === REST_PARAMETER) {\n            var token = new Token(DOT_DOT_DOT, tree.expressions[i].location);\n            this.reportError_(token.location, ("Unexpected token " + token));\n            return;\n          }\n        }\n      },\n      coverFormalsToParenExpression_: function(tree) {\n        if (tree.type === COVER_FORMALS) {\n          var expressions = tree.expressions;\n          if (expressions.length === 0) {\n            var message = \'Unexpected token )\';\n            this.reportError_(tree.location, message);\n          } else {\n            this.validateCoverFormalsAsParenExpression_(tree);\n            var expression;\n            if (expressions.length > 1)\n              expression = new CommaExpression(expressions[0].location, expressions);\n            else\n              expression = expressions[0];\n            return new ParenExpression(tree.location, expression);\n          }\n        }\n        return tree;\n      },\n      toFormalParameters_: function(start, tree, asyncToken) {\n        resetScanner(start.offset);\n        return this.parseArrowFormalParameters_(asyncToken);\n      },\n      parseArrowFormalParameters_: function(asyncToken) {\n        if (asyncToken)\n          this.eat_(IDENTIFIER);\n        this.eat_(OPEN_PAREN);\n        var parameters = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        return parameters;\n      },\n      peekArrow_: function(type) {\n        return type === ARROW && this.options_.arrowFunctions;\n      },\n      parseConciseBody_: function(params) {\n        if (peek(OPEN_CURLY))\n          return this.parseFunctionBody_(params);\n        validateParameters(params, this.strictMode_, this.errorReporter_);\n        return this.parseAssignmentExpression_(ALLOW_IN);\n      },\n      parseGeneratorComprehension_: function(start) {\n        var comprehensionList = this.parseComprehensionList_();\n        var expression = this.parseAssignmentExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        return new GeneratorComprehension(this.getTreeLocation_(start), comprehensionList, expression);\n      },\n      parseForBinding_: function() {\n        if (this.peekPattern_(peekType()))\n          return this.parseBindingPattern_();\n        return this.parseBindingIdentifier_();\n      },\n      peekPattern_: function(type) {\n        return this.options_.destructuring && (this.peekObjectPattern_(type) || this.peekArrayPattern_(type));\n      },\n      peekArrayPattern_: function(type) {\n        return type === OPEN_SQUARE;\n      },\n      peekObjectPattern_: function(type) {\n        return type === OPEN_CURLY;\n      },\n      parseBindingPattern_: function() {\n        return this.parsePattern_(true);\n      },\n      parsePattern_: function(useBinding) {\n        if (this.peekArrayPattern_(peekType()))\n          return this.parseArrayPattern_(useBinding);\n        return this.parseObjectPattern_(useBinding);\n      },\n      parseArrayBindingPattern_: function() {\n        return this.parseArrayPattern_(true);\n      },\n      parsePatternElement_: function(useBinding) {\n        return useBinding ? this.parseBindingElement_() : this.parseAssignmentElement_();\n      },\n      parsePatternRestElement_: function(useBinding) {\n        return useBinding ? this.parseBindingRestElement_() : this.parseAssignmentRestElement_();\n      },\n      parseArrayPattern_: function(useBinding) {\n        var start = this.getTreeStartLocation_();\n        var elements = [];\n        this.eat_(OPEN_SQUARE);\n        while (true) {\n          var type = peekType();\n          if (type === COMMA) {\n            elements.push(null);\n          } else if (this.peekSpread_(type)) {\n            elements.push(this.parsePatternRestElement_(useBinding));\n            break;\n          } else if (type === CLOSE_SQUARE || type === END_OF_FILE) {\n            break;\n          } else {\n            elements.push(this.parsePatternElement_(useBinding));\n          }\n          type = peekType();\n          if (type !== CLOSE_SQUARE) {\n            this.eat_(COMMA);\n          }\n        }\n        this.eat_(CLOSE_SQUARE);\n        return new ArrayPattern(this.getTreeLocation_(start), elements);\n      },\n      parseBindingElementList_: function(elements) {\n        this.parseElisionOpt_(elements);\n        elements.push(this.parseBindingElement_());\n        while (this.eatIf_(COMMA)) {\n          this.parseElisionOpt_(elements);\n          elements.push(this.parseBindingElement_());\n        }\n      },\n      parseElisionOpt_: function(elements) {\n        while (this.eatIf_(COMMA)) {\n          elements.push(null);\n        }\n      },\n      peekBindingElement_: function(type) {\n        return this.peekBindingIdentifier_(type) || this.peekPattern_(type);\n      },\n      parseBindingElement_: function() {\n        var start = this.getTreeStartLocation_();\n        var binding = this.parseBindingElementBinding_();\n        var initializer = this.parseBindingElementInitializer_(INITIALIZER_OPTIONAL);\n        return new BindingElement(this.getTreeLocation_(start), binding, initializer);\n      },\n      parseBindingElementBinding_: function() {\n        if (this.peekPattern_(peekType()))\n          return this.parseBindingPattern_();\n        return this.parseBindingIdentifier_();\n      },\n      parseBindingElementInitializer_: function(initializerRequired) {\n        if (peek(EQUAL) || initializerRequired) {\n          return this.parseInitializer_(ALLOW_IN);\n        }\n        return null;\n      },\n      parseBindingRestElement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DOT_DOT_DOT);\n        var identifier = this.parseBindingIdentifier_();\n        return new SpreadPatternElement(this.getTreeLocation_(start), identifier);\n      },\n      parseObjectPattern_: function(useBinding) {\n        var start = this.getTreeStartLocation_();\n        var elements = [];\n        this.eat_(OPEN_CURLY);\n        var type;\n        while ((type = peekType()) !== CLOSE_CURLY && type !== END_OF_FILE) {\n          elements.push(this.parsePatternProperty_(useBinding));\n          if (!this.eatIf_(COMMA))\n            break;\n        }\n        this.eat_(CLOSE_CURLY);\n        return new ObjectPattern(this.getTreeLocation_(start), elements);\n      },\n      parsePatternProperty_: function(useBinding) {\n        var start = this.getTreeStartLocation_();\n        var name = this.parsePropertyName_();\n        var requireColon = name.type !== LITERAL_PROPERTY_NAME || !name.literalToken.isStrictKeyword() && name.literalToken.type !== IDENTIFIER;\n        if (requireColon || peek(COLON)) {\n          this.eat_(COLON);\n          var element = this.parsePatternElement_(useBinding);\n          return new ObjectPatternField(this.getTreeLocation_(start), name, element);\n        }\n        var token = name.literalToken;\n        if (this.strictMode_ && token.isStrictKeyword())\n          this.reportReservedIdentifier_(token);\n        if (useBinding) {\n          var binding = new BindingIdentifier(name.location, token);\n          var initializer$__18 = this.parseInitializerOpt_(ALLOW_IN);\n          return new BindingElement(this.getTreeLocation_(start), binding, initializer$__18);\n        }\n        var assignment = new IdentifierExpression(name.location, token);\n        var initializer = this.parseInitializerOpt_(ALLOW_IN);\n        return new AssignmentElement(this.getTreeLocation_(start), assignment, initializer);\n      },\n      parseAssignmentPattern_: function() {\n        return this.parsePattern_(false);\n      },\n      parseArrayAssignmentPattern_: function() {\n        return this.parseArrayPattern_(false);\n      },\n      parseAssignmentElement_: function() {\n        var start = this.getTreeStartLocation_();\n        var assignment = this.parseDestructuringAssignmentTarget_();\n        var initializer = this.parseInitializerOpt_(ALLOW_IN);\n        return new AssignmentElement(this.getTreeLocation_(start), assignment, initializer);\n      },\n      parseDestructuringAssignmentTarget_: function() {\n        switch (peekType()) {\n          case OPEN_SQUARE:\n            return this.parseArrayAssignmentPattern_();\n          case OPEN_CURLY:\n            return this.parseObjectAssignmentPattern_();\n        }\n        var expression = this.parseLeftHandSideExpression_();\n        expression = this.coverFormalsToParenExpression_(expression);\n        this.validateAssignmentTarget_(expression, \'assignment\');\n        return expression;\n      },\n      parseAssignmentRestElement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DOT_DOT_DOT);\n        var id = this.parseDestructuringAssignmentTarget_();\n        return new SpreadPatternElement(this.getTreeLocation_(start), id);\n      },\n      parseObjectAssignmentPattern_: function() {\n        return this.parseObjectPattern_(false);\n      },\n      parseAssignmentProperty_: function() {\n        return this.parsePatternProperty_(false);\n      },\n      parseTemplateLiteral_: function(operand) {\n        var start = operand ? operand.location.start : this.getTreeStartLocation_();\n        var token = nextToken();\n        var elements = [new TemplateLiteralPortion(token.location, token)];\n        if (token.type === NO_SUBSTITUTION_TEMPLATE) {\n          return new TemplateLiteralExpression(this.getTreeLocation_(start), operand, elements);\n        }\n        var expression = this.parseExpression_(ALLOW_IN);\n        elements.push(new TemplateSubstitution(expression.location, expression));\n        while (expression.type !== SYNTAX_ERROR_TREE) {\n          token = nextTemplateLiteralToken();\n          if (token.type === ERROR || token.type === END_OF_FILE)\n            break;\n          elements.push(new TemplateLiteralPortion(token.location, token));\n          if (token.type === TEMPLATE_TAIL)\n            break;\n          expression = this.parseExpression_(ALLOW_IN);\n          elements.push(new TemplateSubstitution(expression.location, expression));\n        }\n        return new TemplateLiteralExpression(this.getTreeLocation_(start), operand, elements);\n      },\n      parseTypeAnnotationOpt_: function() {\n        if (this.options_.types && this.eatOpt_(COLON)) {\n          return this.parseType_();\n        }\n        return null;\n      },\n      parseType_: function() {\n        switch (peekType()) {\n          case NEW:\n            return this.parseConstructorType_();\n          case OPEN_PAREN:\n          case OPEN_ANGLE:\n            return this.parseFunctionType_();\n        }\n        var start = this.getTreeStartLocation_();\n        var elementType = this.parsePrimaryType_();\n        return this.parseUnionTypeSuffix_(start, elementType);\n      },\n      parsePrimaryType_: function() {\n        var start = this.getTreeStartLocation_();\n        var elementType,\n            token;\n        switch (peekType()) {\n          case VOID:\n            token = nextToken();\n            elementType = new PredefinedType(this.getTreeLocation_(start), token);\n            break;\n          case IDENTIFIER:\n            switch (peekToken().value) {\n              case \'any\':\n              case \'boolean\':\n              case \'number\':\n              case \'string\':\n              case \'symbol\':\n                token = nextToken();\n                elementType = new PredefinedType(this.getTreeLocation_(start), token);\n                break;\n              default:\n                elementType = this.parseTypeReference_();\n            }\n            break;\n          case TYPEOF:\n            elementType = this.parseTypeQuery_(start);\n            break;\n          case OPEN_CURLY:\n            elementType = this.parseObjectType_();\n            break;\n          default:\n            return this.parseUnexpectedToken_();\n        }\n        return this.parseArrayTypeSuffix_(start, elementType);\n      },\n      parseTypeReference_: function() {\n        var start = this.getTreeStartLocation_();\n        var typeName = this.parseTypeName_();\n        var args = null;\n        if (peek(OPEN_ANGLE)) {\n          var args$__19 = this.parseTypeArguments_();\n          return new TypeReference(this.getTreeLocation_(start), typeName, args$__19);\n        }\n        return typeName;\n      },\n      parseUnionTypeSuffix_: function(start, elementType) {\n        if (peek(BAR)) {\n          var types = [elementType];\n          this.eat_(BAR);\n          while (true) {\n            types.push(this.parsePrimaryType_());\n            if (!this.eatIf_(BAR)) {\n              break;\n            }\n          }\n          return new UnionType(this.getTreeLocation_(start), types);\n        }\n        return elementType;\n      },\n      parseArrayTypeSuffix_: function(start, elementType) {\n        var token = peekTokenNoLineTerminator();\n        if (token && token.type === OPEN_SQUARE) {\n          this.eat_(OPEN_SQUARE);\n          this.eat_(CLOSE_SQUARE);\n          elementType = new ArrayType(this.getTreeLocation_(start), elementType);\n          return this.parseArrayTypeSuffix_(start, elementType);\n        }\n        return elementType;\n      },\n      parseTypeArguments_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_ANGLE);\n        var args = [this.parseType_()];\n        while (peek(COMMA)) {\n          this.eat_(COMMA);\n          args.push(this.parseType_());\n        }\n        var token = nextCloseAngle();\n        if (token.type !== CLOSE_ANGLE) {\n          return this.parseUnexpectedToken_(token);\n        }\n        return new TypeArguments(this.getTreeLocation_(start), args);\n      },\n      parseConstructorType_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(NEW);\n        var typeParameters = this.parseTypeParametersOpt_();\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        this.eat_(ARROW);\n        var returnType = this.parseType_();\n        return new ConstructorType(this.getTreeLocation_(start), typeParameters, parameterList, returnType);\n      },\n      parseObjectType_: function() {\n        var start = this.getTreeStartLocation_();\n        var typeMembers = [];\n        this.eat_(OPEN_CURLY);\n        var type;\n        while (this.peekTypeMember_(type = peekType())) {\n          typeMembers.push(this.parseTypeMember_(type));\n          if (!this.eatIf_(SEMI_COLON)) {\n            break;\n          }\n        }\n        this.eat_(CLOSE_CURLY);\n        return new ObjectType(this.getTreeLocation_(start), typeMembers);\n      },\n      peekTypeMember_: function(type) {\n        switch (type) {\n          case NEW:\n          case OPEN_PAREN:\n          case OPEN_ANGLE:\n          case OPEN_SQUARE:\n          case IDENTIFIER:\n          case STRING:\n          case NUMBER:\n            return true;\n          default:\n            return peekToken().isKeyword();\n        }\n      },\n      parseTypeMember_: function(type) {\n        switch (type) {\n          case NEW:\n            return this.parseConstructSignature_();\n          case OPEN_PAREN:\n          case OPEN_ANGLE:\n            return this.parseCallSignature_();\n          case OPEN_SQUARE:\n            return this.parseIndexSignature_();\n        }\n        var start = this.getTreeStartLocation_();\n        var propertyName = this.parseLiteralPropertyName_();\n        var isOpt = this.eatIf_(QUESTION);\n        type = peekType();\n        if (type === OPEN_ANGLE || type === OPEN_PAREN) {\n          var callSignature = this.parseCallSignature_();\n          return new MethodSignature(this.getTreeLocation_(start), propertyName, isOpt, callSignature);\n        }\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        return new PropertySignature(this.getTreeLocation_(start), propertyName, isOpt, typeAnnotation);\n      },\n      parseCallSignature_: function() {\n        var start = this.getTreeStartLocation_();\n        var typeParameters = this.parseTypeParametersOpt_();\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        var returnType = this.parseTypeAnnotationOpt_();\n        return new CallSignature(this.getTreeLocation_(start), typeParameters, parameterList, returnType);\n      },\n      parseConstructSignature_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(NEW);\n        var typeParameters = this.parseTypeParametersOpt_();\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        var returnType = this.parseTypeAnnotationOpt_();\n        return new ConstructSignature(this.getTreeLocation_(start), typeParameters, parameterList, returnType);\n      },\n      parseIndexSignature_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_SQUARE);\n        var id = this.eatId_();\n        this.eat_(COLON);\n        var typeName;\n        var typeStart = this.getTreeStartLocation_();\n        if (this.peekPredefinedString_(\'string\')) {\n          typeName = this.eatId_(\'string\');\n        } else {\n          typeName = this.eatId_(\'number\');\n        }\n        var indexType = new PredefinedType(this.getTreeLocation_(typeStart), typeName);\n        this.eat_(CLOSE_SQUARE);\n        this.eat_(COLON);\n        var typeAnnotation = this.parseType_();\n        return new IndexSignature(this.getTreeLocation_(start), id, indexType, typeAnnotation);\n      },\n      parseFunctionType_: function() {\n        var start = this.getTreeStartLocation_();\n        var typeParameters = this.parseTypeParametersOpt_();\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        this.eat_(ARROW);\n        var returnType = this.parseType_();\n        return new FunctionType(this.getTreeLocation_(start), typeParameters, parameterList, returnType);\n      },\n      parseTypeQuery_: function(start) {\n        throw \'NYI\';\n      },\n      peekTypeParameters_: function() {\n        return peek(OPEN_ANGLE);\n      },\n      parseTypeParametersOpt_: function() {\n        if (peek(OPEN_ANGLE)) {\n          return this.parseTypeParameters_();\n        }\n        return null;\n      },\n      parseTypeParameters_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_ANGLE);\n        var parameters = [this.parseTypeParameter_()];\n        while (peek(COMMA)) {\n          this.eat_(COMMA);\n          parameters.push(this.parseTypeParameter_());\n        }\n        this.eat_(CLOSE_ANGLE);\n        return new TypeParameters(this.getTreeLocation_(start), parameters);\n      },\n      parseTypeParameter_: function() {\n        var start = this.getTreeStartLocation_();\n        var id = this.eatId_();\n        var extendsType = null;\n        if (this.eatIf_(EXTENDS)) {\n          extendsType = this.parseType_();\n        }\n        return new TypeParameter(this.getTreeLocation_(start), id, extendsType);\n      },\n      parseNamedOrPredefinedType_: function() {\n        var start = this.getTreeStartLocation_();\n        switch (peekToken().value) {\n          case \'any\':\n          case \'number\':\n          case \'boolean\':\n          case \'string\':\n            {\n              var token = nextToken();\n              return new PredefinedType(this.getTreeLocation_(start), token);\n            }\n          default:\n            return this.parseTypeName_();\n        }\n      },\n      parseTypeName_: function() {\n        var start = this.getTreeStartLocation_();\n        var id = this.eatId_();\n        var typeName = new TypeName(this.getTreeLocation_(start), null, id);\n        while (this.eatIf_(PERIOD)) {\n          var memberName = this.eatIdName_();\n          typeName = new TypeName(this.getTreeLocation_(start), typeName, memberName);\n        }\n        return typeName;\n      },\n      parseInterfaceDeclaration_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(INTERFACE);\n        var name = this.eatId_();\n        var typeParameters = this.parseTypeParametersOpt_();\n        var extendsClause;\n        if (this.eatIf_(EXTENDS)) {\n          extendsClause = this.parseInterfaceExtendsClause_();\n        } else {\n          extendsClause = [];\n        }\n        var objectType = this.parseObjectType_();\n        return new InterfaceDeclaration(this.getTreeLocation_(start), name, typeParameters, extendsClause, objectType);\n      },\n      parseInterfaceExtendsClause_: function() {\n        var result = [this.parseTypeReference_()];\n        while (this.eatIf_(COMMA)) {\n          result.push(this.parseTypeReference_());\n        }\n        return result;\n      },\n      parseAnnotatedDeclarations_: function(parsingModuleItem) {\n        this.pushAnnotations_();\n        var declaration;\n        var type = peekType();\n        if (parsingModuleItem) {\n          declaration = this.parseModuleItem_(type);\n        } else {\n          declaration = this.parseStatementListItem_(type);\n        }\n        if (this.annotations_.length > 0) {\n          this.reportError_(this.annotations_[0].location, \'Unsupported annotated expression\');\n        }\n        return declaration;\n      },\n      parseAnnotations_: function() {\n        var annotations = [];\n        while (this.eatIf_(AT)) {\n          annotations.push(this.parseAnnotation_());\n        }\n        return annotations;\n      },\n      pushAnnotations_: function() {\n        this.annotations_ = this.parseAnnotations_();\n      },\n      popAnnotations_: function() {\n        var annotations = this.annotations_;\n        this.annotations_ = [];\n        return annotations;\n      },\n      parseAnnotation_: function() {\n        var start = this.getTreeStartLocation_();\n        var expression = this.parseMemberExpressionNoNew_();\n        var args = null;\n        if (peek(OPEN_PAREN))\n          args = this.parseArguments_();\n        return new Annotation(this.getTreeLocation_(start), expression, args);\n      },\n      parseTypeAliasDeclaration_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eatId_(TYPE);\n        var name = this.eatId_();\n        this.eat_(EQUAL);\n        var type = this.parseType_();\n        this.eatPossibleImplicitSemiColon_();\n        return new TypeAliasDeclaration(this.getTreeLocation_(start), name, type);\n      },\n      parseJsxElement_: function() {\n        var token = this.eatJsx_(OPEN_ANGLE);\n        return this.parseJsxElementContinuation_(token.location.start);\n      },\n      parseJsxElementContinuation_: function(start) {\n        var name = this.parseJsxElementName_();\n        var attrs = this.parseJsxAttributes_();\n        var children = [];\n        switch (peekJsxToken().type) {\n          case SLASH:\n            nextJsxToken();\n            this.eat_(CLOSE_ANGLE);\n            break;\n          case CLOSE_ANGLE:\n            {\n              nextJsxTextToken();\n              loop: while (true) {\n                var token = nextJsxTextToken();\n                switch (token.type) {\n                  case STRING:\n                    {\n                      children.push(new JsxText(token.location, token));\n                      continue;\n                    }\n                  case OPEN_CURLY:\n                    {\n                      var start$__20 = token.location.start;\n                      var expression = null;\n                      if (!peek(CLOSE_CURLY)) {\n                        expression = this.parseAssignmentExpression_(ALLOW_IN);\n                      }\n                      this.eatJsx_(CLOSE_CURLY);\n                      var placeHolder = new JsxPlaceholder(this.getTreeLocation_(start$__20), expression);\n                      children.push(placeHolder);\n                      continue;\n                    }\n                  case OPEN_ANGLE:\n                    {\n                      var start$__21 = token.location.start;\n                      if (peekJsxToken().type === SLASH) {\n                        nextJsxToken();\n                        break loop;\n                      }\n                      var subElement = this.parseJsxElementContinuation_(start$__21);\n                      children.push(subElement);\n                      resetScanner(subElement.location.end.offset);\n                      continue;\n                    }\n                  default:\n                    return this.parseSyntaxError_(\'Unexpected token\');\n                }\n              }\n              var closeName = this.parseJsxElementName_();\n              if (!jsxNamesEqual(name, closeName)) {\n                this.reportError_(closeName.location, ("Non matching JSX closing tag. Expected " + jsxNameToString(name) + ", found " + jsxNameToString(closeName)));\n              }\n              this.eat_(CLOSE_ANGLE);\n              break;\n            }\n          default:\n            return this.parseSyntaxError_(\'Unexpected token\');\n        }\n        var element = new JsxElement(this.getTreeLocation_(start), name, attrs, children);\n        return element;\n      },\n      parseJsxElementName_: function() {\n        var tokens = [];\n        var id = this.eatJsx_(JSX_IDENTIFIER);\n        var start = id.location.start;\n        tokens.push(id);\n        while (peekJsxToken().type === PERIOD) {\n          nextJsxToken();\n          var id$__22 = this.eatJsx_(JSX_IDENTIFIER);\n          tokens.push(id$__22);\n        }\n        return new JsxElementName(this.getTreeLocation_(start), tokens);\n      },\n      parseJsxAttributes_: function() {\n        var attributes = [];\n        loop: while (true) {\n          switch (peekJsxToken().type) {\n            case JSX_IDENTIFIER:\n              attributes.push(this.parseJsxAttribute_());\n              break;\n            case OPEN_CURLY:\n              attributes.push(this.parseJsxSpreadAttribute_());\n              break;\n            default:\n              break loop;\n          }\n        }\n        return attributes;\n      },\n      parseJsxAttribute_: function() {\n        var name = this.eatJsx_(JSX_IDENTIFIER);\n        var start = name.location.start;\n        var value = null;\n        if (peekJsxToken().type === EQUAL) {\n          this.eatJsx_(EQUAL);\n          value = this.parseJsxAttributeValue_();\n        }\n        return new JsxAttribute(this.getTreeLocation_(start), name, value);\n      },\n      parseJsxAttributeValue_: function() {\n        var token = peekJsxToken();\n        var start = token.location.start;\n        switch (token.type) {\n          case STRING:\n            nextJsxToken();\n            return new LiteralExpression(this.getTreeLocation_(start), token);\n          case OPEN_CURLY:\n            {\n              nextJsxToken();\n              var expr = this.parseAssignmentExpression_(ALLOW_IN);\n              this.eatJsx_(CLOSE_CURLY);\n              return new JsxPlaceholder(this.getTreeLocation_(start), expr);\n            }\n          case OPEN_ANGLE:\n            return this.parseJsxElement_();\n        }\n        return this.parseSyntaxError_(\'Unexpected token\');\n      },\n      parseJsxSpreadAttribute_: function() {\n        var token = peekJsxToken();\n        var start = token.location.start;\n        nextJsxToken();\n        this.eatJsx_(DOT_DOT_DOT);\n        var expr = this.parseAssignmentExpression_(ALLOW_IN);\n        this.eatJsx_(CLOSE_CURLY);\n        return new JsxSpreadAttribute(this.getTreeLocation_(start), expr);\n      },\n      eatPossibleImplicitSemiColon_: function() {\n        var token = peekTokenNoLineTerminator();\n        if (!token)\n          return;\n        switch (token.type) {\n          case SEMI_COLON:\n            nextToken();\n            return;\n          case END_OF_FILE:\n          case CLOSE_CURLY:\n            return;\n        }\n        this.reportError_(token.location, \'Semi-colon expected\');\n      },\n      peekImplicitSemiColon_: function() {\n        switch (peekType()) {\n          case SEMI_COLON:\n          case CLOSE_CURLY:\n          case END_OF_FILE:\n            return true;\n        }\n        var token = peekTokenNoLineTerminator();\n        return token === null;\n      },\n      eatOpt_: function(expectedTokenType) {\n        if (peek(expectedTokenType))\n          return nextToken();\n        return null;\n      },\n      eatIdOpt_: function() {\n        return peek(IDENTIFIER) ? this.eatId_() : null;\n      },\n      eatId_: function() {\n        var expected = arguments[0];\n        var token = nextToken();\n        if (token.type === IDENTIFIER) {\n          if (expected && token.value !== expected)\n            this.reportExpectedError_(token, expected);\n          return token;\n        }\n        if (token.isStrictKeyword()) {\n          if (this.strictMode_) {\n            this.reportReservedIdentifier_(token);\n          } else {\n            return new IdentifierToken(token.location, token.type);\n          }\n        } else {\n          this.reportExpectedError_(token, expected || \'identifier\');\n        }\n        return token;\n      },\n      eatIdName_: function() {\n        var t = nextToken();\n        if (t.type !== IDENTIFIER) {\n          if (!t.isKeyword()) {\n            this.reportExpectedError_(t, \'identifier\');\n            return null;\n          }\n          return new IdentifierToken(t.location, t.type);\n        }\n        return t;\n      },\n      eat_: function(expectedTokenType) {\n        return this.isExpectedToken_(nextToken(), expectedTokenType);\n      },\n      eatIf_: function(expectedTokenType) {\n        if (peek(expectedTokenType)) {\n          nextToken();\n          return true;\n        }\n        return false;\n      },\n      eatJsx_: function(expectedTokenType) {\n        return this.isExpectedToken_(nextJsxToken(), expectedTokenType);\n      },\n      isExpectedToken_: function(token, expectedTokenType) {\n        if (token.type !== expectedTokenType) {\n          this.reportExpectedError_(token, expectedTokenType);\n        }\n        return token;\n      },\n      reportExpectedError_: function(token, expected) {\n        this.reportError_(token.location, ("Unexpected token " + token));\n      },\n      getTreeStartLocation_: function() {\n        return peekLocation().start;\n      },\n      getTreeEndLocation_: function() {\n        return getLastToken().location.end;\n      },\n      getTreeLocation_: function(start) {\n        return new SourceRange(start, this.getTreeEndLocation_());\n      },\n      handleComment: function(range) {},\n      isAtEnd: function() {\n        return isAtEnd();\n      },\n      reportError_: function(location, message) {\n        this.errorReporter_.reportError(location, message);\n      },\n      reportReservedIdentifier_: function(token) {\n        this.reportError_(token.location, (token.type + " is a reserved identifier"));\n      },\n      validateAssignmentTarget_: function(tree, operation) {\n        if (!tree.isPattern() && !isValidSimpleAssignmentTarget(tree, this.strictMode_)) {\n          this.reportError_(tree.location, ("Invalid left-hand side expression in " + operation));\n        }\n      }\n    }, {});\n  }();\n  function jsxNamesEqual(name, other) {\n    if (name.names.length !== other.names.length) {\n      return false;\n    }\n    for (var i = 0; i < name.names.length; i++) {\n      if (name.names[i].value !== other.names[i].value) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function jsxNameToString(name) {\n    return name.names.join(\'.\');\n  }\n  return {get Parser() {\n      return Parser;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/util/SourcePosition.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util/SourcePosition.js";\n  var SourcePosition = function() {\n    function SourcePosition(source, offset) {\n      this.source = source;\n      this.offset = offset;\n      this.line_ = -1;\n      this.column_ = -1;\n    }\n    return ($traceurRuntime.createClass)(SourcePosition, {\n      get line() {\n        if (this.line_ === -1)\n          this.line_ = this.source.lineNumberTable.getLine(this.offset);\n        return this.line_;\n      },\n      get column() {\n        if (this.column_ === -1)\n          this.column_ = this.source.lineNumberTable.getColumn(this.offset);\n        return this.column_;\n      },\n      toString: function() {\n        var name = this.source ? this.source.name : \'\';\n        return (name + ":" + (this.line + 1) + ":" + (this.column + 1));\n      }\n    }, {});\n  }();\n  return {get SourcePosition() {\n      return SourcePosition;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/LineNumberTable.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/LineNumberTable.js";\n  var SourcePosition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/SourcePosition.js", "traceur@0.0.111/src/syntax/LineNumberTable.js")).SourcePosition;\n  var SourceRange = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/SourceRange.js", "traceur@0.0.111/src/syntax/LineNumberTable.js")).SourceRange;\n  var isLineTerminator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Scanner.js", "traceur@0.0.111/src/syntax/LineNumberTable.js")).isLineTerminator;\n  var MAX_INT_REPRESENTATION = 9007199254740992;\n  function computeLineStartOffsets(source) {\n    var lineStartOffsets = [0];\n    var k = 1;\n    for (var index = 0; index < source.length; index++) {\n      var code = source.charCodeAt(index);\n      if (isLineTerminator(code)) {\n        if (code === 13 && source.charCodeAt(index + 1) === 10) {\n          index++;\n        }\n        lineStartOffsets[k++] = index + 1;\n      }\n    }\n    lineStartOffsets[k++] = MAX_INT_REPRESENTATION;\n    return lineStartOffsets;\n  }\n  var LineNumberTable = function() {\n    function LineNumberTable(sourceFile) {\n      this.sourceFile_ = sourceFile;\n      this.lineStartOffsets_ = null;\n      this.lastLine_ = 0;\n      this.lastOffset_ = -1;\n    }\n    return ($traceurRuntime.createClass)(LineNumberTable, {\n      ensureLineStartOffsets_: function() {\n        if (!this.lineStartOffsets_) {\n          this.lineStartOffsets_ = computeLineStartOffsets(this.sourceFile_.contents);\n        }\n      },\n      getSourcePosition: function(offset) {\n        return new SourcePosition(this.sourceFile_, offset);\n      },\n      getLine: function(offset) {\n        if (offset === this.lastOffset_)\n          return this.lastLine_;\n        this.ensureLineStartOffsets_();\n        if (offset < 0)\n          return 0;\n        var line;\n        if (offset < this.lastOffset_) {\n          for (var i = this.lastLine_; i >= 0; i--) {\n            if (this.lineStartOffsets_[i] <= offset) {\n              line = i;\n              break;\n            }\n          }\n        } else {\n          for (var i$__1 = this.lastLine_; true; i$__1++) {\n            if (this.lineStartOffsets_[i$__1] > offset) {\n              line = i$__1 - 1;\n              break;\n            }\n          }\n        }\n        this.lastLine_ = line;\n        this.lastOffset_ = offset;\n        return line;\n      },\n      offsetOfLine: function(line) {\n        this.ensureLineStartOffsets_();\n        return this.lineStartOffsets_[line];\n      },\n      getColumn: function(offset) {\n        var line = this.getLine(offset);\n        return offset - this.lineStartOffsets_[line];\n      },\n      getSourceRange: function(startOffset, endOffset) {\n        return new SourceRange(this.getSourcePosition(startOffset), this.getSourcePosition(endOffset));\n      }\n    }, {});\n  }();\n  return {get LineNumberTable() {\n      return LineNumberTable;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/SourceFile.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/SourceFile.js";\n  var LineNumberTable = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./LineNumberTable.js", "traceur@0.0.111/src/syntax/SourceFile.js")).LineNumberTable;\n  var SourceFile = function() {\n    function SourceFile(name, contents) {\n      this.name = name;\n      this.contents = contents;\n      this.lineNumberTable = new LineNumberTable(this);\n    }\n    return ($traceurRuntime.createClass)(SourceFile, {}, {});\n  }();\n  return {get SourceFile() {\n      return SourceFile;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/PlaceholderParser.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/PlaceholderParser.js";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")),\n      ARGUMENT_LIST = $__2.ARGUMENT_LIST,\n      BLOCK = $__2.BLOCK,\n      EXPRESSION_STATEMENT = $__2.EXPRESSION_STATEMENT,\n      FUNCTION_BODY = $__2.FUNCTION_BODY,\n      IDENTIFIER_EXPRESSION = $__2.IDENTIFIER_EXPRESSION;\n  var IdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/IdentifierToken.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")).IdentifierToken;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/LiteralToken.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")).LiteralToken;\n  var CollectingErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/CollectingErrorReporter.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")).CollectingErrorReporter;\n  var Options = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Options.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")).Options;\n  var ParseTree = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTree.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")).ParseTree;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")).ParseTreeTransformer;\n  var Parser = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/Parser.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")).Parser;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")),\n      LiteralExpression = $__10.LiteralExpression,\n      LiteralPropertyName = $__10.LiteralPropertyName,\n      TypeName = $__10.TypeName;\n  var SourceFile = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/SourceFile.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")).SourceFile;\n  var IDENTIFIER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")).IDENTIFIER;\n  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/PlaceholderParser.js")),\n      createArrayLiteral = $__13.createArrayLiteral,\n      createBindingIdentifier = $__13.createBindingIdentifier,\n      createBlock = $__13.createBlock,\n      createBooleanLiteral = $__13.createBooleanLiteral,\n      createCommaExpression = $__13.createCommaExpression,\n      createExpressionStatement = $__13.createExpressionStatement,\n      createFunctionBody = $__13.createFunctionBody,\n      createIdentifierExpression = $__13.createIdentifierExpression,\n      createIdentifierToken = $__13.createIdentifierToken,\n      createMemberExpression = $__13.createMemberExpression,\n      createNullLiteral = $__13.createNullLiteral,\n      createNumberLiteral = $__13.createNumberLiteral,\n      createParenExpression = $__13.createParenExpression,\n      createStringLiteral = $__13.createStringLiteral,\n      createVoid0 = $__13.createVoid0;\n  var NOT_FOUND = {};\n  function makeParseFunction(doParse) {\n    var cache = new Map();\n    return function(sourceLiterals) {\n      for (var values = [],\n          $__1 = 1; $__1 < arguments.length; $__1++)\n        values[$__1 - 1] = arguments[$__1];\n      return parse(sourceLiterals, values, doParse, cache);\n    };\n  }\n  var parseExpression = makeParseFunction(function(p) {\n    return p.parseExpression();\n  });\n  var parseStatement = makeParseFunction(function(p) {\n    return p.parseStatement();\n  });\n  var parseModule = makeParseFunction(function(p) {\n    return p.parseModule();\n  });\n  var parseScript = makeParseFunction(function(p) {\n    return p.parseScript();\n  });\n  var parseStatements = makeParseFunction(function(p) {\n    return p.parseStatements();\n  });\n  var parsePropertyDefinition = makeParseFunction(function(p) {\n    return p.parsePropertyDefinition();\n  });\n  function parse(sourceLiterals, values, doParse, cache) {\n    var tree = cache.get(sourceLiterals);\n    if (!tree) {\n      var source = insertPlaceholderIdentifiers(sourceLiterals);\n      var errorReporter = new CollectingErrorReporter();\n      var parser = getParser(source, errorReporter);\n      tree = doParse(parser);\n      if (errorReporter.hadError() || !tree || !parser.isAtEnd()) {\n        throw new Error(("Internal error trying to parse:\\n\\n" + source + "\\n\\n" + errorReporter.errorsAsString()));\n      }\n      cache.set(sourceLiterals, tree);\n    }\n    if (!values.length)\n      return tree;\n    if (tree instanceof ParseTree)\n      return new PlaceholderTransformer(values).transformAny(tree);\n    return new PlaceholderTransformer(values).transformList(tree);\n  }\n  var PREFIX = \'$__placeholder__\';\n  function insertPlaceholderIdentifiers(sourceLiterals) {\n    var source = sourceLiterals[0];\n    for (var i = 1; i < sourceLiterals.length; i++) {\n      source += PREFIX + String(i - 1) + sourceLiterals[i];\n    }\n    return source;\n  }\n  var counter = 0;\n  function getParser(source, errorReporter) {\n    var file = new SourceFile(null, source);\n    var options = new Options();\n    options.experimental = true;\n    return new Parser(file, errorReporter, options);\n  }\n  function convertValueToExpression(value) {\n    if (value instanceof ParseTree)\n      return value;\n    if (value instanceof IdentifierToken)\n      return createIdentifierExpression(value);\n    if (value instanceof LiteralToken)\n      return new LiteralExpression(value.location, value);\n    if (Array.isArray(value)) {\n      if (value[0] instanceof ParseTree) {\n        if (value.length === 1)\n          return value[0];\n        if (value[0].isStatement())\n          return createBlock(value);\n        else\n          return createParenExpression(createCommaExpression(value));\n      }\n      return createArrayLiteral(value.map(convertValueToExpression));\n    }\n    if (value === null)\n      return createNullLiteral();\n    if (value === undefined)\n      return createVoid0();\n    switch (typeof value) {\n      case \'string\':\n        return createStringLiteral(value);\n      case \'boolean\':\n        return createBooleanLiteral(value);\n      case \'number\':\n        return createNumberLiteral(value);\n    }\n    throw new Error(\'Not implemented\');\n  }\n  function convertValueToIdentifierToken(value) {\n    if (value instanceof IdentifierToken)\n      return value;\n    return createIdentifierToken(value);\n  }\n  function convertValueToType(value) {\n    if (value === null)\n      return null;\n    if (value instanceof ParseTree)\n      return value;\n    if (typeof value === \'string\') {\n      return new TypeName(null, null, convertValueToIdentifierToken(value));\n    }\n    if (value instanceof IdentifierToken) {\n      return new TypeName(null, null, value);\n    }\n    throw new Error(\'Not implemented\');\n  }\n  var PlaceholderTransformer = function($__super) {\n    function PlaceholderTransformer(values) {\n      $traceurRuntime.superConstructor(PlaceholderTransformer).call(this);\n      this.values = values;\n    }\n    return ($traceurRuntime.createClass)(PlaceholderTransformer, {\n      getValueAt: function(index) {\n        return this.values[index];\n      },\n      getValue_: function(str) {\n        if (str.indexOf(PREFIX) !== 0)\n          return NOT_FOUND;\n        return this.getValueAt(Number(str.slice(PREFIX.length)));\n      },\n      transformIdentifierExpression: function(tree) {\n        var value = this.getValue_(tree.identifierToken.value);\n        if (value === NOT_FOUND)\n          return tree;\n        return convertValueToExpression(value);\n      },\n      transformBindingIdentifier: function(tree) {\n        var value = this.getValue_(tree.identifierToken.value);\n        if (value === NOT_FOUND)\n          return tree;\n        return createBindingIdentifier(value);\n      },\n      transformExpressionStatement: function(tree) {\n        if (tree.expression.type === IDENTIFIER_EXPRESSION) {\n          var transformedExpression = this.transformIdentifierExpression(tree.expression);\n          if (transformedExpression === tree.expression)\n            return tree;\n          if (transformedExpression.isStatementListItem() || transformedExpression.type === FUNCTION_BODY) {\n            return transformedExpression;\n          }\n          return createExpressionStatement(transformedExpression);\n        }\n        return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, "transformExpressionStatement").call(this, tree);\n      },\n      transformBlock: function(tree) {\n        if (tree.statements.length === 1 && tree.statements[0].type === EXPRESSION_STATEMENT) {\n          var transformedStatement = this.transformExpressionStatement(tree.statements[0]);\n          if (transformedStatement === tree.statements[0])\n            return tree;\n          if (transformedStatement.type === BLOCK)\n            return transformedStatement;\n        }\n        return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, "transformBlock").call(this, tree);\n      },\n      transformFunctionBody: function(tree) {\n        if (tree.statements.length === 1 && tree.statements[0].type === EXPRESSION_STATEMENT) {\n          var transformedStatement = this.transformExpressionStatement(tree.statements[0]);\n          if (transformedStatement.type === FUNCTION_BODY)\n            return transformedStatement;\n          if (transformedStatement === tree.statements[0])\n            return tree;\n          if (transformedStatement.type === BLOCK)\n            return createFunctionBody(transformedStatement.statements);\n        }\n        return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, "transformFunctionBody").call(this, tree);\n      },\n      transformMemberExpression: function(tree) {\n        var value = this.getValue_(tree.memberName.value);\n        if (value === NOT_FOUND)\n          return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, "transformMemberExpression").call(this, tree);\n        var operand = this.transformAny(tree.operand);\n        return createMemberExpression(operand, value);\n      },\n      transformLiteralPropertyName: function(tree) {\n        if (tree.literalToken.type === IDENTIFIER) {\n          var value = this.getValue_(tree.literalToken.value);\n          if (value !== NOT_FOUND) {\n            return new LiteralPropertyName(null, convertValueToIdentifierToken(value));\n          }\n        }\n        return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, "transformLiteralPropertyName").call(this, tree);\n      },\n      transformArgumentList: function(tree) {\n        if (tree.args.length === 1 && tree.args[0].type === IDENTIFIER_EXPRESSION) {\n          var arg0 = this.transformAny(tree.args[0]);\n          if (arg0 === tree.args[0])\n            return tree;\n          if (arg0.type === ARGUMENT_LIST)\n            return arg0;\n        }\n        return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, "transformArgumentList").call(this, tree);\n      },\n      transformTypeName: function(tree) {\n        var value = this.getValue_(tree.name.value);\n        if (value === NOT_FOUND)\n          return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, "transformTypeName").call(this, tree);\n        var moduleName = this.transformAny(tree.moduleName);\n        if (moduleName !== null) {\n          return new TypeName(null, moduleName, convertValueToIdentifierToken(value));\n        }\n        return convertValueToType(value);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {\n    get parseExpression() {\n      return parseExpression;\n    },\n    get parseStatement() {\n      return parseStatement;\n    },\n    get parseModule() {\n      return parseModule;\n    },\n    get parseScript() {\n      return parseScript;\n    },\n    get parseStatements() {\n      return parseStatements;\n    },\n    get parsePropertyDefinition() {\n      return parsePropertyDefinition;\n    },\n    get PlaceholderTransformer() {\n      return PlaceholderTransformer;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/PrependStatements.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/PrependStatements.js";\n  function prependStatements(statements) {\n    var $__1;\n    for (var statementsToPrepend = [],\n        $__0 = 1; $__0 < arguments.length; $__0++)\n      statementsToPrepend[$__0 - 1] = arguments[$__0];\n    if (!statements.length)\n      return statementsToPrepend;\n    if (!statementsToPrepend.length)\n      return statements;\n    var transformed = [];\n    var inProlog = true;\n    statements.forEach(function(statement) {\n      var $__1;\n      if (inProlog && !statement.isDirectivePrologue()) {\n        ($__1 = transformed).push.apply($__1, $traceurRuntime.spread(statementsToPrepend));\n        inProlog = false;\n      }\n      transformed.push(statement);\n    });\n    if (inProlog) {\n      ($__1 = transformed).push.apply($__1, $traceurRuntime.spread(statementsToPrepend));\n    }\n    return transformed;\n  }\n  return {get prependStatements() {\n      return prependStatements;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js";\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js")),\n      CONST = $__5.CONST,\n      VAR = $__5.VAR;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js")),\n      ImportDeclaration = $__6.ImportDeclaration,\n      ImportedBinding = $__6.ImportedBinding,\n      ImportSpecifier = $__6.ImportSpecifier,\n      ImportSpecifierSet = $__6.ImportSpecifierSet,\n      Module = $__6.Module,\n      ModuleSpecifier = $__6.ModuleSpecifier,\n      Script = $__6.Script;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringSet.js", "traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js")).StringSet;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js")),\n      createBindingIdentifier = $__8.createBindingIdentifier,\n      createIdentifierToken = $__8.createIdentifierToken,\n      createIdentifierExpression = $__8.createIdentifierExpression,\n      createMemberExpression = $__8.createMemberExpression,\n      createStringLiteral = $__8.createStringLiteral,\n      createStringLiteralToken = $__8.createStringLiteralToken,\n      createVariableStatement = $__8.createVariableStatement;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js")).parseExpression;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js")).prependStatements;\n  function toTempName(name) {\n    return ("$__" + name);\n  }\n  function getDeclarationType(options) {\n    return options.parseOptions.blockBinding && !options.transformOptions.blockBinding ? CONST : VAR;\n  }\n  function ImportRuntimeTrait(ParseTreeTransformerClass) {\n    return function($__super) {\n      function $__0() {\n        var $__4;\n        for (var args = [],\n            $__3 = 0; $__3 < arguments.length; $__3++)\n          args[$__3] = arguments[$__3];\n        ($__4 = $traceurRuntime.superConstructor($__0)).call.apply($__4, $traceurRuntime.spread([this], args));\n        this.importedNames = new StringSet();\n        this._existingImports = new StringSet();\n      }\n      return ($traceurRuntime.createClass)($__0, {\n        getRuntimeExpression: function(name) {\n          if (this.options.importRuntime) {\n            this.addImportedName(name);\n            return createIdentifierExpression(toTempName(name));\n          }\n          return createMemberExpression(\'$traceurRuntime\', name);\n        },\n        get requiredNames() {\n          return this.importedNames;\n        },\n        addImportedName: function(name) {\n          this.importedNames.add(name);\n        },\n        transformScript: function(tree) {\n          var transformed = $traceurRuntime.superGet(this, $__0.prototype, "transformScript").call(this, tree);\n          if (tree === transformed) {\n            return tree;\n          }\n          if (!this.options.importRuntime) {\n            return transformed;\n          }\n          var scriptItemList = this.addRuntimeImports(transformed.scriptItemList);\n          return new Script(tree.location, scriptItemList, tree.moduleName);\n        },\n        transformModule: function(tree) {\n          var transformed = $traceurRuntime.superGet(this, $__0.prototype, "transformModule").call(this, tree);\n          if (tree === transformed) {\n            return tree;\n          }\n          if (!this.options.importRuntime) {\n            return transformed;\n          }\n          var scriptItemList = this.addRuntimeImports(transformed.scriptItemList);\n          return new Module(tree.location, scriptItemList, tree.moduleName);\n        },\n        transformImportedBinding: function(tree) {\n          this._existingImports.add(tree.binding.getStringValue());\n          return $traceurRuntime.superGet(this, $__0.prototype, "transformImportedBinding").call(this, tree);\n        },\n        _getModuleSpecifier: function(name) {\n          var base = \'traceur/dist/commonjs\';\n          if (this.options.modules === \'parse\') {\n            base = \'traceur/src\';\n          }\n          var moduleId = createStringLiteralToken((base + "/runtime/modules/" + name + ".js"));\n          return new ModuleSpecifier(null, moduleId);\n        },\n        getRuntimeImports: function() {\n          var $__2 = this;\n          return this.importedNames.valuesAsArray().filter(function(name) {\n            return !$__2._existingImports.has(toTempName(name));\n          }).map(function(name) {\n            var def = createIdentifierToken(\'default\');\n            var binding = new ImportedBinding(null, createBindingIdentifier(toTempName(name)));\n            var specifier = new ImportSpecifier(null, binding, def);\n            return new ImportDeclaration(null, new ImportSpecifierSet(null, [specifier]), $__2._getModuleSpecifier(name));\n          });\n        },\n        addRuntimeImports: function(scriptItemList) {\n          var runtimeImports = this.getRuntimeImports();\n          return prependStatements.apply((void 0), $traceurRuntime.spread([scriptItemList], runtimeImports));\n        }\n      }, {}, $__super);\n    }(ParseTreeTransformerClass);\n  }\n  return {get default() {\n      return ImportRuntimeTrait;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/TempVarTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/TempVarTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/TempVarTransformer.js")).ParseTreeTransformer;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/TempVarTransformer.js")),\n      Module = $__6.Module,\n      Script = $__6.Script;\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/TempVarTransformer.js")).ARGUMENTS;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringSet.js", "traceur@0.0.111/src/codegeneration/TempVarTransformer.js")).StringSet;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/TempVarTransformer.js")),\n      LET = $__9.LET,\n      VAR = $__9.VAR;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/TempVarTransformer.js")),\n      createFunctionBody = $__10.createFunctionBody,\n      createThisExpression = $__10.createThisExpression,\n      createIdentifierExpression = $__10.createIdentifierExpression,\n      createVariableDeclaration = $__10.createVariableDeclaration,\n      createVariableDeclarationList = $__10.createVariableDeclarationList,\n      createVariableStatement = $__10.createVariableStatement;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/TempVarTransformer.js")).prependStatements;\n  var TempVarStatement = function() {\n    function TempVarStatement(name, initializer) {\n      this.name = name;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(TempVarStatement, {}, {});\n  }();\n  var TempScope = function() {\n    function TempScope() {\n      this.identifiers = [];\n    }\n    return ($traceurRuntime.createClass)(TempScope, {\n      push: function(identifier) {\n        this.identifiers.push(identifier);\n      },\n      pop: function() {\n        return this.identifiers.pop();\n      },\n      release: function(obj) {\n        for (var i = this.identifiers.length - 1; i >= 0; i--) {\n          obj.releaseTempName(this.identifiers[i]);\n        }\n      }\n    }, {});\n  }();\n  var VarScope = function() {\n    function VarScope(options) {\n      this.thisName = null;\n      this.argumentName = null;\n      this.tempVarStatements = [];\n      this.declarationType_ = options.blockBinding && !options.transformOptions.blockBinding ? LET : VAR;\n    }\n    return ($traceurRuntime.createClass)(VarScope, {\n      push: function(tempVarStatement) {\n        this.tempVarStatements.push(tempVarStatement);\n      },\n      pop: function() {\n        return this.tempVarStatements.pop();\n      },\n      release: function(obj) {\n        for (var i = this.tempVarStatements.length - 1; i >= 0; i--) {\n          obj.releaseTempName(this.tempVarStatements[i].name);\n        }\n      },\n      isEmpty: function() {\n        return !this.tempVarStatements.length;\n      },\n      createVariableStatement: function() {\n        var declarations = [];\n        var seenNames = new StringSet();\n        for (var i = 0; i < this.tempVarStatements.length; i++) {\n          var $__4 = this.tempVarStatements[i],\n              name = $__4.name,\n              initializer = $__4.initializer;\n          if (seenNames.has(name)) {\n            if (initializer)\n              throw new Error(\'Invalid use of TempVarTransformer\');\n            continue;\n          }\n          seenNames.add(name);\n          declarations.push(createVariableDeclaration(name, initializer));\n        }\n        return createVariableStatement(createVariableDeclarationList(this.declarationType_, declarations));\n      }\n    }, {});\n  }();\n  var TempVarTransformer = function($__super) {\n    function TempVarTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(TempVarTransformer).call(this);\n      this.identifierGenerator = identifierGenerator;\n      this.reporter = reporter;\n      this.options = options;\n      this.tempVarStack_ = [new VarScope(this.options)];\n      this.tempScopeStack_ = [new TempScope()];\n      this.namePool_ = [];\n    }\n    return ($traceurRuntime.createClass)(TempVarTransformer, {\n      transformStatements_: function(statements) {\n        this.tempVarStack_.push(new VarScope(this.options));\n        var transformedStatements = this.transformList(statements);\n        var vars = this.tempVarStack_.pop();\n        if (vars.isEmpty())\n          return transformedStatements;\n        var variableStatement = vars.createVariableStatement();\n        vars.release(this);\n        return prependStatements(transformedStatements, variableStatement);\n      },\n      transformScript: function(tree) {\n        var scriptItemList = this.transformStatements_(tree.scriptItemList);\n        if (scriptItemList === tree.scriptItemList) {\n          return tree;\n        }\n        return new Script(tree.location, scriptItemList, tree.moduleName);\n      },\n      transformModule: function(tree) {\n        var scriptItemList = this.transformStatements_(tree.scriptItemList);\n        if (scriptItemList === tree.scriptItemList) {\n          return tree;\n        }\n        return new Module(tree.location, scriptItemList, tree.moduleName);\n      },\n      transformFunctionBody: function(tree) {\n        this.pushTempScope();\n        var statements = this.transformStatements_(tree.statements);\n        this.popTempScope();\n        if (statements === tree.statements)\n          return tree;\n        return createFunctionBody(statements);\n      },\n      getTempIdentifier: function() {\n        var name = this.getName_();\n        this.tempScopeStack_[this.tempScopeStack_.length - 1].push(name);\n        return name;\n      },\n      getName_: function() {\n        return this.namePool_.length ? this.namePool_.pop() : this.identifierGenerator.generateUniqueIdentifier();\n      },\n      addTempVar: function() {\n        var initializer = arguments[0] !== (void 0) ? arguments[0] : null;\n        var vars = this.tempVarStack_[this.tempVarStack_.length - 1];\n        var name = this.getName_();\n        vars.push(new TempVarStatement(name, initializer));\n        return name;\n      },\n      registerTempVarName: function(name) {\n        var vars = this.tempVarStack_[this.tempVarStack_.length - 1];\n        vars.push(new TempVarStatement(name, null));\n      },\n      addTempVarForThis: function() {\n        var varScope = this.tempVarStack_[this.tempVarStack_.length - 1];\n        return varScope.thisName || (varScope.thisName = this.addTempVar(createThisExpression()));\n      },\n      addTempVarForArguments: function() {\n        var varScope = this.tempVarStack_[this.tempVarStack_.length - 1];\n        return varScope.argumentName || (varScope.argumentName = this.addTempVar(createIdentifierExpression(ARGUMENTS)));\n      },\n      pushTempScope: function() {\n        this.tempScopeStack_.push(new TempScope());\n      },\n      popTempScope: function() {\n        this.tempScopeStack_.pop().release(this);\n      },\n      releaseTempName: function(name) {\n        this.namePool_.push(name);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get TempVarTransformer() {\n      return TempVarTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/bindingsInDestructuringPattern.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/bindingsInDestructuringPattern.js";\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/ParseTreeVisitor.js", "traceur@0.0.111/src/semantics/bindingsInDestructuringPattern.js")).ParseTreeVisitor;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringSet.js", "traceur@0.0.111/src/semantics/bindingsInDestructuringPattern.js")).StringSet;\n  var BindingsInDestructuringPatternVisitor = function($__super) {\n    function BindingsInDestructuringPatternVisitor() {\n      $traceurRuntime.superConstructor(BindingsInDestructuringPatternVisitor).call(this);\n      this.bindings = new StringSet();\n    }\n    return ($traceurRuntime.createClass)(BindingsInDestructuringPatternVisitor, {\n      visitBindingIdentifier: function(tree) {\n        this.bindings.add(tree.getStringValue());\n      },\n      visitBindingElement: function(tree) {\n        this.visitAny(tree.binding);\n      },\n      visitVariableDeclaration: function(tree) {\n        this.visitAny(tree.lvalue);\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  function bindingsInDestructuringPattern(tree) {\n    var v = new BindingsInDestructuringPatternVisitor();\n    v.visitAny(tree);\n    return v.bindings;\n  }\n  return {get default() {\n      return bindingsInDestructuringPattern;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/DestructuringTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/DestructuringTransformer.js";\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/DestructuringTransformer.js")),\n      ARRAY_LITERAL = $__8.ARRAY_LITERAL,\n      ARRAY_PATTERN = $__8.ARRAY_PATTERN,\n      ASSIGNMENT_ELEMENT = $__8.ASSIGNMENT_ELEMENT,\n      BINDING_ELEMENT = $__8.BINDING_ELEMENT,\n      BINDING_IDENTIFIER = $__8.BINDING_IDENTIFIER,\n      BLOCK = $__8.BLOCK,\n      CALL_EXPRESSION = $__8.CALL_EXPRESSION,\n      COMPUTED_PROPERTY_NAME = $__8.COMPUTED_PROPERTY_NAME,\n      IDENTIFIER_EXPRESSION = $__8.IDENTIFIER_EXPRESSION,\n      LITERAL_EXPRESSION = $__8.LITERAL_EXPRESSION,\n      MEMBER_EXPRESSION = $__8.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__8.MEMBER_LOOKUP_EXPRESSION,\n      OBJECT_LITERAL = $__8.OBJECT_LITERAL,\n      OBJECT_PATTERN_FIELD = $__8.OBJECT_PATTERN_FIELD,\n      OBJECT_PATTERN = $__8.OBJECT_PATTERN,\n      PAREN_EXPRESSION = $__8.PAREN_EXPRESSION,\n      VARIABLE_DECLARATION_LIST = $__8.VARIABLE_DECLARATION_LIST,\n      VARIABLE_STATEMENT = $__8.VARIABLE_STATEMENT;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/DestructuringTransformer.js")),\n      AnonBlock = $__9.AnonBlock,\n      AssignmentElement = $__9.AssignmentElement,\n      BindingElement = $__9.BindingElement,\n      Catch = $__9.Catch,\n      ExportDeclaration = $__9.ExportDeclaration,\n      ForInStatement = $__9.ForInStatement,\n      ForOfStatement = $__9.ForOfStatement,\n      ForOnStatement = $__9.ForOnStatement,\n      VariableDeclarationList = $__9.VariableDeclarationList,\n      VariableStatement = $__9.VariableStatement;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/DestructuringTransformer.js")).default;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/DestructuringTransformer.js")).TempVarTransformer;\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/DestructuringTransformer.js")),\n      EQUAL = $__12.EQUAL,\n      LET = $__12.LET,\n      VAR = $__12.VAR;\n  var bindingsInDestructuringPattern = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../semantics/bindingsInDestructuringPattern.js", "traceur@0.0.111/src/codegeneration/DestructuringTransformer.js")).default;\n  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/DestructuringTransformer.js")),\n      createAssignmentExpression = $__14.createAssignmentExpression,\n      createBindingIdentifier = $__14.createBindingIdentifier,\n      createBlock = $__14.createBlock,\n      createCommaExpression = $__14.createCommaExpression,\n      createExpressionStatement = $__14.createExpressionStatement,\n      createFunctionBody = $__14.createFunctionBody,\n      createIdentifierExpression = $__14.createIdentifierExpression,\n      createMemberExpression = $__14.createMemberExpression,\n      createMemberLookupExpression = $__14.createMemberLookupExpression,\n      createParenExpression = $__14.createParenExpression,\n      createVariableDeclaration = $__14.createVariableDeclaration,\n      createVariableDeclarationList = $__14.createVariableDeclarationList,\n      createVariableStatement = $__14.createVariableStatement;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/DestructuringTransformer.js")).parseExpression;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/DestructuringTransformer.js")).prependStatements;\n  var Desugaring = function() {\n    function Desugaring(rvalue) {\n      this.rvalue = rvalue;\n      this.expressions = [];\n      this.pendingExpressions = [];\n    }\n    return ($traceurRuntime.createClass)(Desugaring, {\n      createIterator: function(iterId) {\n        this.pendingExpressions.push(parseExpression($traceurRuntime.getTemplateObject(["", " = ", "[Symbol.iterator]()"]), iterId, this.rvalue));\n      },\n      createInitializer: function(expression) {\n        if (this.pendingExpressions.length === 0)\n          return expression;\n        var expressions = this.pendingExpressions;\n        this.pendingExpressions = [];\n        expressions.push(expression);\n        return createParenExpression(createCommaExpression(expressions));\n      },\n      skipHole: function(iterId) {\n        this.pendingExpressions.push(parseExpression($traceurRuntime.getTemplateObject(["", ".next()"]), iterId));\n      }\n    }, {});\n  }();\n  var AssignmentExpressionDesugaring = function($__super) {\n    function AssignmentExpressionDesugaring(rvalue) {\n      $traceurRuntime.superConstructor(AssignmentExpressionDesugaring).call(this, rvalue);\n    }\n    return ($traceurRuntime.createClass)(AssignmentExpressionDesugaring, {\n      assign: function(lvalue, rvalue) {\n        lvalue = lvalue instanceof AssignmentElement ? lvalue.assignment : lvalue;\n        rvalue = this.createInitializer(rvalue);\n        this.expressions.push(createAssignmentExpression(lvalue, rvalue));\n      },\n      createAssignmentExpression: function(tempId, rvalue) {\n        var $__6;\n        var expressions = this.expressions;\n        expressions.unshift(createAssignmentExpression(tempId, rvalue));\n        ($__6 = expressions).push.apply($__6, $traceurRuntime.spread(this.pendingExpressions, [tempId]));\n        return createParenExpression(createCommaExpression(expressions));\n      }\n    }, {}, $__super);\n  }(Desugaring);\n  var VariableDeclarationDesugaring = function($__super) {\n    function VariableDeclarationDesugaring(rvalue) {\n      $traceurRuntime.superConstructor(VariableDeclarationDesugaring).call(this, rvalue);\n    }\n    return ($traceurRuntime.createClass)(VariableDeclarationDesugaring, {\n      assign: function(lvalue, rvalue) {\n        var binding = lvalue instanceof BindingElement ? lvalue.binding : createBindingIdentifier(lvalue);\n        rvalue = this.createInitializer(rvalue);\n        this.expressions.push(createVariableDeclaration(binding, rvalue));\n      },\n      get declarations() {\n        return this.expressions;\n      }\n    }, {}, $__super);\n  }(Desugaring);\n  var DestructuringTransformer = function($__super) {\n    function DestructuringTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(DestructuringTransformer).call(this, identifierGenerator, reporter, options);\n      this.parameterDeclarations = null;\n    }\n    return ($traceurRuntime.createClass)(DestructuringTransformer, {\n      transformArrayPattern: function(tree) {\n        throw new Error(\'unreachable\');\n      },\n      transformObjectPattern: function(tree) {\n        throw new Error(\'unreachable\');\n      },\n      transformBinaryExpression: function(tree) {\n        this.pushTempScope();\n        var rv;\n        if (tree.operator.type === EQUAL && tree.left.isPattern()) {\n          rv = this.transformAny(this.desugarAssignment_(tree.left, tree.right));\n        } else {\n          rv = $traceurRuntime.superGet(this, DestructuringTransformer.prototype, "transformBinaryExpression").call(this, tree);\n        }\n        this.popTempScope();\n        return rv;\n      },\n      desugarAssignment_: function(lvalue, rvalue) {\n        var tempId = createIdentifierExpression(this.addTempVar());\n        var desugaring = new AssignmentExpressionDesugaring(tempId);\n        this.desugarPattern_(desugaring, lvalue);\n        return desugaring.createAssignmentExpression(tempId, rvalue);\n      },\n      transformVariableDeclarationList: function(tree) {\n        var $__4 = this;\n        if (!hasDestructuring(tree)) {\n          return $traceurRuntime.superGet(this, DestructuringTransformer.prototype, "transformVariableDeclarationList").call(this, tree);\n        }\n        var desugaredDeclarations = [];\n        tree.declarations.forEach(function(declaration) {\n          var $__6;\n          if (declaration.lvalue.isPattern()) {\n            ($__6 = desugaredDeclarations).push.apply($__6, $traceurRuntime.spread($__4.desugarVariableDeclaration_(declaration)));\n          } else {\n            desugaredDeclarations.push(declaration);\n          }\n        });\n        var transformedTree = this.transformVariableDeclarationList(createVariableDeclarationList(tree.declarationType, desugaredDeclarations));\n        return transformedTree;\n      },\n      transformForInStatement: function(tree) {\n        return this.transformForInOrOfOrOn_(tree, $traceurRuntime.superGet(this, DestructuringTransformer.prototype, "transformForInStatement"), ForInStatement);\n      },\n      transformForOfStatement: function(tree) {\n        return this.transformForInOrOfOrOn_(tree, $traceurRuntime.superGet(this, DestructuringTransformer.prototype, "transformForOfStatement"), ForOfStatement);\n      },\n      transformForOnStatement: function(tree) {\n        return this.transformForInOrOfOrOn_(tree, $traceurRuntime.superGet(this, DestructuringTransformer.prototype, "transformForOnStatement"), ForOnStatement);\n      },\n      transformForInOrOfOrOn_: function(tree, superMethod, constr) {\n        var $__6;\n        if (!tree.initializer.isPattern() && (tree.initializer.type !== VARIABLE_DECLARATION_LIST || !hasDestructuring(tree.initializer))) {\n          return superMethod.call(this, tree);\n        }\n        this.pushTempScope();\n        var declarationType,\n            lvalue;\n        if (tree.initializer.isPattern()) {\n          declarationType = null;\n          lvalue = tree.initializer;\n        } else {\n          declarationType = tree.initializer.declarationType;\n          lvalue = tree.initializer.declarations[0].lvalue;\n        }\n        var statements = [];\n        var binding = this.desugarBinding_(lvalue, statements, declarationType);\n        var initializer = createVariableDeclarationList(VAR, binding, null);\n        var collection = this.transformAny(tree.collection);\n        var body = this.transformAny(tree.body);\n        if (body.type === BLOCK)\n          ($__6 = statements).push.apply($__6, $traceurRuntime.spread(body.statements));\n        else\n          statements.push(body);\n        body = createBlock(statements);\n        this.popTempScope();\n        return new constr(tree.location, initializer, collection, body);\n      },\n      transformAssignmentElement: function(tree) {\n        throw new Error(\'unreachable\');\n      },\n      transformBindingElement: function(tree) {\n        if (!tree.binding.isPattern() || tree.initializer)\n          return tree;\n        if (this.parameterDeclarations === null) {\n          this.parameterDeclarations = [];\n          this.pushTempScope();\n        }\n        var varName = this.getTempIdentifier();\n        var binding = createBindingIdentifier(varName);\n        var initializer = createIdentifierExpression(varName);\n        var decl = createVariableDeclaration(tree.binding, initializer);\n        this.parameterDeclarations.push(decl);\n        return new BindingElement(null, binding, null);\n      },\n      transformFunctionBody: function(tree) {\n        if (this.parameterDeclarations === null)\n          return $traceurRuntime.superGet(this, DestructuringTransformer.prototype, "transformFunctionBody").call(this, tree);\n        var list = createVariableDeclarationList(VAR, this.parameterDeclarations);\n        var statement = createVariableStatement(list);\n        var statements = prependStatements(tree.statements, statement);\n        var newBody = createFunctionBody(statements);\n        this.parameterDeclarations = null;\n        var result = $traceurRuntime.superGet(this, DestructuringTransformer.prototype, "transformFunctionBody").call(this, newBody);\n        this.popTempScope();\n        return result;\n      },\n      transformCatch: function(tree) {\n        var $__6;\n        if (!tree.binding.isPattern())\n          return $traceurRuntime.superGet(this, DestructuringTransformer.prototype, "transformCatch").call(this, tree);\n        var body = this.transformAny(tree.catchBody);\n        var statements = [];\n        var kind = this.options.blockBinding ? LET : VAR;\n        var binding = this.desugarBinding_(tree.binding, statements, kind);\n        ($__6 = statements).push.apply($__6, $traceurRuntime.spread(body.statements));\n        return new Catch(tree.location, binding, createBlock(statements));\n      },\n      transformExportDeclaration: function(tree) {\n        if (tree.declaration.type === VARIABLE_STATEMENT && hasDestructuring(tree.declaration.declarations)) {\n          var names = bindingsInDestructuringPattern(tree.declaration.declarations);\n          var declaration = this.transformAny(tree.declaration);\n          var statements = [];\n          var $__5 = declaration.declarations,\n              declarations = $__5.declarations,\n              declarationType = $__5.declarationType;\n          for (var i = 0; i < declarations.length; i++) {\n            var declaration$__7 = declarations[i];\n            var statement = new VariableStatement(declaration$__7.location, new VariableDeclarationList(declaration$__7.location, declarationType, [declaration$__7]));\n            if (names.has(declarations[i].lvalue.getStringValue())) {\n              statement = new ExportDeclaration(statement.location, statement, []);\n            }\n            statements.push(statement);\n          }\n          return new AnonBlock(null, statements);\n        }\n        return $traceurRuntime.superGet(this, DestructuringTransformer.prototype, "transformExportDeclaration").call(this, tree);\n      },\n      desugarBinding_: function(bindingTree, statements, declarationType) {\n        var varName = this.getTempIdentifier();\n        var binding = createBindingIdentifier(varName);\n        var idExpr = createIdentifierExpression(varName);\n        var desugaring;\n        if (declarationType === null)\n          desugaring = new AssignmentExpressionDesugaring(idExpr);\n        else\n          desugaring = new VariableDeclarationDesugaring(idExpr);\n        this.desugarPattern_(desugaring, bindingTree);\n        if (declarationType === null) {\n          statements.push(createExpressionStatement(createCommaExpression(desugaring.expressions)));\n        } else {\n          statements.push(createVariableStatement(this.transformVariableDeclarationList(createVariableDeclarationList(declarationType, desugaring.declarations))));\n        }\n        return binding;\n      },\n      desugarVariableDeclaration_: function(tree) {\n        var tempRValueName = this.getTempIdentifier();\n        var tempRValueIdent = createIdentifierExpression(tempRValueName);\n        var desugaring;\n        var initializer;\n        switch (tree.initializer.type) {\n          case ARRAY_LITERAL:\n          case CALL_EXPRESSION:\n          case IDENTIFIER_EXPRESSION:\n          case LITERAL_EXPRESSION:\n          case MEMBER_EXPRESSION:\n          case MEMBER_LOOKUP_EXPRESSION:\n          case OBJECT_LITERAL:\n          case PAREN_EXPRESSION:\n            initializer = tree.initializer;\n        }\n        desugaring = new VariableDeclarationDesugaring(tempRValueIdent);\n        desugaring.assign(desugaring.rvalue, tree.initializer);\n        var initializerFound = this.desugarPattern_(desugaring, tree.lvalue);\n        if (initializerFound || desugaring.declarations.length > 2) {\n          return desugaring.declarations;\n        }\n        if (!initializer) {\n          initializer = createParenExpression(tree.initializer);\n        }\n        desugaring = new VariableDeclarationDesugaring(initializer);\n        this.desugarPattern_(desugaring, tree.lvalue);\n        return desugaring.declarations;\n      },\n      desugarPattern_: function(desugaring, tree) {\n        var $__4 = this;\n        var initializerFound = false;\n        var pattern;\n        switch (tree.type) {\n          case ARRAY_PATTERN:\n            {\n              pattern = tree;\n              this.pushTempScope();\n              var iterId = createIdentifierExpression(this.addTempVar());\n              var iterObjectId = createIdentifierExpression(this.addTempVar());\n              desugaring.createIterator(iterId);\n              for (var i = 0; i < pattern.elements.length; i++) {\n                var lvalue = pattern.elements[i];\n                if (lvalue === null) {\n                  desugaring.skipHole(iterId);\n                  continue;\n                } else if (lvalue.isSpreadPatternElement()) {\n                  var iteratorToArray = this.getRuntimeExpression(\'iteratorToArray\');\n                  desugaring.assign(lvalue.lvalue, parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), iteratorToArray, iterId));\n                } else {\n                  if (lvalue.initializer) {\n                    initializerFound = true;\n                  }\n                  desugaring.assign(lvalue, this.createConditionalIterExpression(iterObjectId, iterId, lvalue.initializer));\n                }\n              }\n              this.popTempScope();\n              break;\n            }\n          case OBJECT_PATTERN:\n            {\n              pattern = tree;\n              var elementHelper = function(lvalue, initializer) {\n                if (initializer)\n                  initializerFound = true;\n                var lookup = $__4.createConditionalMemberExpression(desugaring.rvalue, lvalue, initializer);\n                desugaring.assign(lvalue, lookup);\n              };\n              pattern.fields.forEach(function(field) {\n                var lookup;\n                switch (field.type) {\n                  case ASSIGNMENT_ELEMENT:\n                    elementHelper(field.assignment, field.initializer);\n                    break;\n                  case BINDING_ELEMENT:\n                    elementHelper(field.binding, field.initializer);\n                    break;\n                  case OBJECT_PATTERN_FIELD:\n                    {\n                      if (field.element.initializer)\n                        initializerFound = true;\n                      var name = field.name;\n                      lookup = $__4.createConditionalMemberExpression(desugaring.rvalue, name, field.element.initializer);\n                      desugaring.assign(field.element, lookup);\n                      break;\n                    }\n                  default:\n                    throw Error(\'unreachable\');\n                }\n              });\n              break;\n            }\n          case PAREN_EXPRESSION:\n            return this.desugarPattern_(desugaring, tree.expression);\n          default:\n            throw new Error(\'unreachable\');\n        }\n        if (desugaring instanceof VariableDeclarationDesugaring && desugaring.declarations.length === 0) {\n          desugaring.assign(createBindingIdentifier(this.getTempIdentifier()), desugaring.rvalue);\n        }\n        return initializerFound;\n      },\n      createConditionalMemberExpression: function(rvalue, name, initializer) {\n        if (name.type === COMPUTED_PROPERTY_NAME) {\n          return this.createConditionalMemberLookupExpression(rvalue, name.expression, initializer);\n        }\n        var token;\n        switch (name.type) {\n          case BINDING_IDENTIFIER:\n          case IDENTIFIER_EXPRESSION:\n            token = name.identifierToken;\n            break;\n          default:\n            token = name.literalToken;\n        }\n        if (!initializer)\n          return createMemberExpression(rvalue, token);\n        var tempIdent = createIdentifierExpression(this.addTempVar());\n        return parseExpression($traceurRuntime.getTemplateObject(["(", " = ", ".", ") === void 0 ?\\n        ", " : ", ""]), tempIdent, rvalue, token, initializer, tempIdent);\n      },\n      createConditionalMemberLookupExpression: function(rvalue, index, initializer) {\n        if (!initializer)\n          return createMemberLookupExpression(rvalue, index);\n        var tempIdent = createIdentifierExpression(this.addTempVar());\n        return parseExpression($traceurRuntime.getTemplateObject(["(", " = ", "[", "]) === void 0 ?\\n        ", " : ", ""]), tempIdent, rvalue, index, initializer, tempIdent);\n      },\n      createConditionalIterExpression: function(iterObjectId, iterId, initializer) {\n        var expr = parseExpression($traceurRuntime.getTemplateObject(["(", " =\\n        ", ".next()).done ? void 0 : ", ".value"]), iterObjectId, iterId, iterObjectId);\n        if (!initializer) {\n          return expr;\n        }\n        var tempIdent = createIdentifierExpression(this.addTempVar());\n        return parseExpression($traceurRuntime.getTemplateObject(["(", " = ", ") === void 0 ?\\n        ", " : ", ""]), tempIdent, expr, initializer, tempIdent);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  function hasDestructuring(tree) {\n    return tree.declarations.some(function(declaration) {\n      return declaration.lvalue.isPattern();\n    });\n  }\n  return {get DestructuringTransformer() {\n      return DestructuringTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/module/ModuleSymbol.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/module/ModuleSymbol.js";\n  var StringMap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../util/StringMap.js", "traceur@0.0.111/src/codegeneration/module/ModuleSymbol.js")).StringMap;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../util/assert.js", "traceur@0.0.111/src/codegeneration/module/ModuleSymbol.js")).assert;\n  var ExportsList = function() {\n    function ExportsList(normalizedName) {\n      this.exports_ = new StringMap();\n      if (normalizedName !== null)\n        this.normalizedName = normalizedName.replace(/\\\\/g, \'/\');\n      else\n        this.normalizedName = null;\n    }\n    return ($traceurRuntime.createClass)(ExportsList, {\n      addExport: function(name, tree) {\n        assert(!this.exports_.has(name));\n        this.exports_.set(name, tree);\n      },\n      getExport: function(name) {\n        return this.exports_.get(name);\n      },\n      getExports: function() {\n        return this.exports_.keysAsArray();\n      },\n      addExportsFromModule: function(module) {\n        var $__2 = this;\n        Object.getOwnPropertyNames(module).forEach(function(name) {\n          $__2.addExport(name, true);\n        });\n      }\n    }, {});\n  }();\n  var ModuleSymbol = function($__super) {\n    function ModuleSymbol(tree, normalizedName) {\n      $traceurRuntime.superConstructor(ModuleSymbol).call(this, normalizedName);\n      this.tree = tree;\n      this.imports_ = new StringMap();\n    }\n    return ($traceurRuntime.createClass)(ModuleSymbol, {\n      addImport: function(name, tree) {\n        assert(!this.imports_.has(name));\n        this.imports_.set(name, tree);\n      },\n      getImport: function(name) {\n        return this.imports_.get(name);\n      }\n    }, {}, $__super);\n  }(ExportsList);\n  return {\n    get ExportsList() {\n      return ExportsList;\n    },\n    get ModuleSymbol() {\n      return ModuleSymbol;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/module/ModuleVisitor.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/module/ModuleVisitor.js";\n  var ExportsList = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModuleSymbol.js", "traceur@0.0.111/src/codegeneration/module/ModuleVisitor.js")).ExportsList;\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/ParseTreeVisitor.js", "traceur@0.0.111/src/codegeneration/module/ModuleVisitor.js")).ParseTreeVisitor;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/module/ModuleVisitor.js")),\n      EXPORT_DECLARATION = $__3.EXPORT_DECLARATION,\n      IMPORT_DECLARATION = $__3.IMPORT_DECLARATION;\n  var ModuleVisitor = function($__super) {\n    function ModuleVisitor(reporter, loader, moduleSymbol) {\n      $traceurRuntime.superConstructor(ModuleVisitor).call(this);\n      this.reporter = reporter;\n      this.loader_ = loader;\n      this.moduleSymbol = moduleSymbol;\n    }\n    return ($traceurRuntime.createClass)(ModuleVisitor, {\n      getExportsListForModuleSpecifier: function(name) {\n        var referrer = this.moduleSymbol.normalizedName;\n        return this.loader_.getExportsListForModuleSpecifier(name, referrer);\n      },\n      visitFunctionDeclaration: function(tree) {},\n      visitFunctionExpression: function(tree) {},\n      visitFunctionBody: function(tree) {},\n      visitBlock: function(tree) {},\n      visitClassDeclaration: function(tree) {},\n      visitClassExpression: function(tree) {},\n      visitModuleElement_: function(element) {\n        switch (element.type) {\n          case EXPORT_DECLARATION:\n          case IMPORT_DECLARATION:\n            this.visitAny(element);\n        }\n      },\n      visitScript: function(tree) {\n        tree.scriptItemList.forEach(this.visitModuleElement_, this);\n      },\n      visitModule: function(tree) {\n        tree.scriptItemList.forEach(this.visitModuleElement_, this);\n      },\n      reportError: function(tree, message) {\n        this.reporter.reportError(tree.location, message);\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  return {get ModuleVisitor() {\n      return ModuleVisitor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/module/ExportVisitor.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/module/ExportVisitor.js";\n  var ModuleVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModuleVisitor.js", "traceur@0.0.111/src/codegeneration/module/ExportVisitor.js")).ModuleVisitor;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../util/assert.js", "traceur@0.0.111/src/codegeneration/module/ExportVisitor.js")).assert;\n  var ExportVisitor = function($__super) {\n    function ExportVisitor(reporter, loader, moduleSymbol) {\n      $traceurRuntime.superConstructor(ExportVisitor).call(this, reporter, loader, moduleSymbol);\n      this.inExport_ = false;\n      this.moduleSpecifier = null;\n    }\n    return ($traceurRuntime.createClass)(ExportVisitor, {\n      addExport_: function(name, tree) {\n        assert(typeof name === \'string\');\n        if (this.inExport_)\n          this.addExport(name, tree);\n      },\n      addExport: function(name, tree) {\n        var moduleSymbol = this.moduleSymbol;\n        var existingExport = moduleSymbol.getExport(name);\n        if (existingExport) {\n          this.reportError(tree, ("Duplicate export. \'" + name + "\' was previously ") + ("exported at " + existingExport.location.start));\n        } else {\n          moduleSymbol.addExport(name, tree);\n        }\n      },\n      visitClassDeclaration: function(tree) {\n        this.addExport_(tree.name.identifierToken.value, tree);\n      },\n      visitExportDeclaration: function(tree) {\n        this.inExport_ = true;\n        this.visitAny(tree.declaration);\n        this.inExport_ = false;\n      },\n      visitNamedExport: function(tree) {\n        this.moduleSpecifier = tree.moduleSpecifier;\n        this.visitAny(tree.exportClause);\n        this.moduleSpecifier = null;\n      },\n      visitExportDefault: function(tree) {\n        this.addExport_(\'default\', tree);\n      },\n      visitExportSpecifier: function(tree) {\n        this.addExport_((tree.rhs || tree.lhs).value, tree);\n      },\n      visitExportStar: function(tree) {\n        var $__1 = this;\n        var name = this.moduleSpecifier.token.processedValue;\n        var exportList = this.getExportsListForModuleSpecifier(name);\n        if (exportList) {\n          exportList.getExports().forEach(function(name) {\n            return $__1.addExport(name, tree);\n          });\n        }\n      },\n      visitNameSpaceExport: function(tree) {\n        this.addExport_(tree.name.value, tree);\n      },\n      visitForwardDefaultExport: function(tree) {\n        this.addExport_(tree.name.value, tree);\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.addExport_(tree.name.getStringValue(), tree);\n      },\n      visitVariableDeclaration: function(tree) {\n        this.visitAny(tree.lvalue);\n      },\n      visitBindingIdentifier: function(tree) {\n        this.addExport_(tree.getStringValue(), tree);\n      },\n      visitBindingElement: function(tree) {\n        this.visitAny(tree.binding);\n      },\n      visitTypeAliasDeclaration: function(tree) {\n        this.addExport(tree.name.value, tree);\n      }\n    }, {}, $__super);\n  }(ModuleVisitor);\n  return {get ExportVisitor() {\n      return ExportVisitor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/module/DirectExportVisitor.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/module/DirectExportVisitor.js";\n  var ExportVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ExportVisitor.js", "traceur@0.0.111/src/codegeneration/module/DirectExportVisitor.js")).ExportVisitor;\n  var TYPE_ALIAS_DECLARATION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/module/DirectExportVisitor.js")).TYPE_ALIAS_DECLARATION;\n  var DirectExportVisitor = function($__super) {\n    function DirectExportVisitor() {\n      $traceurRuntime.superConstructor(DirectExportVisitor).call(this, null, null, null);\n      this.namedExports = [];\n      this.starExports = [];\n    }\n    return ($traceurRuntime.createClass)(DirectExportVisitor, {\n      addExport: function(name, tree) {\n        this.namedExports.push({\n          name: name,\n          tree: tree,\n          moduleSpecifier: this.moduleSpecifier\n        });\n      },\n      visitExportStar: function(tree) {\n        this.starExports.push(this.moduleSpecifier);\n      },\n      hasExports: function() {\n        return this.namedExports.length !== 0 || this.starExports.length !== 0;\n      },\n      getNonTypeNamedExports: function() {\n        return this.namedExports.filter(function(exp) {\n          return exp.tree.type !== TYPE_ALIAS_DECLARATION;\n        });\n      }\n    }, {}, $__super);\n  }(ExportVisitor);\n  return {get DirectExportVisitor() {\n      return DirectExportVisitor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js";\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js")),\n      AnonBlock = $__5.AnonBlock,\n      ImportDeclaration = $__5.ImportDeclaration,\n      ImportSpecifier = $__5.ImportSpecifier,\n      ImportSpecifierSet = $__5.ImportSpecifierSet,\n      Module = $__5.Module;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js")).ParseTreeTransformer;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js")),\n      ANON_BLOCK = $__7.ANON_BLOCK,\n      IMPORT_CLAUSE_PAIR = $__7.IMPORT_CLAUSE_PAIR,\n      IMPORT_DECLARATION = $__7.IMPORT_DECLARATION,\n      IMPORT_SPECIFIER_SET = $__7.IMPORT_SPECIFIER_SET,\n      IMPORTED_BINDING = $__7.IMPORTED_BINDING,\n      NAME_SPACE_IMPORT = $__7.NAME_SPACE_IMPORT;\n  var createIdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js")).createIdentifierToken;\n  var ImportSimplifyingTransformer = function($__super) {\n    function ImportSimplifyingTransformer() {\n      $traceurRuntime.superConstructor(ImportSimplifyingTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ImportSimplifyingTransformer, {\n      transformModule: function(tree) {\n        var $__2;\n        var statements = [];\n        for (var i = 0; i < tree.scriptItemList.length; i++) {\n          var item = tree.scriptItemList[i];\n          switch (item.type) {\n            case IMPORT_DECLARATION:\n              {\n                var transformed = this.transformAny(item);\n                if (transformed.type === ANON_BLOCK) {\n                  ($__2 = statements).push.apply($__2, $traceurRuntime.spread(transformed.statements));\n                } else {\n                  statements.push(transformed);\n                }\n                break;\n              }\n            default:\n              statements.push(item);\n          }\n        }\n        return new Module(tree.location, statements, tree.moduleName);\n      },\n      transformImportDeclaration: function(tree) {\n        var importClause = tree.importClause;\n        if (importClause === null) {\n          var set = new ImportSpecifierSet(null, []);\n          return new ImportDeclaration(tree.location, set, tree.moduleSpecifier);\n        }\n        if (importClause.type === NAME_SPACE_IMPORT) {\n          return tree;\n        }\n        if (importClause.type === IMPORTED_BINDING) {\n          var specifier = this.transformAny(importClause);\n          var set$__3 = new ImportSpecifierSet(null, [specifier]);\n          return new ImportDeclaration(tree.location, set$__3, tree.moduleSpecifier);\n        }\n        if (importClause.type === IMPORT_CLAUSE_PAIR) {\n          var $__1 = importClause,\n              first = $__1.first,\n              second = $__1.second;\n          if (second.type === IMPORT_SPECIFIER_SET) {\n            var defaultSpecifier = this.transformAny(first);\n            var specifiers = $traceurRuntime.spread([defaultSpecifier], second.specifiers);\n            var set$__4 = new ImportSpecifierSet(first.location, specifiers);\n            return new ImportDeclaration(tree.location, set$__4, tree.moduleSpecifier);\n          }\n          var firstImport = new ImportDeclaration(tree.location, first, tree.moduleSpecifier);\n          firstImport = this.transformAny(firstImport);\n          var secondImport = new ImportDeclaration(tree.location, second, tree.moduleSpecifier);\n          return new AnonBlock(null, [firstImport, secondImport]);\n        }\n        return $traceurRuntime.superGet(this, ImportSimplifyingTransformer.prototype, "transformImportDeclaration").call(this, tree);\n      },\n      transformImportSpecifier: function(tree) {\n        return tree;\n      },\n      transformImportedBinding: function(tree) {\n        var name = createIdentifierToken(\'default\');\n        return new ImportSpecifier(tree.location, tree, name);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get ImportSimplifyingTransformer() {\n      return ImportSimplifyingTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/util/url.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/util/url.js";\n  var canonicalizeUrl = $traceurRuntime.canonicalizeUrl;\n  var isAbsolute = $traceurRuntime.isAbsolute;\n  var removeDotSegments = $traceurRuntime.removeDotSegments;\n  var resolveUrl = $traceurRuntime.resolveUrl;\n  return {\n    get canonicalizeUrl() {\n      return canonicalizeUrl;\n    },\n    get isAbsolute() {\n      return isAbsolute;\n    },\n    get removeDotSegments() {\n      return removeDotSegments;\n    },\n    get resolveUrl() {\n      return resolveUrl;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/SkipFunctionsTransformerTrait.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/SkipFunctionsTransformerTrait.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/SkipFunctionsTransformerTrait.js")),\n      ArrowFunction = $__1.ArrowFunction,\n      FunctionDeclaration = $__1.FunctionDeclaration,\n      FunctionExpression = $__1.FunctionExpression,\n      GetAccessor = $__1.GetAccessor,\n      Method = $__1.Method,\n      SetAccessor = $__1.SetAccessor;\n  function SkipFunctionsTransformerTrait(ParseTreeTransformer) {\n    return function($__super) {\n      function SkipFunctionsTransformer() {\n        $traceurRuntime.superConstructor(SkipFunctionsTransformer).apply(this, arguments);\n      }\n      return ($traceurRuntime.createClass)(SkipFunctionsTransformer, {\n        transformFunctionDeclaration: function(tree) {\n          var annotations = this.transformList(tree.annotations);\n          if (annotations === tree.annotations) {\n            return tree;\n          }\n          return new FunctionDeclaration(tree.location, tree.name, tree.functionKind, tree.parameterList, tree.typeAnnotation, annotations, tree.body);\n        },\n        transformFunctionExpression: function(tree) {\n          var annotations = this.transformList(tree.annotations);\n          if (annotations === tree.annotations) {\n            return tree;\n          }\n          return new FunctionDeclaration(tree.location, tree.name, tree.functionKind, tree.parameterList, tree.typeAnnotation, annotations, tree.body);\n        },\n        transformSetAccessor: function(tree) {\n          var name = this.transformAny(tree.name);\n          var annotations = this.transformList(tree.annotations);\n          if (name === tree.name && annotations === tree.annotations) {\n            return tree;\n          }\n          return new SetAccessor(tree.location, tree.isStatic, name, tree.parameterList, annotations, tree.body);\n        },\n        transformGetAccessor: function(tree) {\n          var name = this.transformAny(tree.name);\n          var annotations = this.transformList(tree.annotations);\n          if (name === tree.name && annotations === tree.annotations) {\n            return tree;\n          }\n          return new GetAccessor(tree.location, tree.isStatic, name, annotations, tree.body);\n        },\n        transformMethod: function(tree) {\n          var name = this.transformAny(tree.name);\n          var annotations = this.transformList(tree.annotations);\n          if (name === tree.name && annotations === tree.annotations) {\n            return tree;\n          }\n          return new Method(tree.location, tree.isStatic, tree.functionKind, name, tree.parameterList, tree.typeAnnotation, annotations, tree.body, tree.debugName);\n        },\n        transformArrowFunction: function(tree) {\n          return tree;\n        }\n      }, {}, $__super);\n    }(ParseTreeTransformer);\n  }\n  return {get default() {\n      return SkipFunctionsTransformerTrait;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ModuleTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ModuleTransformer.js";\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")),\n      AnonBlock = $__8.AnonBlock,\n      BindingElement = $__8.BindingElement,\n      EmptyStatement = $__8.EmptyStatement,\n      LiteralPropertyName = $__8.LiteralPropertyName,\n      Module = $__8.Module,\n      ObjectPattern = $__8.ObjectPattern,\n      ObjectPatternField = $__8.ObjectPatternField,\n      Script = $__8.Script;\n  var DestructuringTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./DestructuringTransformer.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")).DestructuringTransformer;\n  var DirectExportVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./module/DirectExportVisitor.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")).DirectExportVisitor;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")).default;\n  var ImportSimplifyingTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportSimplifyingTransformer.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")).ImportSimplifyingTransformer;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")).TempVarTransformer;\n  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")),\n      CLASS_DECLARATION = $__14.CLASS_DECLARATION,\n      EXPORT_DEFAULT = $__14.EXPORT_DEFAULT,\n      EXPORT_SPECIFIER = $__14.EXPORT_SPECIFIER,\n      FORWARD_DEFAULT_EXPORT = $__14.FORWARD_DEFAULT_EXPORT,\n      FUNCTION_DECLARATION = $__14.FUNCTION_DECLARATION,\n      IMPORT_SPECIFIER_SET = $__14.IMPORT_SPECIFIER_SET,\n      IMPORT_TYPE_CLAUSE = $__14.IMPORT_TYPE_CLAUSE,\n      NAME_SPACE_EXPORT = $__14.NAME_SPACE_EXPORT;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")).VAR;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/assert.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")).assert;\n  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/url.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")),\n      resolveUrl = $__17.resolveUrl,\n      canonicalizeUrl = $__17.canonicalizeUrl;\n  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")),\n      createArgumentList = $__18.createArgumentList,\n      createExpressionStatement = $__18.createExpressionStatement,\n      createIdentifierExpression = $__18.createIdentifierExpression,\n      createIdentifierToken = $__18.createIdentifierToken,\n      createMemberExpression = $__18.createMemberExpression,\n      createObjectLiteral = $__18.createObjectLiteral,\n      createUseStrictDirective = $__18.createUseStrictDirective,\n      createVariableStatement = $__18.createVariableStatement,\n      createVoid0 = $__18.createVoid0;\n  var $__19 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")),\n      parseExpression = $__19.parseExpression,\n      parsePropertyDefinition = $__19.parsePropertyDefinition,\n      parseStatement = $__19.parseStatement,\n      parseStatements = $__19.parseStatements;\n  var SkipFunctionsTransformerTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SkipFunctionsTransformerTrait.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")).default;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")).ParseTreeTransformer;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/ModuleTransformer.js")).prependStatements;\n  function removeUseStrictDirectives(tree) {\n    var result = tree.scriptItemList.filter(function(tree) {\n      return !tree.isUseStrictDirective();\n    });\n    return new Module(tree.location, result, tree.moduleName);\n  }\n  var DestructImportVarStatement = function($__super) {\n    function DestructImportVarStatement() {\n      $traceurRuntime.superConstructor(DestructImportVarStatement).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(DestructImportVarStatement, {createGuardedExpression: function(tree) {\n        return tree;\n      }}, {}, $__super);\n  }(DestructuringTransformer);\n  var ModuleTransformer = function($__super) {\n    function ModuleTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(ModuleTransformer).call(this, identifierGenerator, reporter, options);\n      this.exportVisitor = new DirectExportVisitor();\n      this.importSimplifier_ = new ImportSimplifyingTransformer();\n      this.moduleName = null;\n    }\n    return ($traceurRuntime.createClass)(ModuleTransformer, {\n      getTempVarNameForModuleName: function(moduleName) {\n        return \'$__\' + moduleName.replace(/[^a-zA-Z0-9$]/g, function(c) {\n          return \'_\' + String(c.charCodeAt(0)) + \'_\';\n        }) + \'__\';\n      },\n      getModuleName: function(tree) {\n        return tree.moduleName;\n      },\n      getTempVarNameForModuleSpecifier: function(moduleSpecifier) {\n        var name = moduleSpecifier.token.processedValue;\n        if (name[0] === \'.\' && this.moduleName) {\n          name = resolveUrl(this.moduleName, name);\n        } else {\n          name = canonicalizeUrl(name);\n        }\n        return this.getTempVarNameForModuleName(name);\n      },\n      transformScript: function(tree) {\n        this.moduleName = tree.moduleName;\n        return $traceurRuntime.superGet(this, ModuleTransformer.prototype, "transformScript").call(this, tree);\n      },\n      transformModule: function(tree) {\n        tree = removeUseStrictDirectives(tree);\n        tree = this.importSimplifier_.transformModule(tree);\n        var replaceThis = new ReplaceThis();\n        tree = replaceThis.transformAny(tree);\n        this.moduleName = this.getModuleName(tree);\n        this.pushTempScope();\n        var statements = this.transformList(tree.scriptItemList);\n        statements = this.addExportStatement(statements);\n        var runtimeImports = this.transformList(this.getRuntimeImports());\n        statements = prependStatements.apply((void 0), $traceurRuntime.spread([statements], runtimeImports));\n        this.popTempScope();\n        statements = this.wrapModule(this.moduleProlog().concat(statements));\n        return new Script(tree.location, statements, null);\n      },\n      moduleProlog: function() {\n        var statements = [createUseStrictDirective()];\n        if (this.moduleName) {\n          statements.push(parseStatement($traceurRuntime.getTemplateObject(["var __moduleName = ", ";"]), this.moduleName));\n        }\n        return statements;\n      },\n      wrapModule: function(statements) {\n        var functionExpression;\n        if (this.options.transformOptions.require) {\n          functionExpression = parseExpression($traceurRuntime.getTemplateObject(["function(require) {\\n        ", "\\n      }"]), statements);\n        } else {\n          functionExpression = parseExpression($traceurRuntime.getTemplateObject(["function() {\\n        ", "\\n      }"]), statements);\n        }\n        if (this.moduleName === null) {\n          return parseStatements($traceurRuntime.getTemplateObject(["$traceurRuntime.ModuleStore.getAnonymousModule(\\n              ", ");"]), functionExpression);\n        }\n        return parseStatements($traceurRuntime.getTemplateObject(["$traceurRuntime.registerModule(", ", [], ", ");"]), this.moduleName, functionExpression);\n      },\n      getGetterExport: function(exp) {\n        var returnExpression = this.getGetterExportReturnExpression(exp);\n        return parsePropertyDefinition($traceurRuntime.getTemplateObject(["get ", "() { return ", "; }"]), exp.name, returnExpression);\n      },\n      getGetterExportReturnExpression: function($__4) {\n        var $__5 = $__4,\n            name = $__5.name,\n            tree = $__5.tree,\n            moduleSpecifier = $__5.moduleSpecifier;\n        var returnExpression;\n        switch (tree.type) {\n          case EXPORT_DEFAULT:\n            switch (tree.expression.type) {\n              case CLASS_DECLARATION:\n              case FUNCTION_DECLARATION:\n                return createIdentifierExpression(tree.expression.name);\n              default:\n                return createIdentifierExpression(\'$__default\');\n            }\n            break;\n          case EXPORT_SPECIFIER:\n            if (moduleSpecifier) {\n              var idName = this.getTempVarNameForModuleSpecifier(moduleSpecifier);\n              return createMemberExpression(idName, tree.lhs);\n            }\n            return createIdentifierExpression(tree.lhs);\n          case NAME_SPACE_EXPORT:\n            {\n              var idName$__6 = this.getTempVarNameForModuleSpecifier(moduleSpecifier);\n              return createIdentifierExpression(idName$__6);\n            }\n          case FORWARD_DEFAULT_EXPORT:\n            {\n              var idName$__7 = this.getTempVarNameForModuleSpecifier(moduleSpecifier);\n              return createMemberExpression(idName$__7, \'default\');\n            }\n          default:\n            return createIdentifierExpression(name);\n        }\n      },\n      getExportProperties: function() {\n        var $__3 = this;\n        return this.exportVisitor.getNonTypeNamedExports().map(function(exp) {\n          return $__3.getGetterExport(exp);\n        }).concat(this.exportVisitor.namedExports.map(function(exp) {\n          return $__3.getSetterExport(exp);\n        })).filter(function(e) {\n          return e;\n        });\n      },\n      getSetterExport: function($__4) {\n        var $__5 = $__4,\n            name = $__5.name,\n            tree = $__5.tree,\n            moduleSpecifier = $__5.moduleSpecifier;\n        return null;\n      },\n      getExportObject: function() {\n        var exportObject = createObjectLiteral(this.getExportProperties());\n        if (this.hasStarExports()) {\n          return this.getExportStar(exportObject);\n        }\n        return exportObject;\n      },\n      getExportStar: function(exportObject) {\n        var $__3 = this;\n        var starExports = this.exportVisitor.starExports;\n        var starIdents = starExports.map(function(moduleSpecifier) {\n          return createIdentifierExpression($__3.getTempVarNameForModuleSpecifier(moduleSpecifier));\n        });\n        var args = createArgumentList($traceurRuntime.spread([exportObject], starIdents));\n        var runtime = this.getRuntimeExpression(\'exportStar\');\n        return parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), runtime, args);\n      },\n      addExportStatement: function(statements) {\n        var exportObject = this.getExportObject();\n        statements.push(parseStatement($traceurRuntime.getTemplateObject(["return ", ""]), exportObject));\n        return statements;\n      },\n      hasExports: function() {\n        return this.exportVisitor.hasExports();\n      },\n      hasStarExports: function() {\n        return this.exportVisitor.starExports.length > 0;\n      },\n      transformExportDeclaration: function(tree) {\n        this.exportVisitor.visitAny(tree);\n        return this.transformAny(tree.declaration);\n      },\n      transformExportDefault: function(tree) {\n        switch (tree.expression.type) {\n          case CLASS_DECLARATION:\n          case FUNCTION_DECLARATION:\n            return tree.expression;\n        }\n        return parseStatement($traceurRuntime.getTemplateObject(["var $__default = ", ""]), tree.expression);\n      },\n      transformNamedExport: function(tree) {\n        var moduleSpecifier = tree.moduleSpecifier;\n        if (moduleSpecifier) {\n          var expression = this.transformAny(moduleSpecifier);\n          var idName = this.getTempVarNameForModuleSpecifier(moduleSpecifier);\n          return createVariableStatement(VAR, idName, expression);\n        }\n        return new AnonBlock(null, []);\n      },\n      transformModuleSpecifier: function(tree) {\n        assert(this.moduleName);\n        var name = tree.token.processedValue;\n        return parseExpression($traceurRuntime.getTemplateObject(["$traceurRuntime.getModule(\\n      $traceurRuntime.normalizeModuleName(", ", ", "));"]), name, this.moduleName);\n      },\n      transformImportDeclaration: function(tree) {\n        if (tree.importClause.type === IMPORT_TYPE_CLAUSE) {\n          return new AnonBlock(null, []);\n        }\n        if (tree.importClause.type === IMPORT_SPECIFIER_SET && tree.importClause.specifiers.length === 0) {\n          return createExpressionStatement(this.transformAny(tree.moduleSpecifier));\n        }\n        var binding = this.transformAny(tree.importClause);\n        var initializer = this.transformAny(tree.moduleSpecifier);\n        var varStatement = createVariableStatement(VAR, binding, initializer);\n        if (this.options.transformOptions.destructuring || !this.options.parseOptions.destructuring) {\n          var destructuringTransformer = new DestructImportVarStatement(this.identifierGenerator, this.reporter, this.options);\n          varStatement = varStatement.transform(destructuringTransformer);\n        }\n        return varStatement;\n      },\n      transformImportSpecifierSet: function(tree) {\n        var fields = this.transformList(tree.specifiers);\n        return new ObjectPattern(null, fields);\n      },\n      transformNameSpaceImport: function(tree) {\n        return tree.binding.binding;\n      },\n      transformImportSpecifier: function(tree) {\n        var binding = tree.binding.binding;\n        var bindingElement = new BindingElement(binding.location, binding, null);\n        if (tree.name) {\n          var name = new LiteralPropertyName(tree.name.location, tree.name);\n          return new ObjectPatternField(tree.location, name, bindingElement);\n        }\n        return bindingElement;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  var ReplaceThis = function($__super) {\n    function ReplaceThis() {\n      $traceurRuntime.superConstructor(ReplaceThis).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ReplaceThis, {transformThisExpression: function(tree) {\n        return createVoid0();\n      }}, {}, $__super);\n  }(SkipFunctionsTransformerTrait(ParseTreeTransformer));\n  return {get ModuleTransformer() {\n      return ModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/globalThis.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/globalThis.js";\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/globalThis.js")).parseExpression;\n  var expr;\n  function globalThis() {\n    if (!expr)\n      expr = parseExpression($traceurRuntime.getTemplateObject(["Reflect.global"]));\n    return expr;\n  }\n  var $__default = globalThis;\n  return {get default() {\n      return $__default;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/AmdTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/AmdTransformer.js";\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModuleTransformer.js", "traceur@0.0.111/src/codegeneration/AmdTransformer.js")).ModuleTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/AmdTransformer.js")),\n      createIdentifierExpression = $__3.createIdentifierExpression,\n      createFormalParameter = $__3.createFormalParameter,\n      createStringLiteralToken = $__3.createStringLiteralToken;\n  var globalThis = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./globalThis.js", "traceur@0.0.111/src/codegeneration/AmdTransformer.js")).default;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/AmdTransformer.js")),\n      parseExpression = $__5.parseExpression,\n      parseStatement = $__5.parseStatement,\n      parseStatements = $__5.parseStatements,\n      parsePropertyDefinition = $__5.parsePropertyDefinition;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/AmdTransformer.js")),\n      FormalParameterList = $__6.FormalParameterList,\n      FunctionBody = $__6.FunctionBody,\n      FunctionExpression = $__6.FunctionExpression;\n  var AmdTransformer = function($__super) {\n    function AmdTransformer(identifierGenerator, reporter) {\n      var options = arguments[2];\n      $traceurRuntime.superConstructor(AmdTransformer).call(this, identifierGenerator, reporter, options);\n      this.dependencies = [];\n      this.anonymousModule = options && !options.bundle && options.moduleName !== true;\n    }\n    return ($traceurRuntime.createClass)(AmdTransformer, {\n      getModuleName: function(tree) {\n        if (this.anonymousModule)\n          return null;\n        return tree.moduleName;\n      },\n      getExportProperties: function() {\n        var properties = $traceurRuntime.superGet(this, AmdTransformer.prototype, "getExportProperties").call(this);\n        if (this.exportVisitor.hasExports())\n          properties.push(parsePropertyDefinition($traceurRuntime.getTemplateObject(["__esModule: true"])));\n        return properties;\n      },\n      moduleProlog: function() {\n        var locals = this.dependencies.map(function(dep) {\n          var local = createIdentifierExpression(dep.local);\n          return parseStatement($traceurRuntime.getTemplateObject(["if (!", " || !", ".__esModule)\\n            ", " = {default: ", "}"]), local, local, local, local);\n        });\n        return $traceurRuntime.superGet(this, AmdTransformer.prototype, "moduleProlog").call(this).concat(locals);\n      },\n      wrapModule: function(statements) {\n        var depPaths = this.dependencies.map(function(dep) {\n          return dep.path;\n        });\n        var formals = this.dependencies.map(function(dep) {\n          return createFormalParameter(dep.local);\n        });\n        var parameterList = new FormalParameterList(null, formals);\n        var body = new FunctionBody(null, statements);\n        var func = new FunctionExpression(null, null, null, parameterList, null, [], body);\n        if (this.moduleName) {\n          return parseStatements($traceurRuntime.getTemplateObject(["define(", ", ", ", ", ");"]), this.moduleName, depPaths, func);\n        } else {\n          return parseStatements($traceurRuntime.getTemplateObject(["define(", ", ", ");"]), depPaths, func);\n        }\n      },\n      transformModuleSpecifier: function(tree) {\n        var localName = this.getTempIdentifier();\n        var value = tree.token.processedValue;\n        var stringLiteral = createStringLiteralToken(value.replace(/\\.js$/, \'\'));\n        this.dependencies.push({\n          path: stringLiteral,\n          local: localName\n        });\n        return createIdentifierExpression(localName);\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  return {get AmdTransformer() {\n      return AmdTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/staticsemantics/PropName.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/staticsemantics/PropName.js";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/staticsemantics/PropName.js")),\n      COMPUTED_PROPERTY_NAME = $__0.COMPUTED_PROPERTY_NAME,\n      GET_ACCESSOR = $__0.GET_ACCESSOR,\n      LITERAL_PROPERTY_NAME = $__0.LITERAL_PROPERTY_NAME,\n      METHOD = $__0.METHOD,\n      PROPERTY_NAME_ASSIGNMENT = $__0.PROPERTY_NAME_ASSIGNMENT,\n      PROPERTY_NAME_SHORTHAND = $__0.PROPERTY_NAME_SHORTHAND,\n      SET_ACCESSOR = $__0.SET_ACCESSOR;\n  var IDENTIFIER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/staticsemantics/PropName.js")).IDENTIFIER;\n  function propName(tree) {\n    switch (tree.type) {\n      case LITERAL_PROPERTY_NAME:\n        {\n          var token = tree.literalToken;\n          if (token.isKeyword() || token.type === IDENTIFIER)\n            return token.toString();\n          return String(tree.literalToken.processedValue);\n        }\n      case COMPUTED_PROPERTY_NAME:\n        return \'\';\n      case PROPERTY_NAME_SHORTHAND:\n        return tree.name.toString();\n      case METHOD:\n      case PROPERTY_NAME_ASSIGNMENT:\n      case GET_ACCESSOR:\n      case SET_ACCESSOR:\n        return propName(tree.name);\n    }\n  }\n  return {get propName() {\n      return propName;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js")).ParseTreeTransformer;\n  var CONSTRUCTOR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js")).CONSTRUCTOR;\n  var STRING = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js")).STRING;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js")),\n      AnonBlock = $__8.AnonBlock,\n      ClassDeclaration = $__8.ClassDeclaration,\n      ExportDeclaration = $__8.ExportDeclaration,\n      FormalParameter = $__8.FormalParameter,\n      FunctionDeclaration = $__8.FunctionDeclaration,\n      GetAccessor = $__8.GetAccessor,\n      LiteralExpression = $__8.LiteralExpression,\n      Method = $__8.Method,\n      SetAccessor = $__8.SetAccessor;\n  var propName = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../staticsemantics/PropName.js", "traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js")).propName;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js")),\n      createArgumentList = $__10.createArgumentList,\n      createArrayLiteral = $__10.createArrayLiteral,\n      createAssignmentStatement = $__10.createAssignmentStatement,\n      createIdentifierExpression = $__10.createIdentifierExpression,\n      createMemberExpression = $__10.createMemberExpression,\n      createNewExpression = $__10.createNewExpression,\n      createStringLiteralToken = $__10.createStringLiteralToken;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js")),\n      parseExpression = $__11.parseExpression,\n      parseStatement = $__11.parseStatement;\n  var AnnotationsScope = function() {\n    function AnnotationsScope() {\n      this.className = null;\n      this.isExport = false;\n      this.constructorParameters = [];\n      this.annotations = [];\n      this.metadata = [];\n    }\n    return ($traceurRuntime.createClass)(AnnotationsScope, {get inClassScope() {\n        return this.className !== null;\n      }}, {});\n  }();\n  var AnnotationsTransformer = function($__super) {\n    function AnnotationsTransformer() {\n      $traceurRuntime.superConstructor(AnnotationsTransformer).call(this);\n      this.stack_ = [new AnnotationsScope()];\n    }\n    return ($traceurRuntime.createClass)(AnnotationsTransformer, {\n      transformExportDeclaration: function(tree) {\n        var $__3;\n        var scope = this.pushAnnotationScope_();\n        scope.isExport = true;\n        ($__3 = scope.annotations).push.apply($__3, $traceurRuntime.spread(tree.annotations));\n        var declaration = this.transformAny(tree.declaration);\n        if (declaration !== tree.declaration || tree.annotations.length > 0)\n          tree = new ExportDeclaration(tree.location, declaration, []);\n        return this.appendMetadata_(tree);\n      },\n      transformClassDeclaration: function(tree) {\n        var $__3,\n            $__4;\n        var elementsChanged = false;\n        var exportAnnotations = this.scope.isExport ? this.scope.annotations : [];\n        var scope = this.pushAnnotationScope_();\n        scope.className = tree.name;\n        ($__3 = scope.annotations).push.apply($__3, $traceurRuntime.spread(exportAnnotations, tree.annotations));\n        tree = $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, "transformClassDeclaration").call(this, tree);\n        ($__4 = scope.metadata).unshift.apply($__4, $traceurRuntime.spread(this.transformMetadata_(createIdentifierExpression(tree.name), scope.annotations, scope.constructorParameters)));\n        if (tree.annotations.length > 0) {\n          tree = new ClassDeclaration(tree.location, tree.name, tree.superClass, tree.elements, [], null);\n        }\n        return this.appendMetadata_(tree);\n      },\n      transformFunctionDeclaration: function(tree) {\n        var $__3,\n            $__4;\n        var exportAnnotations = this.scope.isExport ? this.scope.annotations : [];\n        var scope = this.pushAnnotationScope_();\n        ($__3 = scope.annotations).push.apply($__3, $traceurRuntime.spread(exportAnnotations, tree.annotations));\n        ($__4 = scope.metadata).push.apply($__4, $traceurRuntime.spread(this.transformMetadata_(createIdentifierExpression(tree.name), scope.annotations, tree.parameterList.parameters)));\n        tree = $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, "transformFunctionDeclaration").call(this, tree);\n        if (tree.annotations.length > 0) {\n          tree = new FunctionDeclaration(tree.location, tree.name, tree.functionKind, tree.parameterList, tree.typeAnnotation, [], tree.body);\n        }\n        return this.appendMetadata_(tree);\n      },\n      transformFormalParameter: function(tree) {\n        if (tree.annotations.length > 0) {\n          tree = new FormalParameter(tree.location, tree.parameter, tree.typeAnnotation, []);\n        }\n        return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, "transformFormalParameter").call(this, tree);\n      },\n      transformGetAccessor: function(tree) {\n        var $__3;\n        if (!this.scope.inClassScope)\n          return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, "transformGetAccessor").call(this, tree);\n        ($__3 = this.scope.metadata).push.apply($__3, $traceurRuntime.spread(this.transformMetadata_(this.transformAccessor_(tree, this.scope.className, \'get\'), tree.annotations, [])));\n        if (tree.annotations.length > 0) {\n          tree = new GetAccessor(tree.location, tree.isStatic, tree.name, tree.typeAnnotation, [], tree.body);\n        }\n        return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, "transformGetAccessor").call(this, tree);\n      },\n      transformSetAccessor: function(tree) {\n        var $__3;\n        if (!this.scope.inClassScope)\n          return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, "transformSetAccessor").call(this, tree);\n        ($__3 = this.scope.metadata).push.apply($__3, $traceurRuntime.spread(this.transformMetadata_(this.transformAccessor_(tree, this.scope.className, \'set\'), tree.annotations, tree.parameterList.parameters)));\n        var parameterList = this.transformAny(tree.parameterList);\n        if (parameterList !== tree.parameterList || tree.annotations.length > 0) {\n          tree = new SetAccessor(tree.location, tree.isStatic, tree.name, parameterList, [], tree.body);\n        }\n        return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, "transformSetAccessor").call(this, tree);\n      },\n      transformMethod: function(tree) {\n        var $__3,\n            $__4;\n        if (!this.scope.inClassScope)\n          return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, "transformMethod").call(this, tree);\n        if (!tree.isStatic && propName(tree) === CONSTRUCTOR) {\n          ($__3 = this.scope.annotations).push.apply($__3, $traceurRuntime.spread(tree.annotations));\n          this.scope.constructorParameters = tree.parameterList.parameters;\n        } else {\n          ($__4 = this.scope.metadata).push.apply($__4, $traceurRuntime.spread(this.transformMetadata_(this.transformPropertyMethod_(tree, this.scope.className), tree.annotations, tree.parameterList.parameters)));\n        }\n        var parameterList = this.transformAny(tree.parameterList);\n        if (parameterList !== tree.parameterList || tree.annotations.length > 0) {\n          tree = new Method(tree.location, tree.isStatic, tree.functionKind, tree.name, parameterList, tree.typeAnnotation, [], tree.body, tree.debugName);\n        }\n        return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, "transformMethod").call(this, tree);\n      },\n      appendMetadata_: function(tree) {\n        var $__3;\n        var metadata = this.stack_.pop().metadata;\n        if (metadata.length > 0) {\n          if (this.scope.isExport) {\n            ($__3 = this.scope.metadata).push.apply($__3, $traceurRuntime.spread(metadata));\n          } else {\n            tree = new AnonBlock(null, $traceurRuntime.spread([tree], metadata));\n          }\n        }\n        return tree;\n      },\n      transformClassReference_: function(tree, className) {\n        var parent = createIdentifierExpression(className);\n        if (!tree.isStatic)\n          parent = createMemberExpression(parent, \'prototype\');\n        return parent;\n      },\n      transformPropertyMethod_: function(tree, className) {\n        return createMemberExpression(this.transformClassReference_(tree, className), tree.name.literalToken);\n      },\n      transformAccessor_: function(tree, className, accessor) {\n        var args = createArgumentList([this.transformClassReference_(tree, className), this.createLiteralStringExpression_(tree.name)]);\n        var descriptor = parseExpression($traceurRuntime.getTemplateObject(["Object.getOwnPropertyDescriptor(", ")"]), args);\n        return createMemberExpression(descriptor, accessor);\n      },\n      transformParameters_: function(parameters) {\n        var $__2 = this;\n        var hasParameterMetadata = false;\n        parameters = parameters.map(function(param) {\n          var $__3;\n          var metadata = [];\n          if (param.typeAnnotation)\n            metadata.push($__2.transformAny(param.typeAnnotation));\n          if (param.annotations && param.annotations.length > 0)\n            ($__3 = metadata).push.apply($__3, $traceurRuntime.spread($__2.transformAnnotations_(param.annotations)));\n          if (metadata.length > 0) {\n            hasParameterMetadata = true;\n            return createArrayLiteral(metadata);\n          }\n          return createArrayLiteral([]);\n        });\n        return hasParameterMetadata ? parameters : [];\n      },\n      transformAnnotations_: function(annotations) {\n        return annotations.map(function(annotation) {\n          return createNewExpression(annotation.name, annotation.args);\n        });\n      },\n      transformMetadata_: function(target, annotations, parameters) {\n        var metadataStatements = [];\n        if (annotations !== null) {\n          annotations = this.transformAnnotations_(annotations);\n          if (annotations.length > 0) {\n            metadataStatements.push(this.createDefinePropertyStatement_(target, \'annotations\', createArrayLiteral(annotations)));\n          }\n        }\n        if (parameters !== null) {\n          parameters = this.transformParameters_(parameters);\n          if (parameters.length > 0) {\n            metadataStatements.push(this.createDefinePropertyStatement_(target, \'parameters\', createArrayLiteral(parameters)));\n          }\n        }\n        return metadataStatements;\n      },\n      createDefinePropertyStatement_: function(target, property, value) {\n        return parseStatement($traceurRuntime.getTemplateObject(["Object.defineProperty(", ", ", ",\\n        {get: function() {return ", "}});"]), target, property, value);\n      },\n      createLiteralStringExpression_: function(tree) {\n        var token = tree.literalToken;\n        if (tree.literalToken.type !== STRING)\n          token = createStringLiteralToken(tree.literalToken.value);\n        return new LiteralExpression(null, token);\n      },\n      get scope() {\n        return this.stack_[this.stack_.length - 1];\n      },\n      pushAnnotationScope_: function() {\n        var scope = new AnnotationsScope();\n        this.stack_.push(scope);\n        return scope;\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get AnnotationsTransformer() {\n      return AnnotationsTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/FindInFunctionScope.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/FindInFunctionScope.js";\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindVisitor.js", "traceur@0.0.111/src/codegeneration/FindInFunctionScope.js")).FindVisitor;\n  var FindInFunctionScope = function($__super) {\n    function FindInFunctionScope() {\n      $traceurRuntime.superConstructor(FindInFunctionScope).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(FindInFunctionScope, {\n      visitFunctionDeclaration: function(tree) {\n        this.visitList(tree.annotations);\n      },\n      visitFunctionExpression: function(tree) {\n        this.visitList(tree.annotations);\n      },\n      visitSetAccessor: function(tree) {\n        this.visitAny(tree.name);\n        this.visitList(tree.annotations);\n      },\n      visitGetAccessor: function(tree) {\n        this.visitAny(tree.name);\n        this.visitList(tree.annotations);\n      },\n      visitMethod: function(tree) {\n        this.visitAny(tree.name);\n        this.visitList(tree.annotations);\n      }\n    }, {}, $__super);\n  }(FindVisitor);\n  return {get FindInFunctionScope() {\n      return FindInFunctionScope;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/util.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/util.js";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/semantics/util.js")),\n      IDENTIFIER_EXPRESSION = $__0.IDENTIFIER_EXPRESSION,\n      LITERAL_EXPRESSION = $__0.LITERAL_EXPRESSION,\n      PAREN_EXPRESSION = $__0.PAREN_EXPRESSION,\n      UNARY_EXPRESSION = $__0.UNARY_EXPRESSION;\n  var UNDEFINED = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/semantics/util.js")).UNDEFINED;\n  var VOID = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/semantics/util.js")).VOID;\n  function hasUseStrict(list) {\n    for (var i = 0; i < list.length; i++) {\n      if (!list[i].isDirectivePrologue())\n        return false;\n      if (list[i].isUseStrictDirective())\n        return true;\n    }\n    return false;\n  }\n  function isUndefined(tree) {\n    if (tree.type === PAREN_EXPRESSION)\n      return isUndefined(tree.expression);\n    return tree.type === IDENTIFIER_EXPRESSION && tree.identifierToken.value === UNDEFINED;\n  }\n  function isVoidExpression(tree) {\n    if (tree.type === PAREN_EXPRESSION)\n      return isVoidExpression(tree.expression);\n    return tree.type === UNARY_EXPRESSION && tree.operator.type === VOID && isLiteralExpression(tree.operand);\n  }\n  function isLiteralExpression(tree) {\n    if (tree.type === PAREN_EXPRESSION)\n      return isLiteralExpression(tree.expression);\n    return tree.type === LITERAL_EXPRESSION;\n  }\n  return {\n    get hasUseStrict() {\n      return hasUseStrict;\n    },\n    get isUndefined() {\n      return isUndefined;\n    },\n    get isVoidExpression() {\n      return isVoidExpression;\n    },\n    get isLiteralExpression() {\n      return isLiteralExpression;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/isTreeStrict.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/isTreeStrict.js";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/semantics/isTreeStrict.js")),\n      ARROW_FUNCTION = $__0.ARROW_FUNCTION,\n      CLASS_DECLARATION = $__0.CLASS_DECLARATION,\n      CLASS_EXPRESSION = $__0.CLASS_EXPRESSION,\n      FUNCTION_BODY = $__0.FUNCTION_BODY,\n      FUNCTION_DECLARATION = $__0.FUNCTION_DECLARATION,\n      FUNCTION_EXPRESSION = $__0.FUNCTION_EXPRESSION,\n      GET_ACCESSOR = $__0.GET_ACCESSOR,\n      METHOD = $__0.METHOD,\n      MODULE = $__0.MODULE,\n      SCRIPT = $__0.SCRIPT,\n      SET_ACCESSOR = $__0.SET_ACCESSOR;\n  var hasUseStrict = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./util.js", "traceur@0.0.111/src/semantics/isTreeStrict.js")).hasUseStrict;\n  function isTreeStrict(tree) {\n    switch (tree.type) {\n      case CLASS_DECLARATION:\n      case CLASS_EXPRESSION:\n      case MODULE:\n        return true;\n      case FUNCTION_BODY:\n        return hasUseStrict(tree.statements);\n      case FUNCTION_EXPRESSION:\n      case FUNCTION_DECLARATION:\n      case METHOD:\n        return isTreeStrict(tree.body);\n      case ARROW_FUNCTION:\n        if (tree.body.type === FUNCTION_BODY) {\n          return isTreeStrict(tree.body);\n        }\n        return false;\n      case GET_ACCESSOR:\n      case SET_ACCESSOR:\n        return isTreeStrict(tree.body);\n      case SCRIPT:\n        return hasUseStrict(tree.scriptItemList);\n      default:\n        return false;\n    }\n  }\n  return {get isTreeStrict() {\n      return isTreeStrict;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/Scope.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/Scope.js";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/semantics/Scope.js")),\n      BLOCK = $__2.BLOCK,\n      CATCH = $__2.CATCH,\n      FUNCTION_EXPRESSION = $__2.FUNCTION_EXPRESSION;\n  var StringMap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringMap.js", "traceur@0.0.111/src/semantics/Scope.js")).StringMap;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/semantics/Scope.js")).VAR;\n  var isTreeStrict = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./isTreeStrict.js", "traceur@0.0.111/src/semantics/Scope.js")).isTreeStrict;\n  function reportDuplicateVar(reporter, tree, name) {\n    reporter.reportError(tree.location, ("Duplicate declaration, " + name));\n  }\n  var Scope = function() {\n    function Scope(parent, tree) {\n      this.parent = parent;\n      this.tree = tree;\n      this.variableDeclarations_ = new StringMap();\n      this.lexicalDeclarations_ = new StringMap();\n      this.strictMode = parent && parent.strictMode || isTreeStrict(tree);\n      this.inGenerator = parent ? parent.inGenerator || false : false;\n    }\n    return ($traceurRuntime.createClass)(Scope, {\n      addBinding: function(tree, type, reporter) {\n        if (type === VAR) {\n          this.addVar(tree, reporter);\n        } else {\n          this.addDeclaration(tree, type, reporter);\n        }\n      },\n      addVar: function(tree, reporter) {\n        var name = tree.getStringValue();\n        if (this.lexicalDeclarations_.has(name) && !this.isFunctionExpressionName(name)) {\n          reportDuplicateVar(reporter, tree, name);\n          return;\n        }\n        this.variableDeclarations_.set(name, {\n          type: VAR,\n          tree: tree,\n          scope: this\n        });\n        if (!this.isVarScope && this.parent) {\n          this.parent.addVar(tree, reporter);\n        }\n      },\n      addDeclaration: function(tree, type, reporter) {\n        var name = tree.getStringValue();\n        if ((this.lexicalDeclarations_.has(name) || this.variableDeclarations_.has(name)) && !this.isFunctionExpressionName(name)) {\n          reportDuplicateVar(reporter, tree, name);\n          return;\n        }\n        this.lexicalDeclarations_.set(name, {\n          type: type,\n          tree: tree,\n          scope: this\n        });\n      },\n      renameBinding: function(oldName, newTree, newType, reporter) {\n        var name = newTree.getStringValue();\n        if (newType === VAR) {\n          if (this.lexicalDeclarations_.has(oldName)) {\n            this.lexicalDeclarations_.delete(oldName);\n            this.addVar(newTree, reporter);\n          }\n        } else if (this.variableDeclarations_.has(oldName)) {\n          this.variableDeclarations_.delete(oldName);\n          this.addDeclaration(newTree, newType, reporter);\n          if (!this.isVarScope && this.parent) {\n            this.parent.renameBinding(oldName, newTree, newType);\n          }\n        }\n      },\n      get isVarScope() {\n        switch (this.tree.type) {\n          case BLOCK:\n          case CATCH:\n            return false;\n        }\n        return true;\n      },\n      getVarScope: function() {\n        if (this.isVarScope) {\n          return this;\n        }\n        if (this.parent) {\n          return this.parent.getVarScope();\n        }\n        return null;\n      },\n      isFunctionExpressionName: function(name) {\n        var b = this.getBindingByName(name);\n        return b && b.scope.tree.type === FUNCTION_EXPRESSION && b.scope.tree.name === b.tree;\n      },\n      getBinding: function(tree) {\n        var name = tree.getStringValue();\n        return this.getBindingByName(name);\n      },\n      getBindingByName: function(name) {\n        var b = this.variableDeclarations_.get(name);\n        if (b && this.isVarScope) {\n          return b;\n        }\n        b = this.lexicalDeclarations_.get(name);\n        if (b) {\n          return b;\n        }\n        if (this.parent) {\n          return this.parent.getBindingByName(name);\n        }\n        return null;\n      },\n      getAllBindingNames: function() {\n        var names = this.variableDeclarations_.keysAsSet();\n        this.lexicalDeclarations_.forEach(function(name) {\n          return names.add(name);\n        });\n        return names;\n      },\n      getVariableBindingNames: function() {\n        return this.variableDeclarations_.keysAsSet();\n      },\n      getLexicalBindingNames: function() {\n        return this.lexicalDeclarations_.keysAsSet();\n      },\n      hasBindingName: function(name) {\n        return this.lexicalDeclarations_.has(name) || this.variableDeclarations_.has(name);\n      },\n      hasLexicalBindingName: function(name) {\n        return this.lexicalDeclarations_.has(name);\n      },\n      hasVariableBindingName: function(name) {\n        return this.variableDeclarations_.has(name);\n      }\n    }, {});\n  }();\n  return {get Scope() {\n      return Scope;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/ScopeVisitor.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/ScopeVisitor.js";\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/ParseTreeVisitor.js", "traceur@0.0.111/src/semantics/ScopeVisitor.js")).ParseTreeVisitor;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/semantics/ScopeVisitor.js")).VAR;\n  var Scope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Scope.js", "traceur@0.0.111/src/semantics/ScopeVisitor.js")).Scope;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/semantics/ScopeVisitor.js")),\n      COMPREHENSION_FOR = $__6.COMPREHENSION_FOR,\n      VARIABLE_DECLARATION_LIST = $__6.VARIABLE_DECLARATION_LIST;\n  var ScopeVisitor = function($__super) {\n    function ScopeVisitor() {\n      $traceurRuntime.superConstructor(ScopeVisitor).call(this);\n      this.map_ = new Map();\n      this.scope = null;\n      this.withBlockCounter_ = 0;\n    }\n    return ($traceurRuntime.createClass)(ScopeVisitor, {\n      getScopeForTree: function(tree) {\n        return this.map_.get(tree);\n      },\n      createScope: function(tree) {\n        return new Scope(this.scope, tree);\n      },\n      pushScope: function(tree) {\n        var scope = this.createScope(tree);\n        this.map_.set(tree, scope);\n        return this.scope = scope;\n      },\n      popScope: function(scope) {\n        if (this.scope !== scope) {\n          throw new Error(\'ScopeVisitor scope mismatch\');\n        }\n        this.scope = scope.parent;\n      },\n      visitScript: function(tree) {\n        var scope = this.pushScope(tree);\n        $traceurRuntime.superGet(this, ScopeVisitor.prototype, "visitScript").call(this, tree);\n        this.popScope(scope);\n      },\n      visitModule: function(tree) {\n        var scope = this.pushScope(tree);\n        $traceurRuntime.superGet(this, ScopeVisitor.prototype, "visitModule").call(this, tree);\n        this.popScope(scope);\n      },\n      visitBlock: function(tree) {\n        var scope = this.pushScope(tree);\n        $traceurRuntime.superGet(this, ScopeVisitor.prototype, "visitBlock").call(this, tree);\n        this.popScope(scope);\n      },\n      visitCatch: function(tree) {\n        var scope = this.pushScope(tree);\n        this.visitAny(tree.binding);\n        this.visitList(tree.catchBody.statements);\n        this.popScope(scope);\n      },\n      visitFunctionBodyForScope: function(tree) {\n        var parameterList = arguments[1] !== (void 0) ? arguments[1] : tree.parameterList;\n        var scope = this.pushScope(tree);\n        this.visitAny(parameterList);\n        scope.inGenerator = tree.functionKind && tree.isGenerator();\n        this.visitAny(tree.body);\n        this.popScope(scope);\n      },\n      visitFunctionExpression: function(tree) {\n        this.visitFunctionBodyForScope(tree);\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.visitAny(tree.name);\n        this.visitFunctionBodyForScope(tree);\n      },\n      visitArrowFunction: function(tree) {\n        this.visitFunctionBodyForScope(tree);\n      },\n      visitGetAccessor: function(tree) {\n        this.visitFunctionBodyForScope(tree, null);\n      },\n      visitSetAccessor: function(tree) {\n        this.visitFunctionBodyForScope(tree);\n      },\n      visitMethod: function(tree) {\n        this.visitFunctionBodyForScope(tree);\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitAny(tree.superClass);\n        var scope = this.pushScope(tree);\n        this.visitAny(tree.name);\n        this.visitList(tree.elements);\n        this.popScope(scope);\n      },\n      visitClassExpression: function(tree) {\n        this.visitAny(tree.superClass);\n        var scope;\n        if (tree.name) {\n          scope = this.pushScope(tree);\n          this.visitAny(tree.name);\n        }\n        this.visitList(tree.elements);\n        if (tree.name) {\n          this.popScope(scope);\n        }\n      },\n      visitWithStatement: function(tree) {\n        this.visitAny(tree.expression);\n        this.withBlockCounter_++;\n        this.visitAny(tree.body);\n        this.withBlockCounter_--;\n      },\n      get inWithBlock() {\n        return this.withBlockCounter_ > 0;\n      },\n      visitLoop_: function(tree, func) {\n        if (tree.initializer.type !== VARIABLE_DECLARATION_LIST || tree.initializer.declarationType === VAR) {\n          func();\n          return;\n        }\n        var scope = this.pushScope(tree);\n        func();\n        this.popScope(scope);\n      },\n      visitForInStatement: function(tree) {\n        var $__1 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__1, ScopeVisitor.prototype, "visitForInStatement").call($__1, tree);\n        });\n      },\n      visitForOfStatement: function(tree) {\n        var $__1 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__1, ScopeVisitor.prototype, "visitForOfStatement").call($__1, tree);\n        });\n      },\n      visitForStatement: function(tree) {\n        var $__1 = this;\n        if (!tree.initializer) {\n          $traceurRuntime.superGet(this, ScopeVisitor.prototype, "visitForStatement").call(this, tree);\n        } else {\n          this.visitLoop_(tree, function() {\n            return $traceurRuntime.superGet($__1, ScopeVisitor.prototype, "visitForStatement").call($__1, tree);\n          });\n        }\n      },\n      visitComprehension_: function(tree) {\n        var scopes = [];\n        for (var i = 0; i < tree.comprehensionList.length; i++) {\n          var scope = null;\n          if (tree.comprehensionList[i].type === COMPREHENSION_FOR) {\n            scope = this.pushScope(tree.comprehensionList[i]);\n          }\n          scopes.push(scope);\n          this.visitAny(tree.comprehensionList[i]);\n        }\n        this.visitAny(tree.expression);\n        for (var i$__2 = scopes.length - 1; i$__2 >= 0; i$__2--) {\n          if (scopes[i$__2]) {\n            this.popScope(scopes[i$__2]);\n          }\n        }\n      },\n      visitArrayComprehension: function(tree) {\n        this.visitComprehension_(tree);\n      },\n      visitGeneratorComprehension: function(tree) {\n        this.visitComprehension_(tree);\n      },\n      visitPredefinedType: function(tree) {},\n      visitTypeArguments: function(tree) {},\n      visitFunctionType: function(tree) {}\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  return {get ScopeVisitor() {\n      return ScopeVisitor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/ScopeChainBuilder.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/ScopeChainBuilder.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/semantics/ScopeChainBuilder.js")),\n      CONST = $__1.CONST,\n      LET = $__1.LET,\n      VAR = $__1.VAR;\n  var ScopeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ScopeVisitor.js", "traceur@0.0.111/src/semantics/ScopeChainBuilder.js")).ScopeVisitor;\n  var ScopeChainBuilder = function($__super) {\n    function ScopeChainBuilder(reporter) {\n      $traceurRuntime.superConstructor(ScopeChainBuilder).call(this);\n      this.reporter = reporter;\n      this.declarationType_ = null;\n    }\n    return ($traceurRuntime.createClass)(ScopeChainBuilder, {\n      visitCatch: function(tree) {\n        var scope = this.pushScope(tree);\n        this.declarationType_ = LET;\n        this.visitAny(tree.binding);\n        this.visitList(tree.catchBody.statements);\n        this.popScope(scope);\n      },\n      visitImportedBinding: function(tree) {\n        this.declarationType_ = CONST;\n        $traceurRuntime.superGet(this, ScopeChainBuilder.prototype, "visitImportedBinding").call(this, tree);\n      },\n      visitVariableDeclarationList: function(tree) {\n        this.declarationType_ = tree.declarationType;\n        $traceurRuntime.superGet(this, ScopeChainBuilder.prototype, "visitVariableDeclarationList").call(this, tree);\n      },\n      visitBindingIdentifier: function(tree) {\n        this.declareVariable(tree);\n      },\n      visitFunctionExpression: function(tree) {\n        var scope = this.pushScope(tree);\n        if (tree.name) {\n          this.declarationType_ = CONST;\n          this.visitAny(tree.name);\n        }\n        this.visitAny(tree.parameterList);\n        scope.inGenerator = tree.isGenerator();\n        this.visitAny(tree.body);\n        this.popScope(scope);\n      },\n      visitFormalParameter: function(tree) {\n        this.declarationType_ = VAR;\n        $traceurRuntime.superGet(this, ScopeChainBuilder.prototype, "visitFormalParameter").call(this, tree);\n      },\n      visitFunctionDeclaration: function(tree) {\n        if (this.scope) {\n          if (this.scope.isVarScope) {\n            this.declarationType_ = VAR;\n            this.visitAny(tree.name);\n          } else {\n            if (!this.scope.strictMode) {\n              var varScope = this.scope.getVarScope();\n              if (varScope) {\n                varScope.addVar(tree.name, this.reporter);\n              }\n            }\n            this.declarationType_ = LET;\n            this.visitAny(tree.name);\n          }\n        }\n        this.visitFunctionBodyForScope(tree, tree.parameterList, tree.body);\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitAny(tree.superClass);\n        this.declarationType_ = LET;\n        this.visitAny(tree.name);\n        var scope = this.pushScope(tree);\n        this.declarationType_ = CONST;\n        this.visitAny(tree.name);\n        this.visitList(tree.elements);\n        this.popScope(scope);\n      },\n      visitClassExpression: function(tree) {\n        this.visitAny(tree.superClass);\n        var scope;\n        if (tree.name) {\n          scope = this.pushScope(tree);\n          this.declarationType_ = CONST;\n          this.visitAny(tree.name);\n        }\n        this.visitList(tree.elements);\n        if (tree.name) {\n          this.popScope(scope);\n        }\n      },\n      visitComprehensionFor: function(tree) {\n        this.declarationType_ = LET;\n        $traceurRuntime.superGet(this, ScopeChainBuilder.prototype, "visitComprehensionFor").call(this, tree);\n      },\n      declareVariable: function(tree) {\n        this.scope.addBinding(tree, this.declarationType_, this.reporter);\n      }\n    }, {}, $__super);\n  }(ScopeVisitor);\n  return {get ScopeChainBuilder() {\n      return ScopeChainBuilder;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/VariableBinder.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/VariableBinder.js";\n  var ScopeChainBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ScopeChainBuilder.js", "traceur@0.0.111/src/semantics/VariableBinder.js")).ScopeChainBuilder;\n  function variablesInBlock(tree) {\n    var includeFunctionScope = arguments[1];\n    var builder = new ScopeChainBuilder(null);\n    builder.visitAny(tree);\n    var scope = builder.getScopeForTree(tree);\n    var names = scope.getLexicalBindingNames();\n    if (!includeFunctionScope) {\n      return names;\n    }\n    var variableBindingNames = scope.getVariableBindingNames();\n    variableBindingNames.forEach(function(name) {\n      return names.add(name);\n    });\n    return names;\n  }\n  function variablesInFunction(tree) {\n    var builder = new ScopeChainBuilder(null);\n    builder.visitAny(tree);\n    var scope = builder.getScopeForTree(tree);\n    return scope.getAllBindingNames();\n  }\n  return {\n    get variablesInBlock() {\n      return variablesInBlock;\n    },\n    get variablesInFunction() {\n      return variablesInFunction;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ScopeTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ScopeTransformer.js";\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/ScopeTransformer.js")),\n      ARGUMENTS = $__4.ARGUMENTS,\n      THIS = $__4.THIS;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindInFunctionScope.js", "traceur@0.0.111/src/codegeneration/ScopeTransformer.js")).FindInFunctionScope;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/ScopeTransformer.js")).ParseTreeTransformer;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ScopeTransformer.js")),\n      FunctionDeclaration = $__7.FunctionDeclaration,\n      FunctionExpression = $__7.FunctionExpression,\n      GetAccessor = $__7.GetAccessor,\n      Method = $__7.Method,\n      SetAccessor = $__7.SetAccessor;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringSet.js", "traceur@0.0.111/src/codegeneration/ScopeTransformer.js")).StringSet;\n  var VARIABLE_DECLARATION_LIST = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ScopeTransformer.js")).VARIABLE_DECLARATION_LIST;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/ScopeTransformer.js")).VAR;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../semantics/VariableBinder.js", "traceur@0.0.111/src/codegeneration/ScopeTransformer.js")),\n      variablesInBlock = $__11.variablesInBlock,\n      variablesInFunction = $__11.variablesInFunction;\n  var FindNames = function($__super) {\n    function FindNames(names) {\n      $traceurRuntime.superConstructor(FindNames).call(this);\n      this.names = names;\n    }\n    return ($traceurRuntime.createClass)(FindNames, {visitBindingIdentifier: function(tree) {\n        this.names.add(tree.getStringValue());\n      }}, {}, $__super);\n  }(FindInFunctionScope);\n  function getLexicalBindingNames(tree) {\n    var names = new StringSet();\n    if (tree !== null && tree.type === VARIABLE_DECLARATION_LIST && tree.declarationType !== VAR) {\n      var visitor = new FindNames(names);\n      for (var i = 0; i < tree.declarations.length; i++) {\n        visitor.visitAny(tree.declarations[i].lvalue);\n      }\n    }\n    return names;\n  }\n  var ScopeTransformer = function($__super) {\n    function ScopeTransformer(varName) {\n      $traceurRuntime.superConstructor(ScopeTransformer).call(this);\n      this.varName_ = varName;\n    }\n    return ($traceurRuntime.createClass)(ScopeTransformer, {\n      transformBlock: function(tree) {\n        if (variablesInBlock(tree).has(this.varName_)) {\n          return tree;\n        }\n        return $traceurRuntime.superGet(this, ScopeTransformer.prototype, "transformBlock").call(this, tree);\n      },\n      sameTreeIfNameInLoopInitializer_: function(tree) {\n        var names = getLexicalBindingNames(tree.initializer);\n        if (names.has(this.varName_)) {\n          return tree;\n        }\n        return null;\n      },\n      transformForStatement: function(tree) {\n        return this.sameTreeIfNameInLoopInitializer_(tree) || $traceurRuntime.superGet(this, ScopeTransformer.prototype, "transformForStatement").call(this, tree);\n      },\n      transformForInStatement: function(tree) {\n        return this.sameTreeIfNameInLoopInitializer_(tree) || $traceurRuntime.superGet(this, ScopeTransformer.prototype, "transformForInStatement").call(this, tree);\n      },\n      transformForOfStatement: function(tree) {\n        return this.sameTreeIfNameInLoopInitializer_(tree) || $traceurRuntime.superGet(this, ScopeTransformer.prototype, "transformForOfStatement").call(this, tree);\n      },\n      transformForOnStatement: function(tree) {\n        return this.sameTreeIfNameInLoopInitializer_(tree) || $traceurRuntime.superGet(this, ScopeTransformer.prototype, "transformForOnStatement").call(this, tree);\n      },\n      transformThisExpression: function(tree) {\n        if (this.varName_ !== THIS)\n          return tree;\n        return $traceurRuntime.superGet(this, ScopeTransformer.prototype, "transformThisExpression").call(this, tree);\n      },\n      transformParameterListAndBody_: function(tree) {\n        if (this.getDoNotRecurse(tree))\n          return tree;\n        return {\n          parameterList: this.transformAny(tree.parameterList),\n          body: this.transformAny(tree.body)\n        };\n      },\n      transformFunctionDeclaration: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var $__3 = this.transformParameterListAndBody_(tree),\n            parameterList = $__3.parameterList,\n            body = $__3.body;\n        if (name === tree.name && parameterList === tree.parameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new FunctionDeclaration(tree.location, name, tree.functionKind, parameterList, typeAnnotation, annotations, body);\n      },\n      transformFunctionExpression: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var $__3 = this.transformParameterListAndBody_(tree),\n            parameterList = $__3.parameterList,\n            body = $__3.body;\n        if (name === tree.name && parameterList === tree.parameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new FunctionExpression(tree.location, name, tree.functionKind, parameterList, typeAnnotation, annotations, body);\n      },\n      transformMethod: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var $__3 = this.transformParameterListAndBody_(tree),\n            parameterList = $__3.parameterList,\n            body = $__3.body;\n        if (name === tree.name && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && parameterList === tree.parameterList && body === tree.body) {\n          return tree;\n        }\n        return new Method(tree.location, tree.isStatic, tree.functionKind, name, parameterList, typeAnnotation, annotations, body, tree.debugName);\n      },\n      transformGetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.getDoNotRecurse(tree) ? tree.body : this.transformAny(tree.body);\n        if (name === tree.name && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new GetAccessor(tree.location, tree.isStatic, name, typeAnnotation, annotations, body);\n      },\n      transformSetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var annotations = this.transformList(tree.annotations);\n        var $__3 = this.transformParameterListAndBody_(tree),\n            parameterList = $__3.parameterList,\n            body = $__3.body;\n        if (name === tree.name && annotations === tree.annotations && parameterList === tree.parameterList && body === tree.body) {\n          return tree;\n        }\n        return new SetAccessor(tree.location, tree.isStatic, name, parameterList, annotations, body);\n      },\n      getDoNotRecurse: function(tree) {\n        return this.varName_ === ARGUMENTS || this.varName_ === THIS || variablesInFunction(tree).has(this.varName_);\n      },\n      transformCatch: function(tree) {\n        if (!tree.binding.isPattern() && this.varName_ === tree.binding.identifierToken.value) {\n          return tree;\n        }\n        return $traceurRuntime.superGet(this, ScopeTransformer.prototype, "transformCatch").call(this, tree);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get ScopeTransformer() {\n      return ScopeTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/AlphaRenamer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/AlphaRenamer.js";\n  var ScopeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ScopeTransformer.js", "traceur@0.0.111/src/codegeneration/AlphaRenamer.js")).ScopeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/AlphaRenamer.js")),\n      FunctionDeclaration = $__2.FunctionDeclaration,\n      FunctionExpression = $__2.FunctionExpression;\n  var THIS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/AlphaRenamer.js")).THIS;\n  var createIdentifierExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/AlphaRenamer.js")).createIdentifierExpression;\n  var AlphaRenamer = function($__super) {\n    function AlphaRenamer(varName, newName) {\n      $traceurRuntime.superConstructor(AlphaRenamer).call(this, varName);\n      this.newName_ = newName;\n    }\n    return ($traceurRuntime.createClass)(AlphaRenamer, {\n      transformIdentifierExpression: function(tree) {\n        if (this.varName_ === tree.identifierToken.value) {\n          return createIdentifierExpression(this.newName_);\n        } else {\n          return tree;\n        }\n      },\n      transformThisExpression: function(tree) {\n        if (this.varName_ !== THIS)\n          return tree;\n        return createIdentifierExpression(this.newName_);\n      },\n      transformFunctionDeclaration: function(tree) {\n        if (this.varName_ === tree.name) {\n          tree = new FunctionDeclaration(tree.location, this.newName_, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n        }\n        return $traceurRuntime.superGet(this, AlphaRenamer.prototype, "transformFunctionDeclaration").call(this, tree);\n      },\n      transformFunctionExpression: function(tree) {\n        if (this.varName_ === tree.name) {\n          tree = new FunctionExpression(tree.location, this.newName_, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n        }\n        return $traceurRuntime.superGet(this, AlphaRenamer.prototype, "transformFunctionExpression").call(this, tree);\n      }\n    }, {rename: function(tree, varName, newName) {\n        return new AlphaRenamer(varName, newName).transformAny(tree);\n      }}, $__super);\n  }(ScopeTransformer);\n  return {get AlphaRenamer() {\n      return AlphaRenamer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/FindThisOrArguments.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/FindThisOrArguments.js";\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/FindThisOrArguments.js")).ARGUMENTS;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindInFunctionScope.js", "traceur@0.0.111/src/codegeneration/FindThisOrArguments.js")).FindInFunctionScope;\n  var FindThisOrArguments = function($__super) {\n    function FindThisOrArguments() {\n      $traceurRuntime.superConstructor(FindThisOrArguments).call(this);\n      this.foundThis = false;\n      this.foundArguments = false;\n    }\n    return ($traceurRuntime.createClass)(FindThisOrArguments, {\n      visitThisExpression: function(tree) {\n        this.foundThis = true;\n        this.found = this.foundArguments;\n      },\n      visitIdentifierExpression: function(tree) {\n        if (tree.identifierToken.value === ARGUMENTS) {\n          this.foundArguments = true;\n          this.found = this.foundThis;\n        }\n      }\n    }, {}, $__super);\n  }(FindInFunctionScope);\n  return {get FindThisOrArguments() {\n      return FindThisOrArguments;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/alphaRenameThisAndArguments.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/alphaRenameThisAndArguments.js";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/alphaRenameThisAndArguments.js")),\n      ARGUMENTS = $__0.ARGUMENTS,\n      THIS = $__0.THIS;\n  var AlphaRenamer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AlphaRenamer.js", "traceur@0.0.111/src/codegeneration/alphaRenameThisAndArguments.js")).AlphaRenamer;\n  var FindThisOrArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindThisOrArguments.js", "traceur@0.0.111/src/codegeneration/alphaRenameThisAndArguments.js")).FindThisOrArguments;\n  function alphaRenameThisAndArguments(tempVarTransformer, tree) {\n    var finder = new FindThisOrArguments();\n    finder.visitAny(tree);\n    if (finder.foundArguments) {\n      var argumentsTempName = tempVarTransformer.addTempVarForArguments();\n      tree = AlphaRenamer.rename(tree, ARGUMENTS, argumentsTempName);\n    }\n    if (finder.foundThis) {\n      var thisTempName = tempVarTransformer.addTempVarForThis();\n      tree = AlphaRenamer.rename(tree, THIS, thisTempName);\n    }\n    return tree;\n  }\n  return {get default() {\n      return alphaRenameThisAndArguments;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js";\n  var alphaRenameThisAndArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./alphaRenameThisAndArguments.js", "traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js")).default;\n  var FunctionExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js")).FunctionExpression;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js")).TempVarTransformer;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js")),\n      LET = $__4.LET,\n      STAR = $__4.STAR,\n      VAR = $__4.VAR;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js")),\n      COMPREHENSION_FOR = $__5.COMPREHENSION_FOR,\n      COMPREHENSION_IF = $__5.COMPREHENSION_IF;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/Token.js", "traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js")).Token;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js")),\n      createCallExpression = $__7.createCallExpression,\n      createEmptyParameterList = $__7.createEmptyParameterList,\n      createForOfStatement = $__7.createForOfStatement,\n      createFunctionBody = $__7.createFunctionBody,\n      createIfStatement = $__7.createIfStatement,\n      createParenExpression = $__7.createParenExpression,\n      createVariableDeclarationList = $__7.createVariableDeclarationList;\n  var ComprehensionTransformer = function($__super) {\n    function ComprehensionTransformer() {\n      $traceurRuntime.superConstructor(ComprehensionTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ComprehensionTransformer, {transformComprehension: function(tree, statement, isGenerator) {\n        var prefix = arguments[3];\n        var suffix = arguments[4];\n        var bindingKind = isGenerator || !this.options.blockBinding ? VAR : LET;\n        var statements = prefix ? [prefix] : [];\n        for (var i = tree.comprehensionList.length - 1; i >= 0; i--) {\n          var item = tree.comprehensionList[i];\n          switch (item.type) {\n            case COMPREHENSION_IF:\n              {\n                var expression = this.transformAny(item.expression);\n                statement = createIfStatement(expression, statement);\n                break;\n              }\n            case COMPREHENSION_FOR:\n              {\n                var left = this.transformAny(item.left);\n                var iterator = this.transformAny(item.iterator);\n                var initializer = createVariableDeclarationList(bindingKind, left, null);\n                statement = createForOfStatement(initializer, iterator, statement);\n                break;\n              }\n            default:\n              throw new Error(\'Unreachable.\');\n          }\n        }\n        statement = alphaRenameThisAndArguments(this, statement);\n        statements.push(statement);\n        if (suffix)\n          statements.push(suffix);\n        var functionKind = isGenerator ? new Token(STAR, null) : null;\n        var func = new FunctionExpression(null, null, functionKind, createEmptyParameterList(), null, [], createFunctionBody(statements));\n        return createParenExpression(createCallExpression(func));\n      }}, {}, $__super);\n  }(TempVarTransformer);\n  return {get ComprehensionTransformer() {\n      return ComprehensionTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ArrayComprehensionTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ArrayComprehensionTransformer.js";\n  var ComprehensionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ComprehensionTransformer.js", "traceur@0.0.111/src/codegeneration/ArrayComprehensionTransformer.js")).ComprehensionTransformer;\n  var createIdentifierExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ArrayComprehensionTransformer.js")).createIdentifierExpression;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/ArrayComprehensionTransformer.js")).parseStatement;\n  var ArrayComprehensionTransformer = function($__super) {\n    function ArrayComprehensionTransformer() {\n      $traceurRuntime.superConstructor(ArrayComprehensionTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ArrayComprehensionTransformer, {transformArrayComprehension: function(tree) {\n        this.pushTempScope();\n        var expression = this.transformAny(tree.expression);\n        var index = createIdentifierExpression(this.getTempIdentifier());\n        var result = createIdentifierExpression(this.getTempIdentifier());\n        var tempVarsStatatement = parseStatement($traceurRuntime.getTemplateObject(["var ", " = 0, ", " = [];"]), index, result);\n        var statement = parseStatement($traceurRuntime.getTemplateObject(["", "[", "++] = ", ";"]), result, index, expression);\n        var returnStatement = parseStatement($traceurRuntime.getTemplateObject(["return ", ";"]), result);\n        var functionKind = null;\n        result = this.transformComprehension(tree, statement, functionKind, tempVarsStatatement, returnStatement);\n        this.popTempScope();\n        return result;\n      }}, {}, $__super);\n  }(ComprehensionTransformer);\n  return {get ArrayComprehensionTransformer() {\n      return ArrayComprehensionTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ParenTrait.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ParenTrait.js";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ParenTrait.js")),\n      ArgumentList = $__2.ArgumentList,\n      ArrayLiteral = $__2.ArrayLiteral,\n      BinaryExpression = $__2.BinaryExpression,\n      ConditionalExpression = $__2.ConditionalExpression,\n      ExpressionStatement = $__2.ExpressionStatement,\n      NewExpression = $__2.NewExpression,\n      ParenExpression = $__2.ParenExpression,\n      PropertyNameAssignment = $__2.PropertyNameAssignment,\n      VariableDeclaration = $__2.VariableDeclaration;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ParenTrait.js")),\n      CALL_EXPRESSION = $__3.CALL_EXPRESSION,\n      COMMA_EXPRESSION = $__3.COMMA_EXPRESSION,\n      FUNCTION_EXPRESSION = $__3.FUNCTION_EXPRESSION,\n      OBJECT_LITERAL = $__3.OBJECT_LITERAL,\n      OBJECT_PATTERN = $__3.OBJECT_PATTERN,\n      TEMPLATE_LITERAL_EXPRESSION = $__3.TEMPLATE_LITERAL_EXPRESSION,\n      YIELD_EXPRESSION = $__3.YIELD_EXPRESSION;\n  function wrap(tree) {\n    return new ParenExpression(tree.location, tree);\n  }\n  function ParenTrait(ParseTreeTransformerClass) {\n    return function($__super) {\n      function $__0() {\n        $traceurRuntime.superConstructor($__0).apply(this, arguments);\n      }\n      return ($traceurRuntime.createClass)($__0, {\n        transformVariableDeclaration: function(tree) {\n          var lvalue = this.transformAny(tree.lvalue);\n          var typeAnnotation = this.transformAny(tree.typeAnnotation);\n          var initializer = this.transformAny(tree.initializer);\n          if (initializer !== null && initializer.type === COMMA_EXPRESSION) {\n            initializer = wrap(initializer);\n          } else if (tree.lvalue === lvalue && tree.typeAnnotation === typeAnnotation && tree.initializer === initializer) {\n            return tree;\n          }\n          return new VariableDeclaration(tree.location, lvalue, typeAnnotation, initializer);\n        },\n        transformExpressionStatement: function(tree) {\n          var expression = this.transformAny(tree.expression);\n          switch (expression.type) {\n            case OBJECT_LITERAL:\n            case OBJECT_PATTERN:\n            case FUNCTION_EXPRESSION:\n              expression = wrap(expression);\n              break;\n          }\n          if (tree.expression === expression) {\n            return tree;\n          }\n          return new ExpressionStatement(tree.location, expression);\n        },\n        transformNewExpression: function(tree) {\n          var operand = this.transformAny(tree.operand);\n          var args = this.transformAny(tree.args);\n          switch (operand.type) {\n            case CALL_EXPRESSION:\n            case TEMPLATE_LITERAL_EXPRESSION:\n              operand = wrap(operand);\n          }\n          if (operand === tree.operand && args === tree.args) {\n            return tree;\n          }\n          return new NewExpression(tree.location, operand, args);\n        },\n        transformExpressionList_: function(list) {\n          var expressions = this.transformList(list);\n          var newList = null;\n          for (var i = 0; i < list.length; i++) {\n            var expression = expressions[i];\n            if (expression !== null && expression.type === COMMA_EXPRESSION) {\n              expression = wrap(expression);\n              if (newList === null) {\n                newList = expressions.slice(0, i);\n              }\n              newList.push(expression);\n            } else if (newList !== null) {\n              newList.push(expression);\n            }\n          }\n          if (newList !== null) {\n            return newList;\n          }\n          return expressions;\n        },\n        transformArgumentList: function(tree) {\n          var args = this.transformExpressionList_(tree.args);\n          if (tree.args === args) {\n            return tree;\n          }\n          return new ArgumentList(tree.location, args);\n        },\n        transformArrayLiteral: function(tree) {\n          var elements = this.transformExpressionList_(tree.elements);\n          if (tree.elements === elements) {\n            return tree;\n          }\n          return new ArrayLiteral(tree.location, elements);\n        },\n        transformPropertyNameAssignment: function(tree) {\n          var name = this.transformAny(tree.name);\n          var value = this.transformAny(tree.value);\n          if (value.type === COMMA_EXPRESSION) {\n            value = wrap(value);\n          } else if (name === tree.name && value === tree.value) {\n            return tree;\n          }\n          return new PropertyNameAssignment(tree.location, name, value);\n        },\n        transformBinaryExpression: function(tree) {\n          var left = this.transformAny(tree.left);\n          var right = this.transformAny(tree.right);\n          if (commaOrYield(left.type)) {\n            left = wrap(left);\n          }\n          if (commaOrYield(right.type)) {\n            right = wrap(right);\n          }\n          if (left === tree.left && right === tree.right) {\n            return tree;\n          }\n          return new BinaryExpression(tree.location, left, tree.operator, right);\n        },\n        transformConditionalExpression: function(tree) {\n          var condition = this.transformAny(tree.condition);\n          var left = this.transformAny(tree.left);\n          var right = this.transformAny(tree.right);\n          if (commaOrYield(condition.type)) {\n            condition = wrap(condition);\n          }\n          if (left.type == COMMA_EXPRESSION) {\n            left = wrap(left);\n          }\n          if (right.type == COMMA_EXPRESSION) {\n            right = wrap(right);\n          }\n          if (condition === tree.condition && left === tree.left && right === tree.right) {\n            return tree;\n          }\n          return new ConditionalExpression(tree.location, condition, left, right);\n        }\n      }, {}, $__super);\n    }(ParseTreeTransformerClass);\n  }\n  function commaOrYield(type) {\n    return type === COMMA_EXPRESSION || type == YIELD_EXPRESSION;\n  }\n  return {get ParenTrait() {\n      return ParenTrait;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js")),\n      ARGUMENTS = $__1.ARGUMENTS,\n      CONSTRUCTOR = $__1.CONSTRUCTOR,\n      THIS = $__1.THIS;\n  var AlphaRenamer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AlphaRenamer.js", "traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js")).AlphaRenamer;\n  var FunctionExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js")).FunctionExpression;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js")).TempVarTransformer;\n  var ParenTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParenTrait.js", "traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js")).ParenTrait;\n  var alphaRenameThisAndArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./alphaRenameThisAndArguments.js", "traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js")).default;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js")),\n      FUNCTION_BODY = $__7.FUNCTION_BODY,\n      LITERAL_PROPERTY_NAME = $__7.LITERAL_PROPERTY_NAME;\n  var FindThisOrArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindThisOrArguments.js", "traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js")).FindThisOrArguments;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js")),\n      createAssignmentExpression = $__9.createAssignmentExpression,\n      createCommaExpression = $__9.createCommaExpression,\n      createFunctionBody = $__9.createFunctionBody,\n      createIdentifierExpression = $__9.createIdentifierExpression,\n      createReturnStatement = $__9.createReturnStatement,\n      createThisExpression = $__9.createThisExpression;\n  function convertConciseBody(tree) {\n    if (tree.type !== FUNCTION_BODY)\n      return createFunctionBody([createReturnStatement(tree)]);\n    return tree;\n  }\n  var ArrowFunctionTransformer = function($__super) {\n    function ArrowFunctionTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(ArrowFunctionTransformer).call(this, identifierGenerator, reporter, options);\n      this.inDerivedClass_ = false;\n      this.inConstructor_ = false;\n    }\n    return ($traceurRuntime.createClass)(ArrowFunctionTransformer, {\n      transformArrowFunction: function(tree) {\n        if (this.inDerivedClass_ && this.inConstructor_) {\n          return this.transformUsingCommaExpression_(tree);\n        }\n        return this.transformUsingTempVar_(tree);\n      },\n      transformUsingCommaExpression_: function(tree) {\n        var finder = new FindThisOrArguments();\n        var argumentsTempName,\n            thisTempName;\n        finder.visitAny(tree);\n        if (finder.foundArguments) {\n          argumentsTempName = this.addTempVar();\n          tree = AlphaRenamer.rename(tree, ARGUMENTS, argumentsTempName);\n        }\n        if (finder.foundThis) {\n          thisTempName = this.addTempVar();\n          tree = AlphaRenamer.rename(tree, THIS, thisTempName);\n        }\n        var parameterList = this.transformAny(tree.parameterList);\n        var body = this.transformAny(tree.body);\n        body = convertConciseBody(body);\n        var functionExpression = new FunctionExpression(tree.location, null, tree.functionKind, parameterList, null, [], body);\n        var expressions = [];\n        if (argumentsTempName) {\n          expressions.push(createAssignmentExpression(createIdentifierExpression(argumentsTempName), createIdentifierExpression(ARGUMENTS)));\n        }\n        if (thisTempName) {\n          expressions.push(createAssignmentExpression(createIdentifierExpression(thisTempName), createThisExpression()));\n        }\n        if (expressions.length === 0) {\n          return functionExpression;\n        }\n        expressions.push(functionExpression);\n        return createCommaExpression(expressions);\n      },\n      transformUsingTempVar_: function(tree) {\n        var alphaRenamed = alphaRenameThisAndArguments(this, tree);\n        var parameterList = this.transformAny(alphaRenamed.parameterList);\n        var body = this.transformAny(alphaRenamed.body);\n        body = convertConciseBody(body);\n        var functionExpression = new FunctionExpression(tree.location, null, tree.functionKind, parameterList, null, [], body);\n        return functionExpression;\n      },\n      transformClassExpression: function(tree) {\n        var inDerivedClass = this.inDerivedClass_;\n        this.inDerivedClass_ = tree.superClass !== null;\n        var result = $traceurRuntime.superGet(this, ArrowFunctionTransformer.prototype, "transformClassExpression").call(this, tree);\n        this.inDerivedClass_ = inDerivedClass;\n        return result;\n      },\n      transformClassDeclaration: function(tree) {\n        var inDerivedClass = this.inDerivedClass_;\n        this.inDerivedClass_ = tree.superClass !== null;\n        var result = $traceurRuntime.superGet(this, ArrowFunctionTransformer.prototype, "transformClassDeclaration").call(this, tree);\n        this.inDerivedClass_ = inDerivedClass;\n        return result;\n      },\n      transformMethod: function(tree) {\n        var inConstructor = this.inConstructor_;\n        this.inConstructor_ = !tree.isStatic && tree.functionKind === null && tree.name.type === LITERAL_PROPERTY_NAME && tree.name.literalToken.value === CONSTRUCTOR;\n        var result = $traceurRuntime.superGet(this, ArrowFunctionTransformer.prototype, "transformMethod").call(this, tree);\n        this.inConstructor_ = inConstructor;\n        return result;\n      }\n    }, {transform: function(tempVarTransformer, tree) {\n        tree = alphaRenameThisAndArguments(tempVarTransformer, tree);\n        var body = convertConciseBody(tree.body);\n        return new FunctionExpression(tree.location, null, tree.functionKind, tree.parameterList, null, [], body);\n      }}, $__super);\n  }(ParenTrait(TempVarTransformer));\n  return {get ArrowFunctionTransformer() {\n      return ArrowFunctionTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js";\n  var alphaRenameThisAndArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./alphaRenameThisAndArguments.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js")).default;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js")),\n      createArgumentList = $__2.createArgumentList,\n      createBlock = $__2.createBlock,\n      createFunctionBody = $__2.createFunctionBody,\n      id = $__2.createIdentifierExpression,\n      createMemberExpression = $__2.createMemberExpression,\n      createThisExpression = $__2.createThisExpression,\n      createVariableDeclaration = $__2.createVariableDeclaration,\n      createVariableDeclarationList = $__2.createVariableDeclarationList,\n      createVariableStatement = $__2.createVariableStatement;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js")).parseStatement;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js")).default;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js")).TempVarTransformer;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js")),\n      AwaitExpression = $__6.AwaitExpression,\n      Block = $__6.Block,\n      CallExpression = $__6.CallExpression,\n      Catch = $__6.Catch;\n  var SkipFunctionsTransformerTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SkipFunctionsTransformerTrait.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js")).default;\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js")).ARGUMENTS;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js")).VAR;\n  var AsyncGeneratorTransformer = function($__super) {\n    function AsyncGeneratorTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(AsyncGeneratorTransformer).call(this, identifierGenerator, reporter, options);\n      this.variableDeclarations_ = [];\n      this.ctx_ = id(this.getTempIdentifier());\n    }\n    return ($traceurRuntime.createClass)(AsyncGeneratorTransformer, {\n      transformYieldExpression: function(tree) {\n        var argList = createArgumentList([tree.expression]);\n        if (tree.isYieldFor) {\n          return new AwaitExpression(tree.location, new CallExpression(null, createMemberExpression(this.ctx_, \'yieldFor\'), argList));\n        }\n        return new CallExpression(tree.location, createMemberExpression(this.ctx_, \'yield\'), argList);\n      },\n      transformCatch: function(tree) {\n        var body = tree.catchBody;\n        body = new Block(body.location, $traceurRuntime.spread([parseStatement($traceurRuntime.getTemplateObject(["\\n        if (", ".inReturn) {\\n          throw undefined;\\n        }"]), this.ctx_)], body.statements));\n        return new Catch(tree.location, tree.binding, body);\n      },\n      transformAsyncGeneratorBody_: function(tree, name) {\n        tree = this.transformAny(tree);\n        tree = alphaRenameThisAndArguments(this, tree);\n        var statements = [];\n        if (this.variableDeclarations_.length > 0) {\n          statements.push(createVariableStatement(createVariableDeclarationList(VAR, this.variableDeclarations_)));\n        }\n        var body = createBlock(tree.statements);\n        var createAsyncGeneratorInstance = this.getRuntimeExpression(\'createAsyncGeneratorInstance\');\n        statements.push(parseStatement($traceurRuntime.getTemplateObject(["\\n        return ", "(\\n            async function (", ") {\\n                ", "\\n            }, ", ");"]), createAsyncGeneratorInstance, this.ctx_, body, name));\n        return createFunctionBody(statements);\n      },\n      addTempVarForArguments: function() {\n        var tmpVarName = this.getTempIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, id(ARGUMENTS)));\n        return tmpVarName;\n      },\n      addTempVarForThis: function() {\n        var tmpVarName = this.getTempIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, createThisExpression()));\n        return tmpVarName;\n      }\n    }, {transformAsyncGeneratorBody: function(identifierGenerator, reporter, options, body, name) {\n        return new AsyncGeneratorTransformer(identifierGenerator, reporter, options).transformAsyncGeneratorBody_(body, name);\n      }}, $__super);\n  }(SkipFunctionsTransformerTrait(ImportRuntimeTrait(TempVarTransformer)));\n  return {get AsyncGeneratorTransformer() {\n      return AsyncGeneratorTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js";\n  var AsyncGeneratorTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AsyncGeneratorTransformer.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js")).AsyncGeneratorTransformer;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js")).TempVarTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js")),\n      AnonBlock = $__3.AnonBlock,\n      FunctionDeclaration = $__3.FunctionDeclaration,\n      FunctionExpression = $__3.FunctionExpression;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js")).default;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js")),\n      createBindingIdentifier = $__5.createBindingIdentifier,\n      id = $__5.createIdentifierExpression,\n      createIdentifierToken = $__5.createIdentifierToken;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js")),\n      parseExpression = $__6.parseExpression,\n      parseStatement = $__6.parseStatement;\n  var AsyncGeneratorTransformPass = function($__super) {\n    function AsyncGeneratorTransformPass(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(AsyncGeneratorTransformPass).call(this, identifierGenerator, reporter, options);\n      this.transformOptions_ = options.transformOptions;\n      this.inBlock_ = false;\n    }\n    return ($traceurRuntime.createClass)(AsyncGeneratorTransformPass, {\n      needsTransform_: function(tree) {\n        return this.transformOptions_.asyncGenerators && tree.isAsyncGenerator();\n      },\n      transformFunctionDeclaration: function(tree) {\n        if (!this.needsTransform_(tree))\n          return $traceurRuntime.superGet(this, AsyncGeneratorTransformPass.prototype, "transformFunctionDeclaration").call(this, tree);\n        var nameIdExpression = id(tree.name.identifierToken);\n        var initAsyncGeneratorFunction = this.getRuntimeExpression(\'initAsyncGeneratorFunction\');\n        var setupPrototypeExpression = parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), initAsyncGeneratorFunction, nameIdExpression);\n        var tmpVar = id(this.inBlock_ ? this.getTempIdentifier() : this.addTempVar(setupPrototypeExpression));\n        var funcDecl = this.transformFunction_(tree, FunctionDeclaration, tmpVar);\n        if (!this.inBlock_)\n          return funcDecl;\n        return new AnonBlock(null, [funcDecl, parseStatement($traceurRuntime.getTemplateObject(["var ", " = ", ""]), tmpVar, setupPrototypeExpression)]);\n      },\n      transformFunctionExpression: function(tree) {\n        if (!this.needsTransform_(tree)) {\n          return $traceurRuntime.superGet(this, AsyncGeneratorTransformPass.prototype, "transformFunctionExpression").call(this, tree);\n        }\n        var name;\n        if (!tree.name) {\n          name = createIdentifierToken(this.getTempIdentifier());\n          tree = new FunctionExpression(tree.location, createBindingIdentifier(name), tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n        } else {\n          name = tree.name.identifierToken;\n        }\n        var functionExpression = this.transformFunction_(tree, FunctionExpression, id(name));\n        var initAsyncGeneratorFunction = this.getRuntimeExpression(\'initAsyncGeneratorFunction\');\n        return parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), initAsyncGeneratorFunction, functionExpression);\n      },\n      transformFunction_: function(tree, constructor, nameExpression) {\n        var body = $traceurRuntime.superGet(this, AsyncGeneratorTransformPass.prototype, "transformAny").call(this, tree.body);\n        body = AsyncGeneratorTransformer.transformAsyncGeneratorBody(this.identifierGenerator, this.reporter, this.options, body, nameExpression);\n        var functionKind = null;\n        return new constructor(tree.location, tree.name, functionKind, tree.parameterList, tree.typeAnnotation || null, tree.annotations || null, body);\n      },\n      transformBlock: function(tree) {\n        var inBlock = this.inBlock_;\n        this.inBlock_ = true;\n        var rv = $traceurRuntime.superGet(this, AsyncGeneratorTransformPass.prototype, "transformBlock").call(this, tree);\n        this.inBlock_ = inBlock;\n        return rv;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get AsyncGeneratorTransformPass() {\n      return AsyncGeneratorTransformPass;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/FindArguments.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/FindArguments.js";\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/FindArguments.js")).ARGUMENTS;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindInFunctionScope.js", "traceur@0.0.111/src/codegeneration/FindArguments.js")).FindInFunctionScope;\n  var FindArguments = function($__super) {\n    function FindArguments() {\n      $traceurRuntime.superConstructor(FindArguments).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(FindArguments, {visitIdentifierExpression: function(tree) {\n        if (tree.identifierToken.value === ARGUMENTS) {\n          this.found = true;\n        }\n      }}, {}, $__super);\n  }(FindInFunctionScope);\n  return {get default() {\n      return FindArguments;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js";\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js")).ARGUMENTS;\n  var FindArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindArguments.js", "traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js")).default;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js")),\n      FunctionBody = $__3.FunctionBody,\n      FunctionDeclaration = $__3.FunctionDeclaration,\n      FunctionExpression = $__3.FunctionExpression,\n      Method = $__3.Method,\n      YieldExpression = $__3.YieldExpression;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js")).default;\n  var ParenTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParenTrait.js", "traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js")).ParenTrait;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js")).parseStatement;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js")).TempVarTransformer;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js")),\n      createIdentifierExpression = $__8.createIdentifierExpression,\n      createNullLiteral = $__8.createNullLiteral;\n  var AsyncToGeneratorTransformer = function($__super) {\n    function AsyncToGeneratorTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(AsyncToGeneratorTransformer).call(this, identifierGenerator, reporter, options);\n      this.inAsyncFunction_ = false;\n    }\n    return ($traceurRuntime.createClass)(AsyncToGeneratorTransformer, {\n      transformFunctionDeclaration: function(tree) {\n        if (tree.isAsyncFunction()) {\n          return this.transformFunctionShared_(tree, FunctionDeclaration);\n        }\n        return $traceurRuntime.superGet(this, AsyncToGeneratorTransformer.prototype, "transformFunctionDeclaration").call(this, tree);\n      },\n      transformFunctionExpression: function(tree) {\n        if (tree.isAsyncFunction()) {\n          return this.transformFunctionShared_(tree, FunctionExpression);\n        }\n        return $traceurRuntime.superGet(this, AsyncToGeneratorTransformer.prototype, "transformFunctionExpression").call(this, tree);\n      },\n      transformFunctionShared_: function(tree, ctor) {\n        var parameterList = this.transformAny(tree.parameterList);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAsyncBody_(tree.body);\n        return new ctor(tree.location, tree.name, null, parameterList, typeAnnotation, annotations, body);\n      },\n      transformAsyncBody_: function(body) {\n        var inAsyncFunction = this.inAsyncFunction_;\n        this.inAsyncFunction_ = true;\n        body = this.transformFunctionBody(body);\n        var spawn = this.getRuntimeExpression(\'spawn\');\n        body = wrapBodyInSpawn(body, spawn);\n        this.inAsyncFunction_ = inAsyncFunction;\n        return body;\n      },\n      transformMethod: function(tree) {\n        if (tree.isAsyncFunction()) {\n          var name = this.transformAny(tree.name);\n          var parameterList = this.transformAny(tree.parameterList);\n          var typeAnnotation = this.transformAny(tree.typeAnnotation);\n          var annotations = this.transformList(tree.annotations);\n          var body = this.transformAsyncBody_(tree.body);\n          return new Method(tree.location, tree.isStatic, null, name, parameterList, typeAnnotation, annotations, body, tree.debugName);\n        }\n        return $traceurRuntime.superGet(this, AsyncToGeneratorTransformer.prototype, "transformMethod").call(this, tree);\n      },\n      transformAwaitExpression: function(tree) {\n        if (this.inAsyncFunction_) {\n          var expression = this.transformAny(tree.expression);\n          return new YieldExpression(tree.location, expression, false);\n        }\n        return $traceurRuntime.superGet(this, AsyncToGeneratorTransformer.prototype, "transformAwaitExpression").call(this, tree);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(ParenTrait(TempVarTransformer)));\n  function wrapBodyInSpawn(body, spawn) {\n    var visitor = new FindArguments();\n    visitor.visitAny(body);\n    var argExpr = visitor.found ? createIdentifierExpression(ARGUMENTS) : createNullLiteral();\n    var statement = parseStatement($traceurRuntime.getTemplateObject(["return ", "(this, ", ", function*() { ", " });"]), spawn, argExpr, body);\n    return new FunctionBody(body.location, [statement]);\n  }\n  return {get AsyncToGeneratorTransformer() {\n      return AsyncToGeneratorTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/FindIdentifiers.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/FindIdentifiers.js";\n  var ScopeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../semantics/ScopeVisitor.js", "traceur@0.0.111/src/codegeneration/FindIdentifiers.js")).ScopeVisitor;\n  var FindIdentifiers = function($__super) {\n    function FindIdentifiers(tree, filterFunction) {\n      $traceurRuntime.superConstructor(FindIdentifiers).call(this);\n      this.filterFunction_ = filterFunction;\n      this.found_ = false;\n      this.visitAny(tree);\n    }\n    return ($traceurRuntime.createClass)(FindIdentifiers, {\n      visitIdentifierExpression: function(tree) {\n        if (this.filterFunction_(tree.identifierToken.value, this.scope.tree)) {\n          this.found = true;\n        }\n      },\n      get found() {\n        return this.found_;\n      },\n      set found(v) {\n        if (v) {\n          this.found_ = true;\n        }\n      },\n      visitAny: function(tree) {\n        !this.found_ && tree && tree.visit(this);\n      },\n      visitList: function(list) {\n        if (list) {\n          for (var i = 0; !this.found_ && i < list.length; i++) {\n            this.visitAny(list[i]);\n          }\n        }\n      }\n    }, {}, $__super);\n  }(ScopeVisitor);\n  return {get FindIdentifiers() {\n      return FindIdentifiers;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js")).ParseTreeTransformer;\n  var alphaRenameThisAndArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./alphaRenameThisAndArguments.js", "traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js")).default;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js")).parseStatement;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js")),\n      AnonBlock = $__6.AnonBlock,\n      BreakStatement = $__6.BreakStatement,\n      ContinueStatement = $__6.ContinueStatement,\n      FormalParameterList = $__6.FormalParameterList,\n      FunctionExpression = $__6.FunctionExpression,\n      ReturnStatement = $__6.ReturnStatement,\n      YieldExpression = $__6.YieldExpression;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js")),\n      createArgumentList = $__7.createArgumentList,\n      createAssignmentStatement = $__7.createAssignmentStatement,\n      createAssignmentExpression = $__7.createAssignmentExpression,\n      createBlock = $__7.createBlock,\n      createCallExpression = $__7.createCallExpression,\n      createCaseClause = $__7.createCaseClause,\n      createDefaultClause = $__7.createDefaultClause,\n      createExpressionStatement = $__7.createExpressionStatement,\n      createFunctionBody = $__7.createFunctionBody,\n      createFunctionExpression = $__7.createFunctionExpression,\n      createIdentifierExpression = $__7.createIdentifierExpression,\n      createNumberLiteral = $__7.createNumberLiteral,\n      createObjectLiteralForDescriptor = $__7.createObjectLiteralForDescriptor,\n      createSwitchStatement = $__7.createSwitchStatement,\n      createThisExpression = $__7.createThisExpression,\n      createVariableDeclaration = $__7.createVariableDeclaration,\n      createVariableDeclarationList = $__7.createVariableDeclarationList,\n      createVariableStatement = $__7.createVariableStatement,\n      createVoid0 = $__7.createVoid0;\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js")).ARGUMENTS;\n  var SkipFunctionsTransformerTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SkipFunctionsTransformerTrait.js", "traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js")).default;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringSet.js", "traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js")).StringSet;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/Token.js", "traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js")).Token;\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js")),\n      STAR = $__12.STAR,\n      VAR = $__12.VAR;\n  var FnExtractAbruptCompletions = function($__super) {\n    function FnExtractAbruptCompletions(idGenerator, requestParentLabel) {\n      $traceurRuntime.superConstructor(FnExtractAbruptCompletions).call(this);\n      this.idGenerator_ = idGenerator;\n      this.inLoop_ = 0;\n      this.inBreakble_ = 0;\n      this.variableDeclarations_ = [];\n      this.extractedStatements_ = [];\n      this.requestParentLabel_ = requestParentLabel;\n      this.labelledStatements_ = new StringSet();\n    }\n    return ($traceurRuntime.createClass)(FnExtractAbruptCompletions, {\n      createIIFE: function(body, paramList, argsList, inGenerator) {\n        body = this.transformAny(body);\n        body = alphaRenameThisAndArguments(this, body);\n        var tmpFnName = this.idGenerator_.generateUniqueIdentifier();\n        var functionKind = inGenerator ? new Token(STAR, null) : null;\n        var functionExpression = new FunctionExpression(null, null, functionKind, new FormalParameterList(null, paramList), null, [], createFunctionBody(body.statements || [body]));\n        this.variableDeclarations_.push(createVariableDeclaration(tmpFnName, functionExpression));\n        var functionCall = createCallExpression(createIdentifierExpression(tmpFnName), createArgumentList(argsList));\n        if (inGenerator) {\n          functionCall = new YieldExpression(null, functionCall, true);\n        }\n        var loopBody = null;\n        if (this.extractedStatements_.length || this.hasReturns) {\n          var tmpVarName = createIdentifierExpression(this.idGenerator_.generateUniqueIdentifier());\n          this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, null));\n          var maybeReturn;\n          if (this.hasReturns) {\n            maybeReturn = parseStatement($traceurRuntime.getTemplateObject(["if (typeof ", " === \\"object\\")\\n            return ", ".v;"]), tmpVarName, tmpVarName);\n          }\n          if (this.extractedStatements_.length) {\n            var caseClauses = this.extractedStatements_.map(function(statement, index) {\n              return createCaseClause(createNumberLiteral(index), [statement]);\n            });\n            if (maybeReturn) {\n              caseClauses.push(createDefaultClause([maybeReturn]));\n            }\n            loopBody = createBlock([createExpressionStatement(createAssignmentExpression(tmpVarName, functionCall)), createSwitchStatement(tmpVarName, caseClauses)]);\n          } else {\n            loopBody = createBlock([createExpressionStatement(createAssignmentExpression(tmpVarName, functionCall)), maybeReturn]);\n          }\n        } else {\n          loopBody = createBlock([createExpressionStatement(functionCall)]);\n        }\n        return {\n          variableStatements: createVariableStatement(createVariableDeclarationList(VAR, this.variableDeclarations_)),\n          loopBody: loopBody\n        };\n      },\n      addTempVarForArguments: function() {\n        var tmpVarName = this.idGenerator_.generateUniqueIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, createIdentifierExpression(ARGUMENTS)));\n        return tmpVarName;\n      },\n      addTempVarForThis: function() {\n        var tmpVarName = this.idGenerator_.generateUniqueIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, createThisExpression()));\n        return tmpVarName;\n      },\n      transformAny: function(tree) {\n        if (tree) {\n          if (tree.isBreakableStatement())\n            this.inBreakble_++;\n          if (tree.isIterationStatement())\n            this.inLoop_++;\n          tree = $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, "transformAny").call(this, tree);\n          if (tree.isBreakableStatement())\n            this.inBreakble_--;\n          if (tree.isIterationStatement())\n            this.inLoop_--;\n        }\n        return tree;\n      },\n      transformReturnStatement: function(tree) {\n        this.hasReturns = true;\n        return new ReturnStatement(tree.location, createObjectLiteralForDescriptor({v: tree.expression || createVoid0()}));\n      },\n      transformAbruptCompletion_: function(tree) {\n        this.extractedStatements_.push(tree);\n        var index = this.extractedStatements_.length - 1;\n        return parseStatement($traceurRuntime.getTemplateObject(["return ", ";"]), index);\n      },\n      transformBreakStatement: function(tree) {\n        if (!tree.name) {\n          if (this.inBreakble_) {\n            return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, "transformBreakStatement").call(this, tree);\n          } else {\n            tree = new BreakStatement(tree.location, this.requestParentLabel_());\n          }\n        } else if (this.labelledStatements_.has(tree.name.value)) {\n          return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, "transformBreakStatement").call(this, tree);\n        }\n        return this.transformAbruptCompletion_(tree);\n      },\n      transformContinueStatement: function(tree) {\n        if (!tree.name) {\n          if (this.inLoop_) {\n            return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, "transformContinueStatement").call(this, tree);\n          } else {\n            tree = new ContinueStatement(tree.location, this.requestParentLabel_());\n          }\n        } else if (this.labelledStatements_.has(tree.name.value)) {\n          return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, "transformContinueStatement").call(this, tree);\n        }\n        return this.transformAbruptCompletion_(tree);\n      },\n      transformLabelledStatement: function(tree) {\n        this.labelledStatements_.add(tree.name.value);\n        return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, "transformLabelledStatement").call(this, tree);\n      },\n      transformVariableStatement: function(tree) {\n        var $__2 = this;\n        if (tree.declarations.declarationType === VAR) {\n          var assignments = [];\n          tree.declarations.declarations.forEach(function(variableDeclaration) {\n            var variableName = variableDeclaration.lvalue.getStringValue();\n            var initializer = $traceurRuntime.superGet($__2, FnExtractAbruptCompletions.prototype, "transformAny").call($__2, variableDeclaration.initializer);\n            $__2.variableDeclarations_.push(createVariableDeclaration(variableName, null));\n            assignments.push(createAssignmentStatement(createIdentifierExpression(variableName), initializer));\n          });\n          return new AnonBlock(null, assignments);\n        }\n        return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, "transformVariableStatement").call(this, tree);\n      }\n    }, {createIIFE: function(idGenerator, body, paramList, argsList, requestParentLabel, inGenerator) {\n        return new FnExtractAbruptCompletions(idGenerator, requestParentLabel).createIIFE(body, paramList, argsList, inGenerator);\n      }}, $__super);\n  }(SkipFunctionsTransformerTrait(ParseTreeTransformer));\n  return {get FnExtractAbruptCompletions() {\n      return FnExtractAbruptCompletions;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/ScopeReferences.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/ScopeReferences.js";\n  var Scope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Scope.js", "traceur@0.0.111/src/semantics/ScopeReferences.js")).Scope;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringSet.js", "traceur@0.0.111/src/semantics/ScopeReferences.js")).StringSet;\n  var ScopeReferences = function($__super) {\n    function ScopeReferences(parent, tree) {\n      $traceurRuntime.superConstructor(ScopeReferences).call(this, parent, tree);\n      this.freeVars_ = new StringSet();\n    }\n    return ($traceurRuntime.createClass)(ScopeReferences, {\n      addReference: function(name) {\n        this.freeVars_.add(name);\n      },\n      hasFreeVariable: function(name) {\n        return this.freeVars_.has(name);\n      }\n    }, {}, $__super);\n  }(Scope);\n  return {get ScopeReferences() {\n      return ScopeReferences;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js";\n  var ScopeChainBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ScopeChainBuilder.js", "traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js")).ScopeChainBuilder;\n  var ScopeReferences = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ScopeReferences.js", "traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js")).ScopeReferences;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js")),\n      FUNCTION_DECLARATION = $__3.FUNCTION_DECLARATION,\n      FUNCTION_EXPRESSION = $__3.FUNCTION_EXPRESSION,\n      GET_ACCESSOR = $__3.GET_ACCESSOR,\n      IDENTIFIER_EXPRESSION = $__3.IDENTIFIER_EXPRESSION,\n      METHOD = $__3.METHOD,\n      MODULE = $__3.MODULE,\n      SET_ACCESSOR = $__3.SET_ACCESSOR;\n  var TYPEOF = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js")).TYPEOF;\n  function hasArgumentsInScope(scope) {\n    for (; scope; scope = scope.parent) {\n      switch (scope.tree.type) {\n        case FUNCTION_DECLARATION:\n        case FUNCTION_EXPRESSION:\n        case GET_ACCESSOR:\n        case METHOD:\n        case SET_ACCESSOR:\n          return true;\n      }\n    }\n    return false;\n  }\n  function inModuleScope(scope) {\n    for (; scope; scope = scope.parent) {\n      if (scope.tree.type === MODULE) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var ScopeChainBuilderWithReferences = function($__super) {\n    function ScopeChainBuilderWithReferences() {\n      $traceurRuntime.superConstructor(ScopeChainBuilderWithReferences).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ScopeChainBuilderWithReferences, {\n      createScope: function(tree) {\n        return new ScopeReferences(this.scope, tree);\n      },\n      visitIdentifierExpression: function(tree) {\n        if (this.inWithBlock) {\n          return;\n        }\n        var scope = this.scope;\n        var name = tree.getStringValue();\n        if (name === \'arguments\' && hasArgumentsInScope(scope)) {\n          return;\n        }\n        if (name === \'__moduleName\' && inModuleScope(scope)) {\n          return;\n        }\n        this.referenceFound(tree, name);\n      },\n      visitUnaryExpression: function(tree) {\n        if (tree.operator.type === TYPEOF && tree.operand.type === IDENTIFIER_EXPRESSION) {\n          var scope = this.scope;\n          var binding = scope.getBinding(tree.operand);\n          if (!binding) {\n            scope.addVar(tree.operand, this.reporter);\n          }\n        } else {\n          $traceurRuntime.superGet(this, ScopeChainBuilderWithReferences.prototype, "visitUnaryExpression").call(this, tree);\n        }\n      },\n      referenceFound: function(tree, name) {\n        this.scope.addReference(name);\n      }\n    }, {}, $__super);\n  }(ScopeChainBuilder);\n  return {get ScopeChainBuilderWithReferences() {\n      return ScopeChainBuilderWithReferences;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js";\n  var AlphaRenamer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AlphaRenamer.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")).AlphaRenamer;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")),\n      ANON_BLOCK = $__7.ANON_BLOCK,\n      BINDING_IDENTIFIER = $__7.BINDING_IDENTIFIER,\n      FOR_IN_STATEMENT = $__7.FOR_IN_STATEMENT,\n      FOR_OF_STATEMENT = $__7.FOR_OF_STATEMENT,\n      VARIABLE_DECLARATION_LIST = $__7.VARIABLE_DECLARATION_LIST;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")),\n      AnonBlock = $__8.AnonBlock,\n      BindingElement = $__8.BindingElement,\n      BindingIdentifier = $__8.BindingIdentifier,\n      Block = $__8.Block,\n      Catch = $__8.Catch,\n      DoWhileStatement = $__8.DoWhileStatement,\n      ForInStatement = $__8.ForInStatement,\n      ForStatement = $__8.ForStatement,\n      FormalParameter = $__8.FormalParameter,\n      FunctionBody = $__8.FunctionBody,\n      FunctionExpression = $__8.FunctionExpression,\n      LabelledStatement = $__8.LabelledStatement,\n      LiteralPropertyName = $__8.LiteralPropertyName,\n      Module = $__8.Module,\n      ObjectPatternField = $__8.ObjectPatternField,\n      Script = $__8.Script,\n      VariableDeclaration = $__8.VariableDeclaration,\n      VariableDeclarationList = $__8.VariableDeclarationList,\n      VariableStatement = $__8.VariableStatement,\n      WhileStatement = $__8.WhileStatement;\n  var IdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/IdentifierToken.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")).IdentifierToken;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")).ParseTreeTransformer;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")).VAR;\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")),\n      createBindingIdentifier = $__12.createBindingIdentifier,\n      createIdentifierExpression = $__12.createIdentifierExpression,\n      createIdentifierToken = $__12.createIdentifierToken;\n  var FindIdentifiers = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindIdentifiers.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")).FindIdentifiers;\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindVisitor.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")).FindVisitor;\n  var FnExtractAbruptCompletions = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FnExtractAbruptCompletions.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")).FnExtractAbruptCompletions;\n  var ScopeChainBuilderWithReferences = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../semantics/ScopeChainBuilderWithReferences.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")).ScopeChainBuilderWithReferences;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")).parseExpression;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js")).prependStatements;\n  function varNeedsInitializer(tree, loopTree) {\n    if (loopTree === null)\n      return false;\n    var type = loopTree.type;\n    if (type !== FOR_IN_STATEMENT && type !== FOR_OF_STATEMENT)\n      return true;\n    return loopTree.initializer.declarations[0] !== tree;\n  }\n  var BlockBindingTransformer = function($__super) {\n    function BlockBindingTransformer(idGenerator, reporter, tree) {\n      var scopeBuilder = arguments[3];\n      var latestScope = arguments[4];\n      $traceurRuntime.superConstructor(BlockBindingTransformer).call(this);\n      this.idGenerator_ = idGenerator;\n      this.reporter_ = reporter;\n      if (!scopeBuilder) {\n        scopeBuilder = new ScopeChainBuilderWithReferences(reporter);\n        scopeBuilder.visitAny(tree);\n      }\n      this.scopeBuilder_ = scopeBuilder;\n      this.labelledLoops_ = new Map();\n      this.prependStatement_ = [];\n      this.prependBlockStatement_ = [];\n      this.blockRenames_ = [];\n      this.rootTree_ = tree;\n      if (latestScope) {\n        this.scope_ = latestScope;\n      } else {\n        this.pushScope(tree);\n      }\n      this.usedVars_ = this.scope_.getAllBindingNames();\n      this.maybeRename_ = false;\n      this.inObjectPattern_ = false;\n      this.currentLoopTree_ = null;\n    }\n    return ($traceurRuntime.createClass)(BlockBindingTransformer, {\n      getVariableName_: function(variable) {\n        var lvalue = variable.lvalue;\n        if (lvalue.type === BINDING_IDENTIFIER) {\n          return lvalue.getStringValue();\n        }\n        throw new Error(\'Unexpected destructuring declaration found.\');\n      },\n      flushRenames: function(tree) {\n        tree = renameAll(this.blockRenames_, tree);\n        this.blockRenames_.length = 0;\n        return tree;\n      },\n      pushScope: function(tree) {\n        var scope = this.scopeBuilder_.getScopeForTree(tree);\n        if (!scope)\n          throw new Error(\'BlockBindingTransformer tree with no scope\');\n        if (this.scope_)\n          this.scope_.blockBindingRenames = this.blockRenames_;\n        this.scope_ = scope;\n        this.blockRenames_ = [];\n        return scope;\n      },\n      popScope: function(scope) {\n        if (this.scope_ !== scope) {\n          throw new Error(\'BlockBindingTransformer scope mismatch\');\n        }\n        this.scope_ = scope.parent;\n        this.blockRenames_ = this.scope_ && this.scope_.blockBindingRenames || [];\n      },\n      revisitTreeForScopes: function(tree) {\n        this.scopeBuilder_.scope = this.scope_;\n        this.scopeBuilder_.visitAny(tree);\n        this.scopeBuilder_.scope = null;\n      },\n      needsRename_: function(name) {\n        if (this.usedVars_.has(name))\n          return true;\n        var scope = this.scope_;\n        var parent = scope.parent;\n        if (!parent || scope.isVarScope)\n          return false;\n        var varScope = scope.getVarScope();\n        if (varScope && varScope.hasFreeVariable(name)) {\n          return true;\n        }\n        var parentBinding = parent.getBindingByName(name);\n        if (!parentBinding)\n          return false;\n        var currentBinding = scope.getBindingByName(name);\n        if (currentBinding.tree === parentBinding.tree)\n          return false;\n        return true;\n      },\n      newNameFromOrig: function(origName, renames) {\n        var newName;\n        if (this.needsRename_(origName)) {\n          newName = origName + this.idGenerator_.generateUniqueIdentifier();\n          renames.push(new Rename(origName, newName));\n        } else {\n          this.usedVars_.add(origName);\n          newName = origName;\n        }\n        return newName;\n      },\n      transformFunctionBody: function(tree) {\n        if (tree === this.rootTree_ || !this.rootTree_) {\n          tree = $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, "transformFunctionBody").call(this, tree);\n          if (this.prependStatement_.length || this.blockRenames_.length) {\n            var statements = prependStatements.apply((void 0), $traceurRuntime.spread([tree.statements], this.prependStatement_));\n            tree = new FunctionBody(tree.location, statements);\n            tree = this.flushRenames(tree);\n          }\n        } else {\n          var functionTransform = new BlockBindingTransformer(this.idGenerator_, this.reporter_, tree, this.scopeBuilder_, this.scope_);\n          var functionBodyTree = functionTransform.transformAny(tree);\n          if (functionBodyTree === tree) {\n            return tree;\n          }\n          tree = new FunctionBody(tree.location, functionBodyTree.statements);\n        }\n        return tree;\n      },\n      transformScript: function(tree) {\n        if (tree === this.rootTree_ || !this.rootTree_) {\n          tree = $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, "transformScript").call(this, tree);\n          if (this.prependStatement_.length || this.blockRenames_.length) {\n            var scriptItemList = prependStatements.apply((void 0), $traceurRuntime.spread([tree.scriptItemList], this.prependStatement_));\n            tree = new Script(tree.location, scriptItemList, tree.moduleName);\n            tree = this.flushRenames(tree);\n          }\n        } else {\n          var functionTransform = new BlockBindingTransformer(this.idGenerator_, this.reporter_, tree, this.scopeBuilder_);\n          var newTree = functionTransform.transformAny(tree);\n          if (newTree === tree) {\n            return tree;\n          }\n          tree = new Script(tree.location, newTree.scriptItemList, tree.moduleName);\n        }\n        return tree;\n      },\n      transformModule: function(tree) {\n        if (tree === this.rootTree_ || !this.rootTree_) {\n          tree = $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, "transformModule").call(this, tree);\n          if (this.prependStatement_.length || this.blockRenames_.length) {\n            var scriptItemList = prependStatements.apply((void 0), $traceurRuntime.spread([tree.scriptItemList], this.prependStatement_));\n            tree = new Module(tree.location, scriptItemList, tree.moduleName);\n            tree = this.flushRenames(tree);\n          }\n        } else {\n          var functionTransform = new BlockBindingTransformer(this.idGenerator_, this.reporter_, tree, this.scopeBuilder_);\n          var newTree = functionTransform.transformAny(tree);\n          if (newTree === tree) {\n            return tree;\n          }\n          tree = new Module(tree.location, newTree.scriptItemList, tree.moduleName);\n        }\n        return tree;\n      },\n      transformVariableStatement: function(tree) {\n        var declarations = this.transformAny(tree.declarations);\n        if (declarations.type === ANON_BLOCK) {\n          return declarations;\n        }\n        if (declarations === tree.declarations) {\n          return tree;\n        }\n        return new VariableStatement(tree.location, declarations);\n      },\n      transformVariableDeclarationList: function(tree) {\n        if (tree.declarationType === VAR) {\n          return $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, "transformVariableDeclarationList").call(this, tree);\n        }\n        this.maybeRename_ = !this.scope_.isVarScope;\n        var declarations = this.transformList(tree.declarations);\n        this.maybeRename_ = false;\n        return new VariableDeclarationList(tree.location, VAR, declarations);\n      },\n      transformVariableDeclaration: function(tree) {\n        var maybeRename = this.maybeRename_;\n        var lvalue = this.transformAny(tree.lvalue);\n        this.maybeRename_ = false;\n        var initializer = null;\n        if (tree.initializer) {\n          initializer = this.transformAny(tree.initializer);\n        } else if (varNeedsInitializer(tree, this.currentLoopTree_)) {\n          initializer = parseExpression($traceurRuntime.getTemplateObject(["void 0"]));\n        }\n        this.maybeRename_ = maybeRename;\n        if (tree.lvalue === lvalue && tree.initializer === initializer) {\n          return tree;\n        }\n        return new VariableDeclaration(tree.location, lvalue, tree.typeAnnotation, initializer);\n      },\n      transformBindingIdentifier: function(tree) {\n        if (this.maybeRename_) {\n          var origName = tree.getStringValue();\n          var newName = this.newNameFromOrig(origName, this.blockRenames_);\n          if (origName === newName) {\n            return tree;\n          }\n          var newToken = new IdentifierToken(tree.location, newName);\n          var bindingIdentifier = new BindingIdentifier(tree.location, newToken);\n          this.scope_.renameBinding(origName, bindingIdentifier, VAR, this.reporter_);\n          return bindingIdentifier;\n        }\n        return $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, "transformBindingIdentifier").call(this, tree);\n      },\n      transformBindingElement: function(tree) {\n        var maybeRename = this.maybeRename_;\n        var inObjectPattern = this.inObjectPattern_;\n        var binding = this.transformAny(tree.binding);\n        this.maybeRename_ = false;\n        this.inObjectPattern_ = false;\n        var initializer = this.transformAny(tree.initializer);\n        this.maybeRename_ = maybeRename;\n        this.inObjectPattern_ = inObjectPattern;\n        if (tree.binding === binding && tree.initializer === initializer) {\n          return tree;\n        }\n        var bindingElement = new BindingElement(tree.location, binding, initializer);\n        if (this.inObjectPattern_ && tree.binding !== binding && tree.binding.type === BINDING_IDENTIFIER) {\n          return new ObjectPatternField(tree.location, new LiteralPropertyName(tree.location, tree.binding.identifierToken), bindingElement);\n        }\n        return bindingElement;\n      },\n      transformObjectPattern: function(tree) {\n        var inObjectPattern = this.inObjectPattern_;\n        this.inObjectPattern_ = true;\n        var transformed = $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, "transformObjectPattern").call(this, tree);\n        this.inObjectPattern_ = inObjectPattern;\n        return transformed;\n      },\n      transformObjectPatternField: function(tree) {\n        var name = this.transformAny(tree.name);\n        this.inObjectPattern_ = false;\n        var element = this.transformAny(tree.element);\n        this.inObjectPattern_ = true;\n        if (tree.name === name && tree.element === element) {\n          return tree;\n        }\n        return new ObjectPatternField(tree.location, name, element);\n      },\n      transformBlock: function(tree) {\n        var scope = this.pushScope(tree);\n        var outerPrepends = this.prependBlockStatement_;\n        this.prependBlockStatement_ = [];\n        tree = $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, "transformBlock").call(this, tree);\n        if (this.prependBlockStatement_.length) {\n          tree = new Block(tree.location, prependStatements.apply((void 0), $traceurRuntime.spread([tree.statements], this.prependBlockStatement_)));\n        }\n        this.prependBlockStatement_ = outerPrepends;\n        tree = this.flushRenames(tree);\n        this.popScope(scope);\n        return tree;\n      },\n      transformCatch: function(tree) {\n        var scope = this.pushScope(tree);\n        var binding = this.transformAny(tree.binding);\n        var statements = this.transformList(tree.catchBody.statements);\n        if (binding !== tree.binding || statements !== tree.catchBody.statements) {\n          tree = new Catch(tree.location, binding, new Block(tree.catchBody.location, statements));\n        }\n        tree = this.flushRenames(tree);\n        this.popScope(scope);\n        return tree;\n      },\n      transformFunctionForScope_: function(func, tree) {\n        var scope = this.pushScope(tree);\n        tree = func();\n        tree = this.flushRenames(tree);\n        this.popScope(scope);\n        return tree;\n      },\n      transformGetAccessor: function(tree) {\n        var $__3 = this;\n        return this.transformFunctionForScope_(function() {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, "transformGetAccessor").call($__3, tree);\n        }, tree);\n      },\n      transformSetAccessor: function(tree) {\n        var $__3 = this;\n        return this.transformFunctionForScope_(function() {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, "transformSetAccessor").call($__3, tree);\n        }, tree);\n      },\n      transformFunctionExpression: function(tree) {\n        var $__3 = this;\n        return this.transformFunctionForScope_(function() {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, "transformFunctionExpression").call($__3, tree);\n        }, tree);\n      },\n      transformFunctionDeclaration: function(tree) {\n        var $__3 = this;\n        if (!this.scope_.isVarScope) {\n          var origName = tree.name.getStringValue();\n          var newName = this.newNameFromOrig(origName, this.blockRenames_);\n          var functionExpression = new FunctionExpression(tree.location, null, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n          this.revisitTreeForScopes(functionExpression);\n          functionExpression = this.transformAny(functionExpression);\n          var bindingIdentifier = createBindingIdentifier(newName);\n          var statement = new VariableStatement(tree.location, new VariableDeclarationList(tree.location, VAR, [new VariableDeclaration(tree.location, bindingIdentifier, null, functionExpression)]));\n          this.scope_.renameBinding(origName, bindingIdentifier, VAR, this.reporter_);\n          this.prependBlockStatement_.push(statement);\n          return new AnonBlock(null, []);\n        }\n        return this.transformFunctionForScope_(function() {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, "transformFunctionDeclaration").call($__3, tree);\n        }, tree);\n      },\n      transformLoop_: function(func, tree, loopFactory) {\n        var $__3 = this;\n        var scope,\n            initializerIsBlockBinding;\n        if (tree.initializer && tree.initializer.type === VARIABLE_DECLARATION_LIST && tree.initializer.declarationType !== VAR) {\n          initializerIsBlockBinding = true;\n        }\n        if (initializerIsBlockBinding) {\n          scope = this.pushScope(tree);\n        }\n        var finder = new FindBlockBindingInLoop(tree, this.scopeBuilder_);\n        finder.visitAny(tree);\n        if (!finder.found) {\n          var callFunc = function() {\n            var currentLoopTree = $__3.currentLoopTree_;\n            $__3.currentLoopTree_ = tree;\n            var rv = func(tree);\n            $__3.currentLoopTree_ = currentLoopTree;\n            return rv;\n          };\n          if (!initializerIsBlockBinding) {\n            return callFunc();\n          }\n          var renames = [];\n          var initializer = new VariableDeclarationList(null, VAR, tree.initializer.declarations.map(function(declaration) {\n            var origName = $__3.getVariableName_(declaration);\n            var newName = $__3.newNameFromOrig(origName, renames);\n            var bindingIdentifier = createBindingIdentifier(newName);\n            $__3.scope_.renameBinding(origName, bindingIdentifier, VAR, $__3.reporter_);\n            return new VariableDeclaration(null, bindingIdentifier, null, declaration.initializer);\n          }));\n          initializer = renameAll(renames, initializer);\n          tree = loopFactory(initializer, renames, renameAll(renames, tree.body));\n          this.revisitTreeForScopes(tree);\n          tree = callFunc();\n        } else {\n          var iifeParameterList = [];\n          var iifeArgumentList = [];\n          var renames$__4 = [];\n          var initializer$__5 = null;\n          if (tree.initializer) {\n            if (tree.initializer.type === VARIABLE_DECLARATION_LIST && tree.initializer.declarationType !== VAR) {\n              initializer$__5 = new VariableDeclarationList(null, VAR, tree.initializer.declarations.map(function(declaration) {\n                var origName = $__3.getVariableName_(declaration);\n                var newName = $__3.newNameFromOrig(origName, renames$__4);\n                iifeArgumentList.push(createIdentifierExpression(newName));\n                iifeParameterList.push(new FormalParameter(null, new BindingElement(null, createBindingIdentifier(origName), null), null, []));\n                var bindingIdentifier = createBindingIdentifier(newName);\n                $__3.scope_.renameBinding(origName, bindingIdentifier, VAR, $__3.reporter_);\n                return new VariableDeclaration(null, bindingIdentifier, null, declaration.initializer);\n              }));\n              initializer$__5 = renameAll(renames$__4, initializer$__5);\n            } else {\n              initializer$__5 = this.transformAny(tree.initializer);\n            }\n          }\n          var loopLabel = this.labelledLoops_.get(tree);\n          var iifeInfo = FnExtractAbruptCompletions.createIIFE(this.idGenerator_, tree.body, iifeParameterList, iifeArgumentList, function() {\n            return loopLabel = loopLabel || createIdentifierToken($__3.idGenerator_.generateUniqueIdentifier());\n          }, this.scope_.inGenerator);\n          tree = loopFactory(initializer$__5, renames$__4, iifeInfo.loopBody);\n          if (loopLabel) {\n            tree = new LabelledStatement(tree.location, loopLabel, tree);\n          }\n          tree = new AnonBlock(tree.location, [iifeInfo.variableStatements, tree]);\n          this.revisitTreeForScopes(tree);\n          tree = this.transformAny(tree);\n        }\n        if (initializerIsBlockBinding) {\n          tree = this.flushRenames(tree);\n          this.popScope(scope);\n        }\n        return tree;\n      },\n      transformForInStatement: function(tree) {\n        var $__3 = this;\n        return this.transformLoop_(function(t) {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, "transformForInStatement").call($__3, t);\n        }, tree, function(initializer, renames, body) {\n          return new ForInStatement(tree.location, initializer, renameAll(renames, tree.collection), body);\n        });\n      },\n      transformForStatement: function(tree) {\n        var $__3 = this;\n        return this.transformLoop_(function(t) {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, "transformForStatement").call($__3, t);\n        }, tree, function(initializer, renames, body) {\n          return new ForStatement(tree.location, initializer, renameAll(renames, tree.condition), renameAll(renames, tree.increment), body);\n        });\n      },\n      transformWhileStatement: function(tree) {\n        var $__3 = this;\n        return this.transformLoop_(function(t) {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, "transformWhileStatement").call($__3, t);\n        }, tree, function(initializer, renames, body) {\n          return new WhileStatement(tree.location, renameAll(renames, tree.condition), body);\n        });\n      },\n      transformDoWhileStatement: function(tree) {\n        var $__3 = this;\n        return this.transformLoop_(function(t) {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, "transformDoWhileStatement").call($__3, t);\n        }, tree, function(initializer, renames, body) {\n          return new DoWhileStatement(tree.location, body, renameAll(renames, tree.condition));\n        });\n      },\n      transformLabelledStatement: function(tree) {\n        if (tree.statement.isIterationStatement()) {\n          this.labelledLoops_.set(tree.statement, tree.name.value);\n          var statement = this.transformAny(tree.statement);\n          if (!statement.isStatement()) {\n            return statement;\n          }\n          if (statement === tree.statement) {\n            return tree;\n          }\n          return new LabelledStatement(tree.location, tree.name, statement);\n        }\n        return $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, "transformLabelledStatement").call(this, tree);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  var Rename = function() {\n    function Rename(oldName, newName) {\n      this.oldName = oldName;\n      this.newName = newName;\n    }\n    return ($traceurRuntime.createClass)(Rename, {}, {});\n  }();\n  function renameAll(renames, tree) {\n    renames.forEach(function(rename) {\n      tree = AlphaRenamer.rename(tree, rename.oldName, rename.newName);\n    });\n    return tree;\n  }\n  var FindBlockBindingInLoop = function($__super) {\n    function FindBlockBindingInLoop(tree, scopeBuilder) {\n      $traceurRuntime.superConstructor(FindBlockBindingInLoop).call(this);\n      this.scopeBuilder_ = scopeBuilder;\n      this.topScope_ = scopeBuilder.getScopeForTree(tree) || scopeBuilder.getScopeForTree(tree.body);\n      this.outOfScope_ = null;\n      this.acceptLoop_ = tree.isIterationStatement();\n    }\n    return ($traceurRuntime.createClass)(FindBlockBindingInLoop, {\n      visitForInStatement: function(tree) {\n        var $__3 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__3, FindBlockBindingInLoop.prototype, "visitForInStatement").call($__3, tree);\n        });\n      },\n      visitForStatement: function(tree) {\n        var $__3 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__3, FindBlockBindingInLoop.prototype, "visitForStatement").call($__3, tree);\n        });\n      },\n      visitWhileStatement: function(tree) {\n        var $__3 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__3, FindBlockBindingInLoop.prototype, "visitWhileStatement").call($__3, tree);\n        });\n      },\n      visitDoWhileStatement: function(tree) {\n        var $__3 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__3, FindBlockBindingInLoop.prototype, "visitDoWhileStatement").call($__3, tree);\n        });\n      },\n      visitLoop_: function(tree, func) {\n        if (this.acceptLoop_) {\n          this.acceptLoop_ = false;\n        } else if (!this.outOfScope_) {\n          this.outOfScope_ = this.scopeBuilder_.getScopeForTree(tree) || this.scopeBuilder_.getScopeForTree(tree.body);\n        }\n        func();\n      },\n      visitArrowFunction: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitFunctionExpression: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitGetAccessor: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitMethod: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitSetAccessor: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitFunction_: function(tree) {\n        var $__3 = this;\n        this.found = new FindIdentifiers(tree, function(identifierToken, identScope) {\n          identScope = $__3.scopeBuilder_.getScopeForTree(identScope);\n          var fnScope = $__3.outOfScope_ || $__3.scopeBuilder_.getScopeForTree(tree);\n          if (identScope.hasLexicalBindingName(identifierToken)) {\n            return false;\n          }\n          while (identScope !== fnScope && (identScope = identScope.parent)) {\n            if (identScope.hasLexicalBindingName(identifierToken)) {\n              return false;\n            }\n          }\n          while (fnScope = fnScope.parent) {\n            if (fnScope.hasLexicalBindingName(identifierToken)) {\n              return true;\n            }\n            if (fnScope.hasVariableBindingName(identifierToken)) {\n              return false;\n            }\n            if (fnScope === $__3.topScope_)\n              break;\n          }\n          return false;\n        }).found;\n      }\n    }, {}, $__super);\n  }(FindVisitor);\n  return {get BlockBindingTransformer() {\n      return BlockBindingTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js")),\n      FunctionBody = $__1.FunctionBody,\n      Script = $__1.Script;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js")).ParseTreeTransformer;\n  var createUseStrictDirective = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js")).createUseStrictDirective;\n  var hasUseStrict = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../semantics/util.js", "traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js")).hasUseStrict;\n  function prepend(statements) {\n    return $traceurRuntime.spread([createUseStrictDirective()], statements);\n  }\n  var MakeStrictTransformer = function($__super) {\n    function MakeStrictTransformer() {\n      $traceurRuntime.superConstructor(MakeStrictTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(MakeStrictTransformer, {\n      transformScript: function(tree) {\n        if (hasUseStrict(tree.scriptItemList))\n          return tree;\n        return new Script(tree.location, prepend(tree.scriptItemList), tree.moduleName);\n      },\n      transformFunctionBody: function(tree) {\n        if (hasUseStrict(tree.statements))\n          return tree;\n        return new FunctionBody(tree.location, prepend(tree.statements));\n      }\n    }, {transformTree: function(tree) {\n        return new MakeStrictTransformer().transformAny(tree);\n      }}, $__super);\n  }(ParseTreeTransformer);\n  return {get MakeStrictTransformer() {\n      return MakeStrictTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ClassTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ClassTransformer.js";\n  var CONSTRUCTOR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/ClassTransformer.js")).CONSTRUCTOR;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ClassTransformer.js")),\n      AnonBlock = $__3.AnonBlock,\n      ClassExpression = $__3.ClassExpression,\n      ExportDeclaration = $__3.ExportDeclaration,\n      ExportSpecifier = $__3.ExportSpecifier,\n      ExportSpecifierSet = $__3.ExportSpecifierSet,\n      FunctionDeclaration = $__3.FunctionDeclaration,\n      FunctionExpression = $__3.FunctionExpression,\n      GetAccessor = $__3.GetAccessor,\n      Method = $__3.Method,\n      NamedExport = $__3.NamedExport,\n      SetAccessor = $__3.SetAccessor;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ClassTransformer.js")),\n      CLASS_DECLARATION = $__4.CLASS_DECLARATION,\n      COMPUTED_PROPERTY_NAME = $__4.COMPUTED_PROPERTY_NAME,\n      EXPORT_DEFAULT = $__4.EXPORT_DEFAULT,\n      GET_ACCESSOR = $__4.GET_ACCESSOR,\n      LITERAL_PROPERTY_NAME = $__4.LITERAL_PROPERTY_NAME,\n      METHOD = $__4.METHOD,\n      SET_ACCESSOR = $__4.SET_ACCESSOR;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/ClassTransformer.js")).TempVarTransformer;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/ClassTransformer.js")),\n      CONST = $__6.CONST,\n      LET = $__6.LET,\n      VAR = $__6.VAR,\n      STRING = $__6.STRING;\n  var MakeStrictTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MakeStrictTransformer.js", "traceur@0.0.111/src/codegeneration/ClassTransformer.js")).MakeStrictTransformer;\n  var ParenTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParenTrait.js", "traceur@0.0.111/src/codegeneration/ClassTransformer.js")).ParenTrait;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/ClassTransformer.js")).default;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ClassTransformer.js")),\n      createBindingIdentifier = $__10.createBindingIdentifier,\n      id = $__10.createIdentifierExpression,\n      createIdentifierToken = $__10.createIdentifierToken,\n      createObjectLiteral = $__10.createObjectLiteral,\n      createVariableStatement = $__10.createVariableStatement;\n  var hasUseStrict = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../semantics/util.js", "traceur@0.0.111/src/codegeneration/ClassTransformer.js")).hasUseStrict;\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/ClassTransformer.js")),\n      parseExpression = $__12.parseExpression,\n      parsePropertyDefinition = $__12.parsePropertyDefinition,\n      parseStatement = $__12.parseStatement;\n  function methodNameFromTree(tree) {\n    if (tree.type === COMPUTED_PROPERTY_NAME) {\n      return \'\';\n    }\n    if (tree.literalToken && tree.literalToken.type === STRING) {\n      return tree.getStringValue().substr(1, -1);\n    }\n    return tree.getStringValue();\n  }\n  function classMethodDebugName(className, methodName, isStatic) {\n    if (isStatic) {\n      return createBindingIdentifier(\'$__\' + className + \'_\' + methodName);\n    }\n    return createBindingIdentifier(\'$__\' + className + \'_prototype_\' + methodName);\n  }\n  function functionExpressionToDeclaration(tree, name) {\n    if (tree.name === null) {\n      name = createBindingIdentifier(name);\n    } else {\n      name = tree.name;\n    }\n    return new FunctionDeclaration(tree.location, name, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n  }\n  function removeStaticModifier(tree) {\n    switch (tree.type) {\n      case GET_ACCESSOR:\n        return new GetAccessor(tree.location, false, tree.name, tree.typeAnnotation, tree.annotations, tree.body);\n      case SET_ACCESSOR:\n        return new SetAccessor(tree.location, false, tree.name, tree.parameterList, tree.annotations, tree.body);\n      case METHOD:\n        return new Method(tree.location, false, tree.functionKind, tree.name, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body, tree.debugName);\n      default:\n        throw new Error(\'unreachable\');\n    }\n  }\n  function isConstructor(tree) {\n    if (tree.type !== METHOD || tree.isStatic || tree.functionKind !== null) {\n      return false;\n    }\n    var name = tree.name;\n    return name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === CONSTRUCTOR;\n  }\n  var ClassTransformer = function($__super) {\n    function ClassTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(ClassTransformer).call(this, identifierGenerator, reporter, options);\n      this.strictCount_ = 0;\n      this.state_ = null;\n    }\n    return ($traceurRuntime.createClass)(ClassTransformer, {\n      transformModule: function(tree) {\n        this.strictCount_ = 1;\n        return $traceurRuntime.superGet(this, ClassTransformer.prototype, "transformModule").call(this, tree);\n      },\n      transformScript: function(tree) {\n        this.strictCount_ = hasUseStrict(tree.scriptItemList) ? 1 : 0;\n        return $traceurRuntime.superGet(this, ClassTransformer.prototype, "transformScript").call(this, tree);\n      },\n      transformFunctionBody: function(tree) {\n        var useStrict = hasUseStrict(tree.statements) ? 1 : 0;\n        this.strictCount_ += useStrict;\n        var result = $traceurRuntime.superGet(this, ClassTransformer.prototype, "transformFunctionBody").call(this, tree);\n        this.strictCount_ -= useStrict;\n        return result;\n      },\n      makeStrict_: function(tree) {\n        if (this.strictCount_)\n          return tree;\n        return MakeStrictTransformer.transformTree(tree);\n      },\n      transformClassDeclaration: function(tree) {\n        var classExpression = new ClassExpression(tree.location, tree.name, tree.superClass, tree.elements, tree.annotations, tree.typeParameters);\n        var transformed = this.transformClassExpression(classExpression);\n        var useLet = !this.options.transformOptions.blockBinding && this.options.parseOptions.blockBinding;\n        return createVariableStatement(useLet ? LET : VAR, tree.name, transformed);\n      },\n      transformClassExpression: function(tree) {\n        var superClass = this.transformAny(tree.superClass);\n        var elements = this.transformList(tree.elements);\n        var annotations = this.transformList(tree.annotations);\n        var constructor = null;\n        var protoElements = elements.filter(function(tree) {\n          if (tree.isStatic)\n            return false;\n          if (isConstructor(tree)) {\n            constructor = tree;\n            return false;\n          }\n          return true;\n        });\n        var staticElements = elements.filter(function(tree) {\n          return tree.isStatic;\n        }).map(removeStaticModifier);\n        var protoObject = createObjectLiteral(protoElements);\n        var staticObject = createObjectLiteral(staticElements);\n        if (!constructor) {\n          constructor = this.getDefaultConstructor_(tree);\n        }\n        var func = new FunctionExpression(tree.location, tree.name, null, constructor.parameterList, null, annotations, constructor.body);\n        var expression;\n        var createClass = this.getRuntimeExpression(\'createClass\');\n        if (tree.name) {\n          var functionStatement;\n          var name = tree.name.identifierToken;\n          var nameId = id(("" + name));\n          if (!this.options.transformOptions.blockBinding && this.options.parseOptions.blockBinding) {\n            functionStatement = createVariableStatement(CONST, tree.name, func);\n          } else {\n            functionStatement = functionExpressionToDeclaration(func, name);\n          }\n          if (superClass) {\n            expression = parseExpression($traceurRuntime.getTemplateObject(["function($__super) {\\n          ", ";\\n          return (", ")(", ", ", ",\\n                                  ", ", $__super);\\n        }(", ")"]), functionStatement, createClass, nameId, protoObject, staticObject, superClass);\n          } else {\n            expression = parseExpression($traceurRuntime.getTemplateObject(["function() {\\n          ", ";\\n          return (", ")(", ", ", ", ", ");\\n        }()"]), functionStatement, createClass, nameId, protoObject, staticObject);\n          }\n        } else {\n          if (superClass) {\n            expression = parseExpression($traceurRuntime.getTemplateObject(["(", ")(", ", ", ", ", ", ", ")"]), createClass, func, protoObject, staticObject, superClass);\n          } else {\n            expression = parseExpression($traceurRuntime.getTemplateObject(["(", ")(", ", ", ", ", ")"]), createClass, func, protoObject, staticObject);\n          }\n        }\n        return this.makeStrict_(expression);\n      },\n      transformExportDeclaration: function(tree) {\n        if (tree.declaration.type === EXPORT_DEFAULT && tree.declaration.expression.type === CLASS_DECLARATION) {\n          return this.transformExportDefaultClass_(tree.declaration);\n        }\n        return $traceurRuntime.superGet(this, ClassTransformer.prototype, "transformExportDeclaration").call(this, tree);\n      },\n      transformExportDefaultClass_: function(tree) {\n        var name = tree.expression.name.identifierToken;\n        var specifier = new ExportSpecifier(name.location, name, createIdentifierToken(\'default\'));\n        var exportTree = new ExportSpecifierSet(name.location, [specifier]);\n        var named = new NamedExport(name.location, exportTree, null);\n        var exp = new ExportDeclaration(name.location, named, []);\n        var classTree = this.transformAny(tree.expression);\n        return new AnonBlock(null, [classTree, exp]);\n      },\n      getDefaultConstructor_: function(tree) {\n        if (tree.superClass) {\n          var name = id(tree.name.identifierToken);\n          var superConstructor = this.getRuntimeExpression(\'superConstructor\');\n          return parsePropertyDefinition($traceurRuntime.getTemplateObject(["constructor() {\\n        ", "(", ").apply(this, arguments)\\n      }"]), superConstructor, name);\n        }\n        return parsePropertyDefinition($traceurRuntime.getTemplateObject(["constructor() {}"]));\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(ParenTrait(TempVarTransformer)));\n  return {get ClassTransformer() {\n      return ClassTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js";\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModuleTransformer.js", "traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js")).ModuleTransformer;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js")),\n      createIdentifierExpression = $__4.createIdentifierExpression,\n      createMemberExpression = $__4.createMemberExpression,\n      createPropertyNameAssignment = $__4.createPropertyNameAssignment;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js")),\n      EXPORT_DEFAULT = $__5.EXPORT_DEFAULT,\n      EXPORT_SPECIFIER = $__5.EXPORT_SPECIFIER;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js")),\n      parseExpression = $__6.parseExpression,\n      parseStatement = $__6.parseStatement,\n      parseStatements = $__6.parseStatements;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js")).prependStatements;\n  var ClosureModuleTransformer = function($__super) {\n    function ClosureModuleTransformer() {\n      $traceurRuntime.superConstructor(ClosureModuleTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ClosureModuleTransformer, {\n      moduleProlog: function() {\n        if (!this.moduleName) {\n          throw new Error(\'Closure modules (goog.module) require a moduleName\');\n        }\n        return parseStatements($traceurRuntime.getTemplateObject(["goog.module(", ");"]), this.moduleName);\n      },\n      wrapModule: function(statements) {\n        if (this.hasStarExports()) {\n          throw new Error(\'Closure modules (goog.module) do not support "export *"\');\n        }\n        return statements;\n      },\n      addExportStatement: function(statements) {\n        if (!this.hasExports())\n          return statements;\n        var exportObject = this.getExportObject();\n        statements.push(parseStatement($traceurRuntime.getTemplateObject(["exports = ", ""]), exportObject));\n        return statements;\n      },\n      getGetterExport: function($__1) {\n        var $__2 = $__1,\n            name = $__2.name,\n            tree = $__2.tree,\n            moduleSpecifier = $__2.moduleSpecifier;\n        var expression;\n        switch (tree.type) {\n          case EXPORT_DEFAULT:\n            expression = createIdentifierExpression(\'$__default\');\n            break;\n          case EXPORT_SPECIFIER:\n            if (moduleSpecifier) {\n              var idName = this.getTempVarNameForModuleSpecifier(moduleSpecifier);\n              expression = createMemberExpression(idName, tree.lhs);\n            } else {\n              expression = createPropertyNameAssignment(name, tree.lhs);\n            }\n            break;\n          default:\n            expression = createIdentifierExpression(name);\n            break;\n        }\n        return createPropertyNameAssignment(name, expression);\n      },\n      transformModuleSpecifier: function(tree) {\n        var moduleName = tree.token.processedValue;\n        return parseExpression($traceurRuntime.getTemplateObject(["goog.require(", ")"]), moduleName);\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  return {get ClosureModuleTransformer() {\n      return ClosureModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js";\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModuleTransformer.js", "traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js")).ModuleTransformer;\n  var NAMED_EXPORT = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js")).NAMED_EXPORT;\n  var AnonBlock = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js")).AnonBlock;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js")),\n      parseExpression = $__6.parseExpression,\n      parsePropertyDefinition = $__6.parsePropertyDefinition,\n      parseStatement = $__6.parseStatement;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js")),\n      createExpressionStatement = $__7.createExpressionStatement,\n      createObjectLiteral = $__7.createObjectLiteral,\n      createObjectLiteralForDescriptor = $__7.createObjectLiteralForDescriptor,\n      createPropertyNameAssignment = $__7.createPropertyNameAssignment;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js")).prependStatements;\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindVisitor.js", "traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js")).FindVisitor;\n  var CommonJsModuleTransformer = function($__super) {\n    function CommonJsModuleTransformer(identifierGenerator, reporter) {\n      var options = arguments[2];\n      $traceurRuntime.superConstructor(CommonJsModuleTransformer).call(this, identifierGenerator, reporter, options);\n      this.anonymousModule = options && !options.bundle && options.moduleName !== true;\n      this.namedExportsWithModuleSpecifiers_ = [];\n      this.isImportingDefault_ = false;\n      this.needsInteropRequire_ = false;\n    }\n    return ($traceurRuntime.createClass)(CommonJsModuleTransformer, {\n      getModuleName: function(tree) {\n        if (this.anonymousModule)\n          return null;\n        return tree.moduleName;\n      },\n      wrapModule: function(statements) {\n        if (this.needsInteropRequire_) {\n          var req = parseStatement($traceurRuntime.getTemplateObject(["function $__interopRequire(id) {\\n        id = require(id);\\n        return id && id.__esModule && id || {default: id};\\n      }"]));\n          return prependStatements(statements, req);\n        }\n        return statements;\n      },\n      addExportStatement: function(statements) {\n        if (!this.hasExports()) {\n          return statements;\n        }\n        var descr = this.getExportDescriptors();\n        var exportObject = parseExpression($traceurRuntime.getTemplateObject(["Object.defineProperties(module.exports, ", ")"]), descr);\n        if (this.hasStarExports()) {\n          exportObject = this.getExportStar(exportObject);\n        }\n        return prependStatements.apply((void 0), $traceurRuntime.spread([statements], this.namedExportsWithModuleSpecifiers_, [createExpressionStatement(exportObject)]));\n      },\n      getExportDescriptors: function() {\n        var $__2 = this;\n        var properties = this.exportVisitor.getNonTypeNamedExports().map(function(exp) {\n          var f = parseExpression($traceurRuntime.getTemplateObject(["function() { return ", "; }"]), $__2.getGetterExportReturnExpression(exp));\n          return createPropertyNameAssignment(exp.name, createObjectLiteralForDescriptor({\n            enumerable: true,\n            get: f\n          }));\n        });\n        properties.unshift(parsePropertyDefinition($traceurRuntime.getTemplateObject(["__esModule: {value: true}"])));\n        return createObjectLiteral(properties);\n      },\n      transformExportDeclaration: function(tree) {\n        this.checkForDefaultImport_(tree);\n        this.exportVisitor.visitAny(tree);\n        var transformed = this.transformAny(tree.declaration);\n        if (tree.declaration.type == NAMED_EXPORT && tree.declaration.moduleSpecifier !== null) {\n          this.namedExportsWithModuleSpecifiers_.push(transformed);\n          return new AnonBlock(null, []);\n        }\n        return transformed;\n      },\n      transformImportDeclaration: function(tree) {\n        this.checkForDefaultImport_(tree);\n        return $traceurRuntime.superGet(this, CommonJsModuleTransformer.prototype, "transformImportDeclaration").call(this, tree);\n      },\n      checkForDefaultImport_: function(tree) {\n        var finder = new FindDefault();\n        finder.visitAny(tree);\n        this.isImportingDefault_ = finder.found;\n      },\n      transformModuleSpecifier: function(tree) {\n        var moduleName = tree.token.processedValue;\n        if (this.isImportingDefault_) {\n          this.needsInteropRequire_ = true;\n          return parseExpression($traceurRuntime.getTemplateObject(["$__interopRequire(", ")"]), moduleName);\n        }\n        return parseExpression($traceurRuntime.getTemplateObject(["require(", ")"]), moduleName);\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  var FindDefault = function($__super) {\n    function FindDefault() {\n      $traceurRuntime.superConstructor(FindDefault).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(FindDefault, {\n      visitImportSpecifier: function(tree) {\n        this.found = tree.name !== null && tree.name.value === \'default\';\n      },\n      visitNameSpaceImport: function(tree) {\n        this.found = true;\n      },\n      visitNameSpaceExport: function(tree) {\n        this.found = true;\n      },\n      visitExportSpecifier: function(tree) {\n        this.found = tree.lhs !== null && tree.lhs.value === \'default\';\n      }\n    }, {}, $__super);\n  }(FindVisitor);\n  return {get CommonJsModuleTransformer() {\n      return CommonJsModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ParameterTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ParameterTransformer.js";\n  var FunctionBody = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ParameterTransformer.js")).FunctionBody;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/ParameterTransformer.js")).TempVarTransformer;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/ParameterTransformer.js")).prependStatements;\n  var stack = [];\n  var ParameterTransformer = function($__super) {\n    function ParameterTransformer() {\n      $traceurRuntime.superConstructor(ParameterTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ParameterTransformer, {\n      transformArrowFunction: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, "transformArrowFunction").call(this, tree);\n      },\n      transformFunctionDeclaration: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, "transformFunctionDeclaration").call(this, tree);\n      },\n      transformFunctionExpression: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, "transformFunctionExpression").call(this, tree);\n      },\n      transformGetAccessor: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, "transformGetAccessor").call(this, tree);\n      },\n      transformSetAccessor: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, "transformSetAccessor").call(this, tree);\n      },\n      transformMethod: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, "transformMethod").call(this, tree);\n      },\n      transformFunctionBody: function(tree) {\n        var transformedTree = $traceurRuntime.superGet(this, ParameterTransformer.prototype, "transformFunctionBody").call(this, tree);\n        var statements = stack.pop();\n        if (!statements.length)\n          return transformedTree;\n        statements = prependStatements.apply((void 0), $traceurRuntime.spread([transformedTree.statements], statements));\n        return new FunctionBody(transformedTree.location, statements);\n      },\n      get parameterStatements() {\n        return stack[stack.length - 1];\n      },\n      transformConstructorType: function(tree) {\n        return tree;\n      },\n      transformFunctionType: function(tree) {\n        return tree;\n      }\n    }, {}, $__super);\n  }(TempVarTransformer);\n  return {get ParameterTransformer() {\n      return ParameterTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../semantics/util.js", "traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js")),\n      isUndefined = $__1.isUndefined,\n      isVoidExpression = $__1.isVoidExpression;\n  var FormalParameterList = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js")).FormalParameterList;\n  var ParameterTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParameterTransformer.js", "traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js")).ParameterTransformer;\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js")).ARGUMENTS;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js")),\n      NOT_EQUAL_EQUAL = $__5.NOT_EQUAL_EQUAL,\n      VAR = $__5.VAR;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js")),\n      createBinaryExpression = $__6.createBinaryExpression,\n      createConditionalExpression = $__6.createConditionalExpression,\n      createIdentifierExpression = $__6.createIdentifierExpression,\n      createMemberLookupExpression = $__6.createMemberLookupExpression,\n      createNumberLiteral = $__6.createNumberLiteral,\n      createOperatorToken = $__6.createOperatorToken,\n      createVariableStatement = $__6.createVariableStatement,\n      createVoid0 = $__6.createVoid0;\n  function createDefaultAssignment(index, binding, initializer) {\n    var argumentsExpression = createMemberLookupExpression(createIdentifierExpression(ARGUMENTS), createNumberLiteral(index));\n    var assignmentExpression;\n    if (initializer === null || isUndefined(initializer) || isVoidExpression(initializer)) {\n      assignmentExpression = argumentsExpression;\n    } else {\n      assignmentExpression = createConditionalExpression(createBinaryExpression(argumentsExpression, createOperatorToken(NOT_EQUAL_EQUAL), createVoid0()), argumentsExpression, initializer);\n    }\n    return createVariableStatement(VAR, binding, assignmentExpression);\n  }\n  var DefaultParametersTransformer = function($__super) {\n    function DefaultParametersTransformer() {\n      $traceurRuntime.superConstructor(DefaultParametersTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(DefaultParametersTransformer, {transformFormalParameterList: function(tree) {\n        var parameters = [];\n        var changed = false;\n        var defaultToUndefined = false;\n        for (var i = 0; i < tree.parameters.length; i++) {\n          var param = this.transformAny(tree.parameters[i]);\n          if (param !== tree.parameters[i])\n            changed = true;\n          if (param.isRestParameter() || !param.parameter.initializer && !defaultToUndefined) {\n            parameters.push(param);\n          } else {\n            defaultToUndefined = true;\n            changed = true;\n            this.parameterStatements.push(createDefaultAssignment(i, param.parameter.binding, param.parameter.initializer));\n          }\n        }\n        if (!changed)\n          return tree;\n        return new FormalParameterList(tree.location, parameters);\n      }}, {}, $__super);\n  }(ParameterTransformer);\n  return {get DefaultParametersTransformer() {\n      return DefaultParametersTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/assignmentOperatorToBinaryOperator.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/assignmentOperatorToBinaryOperator.js";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/assignmentOperatorToBinaryOperator.js")),\n      AMPERSAND = $__0.AMPERSAND,\n      AMPERSAND_EQUAL = $__0.AMPERSAND_EQUAL,\n      BAR = $__0.BAR,\n      BAR_EQUAL = $__0.BAR_EQUAL,\n      CARET = $__0.CARET,\n      CARET_EQUAL = $__0.CARET_EQUAL,\n      LEFT_SHIFT = $__0.LEFT_SHIFT,\n      LEFT_SHIFT_EQUAL = $__0.LEFT_SHIFT_EQUAL,\n      MINUS = $__0.MINUS,\n      MINUS_EQUAL = $__0.MINUS_EQUAL,\n      PERCENT = $__0.PERCENT,\n      PERCENT_EQUAL = $__0.PERCENT_EQUAL,\n      PLUS = $__0.PLUS,\n      PLUS_EQUAL = $__0.PLUS_EQUAL,\n      RIGHT_SHIFT = $__0.RIGHT_SHIFT,\n      RIGHT_SHIFT_EQUAL = $__0.RIGHT_SHIFT_EQUAL,\n      SLASH = $__0.SLASH,\n      SLASH_EQUAL = $__0.SLASH_EQUAL,\n      STAR = $__0.STAR,\n      STAR_EQUAL = $__0.STAR_EQUAL,\n      STAR_STAR = $__0.STAR_STAR,\n      STAR_STAR_EQUAL = $__0.STAR_STAR_EQUAL,\n      UNSIGNED_RIGHT_SHIFT = $__0.UNSIGNED_RIGHT_SHIFT,\n      UNSIGNED_RIGHT_SHIFT_EQUAL = $__0.UNSIGNED_RIGHT_SHIFT_EQUAL;\n  function assignmentOperatorToBinaryOperator(type) {\n    switch (type) {\n      case STAR_EQUAL:\n        return STAR;\n      case STAR_STAR_EQUAL:\n        return STAR_STAR;\n      case SLASH_EQUAL:\n        return SLASH;\n      case PERCENT_EQUAL:\n        return PERCENT;\n      case PLUS_EQUAL:\n        return PLUS;\n      case MINUS_EQUAL:\n        return MINUS;\n      case LEFT_SHIFT_EQUAL:\n        return LEFT_SHIFT;\n      case RIGHT_SHIFT_EQUAL:\n        return RIGHT_SHIFT;\n      case UNSIGNED_RIGHT_SHIFT_EQUAL:\n        return UNSIGNED_RIGHT_SHIFT;\n      case AMPERSAND_EQUAL:\n        return AMPERSAND;\n      case CARET_EQUAL:\n        return CARET;\n      case BAR_EQUAL:\n        return BAR;\n      default:\n        throw Error(\'unreachable\');\n    }\n  }\n  var $__default = assignmentOperatorToBinaryOperator;\n  return {get default() {\n      return $__default;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js")).ParseTreeTransformer;\n  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js")),\n      createAssignmentExpression = $__13.createAssignmentExpression,\n      createCommaExpression = $__13.createCommaExpression,\n      id = $__13.createIdentifierExpression,\n      createMemberExpression = $__13.createMemberExpression,\n      createNumberLiteral = $__13.createNumberLiteral,\n      createOperatorToken = $__13.createOperatorToken,\n      createParenExpression = $__13.createParenExpression;\n  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js")),\n      AND = $__14.AND,\n      EQUAL = $__14.EQUAL,\n      MINUS = $__14.MINUS,\n      MINUS_EQUAL = $__14.MINUS_EQUAL,\n      MINUS_MINUS = $__14.MINUS_MINUS,\n      OR = $__14.OR,\n      PLUS = $__14.PLUS,\n      PLUS_EQUAL = $__14.PLUS_EQUAL,\n      PLUS_PLUS = $__14.PLUS_PLUS;\n  var $__15 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js")),\n      COMMA_EXPRESSION = $__15.COMMA_EXPRESSION,\n      IDENTIFIER_EXPRESSION = $__15.IDENTIFIER_EXPRESSION,\n      MEMBER_EXPRESSION = $__15.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__15.MEMBER_LOOKUP_EXPRESSION,\n      PROPERTY_NAME_ASSIGNMENT = $__15.PROPERTY_NAME_ASSIGNMENT,\n      SPREAD_EXPRESSION = $__15.SPREAD_EXPRESSION,\n      TEMPLATE_LITERAL_PORTION = $__15.TEMPLATE_LITERAL_PORTION;\n  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js")),\n      ArgumentList = $__16.ArgumentList,\n      ArrayLiteral = $__16.ArrayLiteral,\n      AwaitExpression = $__16.AwaitExpression,\n      BinaryExpression = $__16.BinaryExpression,\n      CallExpression = $__16.CallExpression,\n      ClassExpression = $__16.ClassExpression,\n      ConditionalExpression = $__16.ConditionalExpression,\n      MemberExpression = $__16.MemberExpression,\n      MemberLookupExpression = $__16.MemberLookupExpression,\n      NewExpression = $__16.NewExpression,\n      ObjectLiteral = $__16.ObjectLiteral,\n      PropertyNameAssignment = $__16.PropertyNameAssignment,\n      SpreadExpression = $__16.SpreadExpression,\n      TemplateLiteralExpression = $__16.TemplateLiteralExpression,\n      TemplateSubstitution = $__16.TemplateSubstitution,\n      UnaryExpression = $__16.UnaryExpression,\n      YieldExpression = $__16.YieldExpression;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/assert.js", "traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js")).assert;\n  var assignmentOperatorToBinaryOperator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./assignmentOperatorToBinaryOperator.js", "traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js")).default;\n  var CommaExpressionBuilder = function() {\n    function CommaExpressionBuilder(tempVar) {\n      this.tempVar = tempVar;\n      this.expressions = [];\n    }\n    return ($traceurRuntime.createClass)(CommaExpressionBuilder, {\n      add: function(tree) {\n        var $__2;\n        if (tree.type === COMMA_EXPRESSION)\n          ($__2 = this.expressions).push.apply($__2, $traceurRuntime.spread(getExpressions(tree)));\n        return this;\n      },\n      build: function(tree) {\n        var tempVar = this.tempVar;\n        this.expressions.push(createAssignmentExpression(tempVar, tree), tempVar);\n        return createCommaExpression(this.expressions);\n      }\n    }, {});\n  }();\n  function getResult(tree) {\n    if (tree.type === COMMA_EXPRESSION)\n      return tree.expressions[tree.expressions.length - 1];\n    return tree;\n  }\n  function getExpressions(tree) {\n    if (tree.type === COMMA_EXPRESSION)\n      return tree.expressions.slice(0, -1);\n    return [];\n  }\n  var ExplodeExpressionTransformer = function($__super) {\n    function ExplodeExpressionTransformer(tempVarTransformer) {\n      $traceurRuntime.superConstructor(ExplodeExpressionTransformer).call(this);\n      this.tempVarTransformer_ = tempVarTransformer;\n    }\n    return ($traceurRuntime.createClass)(ExplodeExpressionTransformer, {\n      addTempVar: function() {\n        var tmpId = this.tempVarTransformer_.addTempVar();\n        return id(tmpId);\n      },\n      transformUnaryExpression: function(tree) {\n        if (tree.operator.type === PLUS_PLUS)\n          return this.transformUnaryNumeric_(tree, PLUS_EQUAL);\n        if (tree.operator.type === MINUS_MINUS)\n          return this.transformUnaryNumeric_(tree, MINUS_EQUAL);\n        var operand = this.transformAny(tree.operand);\n        if (operand === tree.operand)\n          return tree;\n        var expressions = $traceurRuntime.spread(getExpressions(operand), [new UnaryExpression(tree.location, tree.operator, getResult(operand))]);\n        return createCommaExpression(expressions);\n      },\n      transformUnaryNumeric_: function(tree, operator) {\n        return this.transformAny(new BinaryExpression(tree.location, tree.operand, createOperatorToken(operator), createNumberLiteral(1)));\n      },\n      transformPostfixExpression: function(tree) {\n        if (tree.operand.type === MEMBER_EXPRESSION)\n          return this.transformPostfixMemberExpression_(tree);\n        if (tree.operand.type === MEMBER_LOOKUP_EXPRESSION)\n          return this.transformPostfixMemberLookupExpression_(tree);\n        assert(tree.operand.type === IDENTIFIER_EXPRESSION);\n        var operand = tree.operand;\n        var tmp = this.addTempVar();\n        var operator = tree.operator.type === PLUS_PLUS ? PLUS : MINUS;\n        var expressions = [createAssignmentExpression(tmp, operand), createAssignmentExpression(operand, new BinaryExpression(tree.location, tmp, createOperatorToken(operator), createNumberLiteral(1))), tmp];\n        return createCommaExpression(expressions);\n      },\n      transformPostfixMemberExpression_: function(tree) {\n        var memberName = tree.operand.memberName;\n        var operand = this.transformAny(tree.operand.operand);\n        var tmp = this.addTempVar();\n        var memberExpression = new MemberExpression(tree.operand.location, getResult(operand), memberName);\n        var operator = tree.operator.type === PLUS_PLUS ? PLUS : MINUS;\n        var expressions = $traceurRuntime.spread(getExpressions(operand), [createAssignmentExpression(tmp, memberExpression), createAssignmentExpression(memberExpression, new BinaryExpression(tree.location, tmp, createOperatorToken(operator), createNumberLiteral(1))), tmp]);\n        return createCommaExpression(expressions);\n      },\n      transformPostfixMemberLookupExpression_: function(tree) {\n        var memberExpression = this.transformAny(tree.operand.memberExpression);\n        var operand = this.transformAny(tree.operand.operand);\n        var tmp = this.addTempVar();\n        var memberLookupExpression = new MemberLookupExpression(null, getResult(operand), getResult(memberExpression));\n        var operator = tree.operator.type === PLUS_PLUS ? PLUS : MINUS;\n        var expressions = $traceurRuntime.spread(getExpressions(operand), getExpressions(memberExpression), [createAssignmentExpression(tmp, memberLookupExpression), createAssignmentExpression(memberLookupExpression, new BinaryExpression(tree.location, tmp, createOperatorToken(operator), createNumberLiteral(1))), tmp]);\n        return createCommaExpression(expressions);\n      },\n      transformYieldExpression: function(tree) {\n        if (tree.expression === null) {\n          return this.createCommaExpressionBuilder_().build(new YieldExpression(tree.location, null, false));\n        }\n        var expression = this.transformAny(tree.expression);\n        return this.createCommaExpressionBuilder_().add(expression).build(new YieldExpression(tree.location, getResult(expression), tree.isYieldFor));\n      },\n      transformAwaitExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        return this.createCommaExpressionBuilder_().add(expression).build(new AwaitExpression(tree.location, getResult(expression)));\n      },\n      transformParenExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression)\n          return tree;\n        var result = getResult(expression);\n        if (result.type === IDENTIFIER_EXPRESSION)\n          return expression;\n        return this.createCommaExpressionBuilder_().add(expression).build(result);\n      },\n      transformCommaExpression: function(tree) {\n        var expressions = this.transformList(tree.expressions);\n        if (expressions === tree.expressions)\n          return tree;\n        var builder = new CommaExpressionBuilder(null);\n        for (var i = 0; i < expressions.length; i++) {\n          builder.add(expressions[i]);\n        }\n        return createCommaExpression($traceurRuntime.spread(builder.expressions, [getResult(expressions[expressions.length - 1])]));\n      },\n      transformMemberExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        return this.createCommaExpressionBuilder_().add(operand).build(new MemberExpression(tree.location, getResult(operand), tree.memberName));\n      },\n      transformMemberLookupExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var memberExpression = this.transformAny(tree.memberExpression);\n        return this.createCommaExpressionBuilder_().add(operand).add(memberExpression).build(new MemberLookupExpression(tree.location, getResult(operand), getResult(memberExpression)));\n      },\n      transformBinaryExpression: function(tree) {\n        if (tree.operator.isAssignmentOperator())\n          return this.transformAssignmentExpression_(tree);\n        var left = this.transformAny(tree.left);\n        var right = this.transformAny(tree.right);\n        if (left === tree.left && right === tree.right)\n          return tree;\n        if (tree.operator.type === OR)\n          return this.transformOr_(left, right);\n        if (tree.operator.type === AND)\n          return this.transformAnd_(left, right);\n        var expressions = $traceurRuntime.spread(getExpressions(left), getExpressions(right), [new BinaryExpression(tree.location, getResult(left), tree.operator, getResult(right))]);\n        return createCommaExpression(expressions);\n      },\n      transformAssignmentExpression_: function(tree) {\n        var left = tree.left;\n        if (left.type === MEMBER_EXPRESSION)\n          return this.transformAssignMemberExpression_(tree);\n        if (left.type === MEMBER_LOOKUP_EXPRESSION)\n          return this.transformAssignMemberLookupExpression_(tree);\n        assert(tree.left.type === IDENTIFIER_EXPRESSION);\n        if (tree.operator.type === EQUAL) {\n          left = this.transformAny(left);\n          var right$__3 = this.transformAny(tree.right);\n          var expressions$__4 = $traceurRuntime.spread(getExpressions(right$__3), [createAssignmentExpression(left, getResult(right$__3)), getResult(right$__3)]);\n          return createCommaExpression(expressions$__4);\n        }\n        var right = this.transformAny(tree.right);\n        var tmp = this.addTempVar();\n        var binop = createOperatorToken(assignmentOperatorToBinaryOperator(tree.operator.type));\n        var expressions = $traceurRuntime.spread(getExpressions(right), [createAssignmentExpression(tmp, new BinaryExpression(tree.location, left, binop, getResult(right))), createAssignmentExpression(left, tmp), tmp]);\n        return createCommaExpression(expressions);\n      },\n      transformAssignMemberExpression_: function(tree) {\n        var left = tree.left;\n        if (tree.operator.type === EQUAL) {\n          var operand$__5 = this.transformAny(left.operand);\n          var right$__6 = this.transformAny(tree.right);\n          var expressions$__7 = $traceurRuntime.spread(getExpressions(operand$__5), getExpressions(right$__6), [new BinaryExpression(tree.location, new MemberExpression(left.location, getResult(operand$__5), left.memberName), tree.operator, getResult(right$__6)), getResult(right$__6)]);\n          return createCommaExpression(expressions$__7);\n        }\n        var operand = this.transformAny(left.operand);\n        var right = this.transformAny(tree.right);\n        var tmp = this.addTempVar();\n        var memberExpression = new MemberExpression(left.location, getResult(operand), left.memberName);\n        var tmp2 = this.addTempVar();\n        var binop = createOperatorToken(assignmentOperatorToBinaryOperator(tree.operator.type));\n        var expressions = $traceurRuntime.spread(getExpressions(operand), getExpressions(right), [createAssignmentExpression(tmp, memberExpression), createAssignmentExpression(tmp2, new BinaryExpression(tree.location, tmp, binop, getResult(right))), createAssignmentExpression(memberExpression, tmp2), tmp2]);\n        return createCommaExpression(expressions);\n      },\n      transformAssignMemberLookupExpression_: function(tree) {\n        var left = tree.left;\n        if (tree.operator.type === EQUAL) {\n          var operand$__8 = this.transformAny(left.operand);\n          var memberExpression$__9 = this.transformAny(left.memberExpression);\n          var right$__10 = this.transformAny(tree.right);\n          var expressions$__11 = $traceurRuntime.spread(getExpressions(operand$__8), getExpressions(memberExpression$__9), getExpressions(right$__10), [new BinaryExpression(tree.location, new MemberLookupExpression(left.location, getResult(operand$__8), getResult(memberExpression$__9)), tree.operator, getResult(right$__10)), getResult(right$__10)]);\n          return createCommaExpression(expressions$__11);\n        }\n        var operand = this.transformAny(left.operand);\n        var memberExpression = this.transformAny(left.memberExpression);\n        var right = this.transformAny(tree.right);\n        var tmp = this.addTempVar();\n        var memberLookupExpression = new MemberLookupExpression(left.location, getResult(operand), getResult(memberExpression));\n        var tmp2 = this.addTempVar();\n        var binop = createOperatorToken(assignmentOperatorToBinaryOperator(tree.operator.type));\n        var expressions = $traceurRuntime.spread(getExpressions(operand), getExpressions(memberExpression), getExpressions(right), [createAssignmentExpression(tmp, memberLookupExpression), createAssignmentExpression(tmp2, new BinaryExpression(tree.location, tmp, binop, getResult(right))), createAssignmentExpression(memberLookupExpression, tmp2), tmp2]);\n        return createCommaExpression(expressions);\n      },\n      transformArrayLiteral: function(tree) {\n        var elements = this.transformList(tree.elements);\n        if (elements === tree.elements)\n          return tree;\n        var builder = this.createCommaExpressionBuilder_();\n        var results = [];\n        for (var i = 0; i < elements.length; i++) {\n          builder.add(elements[i]);\n          results.push(getResult(elements[i]));\n        }\n        return builder.build(new ArrayLiteral(tree.location, results));\n      },\n      transformObjectLiteral: function(tree) {\n        var propertyNameAndValues = this.transformList(tree.propertyNameAndValues);\n        if (propertyNameAndValues === tree.propertyNameAndValues)\n          return tree;\n        var builder = this.createCommaExpressionBuilder_();\n        var results = [];\n        for (var i = 0; i < propertyNameAndValues.length; i++) {\n          if (propertyNameAndValues[i].type === PROPERTY_NAME_ASSIGNMENT) {\n            builder.add(propertyNameAndValues[i].value);\n            results.push(new PropertyNameAssignment(propertyNameAndValues[i].location, propertyNameAndValues[i].name, getResult(propertyNameAndValues[i].value)));\n          } else {\n            results.push(propertyNameAndValues[i]);\n          }\n        }\n        return builder.build(new ObjectLiteral(tree.location, results));\n      },\n      transformTemplateLiteralExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var elements = this.transformList(tree.elements);\n        if (!operand && operand === tree.operand && elements === tree.elements)\n          return tree;\n        var builder = this.createCommaExpressionBuilder_();\n        if (operand)\n          builder.add(operand);\n        var results = [];\n        for (var i = 0; i < elements.length; i++) {\n          if (elements[i].type === TEMPLATE_LITERAL_PORTION) {\n            results.push(elements[i]);\n          } else {\n            var expression = elements[i].expression;\n            builder.add(expression);\n            var result = getResult(expression);\n            results.push(new TemplateSubstitution(expression.location, result));\n          }\n        }\n        return builder.build(new TemplateLiteralExpression(tree.location, operand && getResult(operand), results));\n      },\n      transformCallExpression: function(tree) {\n        if (tree.operand.type === MEMBER_EXPRESSION)\n          return this.transformCallMemberExpression_(tree);\n        if (tree.operand.type === MEMBER_LOOKUP_EXPRESSION)\n          return this.transformCallMemberLookupExpression_(tree);\n        return this.transformCallAndNew_(tree, CallExpression);\n      },\n      transformNewExpression: function(tree) {\n        return this.transformCallAndNew_(tree, NewExpression);\n      },\n      transformCallAndNew_: function(tree, ctor) {\n        var operand = this.transformAny(tree.operand);\n        var args = this.transformAny(tree.args);\n        var builder = this.createCommaExpressionBuilder_().add(operand);\n        var argResults = [];\n        args.args.forEach(function(arg) {\n          builder.add(arg);\n          argResults.push(getResult(arg));\n        });\n        return builder.build(new ctor(tree.location, getResult(operand), new ArgumentList(args.location, argResults)));\n      },\n      transformCallMemberExpression_: function(tree) {\n        var memberName = tree.operand.memberName;\n        var operand = this.transformAny(tree.operand.operand);\n        var tmp = this.addTempVar();\n        var memberExpresssion = new MemberExpression(tree.operand.location, getResult(operand), memberName);\n        var args = this.transformAny(tree.args);\n        var expressions = $traceurRuntime.spread(getExpressions(operand), [createAssignmentExpression(tmp, memberExpresssion)]);\n        var argResults = [getResult(operand)];\n        args.args.forEach(function(arg) {\n          var $__2;\n          ($__2 = expressions).push.apply($__2, $traceurRuntime.spread(getExpressions(arg)));\n          argResults.push(getResult(arg));\n        });\n        var callExpression = new CallExpression(tree.location, createMemberExpression(tmp, \'call\'), new ArgumentList(args.location, argResults));\n        var tmp2 = this.addTempVar();\n        expressions.push(createAssignmentExpression(tmp2, callExpression), tmp2);\n        return createCommaExpression(expressions);\n      },\n      transformCallMemberLookupExpression_: function(tree) {\n        var operand = this.transformAny(tree.operand.operand);\n        var memberExpression = this.transformAny(tree.operand.memberExpression);\n        var tmp = this.addTempVar();\n        var lookupExpresssion = new MemberLookupExpression(tree.operand.location, getResult(operand), getResult(memberExpression));\n        var args = this.transformAny(tree.args);\n        var expressions = $traceurRuntime.spread(getExpressions(operand), getExpressions(memberExpression), [createAssignmentExpression(tmp, lookupExpresssion)]);\n        var argResults = [getResult(operand)];\n        args.args.forEach(function(arg, i) {\n          var $__2;\n          ($__2 = expressions).push.apply($__2, $traceurRuntime.spread(getExpressions(arg)));\n          var result = getResult(arg);\n          if (tree.args.args[i].type === SPREAD_EXPRESSION)\n            result = new SpreadExpression(arg.location, result);\n          argResults.push(result);\n        });\n        var callExpression = new CallExpression(tree.location, createMemberExpression(tmp, \'call\'), new ArgumentList(args.location, argResults));\n        var tmp2 = this.addTempVar();\n        expressions.push(createAssignmentExpression(tmp2, callExpression), tmp2);\n        return createCommaExpression(expressions);\n      },\n      transformConditionalExpression: function(tree) {\n        var condition = this.transformAny(tree.condition);\n        var left = this.transformAny(tree.left);\n        var right = this.transformAny(tree.right);\n        if (condition === tree.condition && left === tree.left && right === tree.right)\n          return tree;\n        var res = this.addTempVar();\n        var leftTree = createCommaExpression($traceurRuntime.spread(getExpressions(left), [createAssignmentExpression(res, getResult(left))]));\n        var rightTree = createCommaExpression($traceurRuntime.spread(getExpressions(right), [createAssignmentExpression(res, getResult(right))]));\n        var expressions = $traceurRuntime.spread(getExpressions(condition), [new ConditionalExpression(tree.location, getResult(condition), createParenExpression(leftTree), createParenExpression(rightTree)), res]);\n        return createCommaExpression(expressions);\n      },\n      transformOr_: function(left, right) {\n        var res = this.addTempVar();\n        var leftTree = createCommaExpression([createAssignmentExpression(res, getResult(left))]);\n        var rightTree = createCommaExpression($traceurRuntime.spread(getExpressions(right), [createAssignmentExpression(res, getResult(right))]));\n        var expressions = $traceurRuntime.spread(getExpressions(left), [new ConditionalExpression(left.location, getResult(left), createParenExpression(leftTree), createParenExpression(rightTree)), res]);\n        return createCommaExpression(expressions);\n      },\n      transformAnd_: function(left, right) {\n        var res = this.addTempVar();\n        var leftTree = createCommaExpression($traceurRuntime.spread(getExpressions(right), [createAssignmentExpression(res, getResult(right))]));\n        var rightTree = createCommaExpression([createAssignmentExpression(res, getResult(left))]);\n        var expressions = $traceurRuntime.spread(getExpressions(left), [new ConditionalExpression(left.location, getResult(left), createParenExpression(leftTree), createParenExpression(rightTree)), res]);\n        return createCommaExpression(expressions);\n      },\n      transformSpreadExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression)\n          return tree;\n        var result = getResult(expression);\n        if (result.type !== SPREAD_EXPRESSION)\n          result = new SpreadExpression(result.location, result);\n        var expressions = $traceurRuntime.spread(getExpressions(expression), [result]);\n        return createCommaExpression(expressions);\n      },\n      transformFunctionExpression: function(tree) {\n        return this.createCommaExpressionBuilder_().build(tree);\n      },\n      transformArrowFunction: function(tree) {\n        return this.createCommaExpressionBuilder_().build(tree);\n      },\n      transformClassExpression: function(tree) {\n        var superClass = this.transformAny(tree.superClass);\n        if (superClass === tree.superClass) {\n          return this.createCommaExpressionBuilder_().build(tree);\n        }\n        var builder = this.createCommaExpressionBuilder_();\n        builder.add(superClass);\n        return builder.build(new ClassExpression(tree.location, tree.name, getResult(superClass), tree.elements, tree.annotations, tree.typeParameters));\n      },\n      transformFunctionBody: function(tree) {\n        return tree;\n      },\n      createCommaExpressionBuilder_: function() {\n        return new CommaExpressionBuilder(this.addTempVar());\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get ExplodeExpressionTransformer() {\n      return ExplodeExpressionTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js";\n  var ExplodeExpressionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ExplodeExpressionTransformer.js", "traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js")).ExplodeExpressionTransformer;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js")).TempVarTransformer;\n  var ParenTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParenTrait.js", "traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js")).ParenTrait;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js")),\n      STAR_STAR = $__4.STAR_STAR,\n      STAR_STAR_EQUAL = $__4.STAR_STAR_EQUAL;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js")).parseExpression;\n  var ExponentiationTransformer = function($__super) {\n    function ExponentiationTransformer() {\n      $traceurRuntime.superConstructor(ExponentiationTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ExponentiationTransformer, {transformBinaryExpression: function(tree) {\n        switch (tree.operator.type) {\n          case STAR_STAR:\n            {\n              var left = this.transformAny(tree.left);\n              var right = this.transformAny(tree.right);\n              return parseExpression($traceurRuntime.getTemplateObject(["Math.pow(", ", ", ")"]), left, right);\n            }\n          case STAR_STAR_EQUAL:\n            {\n              var exploded = new ExplodeExpressionTransformer(this).transformAny(tree);\n              return this.transformAny(exploded);\n            }\n        }\n        return $traceurRuntime.superGet(this, ExponentiationTransformer.prototype, "transformBinaryExpression").call(this, tree);\n      }}, {}, $__super);\n  }(ParenTrait(TempVarTransformer));\n  return {get ExponentiationTransformer() {\n      return ExponentiationTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ForOfTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ForOfTransformer.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ForOfTransformer.js")),\n      FOR_OF_STATEMENT = $__1.FOR_OF_STATEMENT,\n      VARIABLE_DECLARATION_LIST = $__1.VARIABLE_DECLARATION_LIST,\n      LABELLED_STATEMENT = $__1.LABELLED_STATEMENT;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/ForOfTransformer.js")).TempVarTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ForOfTransformer.js")),\n      id = $__3.createIdentifierExpression,\n      createMemberExpression = $__3.createMemberExpression,\n      createVariableStatement = $__3.createVariableStatement;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/ForOfTransformer.js")),\n      parseStatement = $__4.parseStatement,\n      parseStatements = $__4.parseStatements;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ForOfTransformer.js")),\n      AnonBlock = $__5.AnonBlock,\n      LabelledStatement = $__5.LabelledStatement;\n  var ForOfTransformer = function($__super) {\n    function ForOfTransformer() {\n      $traceurRuntime.superConstructor(ForOfTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ForOfTransformer, {\n      transformForOfStatement: function(original) {\n        return this.transformForOfStatement_(original, []);\n      },\n      transformForOfStatement_: function(original, labelSet) {\n        var tree = $traceurRuntime.superGet(this, ForOfTransformer.prototype, "transformForOfStatement").call(this, original);\n        var iter = id(this.getTempIdentifier());\n        var result = id(this.getTempIdentifier());\n        var label = id(this.getTempIdentifier());\n        var normalCompletion = id(this.getTempIdentifier());\n        var throwCompletion = id(this.getTempIdentifier());\n        var exception = id(this.getTempIdentifier());\n        var ex = id(this.getTempIdentifier());\n        var labelledStatement;\n        var innerStatement;\n        var assignment;\n        if (tree.initializer.type === VARIABLE_DECLARATION_LIST) {\n          assignment = createVariableStatement(tree.initializer.declarationType, tree.initializer.declarations[0].lvalue, createMemberExpression(result, \'value\'));\n        } else {\n          assignment = parseStatement($traceurRuntime.getTemplateObject(["", " = ", ".value;"]), tree.initializer, result);\n        }\n        innerStatement = parseStatement($traceurRuntime.getTemplateObject(["\\n        for (var ", ",\\n                 ", " = (", ")[Symbol.iterator]();\\n             !(", " = (", " = ", ".next()).done);\\n             ", " = true) {\\n          ", "\\n          ", "\\n        }"]), result, iter, tree.collection, normalCompletion, result, iter, normalCompletion, assignment, tree.body);\n        while (labelledStatement = labelSet.pop()) {\n          innerStatement = new LabelledStatement(labelledStatement.location, labelledStatement.name, innerStatement);\n        }\n        return new AnonBlock(null, parseStatements($traceurRuntime.getTemplateObject(["\\n        var ", " = true;\\n        var ", " = false;\\n        var ", " = undefined;\\n        try {\\n          ", "\\n        } catch (", ") {\\n          ", " = true;\\n          ", " = ", ";\\n        } finally {\\n          try {\\n            if (!", " && ", ".return != null) {\\n              ", ".return();\\n            }\\n          } finally {\\n            if (", ") {\\n              throw ", ";\\n            }\\n          }\\n        }"]), normalCompletion, throwCompletion, exception, innerStatement, ex, throwCompletion, exception, ex, normalCompletion, iter, iter, throwCompletion, exception));\n      },\n      transformLabelledStatement: function(tree) {\n        var labelSet = [tree];\n        var statement = tree.statement;\n        while (statement.type === LABELLED_STATEMENT) {\n          labelSet.push(statement);\n          statement = statement.statement;\n        }\n        if (statement.type !== FOR_OF_STATEMENT) {\n          return $traceurRuntime.superGet(this, ForOfTransformer.prototype, "transformLabelledStatement").call(this, tree);\n        }\n        return this.transformForOfStatement_(statement, labelSet);\n      }\n    }, {}, $__super);\n  }(TempVarTransformer);\n  return {get ForOfTransformer() {\n      return ForOfTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js")).ParseTreeTransformer;\n  var alphaRenameThisAndArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./alphaRenameThisAndArguments.js", "traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js")).default;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js")),\n      parseStatement = $__4.parseStatement,\n      parseStatements = $__4.parseStatements;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js")),\n      AnonBlock = $__5.AnonBlock,\n      Block = $__5.Block,\n      ContinueStatement = $__5.ContinueStatement,\n      LabelledStatement = $__5.LabelledStatement,\n      ReturnStatement = $__5.ReturnStatement;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringSet.js", "traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js")).StringSet;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js")),\n      createAssignmentStatement = $__7.createAssignmentStatement,\n      createCaseClause = $__7.createCaseClause,\n      createDefaultClause = $__7.createDefaultClause,\n      id = $__7.createIdentifierExpression,\n      createNumberLiteral = $__7.createNumberLiteral,\n      createSwitchStatement = $__7.createSwitchStatement,\n      createThisExpression = $__7.createThisExpression,\n      createVariableStatement = $__7.createVariableStatement,\n      createVariableDeclaration = $__7.createVariableDeclaration,\n      createVariableDeclarationList = $__7.createVariableDeclarationList,\n      createVoid0 = $__7.createVoid0;\n  var SkipFunctionsTransformerTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SkipFunctionsTransformerTrait.js", "traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js")).default;\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js")).ARGUMENTS;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js")).VAR;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js")),\n      VARIABLE_DECLARATION_LIST = $__11.VARIABLE_DECLARATION_LIST,\n      BLOCK = $__11.BLOCK;\n  var InnerForOnTransformer = function($__super) {\n    function InnerForOnTransformer(tempIdGenerator, labelSet, options) {\n      var $__1;\n      $traceurRuntime.superConstructor(InnerForOnTransformer).call(this);\n      this.idGenerator_ = tempIdGenerator;\n      this.inLoop_ = 0;\n      this.inBreakble_ = 0;\n      this.variableDeclarations_ = [];\n      this.extractedStatements_ = [];\n      this.labelSet_ = labelSet;\n      this.labelledStatements_ = new StringSet();\n      this.observer_ = id(this.idGenerator_.getTempIdentifier());\n      this.result_ = id(this.idGenerator_.getTempIdentifier());\n      this.parentLabels_ = new StringSet();\n      this.labelSet_.forEach(($__1 = this, function(tree) {\n        $__1.parentLabels_.add(tree.name.value);\n      }));\n      this.options = options;\n    }\n    return ($traceurRuntime.createClass)(InnerForOnTransformer, {\n      transform: function(tree) {\n        var value = id(this.idGenerator_.getTempIdentifier());\n        var assignment;\n        if (tree.initializer.type === VARIABLE_DECLARATION_LIST) {\n          assignment = createVariableStatement(tree.initializer.declarationType, tree.initializer.declarations[0].lvalue, value);\n        } else {\n          assignment = parseStatement($traceurRuntime.getTemplateObject(["\\n          ", " = ", ";"]), tree.initializer, value);\n        }\n        var body;\n        if (tree.body.type === BLOCK) {\n          body = new Block(tree.body.location, $traceurRuntime.spread([assignment], tree.body.statements));\n        } else {\n          body = new Block(null, [assignment, tree.body]);\n        }\n        body = this.transformAny(body);\n        body = alphaRenameThisAndArguments(this, body);\n        this.variableDeclarations_.push(createVariableDeclaration(this.result_, createVoid0()));\n        var caseClauses = this.extractedStatements_.map(function(statement, index) {\n          return createCaseClause(createNumberLiteral(index), [statement]);\n        });\n        caseClauses.push(createCaseClause(createVoid0(), [new ContinueStatement(null, null)]));\n        caseClauses.push(createDefaultClause(parseStatements($traceurRuntime.getTemplateObject(["\\n        return ", ".v;"]), this.result_)));\n        var switchStatement = createSwitchStatement(this.result_, caseClauses);\n        var observeForEach = this.idGenerator_.getRuntimeExpression(\'observeForEach\');\n        var statement = parseStatement($traceurRuntime.getTemplateObject(["\\n        do {\\n          ", "\\n            await ", "(\\n              ", "[Symbol.observer].bind(", "),\\n              async function (", ") {\\n                var ", " = this;\\n                try {\\n                  ", "\\n                } catch (e) {\\n                  ", ".throw(e);\\n                }\\n              });\\n          ", "\\n        } while (false);"]), createVariableStatement(createVariableDeclarationList(VAR, this.variableDeclarations_)), observeForEach, tree.observable, tree.observable, value, this.observer_, body, this.observer_, switchStatement);\n        var labelledStatement;\n        while (labelledStatement = this.labelSet_.pop()) {\n          statement = new LabelledStatement(labelledStatement.location, labelledStatement.name, statement);\n        }\n        return statement;\n      },\n      addTempVarForArguments: function() {\n        var tmpVarName = this.idGenerator_.generateUniqueIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, id(ARGUMENTS)));\n        return tmpVarName;\n      },\n      addTempVarForThis: function() {\n        var tmpVarName = this.idGenerator_.generateUniqueIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, createThisExpression()));\n        return tmpVarName;\n      },\n      transformAny: function(tree) {\n        if (tree) {\n          if (tree.isBreakableStatement())\n            this.inBreakble_++;\n          if (tree.isIterationStatement())\n            this.inLoop_++;\n          tree = $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, "transformAny").call(this, tree);\n          if (tree.isBreakableStatement())\n            this.inBreakble_--;\n          if (tree.isIterationStatement())\n            this.inLoop_--;\n        }\n        return tree;\n      },\n      transformReturnStatement: function(tree) {\n        return new AnonBlock(tree.location, parseStatements($traceurRuntime.getTemplateObject(["\\n        ", ".return();\\n        ", " = {v: ", "};\\n        return;"]), this.observer_, this.result_, (tree.expression || createVoid0())));\n      },\n      transformAbruptCompletion_: function(tree) {\n        this.extractedStatements_.push(tree);\n        var index = this.extractedStatements_.length - 1;\n        return new AnonBlock(null, parseStatements($traceurRuntime.getTemplateObject(["\\n        ", ".return();\\n        ", " = ", ";\\n        return;"]), this.observer_, this.result_, index));\n      },\n      transformBreakStatement: function(tree) {\n        if (!tree.name) {\n          if (this.inBreakble_) {\n            return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, "transformBreakStatement").call(this, tree);\n          }\n          return this.transformAbruptCompletion_(new ContinueStatement(tree.location, null));\n        }\n        if (this.labelledStatements_.has(tree.name.value)) {\n          return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, "transformBreakStatement").call(this, tree);\n        }\n        return this.transformAbruptCompletion_(tree);\n      },\n      transformContinueStatement: function(tree) {\n        if (!tree.name) {\n          if (this.inLoop_) {\n            return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, "transformContinueStatement").call(this, tree);\n          }\n          return new ReturnStatement(tree.location, null);\n        }\n        if (this.labelledStatements_.has(tree.name.value)) {\n          return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, "transformContinueStatement").call(this, tree);\n        }\n        if (this.parentLabels_.has(tree.name.value)) {\n          return new ReturnStatement(tree.location, null);\n        }\n        return this.transformAbruptCompletion_(tree);\n      },\n      transformLabelledStatement: function(tree) {\n        this.labelledStatements_.add(tree.name.value);\n        return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, "transformLabelledStatement").call(this, tree);\n      },\n      transformVariableStatement: function(tree) {\n        var $__1 = this;\n        if (tree.declarations.declarationType === VAR) {\n          var assignments = [];\n          tree.declarations.declarations.forEach(function(variableDeclaration) {\n            var variableName = variableDeclaration.lvalue.getStringValue();\n            var initializer = $traceurRuntime.superGet($__1, InnerForOnTransformer.prototype, "transformAny").call($__1, variableDeclaration.initializer);\n            $__1.variableDeclarations_.push(createVariableDeclaration(variableName, null));\n            assignments.push(createAssignmentStatement(id(variableName), initializer));\n          });\n          return new AnonBlock(null, assignments);\n        }\n        return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, "transformVariableStatement").call(this, tree);\n      }\n    }, {transform: function(tempIdGenerator, tree, labelSet) {\n        return new InnerForOnTransformer(tempIdGenerator, labelSet).transform(tree);\n      }}, $__super);\n  }(SkipFunctionsTransformerTrait(ParseTreeTransformer));\n  return {get InnerForOnTransformer() {\n      return InnerForOnTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ForOnTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ForOnTransformer.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ForOnTransformer.js")),\n      FOR_ON_STATEMENT = $__1.FOR_ON_STATEMENT,\n      LABELLED_STATEMENT = $__1.LABELLED_STATEMENT;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/ForOnTransformer.js")).default;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/ForOnTransformer.js")).TempVarTransformer;\n  var InnerForOnTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./InnerForOnTransformer.js", "traceur@0.0.111/src/codegeneration/ForOnTransformer.js")).InnerForOnTransformer;\n  var ForOnTransformer = function($__super) {\n    function ForOnTransformer() {\n      $traceurRuntime.superConstructor(ForOnTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ForOnTransformer, {\n      transformForOnStatement: function(original) {\n        return this.transformForOnStatement_(original, []);\n      },\n      transformForOnStatement_: function(original, labelSet) {\n        return InnerForOnTransformer.transform(this, $traceurRuntime.superGet(this, ForOnTransformer.prototype, "transformForOnStatement").call(this, original), labelSet);\n      },\n      transformLabelledStatement: function(tree) {\n        var labelSet = [tree];\n        var statement;\n        for (statement = tree.statement; statement.type === LABELLED_STATEMENT; statement = statement.statement) {\n          labelSet.push(statement);\n        }\n        if (statement.type !== FOR_ON_STATEMENT) {\n          return $traceurRuntime.superGet(this, ForOnTransformer.prototype, "transformLabelledStatement").call(this, tree);\n        }\n        return this.transformForOnStatement_(statement, labelSet);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get ForOnTransformer() {\n      return ForOnTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/GeneratorComprehensionTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/GeneratorComprehensionTransformer.js";\n  var ComprehensionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ComprehensionTransformer.js", "traceur@0.0.111/src/codegeneration/GeneratorComprehensionTransformer.js")).ComprehensionTransformer;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/GeneratorComprehensionTransformer.js")).parseStatement;\n  var GeneratorComprehensionTransformer = function($__super) {\n    function GeneratorComprehensionTransformer() {\n      $traceurRuntime.superConstructor(GeneratorComprehensionTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(GeneratorComprehensionTransformer, {transformGeneratorComprehension: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        var statement = parseStatement($traceurRuntime.getTemplateObject(["yield ", ""]), expression);\n        var isGenerator = true;\n        return this.transformComprehension(tree, statement, isGenerator);\n      }}, {}, $__super);\n  }(ComprehensionTransformer);\n  return {get GeneratorComprehensionTransformer() {\n      return GeneratorComprehensionTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/State.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/State.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/generator/State.js")),\n      createAssignStateStatement = $__1.createAssignStateStatement,\n      createBreakStatement = $__1.createBreakStatement,\n      createCaseClause = $__1.createCaseClause,\n      createNumberLiteral = $__1.createNumberLiteral;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/generator/State.js")).parseStatement;\n  var State = function() {\n    function State(id) {\n      this.id = id;\n    }\n    return ($traceurRuntime.createClass)(State, {\n      transformMachineState: function(enclosingFinally, machineEndState, reporter) {\n        return createCaseClause(createNumberLiteral(this.id), this.transform(enclosingFinally, machineEndState, reporter));\n      },\n      transformBreak: function(labelSet, breakState) {\n        return this;\n      },\n      transformBreakOrContinue: function(labelSet) {\n        var breakState = arguments[1];\n        var continueState = arguments[2];\n        return this;\n      }\n    }, {});\n  }();\n  State.START_STATE = 0;\n  State.INVALID_STATE = -1;\n  State.END_STATE = -2;\n  State.RETHROW_STATE = -3;\n  State.generateJump = function(enclosingFinally, fallThroughState) {\n    return $traceurRuntime.spread(State.generateAssignState(enclosingFinally, fallThroughState), [createBreakStatement()]);\n  };\n  State.generateAssignState = function(enclosingFinally, fallThroughState) {\n    var assignState;\n    if (State.isFinallyExit(enclosingFinally, fallThroughState)) {\n      assignState = generateAssignStateOutOfFinally(enclosingFinally, fallThroughState);\n    } else {\n      assignState = [createAssignStateStatement(fallThroughState)];\n    }\n    return assignState;\n  };\n  State.isFinallyExit = function(enclosingFinally, destination) {\n    return !!enclosingFinally && enclosingFinally.tryStates.indexOf(destination) < 0;\n  };\n  function generateAssignStateOutOfFinally(enclosingFinally, destination) {\n    var finallyState = enclosingFinally.finallyState;\n    return [createAssignStateStatement(finallyState), parseStatement($traceurRuntime.getTemplateObject(["$ctx.finallyFallThrough = ", ""]), destination)];\n  }\n  State.replaceStateList = function(oldStates, oldState, newState) {\n    var states = [];\n    for (var i = 0; i < oldStates.length; i++) {\n      states.push(State.replaceStateId(oldStates[i], oldState, newState));\n    }\n    return states;\n  };\n  State.replaceStateId = function(current, oldState, newState) {\n    return current === oldState ? newState : current;\n  };\n  State.replaceAllStates = function(exceptionBlocks, oldState, newState) {\n    var result = [];\n    for (var i = 0; i < exceptionBlocks.length; i++) {\n      result.push(exceptionBlocks[i].replaceState(oldState, newState));\n    }\n    return result;\n  };\n  return {get State() {\n      return State;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/AwaitState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/AwaitState.js";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/AwaitState.js")).State;\n  var parseStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/generator/AwaitState.js")).parseStatements;\n  var AwaitState = function($__super) {\n    function AwaitState(id, callbackState, expression) {\n      $traceurRuntime.superConstructor(AwaitState).call(this, id), this.callbackState = callbackState;\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(AwaitState, {\n      replaceState: function(oldState, newState) {\n        return new AwaitState(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.callbackState, oldState, newState), this.expression);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        var $__1;\n        var stateId,\n            statements;\n        if (State.isFinallyExit(enclosingFinally, this.callbackState)) {\n          stateId = enclosingFinally.finallyState;\n          statements = parseStatements($traceurRuntime.getTemplateObject(["$ctx.finallyFallThrough = ", ""]), this.callbackState);\n        } else {\n          stateId = this.callbackState;\n          statements = [];\n        }\n        ($__1 = statements).push.apply($__1, $traceurRuntime.spread(parseStatements($traceurRuntime.getTemplateObject(["Promise.resolve(", ").then(\\n          $ctx.createCallback(", "), $ctx.errback);\\n          return;"]), this.expression, stateId)));\n        return statements;\n      }\n    }, {}, $__super);\n  }(State);\n  return {get AwaitState() {\n      return AwaitState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/FallThroughState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/FallThroughState.js";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/FallThroughState.js")).State;\n  var FallThroughState = function($__super) {\n    function FallThroughState(id, fallThroughState, statements) {\n      $traceurRuntime.superConstructor(FallThroughState).call(this, id);\n      this.fallThroughState = fallThroughState;\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(FallThroughState, {\n      replaceState: function(oldState, newState) {\n        return new FallThroughState(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.statements);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        return $traceurRuntime.spread(this.statements, State.generateJump(enclosingFinally, this.fallThroughState));\n      }\n    }, {}, $__super);\n  }(State);\n  return {get FallThroughState() {\n      return FallThroughState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/BreakState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/BreakState.js";\n  var FallThroughState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FallThroughState.js", "traceur@0.0.111/src/codegeneration/generator/BreakState.js")).FallThroughState;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/BreakState.js")).State;\n  var BreakState = function($__super) {\n    function BreakState(id, label) {\n      $traceurRuntime.superConstructor(BreakState).call(this, id);\n      this.label = label;\n    }\n    return ($traceurRuntime.createClass)(BreakState, {\n      replaceState: function(oldState, newState) {\n        return new BreakState(State.replaceStateId(this.id, oldState, newState), this.label);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        throw new Error(\'These should be removed before the transform step\');\n      },\n      transformBreak: function(labelSet) {\n        var breakState = arguments[1];\n        if (this.label === null)\n          return new FallThroughState(this.id, breakState, []);\n        if (labelSet.has(this.label)) {\n          return new FallThroughState(this.id, labelSet.get(this.label).fallThroughState, []);\n        }\n        return this;\n      },\n      transformBreakOrContinue: function(labelSet) {\n        var breakState = arguments[1];\n        var continueState = arguments[2];\n        return this.transformBreak(labelSet, breakState);\n      }\n    }, {}, $__super);\n  }(State);\n  return {get BreakState() {\n      return BreakState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/ContinueState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/ContinueState.js";\n  var FallThroughState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FallThroughState.js", "traceur@0.0.111/src/codegeneration/generator/ContinueState.js")).FallThroughState;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/ContinueState.js")).State;\n  var ContinueState = function($__super) {\n    function ContinueState(id, label) {\n      $traceurRuntime.superConstructor(ContinueState).call(this, id);\n      this.label = label;\n    }\n    return ($traceurRuntime.createClass)(ContinueState, {\n      replaceState: function(oldState, newState) {\n        return new ContinueState(State.replaceStateId(this.id, oldState, newState), this.label);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        throw new Error(\'These should be removed before the transform step\');\n      },\n      transformBreakOrContinue: function(labelSet) {\n        var breakState = arguments[1];\n        var continueState = arguments[2];\n        if (this.label === null)\n          return new FallThroughState(this.id, continueState, []);\n        if (labelSet.has(this.label)) {\n          return new FallThroughState(this.id, labelSet.get(this.label).continueState, []);\n        }\n        return this;\n      }\n    }, {}, $__super);\n  }(State);\n  return {get ContinueState() {\n      return ContinueState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/TryState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/TryState.js";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/TryState.js")).State;\n  var Kind = {\n    CATCH: \'catch\',\n    FINALLY: \'finally\'\n  };\n  var TryState = function() {\n    function TryState(kind, tryStates, nestedTrys) {\n      this.kind = kind;\n      this.tryStates = tryStates;\n      this.nestedTrys = nestedTrys;\n    }\n    return ($traceurRuntime.createClass)(TryState, {\n      replaceAllStates: function(oldState, newState) {\n        return State.replaceStateList(this.tryStates, oldState, newState);\n      },\n      replaceNestedTrys: function(oldState, newState) {\n        var states = [];\n        for (var i = 0; i < this.nestedTrys.length; i++) {\n          states.push(this.nestedTrys[i].replaceState(oldState, newState));\n        }\n        return states;\n      }\n    }, {});\n  }();\n  TryState.Kind = Kind;\n  return {get TryState() {\n      return TryState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/trees/StateMachine.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/trees/StateMachine.js";\n  var ParseTree = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTree.js", "traceur@0.0.111/src/syntax/trees/StateMachine.js")).ParseTree;\n  var STATE_MACHINE = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeType.js", "traceur@0.0.111/src/syntax/trees/StateMachine.js")).STATE_MACHINE;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../codegeneration/generator/State.js", "traceur@0.0.111/src/syntax/trees/StateMachine.js")).State;\n  var TryState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../codegeneration/generator/TryState.js", "traceur@0.0.111/src/syntax/trees/StateMachine.js")).TryState;\n  function addCatchOrFinallyStates(kind, enclosingMap, tryStates) {\n    for (var i = 0; i < tryStates.length; i++) {\n      var tryState = tryStates[i];\n      if (tryState.kind === kind) {\n        for (var j = 0; j < tryState.tryStates.length; j++) {\n          var id = tryState.tryStates[j];\n          enclosingMap[id] = tryState;\n        }\n      }\n      addCatchOrFinallyStates(kind, enclosingMap, tryState.nestedTrys);\n    }\n  }\n  function addAllCatchStates(tryStates, catches) {\n    for (var i = 0; i < tryStates.length; i++) {\n      var tryState = tryStates[i];\n      if (tryState.kind === TryState.Kind.CATCH) {\n        catches.push(tryState);\n      }\n      addAllCatchStates(tryState.nestedTrys, catches);\n    }\n  }\n  var StateMachine = function($__super) {\n    function StateMachine(startState, fallThroughState, states, exceptionBlocks) {\n      $traceurRuntime.superConstructor(StateMachine).call(this, null);\n      this.startState = startState;\n      this.fallThroughState = fallThroughState;\n      this.states = states;\n      this.exceptionBlocks = exceptionBlocks;\n    }\n    return ($traceurRuntime.createClass)(StateMachine, {\n      get type() {\n        return STATE_MACHINE;\n      },\n      transform: function(transformer) {\n        return transformer.transformStateMachine(this);\n      },\n      visit: function(visitor) {\n        visitor.visitStateMachine(this);\n      },\n      getAllStateIDs: function() {\n        var result = [];\n        for (var i = 0; i < this.states.length; i++) {\n          result.push(this.states[i].id);\n        }\n        return result;\n      },\n      getEnclosingFinallyMap: function() {\n        var enclosingMap = Object.create(null);\n        addCatchOrFinallyStates(TryState.Kind.FINALLY, enclosingMap, this.exceptionBlocks);\n        return enclosingMap;\n      },\n      allCatchStates: function() {\n        var catches = [];\n        addAllCatchStates(this.exceptionBlocks, catches);\n        return catches;\n      },\n      replaceStateId: function(oldState, newState) {\n        return new StateMachine(State.replaceStateId(this.startState, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), State.replaceAllStates(this.states, oldState, newState), State.replaceAllStates(this.exceptionBlocks, oldState, newState));\n      },\n      replaceStartState: function(newState) {\n        return this.replaceStateId(this.startState, newState);\n      },\n      replaceFallThroughState: function(newState) {\n        return this.replaceStateId(this.fallThroughState, newState);\n      },\n      append: function(nextMachine) {\n        var states = $traceurRuntime.spread(this.states);\n        for (var i = 0; i < nextMachine.states.length; i++) {\n          var otherState = nextMachine.states[i];\n          states.push(otherState.replaceState(nextMachine.startState, this.fallThroughState));\n        }\n        var exceptionBlocks = $traceurRuntime.spread(this.exceptionBlocks);\n        for (var i$__1 = 0; i$__1 < nextMachine.exceptionBlocks.length; i$__1++) {\n          var tryState = nextMachine.exceptionBlocks[i$__1];\n          exceptionBlocks.push(tryState.replaceState(nextMachine.startState, this.fallThroughState));\n        }\n        return new StateMachine(this.startState, nextMachine.fallThroughState, states, exceptionBlocks);\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  return {get StateMachine() {\n      return StateMachine;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js";\n  var BreakState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./BreakState.js", "traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js")).BreakState;\n  var ContinueState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ContinueState.js", "traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js")).ContinueState;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js")).ParseTreeTransformer;\n  var StateMachine = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/StateMachine.js", "traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js")).StateMachine;\n  function safeGetLabel(tree) {\n    return tree.name ? tree.name.value : null;\n  }\n  var BreakContinueTransformer = function($__super) {\n    function BreakContinueTransformer(stateAllocator) {\n      $traceurRuntime.superConstructor(BreakContinueTransformer).call(this);\n      this.transformBreaks_ = true;\n      this.stateAllocator_ = stateAllocator;\n    }\n    return ($traceurRuntime.createClass)(BreakContinueTransformer, {\n      allocateState_: function() {\n        return this.stateAllocator_.allocateState();\n      },\n      stateToStateMachine_: function(newState) {\n        var fallThroughState = this.allocateState_();\n        return new StateMachine(newState.id, fallThroughState, [newState], []);\n      },\n      transformBreakStatement: function(tree) {\n        return this.transformBreaks_ || tree.name ? this.stateToStateMachine_(new BreakState(this.allocateState_(), safeGetLabel(tree))) : tree;\n      },\n      transformContinueStatement: function(tree) {\n        return this.stateToStateMachine_(new ContinueState(this.allocateState_(), safeGetLabel(tree)));\n      },\n      transformDoWhileStatement: function(tree) {\n        return tree;\n      },\n      transformForOfStatement: function(tree) {\n        return tree;\n      },\n      transformForOnStatement: function(tree) {\n        return tree;\n      },\n      transformForStatement: function(tree) {\n        return tree;\n      },\n      transformFunctionDeclaration: function(tree) {\n        return tree;\n      },\n      transformFunctionExpression: function(tree) {\n        return tree;\n      },\n      transformStateMachine: function(tree) {\n        return tree;\n      },\n      transformSwitchStatement: function(tree) {\n        var oldState = this.transformBreaks_;\n        this.transformBreaks_ = false;\n        var result = $traceurRuntime.superGet(this, BreakContinueTransformer.prototype, "transformSwitchStatement").call(this, tree);\n        this.transformBreaks_ = oldState;\n        return result;\n      },\n      transformWhileStatement: function(tree) {\n        return tree;\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get BreakContinueTransformer() {\n      return BreakContinueTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/CatchState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/CatchState.js";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/CatchState.js")).State;\n  var TryState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TryState.js", "traceur@0.0.111/src/codegeneration/generator/CatchState.js")).TryState;\n  var CatchState = function($__super) {\n    function CatchState(identifier, catchState, fallThroughState, allStates, nestedTrys) {\n      $traceurRuntime.superConstructor(CatchState).call(this, TryState.Kind.CATCH, allStates, nestedTrys);\n      this.identifier = identifier;\n      this.catchState = catchState;\n      this.fallThroughState = fallThroughState;\n    }\n    return ($traceurRuntime.createClass)(CatchState, {replaceState: function(oldState, newState) {\n        return new CatchState(this.identifier, State.replaceStateId(this.catchState, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.replaceAllStates(oldState, newState), this.replaceNestedTrys(oldState, newState));\n      }}, {}, $__super);\n  }(TryState);\n  return {get CatchState() {\n      return CatchState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/ConditionalState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/ConditionalState.js";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/ConditionalState.js")).State;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/generator/ConditionalState.js")),\n      createBlock = $__2.createBlock,\n      createIfStatement = $__2.createIfStatement;\n  var parseStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/generator/ConditionalState.js")).parseStatements;\n  var ConditionalState = function($__super) {\n    function ConditionalState(id, ifState, elseState, condition) {\n      $traceurRuntime.superConstructor(ConditionalState).call(this, id);\n      this.ifState = ifState;\n      this.elseState = elseState;\n      this.condition = condition;\n    }\n    return ($traceurRuntime.createClass)(ConditionalState, {\n      replaceState: function(oldState, newState) {\n        return new ConditionalState(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.ifState, oldState, newState), State.replaceStateId(this.elseState, oldState, newState), this.condition);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        if (State.isFinallyExit(enclosingFinally, this.ifState) || State.isFinallyExit(enclosingFinally, this.elseState)) {\n          return [createIfStatement(this.condition, createBlock(State.generateJump(enclosingFinally, this.ifState)), createBlock(State.generateJump(enclosingFinally, this.elseState)))];\n        }\n        return parseStatements($traceurRuntime.getTemplateObject(["$ctx.state = (", ") ? ", " : ", ";\\n        break"]), this.condition, this.ifState, this.elseState);\n      }\n    }, {}, $__super);\n  }(State);\n  return {get ConditionalState() {\n      return ConditionalState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/FinallyFallThroughState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/FinallyFallThroughState.js";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/FinallyFallThroughState.js")).State;\n  var FinallyFallThroughState = function($__super) {\n    function FinallyFallThroughState() {\n      $traceurRuntime.superConstructor(FinallyFallThroughState).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(FinallyFallThroughState, {\n      replaceState: function(oldState, newState) {\n        return new FinallyFallThroughState(State.replaceStateId(this.id, oldState, newState));\n      },\n      transformMachineState: function(enclosingFinally, machineEndState, reporter) {\n        return null;\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        throw new Error(\'these are generated in addFinallyFallThroughDispatches\');\n      }\n    }, {}, $__super);\n  }(State);\n  return {get FinallyFallThroughState() {\n      return FinallyFallThroughState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/FinallyState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/FinallyState.js";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/FinallyState.js")).State;\n  var TryState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TryState.js", "traceur@0.0.111/src/codegeneration/generator/FinallyState.js")).TryState;\n  var FinallyState = function($__super) {\n    function FinallyState(finallyState, fallThroughState, allStates, nestedTrys) {\n      $traceurRuntime.superConstructor(FinallyState).call(this, TryState.Kind.FINALLY, allStates, nestedTrys);\n      this.finallyState = finallyState;\n      this.fallThroughState = fallThroughState;\n    }\n    return ($traceurRuntime.createClass)(FinallyState, {replaceState: function(oldState, newState) {\n        return new FinallyState(State.replaceStateId(this.finallyState, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.replaceAllStates(oldState, newState), this.replaceNestedTrys(oldState, newState));\n      }}, {}, $__super);\n  }(TryState);\n  return {get FinallyState() {\n      return FinallyState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/StateAllocator.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/StateAllocator.js";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/StateAllocator.js")).State;\n  var StateAllocator = function() {\n    function StateAllocator() {\n      this.nextState_ = State.START_STATE + 1;\n    }\n    return ($traceurRuntime.createClass)(StateAllocator, {allocateState: function() {\n        return this.nextState_++;\n      }}, {});\n  }();\n  return {get StateAllocator() {\n      return StateAllocator;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/SwitchState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/SwitchState.js";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/generator/SwitchState.js")),\n      CaseClause = $__2.CaseClause,\n      DefaultClause = $__2.DefaultClause,\n      SwitchStatement = $__2.SwitchStatement;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/SwitchState.js")).State;\n  var createBreakStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/generator/SwitchState.js")).createBreakStatement;\n  var SwitchClause = function() {\n    function SwitchClause(first, second) {\n      this.first = first;\n      this.second = second;\n    }\n    return ($traceurRuntime.createClass)(SwitchClause, {}, {});\n  }();\n  var SwitchState = function($__super) {\n    function SwitchState(id, expression, clauses) {\n      $traceurRuntime.superConstructor(SwitchState).call(this, id);\n      this.expression = expression;\n      this.clauses = clauses;\n    }\n    return ($traceurRuntime.createClass)(SwitchState, {\n      replaceState: function(oldState, newState) {\n        var clauses = this.clauses.map(function(clause) {\n          return new SwitchClause(clause.first, State.replaceStateId(clause.second, oldState, newState));\n        });\n        return new SwitchState(State.replaceStateId(this.id, oldState, newState), this.expression, clauses);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        var clauses = [];\n        for (var i = 0; i < this.clauses.length; i++) {\n          var clause = this.clauses[i];\n          if (clause.first === null) {\n            clauses.push(new DefaultClause(null, State.generateJump(enclosingFinally, clause.second)));\n          } else {\n            clauses.push(new CaseClause(null, clause.first, State.generateJump(enclosingFinally, clause.second)));\n          }\n        }\n        return [new SwitchStatement(null, this.expression, clauses), createBreakStatement()];\n      }\n    }, {}, $__super);\n  }(State);\n  return {\n    get SwitchClause() {\n      return SwitchClause;\n    },\n    get SwitchState() {\n      return SwitchState;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js")),\n      AnonBlock = $__1.AnonBlock,\n      Catch = $__1.Catch,\n      FunctionBody = $__1.FunctionBody,\n      ForInStatement = $__1.ForInStatement,\n      ForOfStatement = $__1.ForOfStatement,\n      ForStatement = $__1.ForStatement,\n      VariableDeclarationList = $__1.VariableDeclarationList,\n      VariableStatement = $__1.VariableStatement;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js")),\n      OBJECT_PATTERN = $__2.OBJECT_PATTERN,\n      VARIABLE_DECLARATION_LIST = $__2.VARIABLE_DECLARATION_LIST;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js")).ParseTreeTransformer;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringSet.js", "traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js")).StringSet;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js")).VAR;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js")),\n      createAssignmentExpression = $__6.createAssignmentExpression,\n      createCommaExpression = $__6.createCommaExpression,\n      createExpressionStatement = $__6.createExpressionStatement,\n      id = $__6.createIdentifierExpression,\n      createParenExpression = $__6.createParenExpression,\n      createVariableDeclaration = $__6.createVariableDeclaration;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js")).prependStatements;\n  var HoistVariablesTransformer = function($__super) {\n    function HoistVariablesTransformer() {\n      var shouldHoistFunctions = arguments[0] !== (void 0) ? arguments[0] : false;\n      $traceurRuntime.superConstructor(HoistVariablesTransformer).call(this);\n      this.hoistedFunctions_ = [];\n      this.hoistedVariables_ = new StringSet();\n      this.keepBindingIdentifiers_ = false;\n      this.inBlockOrFor_ = false;\n      this.shouldHoistFunctions_ = shouldHoistFunctions;\n    }\n    return ($traceurRuntime.createClass)(HoistVariablesTransformer, {\n      transformFunctionBody: function(tree) {\n        var statements = this.transformList(tree.statements);\n        if (statements === tree.statements)\n          return tree;\n        statements = this.prependVariables(statements);\n        statements = this.prependFunctions(statements);\n        return new FunctionBody(tree.location, statements);\n      },\n      addVariable: function(name) {\n        this.hoistedVariables_.add(name);\n      },\n      addFunctionDeclaration: function(tree) {\n        this.hoistedFunctions_.push(tree);\n      },\n      hasVariables: function() {\n        return !this.hoistedVariables_.isEmpty();\n      },\n      hasFunctions: function() {\n        return this.hoistedFunctions_.length > 0;\n      },\n      getVariableNames: function() {\n        return this.hoistedVariables_.valuesAsArray();\n      },\n      getVariableStatement: function() {\n        if (!this.hasVariables())\n          return new AnonBlock(null, []);\n        var declarations = this.getVariableNames().map(function(name) {\n          return createVariableDeclaration(name, null);\n        });\n        return new VariableStatement(null, new VariableDeclarationList(null, VAR, declarations));\n      },\n      getFunctions: function() {\n        return this.hoistedFunctions_;\n      },\n      prependVariables: function(statements) {\n        if (!this.hasVariables())\n          return statements;\n        return prependStatements(statements, this.getVariableStatement());\n      },\n      prependFunctions: function(statements) {\n        if (!this.hasFunctions())\n          return statements;\n        return prependStatements(statements, this.getFunctionDeclarations());\n      },\n      transformVariableStatement: function(tree) {\n        var declarations = this.transformAny(tree.declarations);\n        if (declarations === tree.declarations)\n          return tree;\n        if (declarations === null)\n          return new AnonBlock(null, []);\n        if (declarations.type === VARIABLE_DECLARATION_LIST)\n          return new VariableStatement(tree.location, declarations);\n        return createExpressionStatement(declarations);\n      },\n      transformVariableDeclaration: function(tree) {\n        var lvalue = this.transformAny(tree.lvalue);\n        var initializer = this.transformAny(tree.initializer);\n        if (initializer) {\n          var expression = createAssignmentExpression(lvalue, initializer);\n          if (lvalue.type === OBJECT_PATTERN)\n            expression = createParenExpression(expression);\n          return expression;\n        }\n        return null;\n      },\n      transformObjectPattern: function(tree) {\n        var keepBindingIdentifiers = this.keepBindingIdentifiers_;\n        this.keepBindingIdentifiers_ = true;\n        var transformed = $traceurRuntime.superGet(this, HoistVariablesTransformer.prototype, "transformObjectPattern").call(this, tree);\n        this.keepBindingIdentifiers_ = keepBindingIdentifiers;\n        return transformed;\n      },\n      transformArrayPattern: function(tree) {\n        var keepBindingIdentifiers = this.keepBindingIdentifiers_;\n        this.keepBindingIdentifiers_ = true;\n        var transformed = $traceurRuntime.superGet(this, HoistVariablesTransformer.prototype, "transformArrayPattern").call(this, tree);\n        this.keepBindingIdentifiers_ = keepBindingIdentifiers;\n        return transformed;\n      },\n      transformBindingIdentifier: function(tree) {\n        var idToken = tree.identifierToken;\n        this.addVariable(idToken.value);\n        if (this.keepBindingIdentifiers_)\n          return tree;\n        return id(idToken);\n      },\n      transformVariableDeclarationList: function(tree) {\n        if (tree.declarationType === VAR || !this.inBlockOrFor_) {\n          var expressions = this.transformList(tree.declarations);\n          expressions = expressions.filter(function(tree) {\n            return tree;\n          });\n          if (expressions.length === 0)\n            return null;\n          if (expressions.length === 1)\n            return expressions[0];\n          return createCommaExpression(expressions);\n        }\n        return tree;\n      },\n      transformCatch: function(tree) {\n        var catchBody = this.transformAny(tree.catchBody);\n        if (catchBody === tree.catchBody)\n          return tree;\n        return new Catch(tree.location, tree.binding, catchBody);\n      },\n      transformForInStatement: function(tree) {\n        return this.transformLoop_(tree, ForInStatement);\n      },\n      transformForOfStatement: function(tree) {\n        return this.transformLoop_(tree, ForOfStatement);\n      },\n      transformForOnStatement: function(tree) {\n        return this.transformLoop_(tree, ForOfStatement);\n      },\n      transformLoop_: function(tree, ctor) {\n        var initializer = this.transformLoopIninitaliser_(tree.initializer);\n        var collection = this.transformAny(tree.collection);\n        var body = this.transformAny(tree.body);\n        if (initializer === tree.initializer && collection === tree.collection && body === tree.body) {\n          return tree;\n        }\n        return new ctor(tree.location, initializer, collection, body);\n      },\n      transformLoopIninitaliser_: function(tree) {\n        if (tree.type !== VARIABLE_DECLARATION_LIST || tree.declarationType !== VAR)\n          return tree;\n        return this.transformAny(tree.declarations[0].lvalue);\n      },\n      transformForStatement: function(tree) {\n        var inBlockOrFor = this.inBlockOrFor_;\n        this.inBlockOrFor_ = true;\n        var initializer = this.transformAny(tree.initializer);\n        this.inBlockOrFor_ = inBlockOrFor;\n        var condition = this.transformAny(tree.condition);\n        var increment = this.transformAny(tree.increment);\n        var body = this.transformAny(tree.body);\n        if (initializer === tree.initializer && condition === tree.condition && increment === tree.increment && body === tree.body) {\n          return tree;\n        }\n        return new ForStatement(tree.location, initializer, condition, increment, body);\n      },\n      transformBlock: function(tree) {\n        var inBlockOrFor = this.inBlockOrFor_;\n        this.inBlockOrFor_ = true;\n        tree = $traceurRuntime.superGet(this, HoistVariablesTransformer.prototype, "transformBlock").call(this, tree);\n        this.inBlockOrFor_ = inBlockOrFor;\n        return tree;\n      },\n      addMachineVariable: function(name) {\n        this.machineVariables_[name] = true;\n      },\n      transformClassDeclaration: function(tree) {\n        return tree;\n      },\n      transformClassExpression: function(tree) {\n        return tree;\n      },\n      transformFunctionDeclaration: function(tree) {\n        if (this.shouldHoistFunctions_) {\n          this.addFunctionDeclaration(tree);\n          return new AnonBlock(null, []);\n        }\n        return tree;\n      },\n      transformFunctionExpression: function(tree) {\n        return tree;\n      },\n      transformGetAccessor: function(tree) {\n        return tree;\n      },\n      transformSetAccessor: function(tree) {\n        return tree;\n      },\n      transformMethod: function(tree) {\n        return tree;\n      },\n      transformArrowFunction: function(tree) {\n        return tree;\n      },\n      transformComprehensionFor: function(tree) {\n        return tree;\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  var $__default = HoistVariablesTransformer;\n  return {get default() {\n      return $__default;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js";\n  var AlphaRenamer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../AlphaRenamer.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).AlphaRenamer;\n  var BreakContinueTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./BreakContinueTransformer.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).BreakContinueTransformer;\n  var $__19 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")),\n      BLOCK = $__19.BLOCK,\n      CASE_CLAUSE = $__19.CASE_CLAUSE,\n      CONDITIONAL_EXPRESSION = $__19.CONDITIONAL_EXPRESSION,\n      EXPRESSION_STATEMENT = $__19.EXPRESSION_STATEMENT,\n      PAREN_EXPRESSION = $__19.PAREN_EXPRESSION,\n      STATE_MACHINE = $__19.STATE_MACHINE;\n  var $__20 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")),\n      AnonBlock = $__20.AnonBlock,\n      Block = $__20.Block,\n      CaseClause = $__20.CaseClause,\n      IfStatement = $__20.IfStatement,\n      SwitchStatement = $__20.SwitchStatement;\n  var CatchState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CatchState.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).CatchState;\n  var ConditionalState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ConditionalState.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).ConditionalState;\n  var ExplodeExpressionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ExplodeExpressionTransformer.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).ExplodeExpressionTransformer;\n  var FallThroughState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FallThroughState.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).FallThroughState;\n  var FinallyFallThroughState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FinallyFallThroughState.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).FinallyFallThroughState;\n  var FinallyState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FinallyState.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).FinallyState;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../FindInFunctionScope.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).FindInFunctionScope;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).ParseTreeTransformer;\n  var StringMap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../util/StringMap.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).StringMap;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).TempVarTransformer;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../util/assert.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).assert;\n  var $__32 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")),\n      parseExpression = $__32.parseExpression,\n      parseStatement = $__32.parseStatement,\n      parseStatements = $__32.parseStatements;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).State;\n  var StateAllocator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./StateAllocator.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).StateAllocator;\n  var StateMachine = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/StateMachine.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).StateMachine;\n  var $__36 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SwitchState.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")),\n      SwitchClause = $__36.SwitchClause,\n      SwitchState = $__36.SwitchState;\n  var TryState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TryState.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).TryState;\n  var $__38 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")),\n      createAssignStateStatement = $__38.createAssignStateStatement,\n      createBreakStatement = $__38.createBreakStatement,\n      createCaseClause = $__38.createCaseClause,\n      createDefaultClause = $__38.createDefaultClause,\n      createExpressionStatement = $__38.createExpressionStatement,\n      createFunctionBody = $__38.createFunctionBody,\n      id = $__38.createIdentifierExpression,\n      createMemberExpression = $__38.createMemberExpression,\n      createNumberLiteral = $__38.createNumberLiteral,\n      createSwitchStatement = $__38.createSwitchStatement;\n  var HoistVariablesTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../HoistVariablesTransformer.js", "traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js")).default;\n  var LabelState = function() {\n    function LabelState(name, continueState, fallThroughState) {\n      this.name = name;\n      this.continueState = continueState;\n      this.fallThroughState = fallThroughState;\n    }\n    return ($traceurRuntime.createClass)(LabelState, {}, {});\n  }();\n  var NeedsStateMachine = function($__super) {\n    function NeedsStateMachine() {\n      $traceurRuntime.superConstructor(NeedsStateMachine).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(NeedsStateMachine, {\n      visitBreakStatement: function(tree) {\n        this.found = true;\n      },\n      visitContinueStatement: function(tree) {\n        this.found = true;\n      },\n      visitStateMachine: function(tree) {\n        this.found = true;\n      },\n      visitYieldExpression: function(tee) {\n        this.found = true;\n      }\n    }, {}, $__super);\n  }(FindInFunctionScope);\n  function needsStateMachine(tree) {\n    var visitor = new NeedsStateMachine();\n    visitor.visitAny(tree);\n    return visitor.found;\n  }\n  var HoistVariables = function($__super) {\n    function HoistVariables() {\n      $traceurRuntime.superConstructor(HoistVariables).call(this, true);\n    }\n    return ($traceurRuntime.createClass)(HoistVariables, {\n      prependVariables: function(statements) {\n        return statements;\n      },\n      prependFunctions: function(statements) {\n        return statements;\n      }\n    }, {}, $__super);\n  }(HoistVariablesTransformer);\n  var CPSTransformer = function($__super) {\n    function CPSTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(CPSTransformer).call(this, identifierGenerator, reporter, options);\n      this.stateAllocator_ = new StateAllocator();\n      this.labelSet_ = new StringMap();\n      this.currentLabel_ = null;\n      this.hoistVariablesTransformer_ = new HoistVariables();\n    }\n    return ($traceurRuntime.createClass)(CPSTransformer, {\n      expressionNeedsStateMachine: function(tree) {\n        return false;\n      },\n      allocateState: function() {\n        return this.stateAllocator_.allocateState();\n      },\n      transformBlock: function(tree) {\n        var labels = this.getLabels_();\n        var label = this.clearCurrentLabel_();\n        var transformedTree = $traceurRuntime.superGet(this, CPSTransformer.prototype, "transformBlock").call(this, tree);\n        var machine = this.transformStatementList_(transformedTree.statements);\n        if (machine === null)\n          return transformedTree;\n        if (label) {\n          var states = [];\n          for (var i = 0; i < machine.states.length; i++) {\n            var state = machine.states[i];\n            states.push(state.transformBreakOrContinue(labels));\n          }\n          machine = new StateMachine(machine.startState, machine.fallThroughState, states, machine.exceptionBlocks);\n        }\n        return machine;\n      },\n      transformFunctionBody: function(tree) {\n        this.pushTempScope();\n        var oldLabels = this.clearLabels_();\n        var transformedTree = $traceurRuntime.superGet(this, CPSTransformer.prototype, "transformFunctionBody").call(this, tree);\n        var machine = this.transformStatementList_(transformedTree.statements);\n        this.restoreLabels_(oldLabels);\n        this.popTempScope();\n        return machine === null ? transformedTree : machine;\n      },\n      transformStatementList_: function(trees) {\n        var groups = [];\n        var newMachine;\n        for (var i = 0; i < trees.length; i++) {\n          if (trees[i].type === STATE_MACHINE) {\n            groups.push(trees[i]);\n          } else if (needsStateMachine(trees[i])) {\n            newMachine = this.ensureTransformed_(trees[i]);\n            groups.push(newMachine);\n          } else {\n            var last = groups[groups.length - 1];\n            if (!(last instanceof Array))\n              groups.push(last = []);\n            last.push(trees[i]);\n          }\n        }\n        if (groups.length === 1 && groups[0] instanceof Array)\n          return null;\n        var machine = null;\n        for (var i$__11 = 0; i$__11 < groups.length; i$__11++) {\n          if (groups[i$__11] instanceof Array) {\n            newMachine = this.statementsToStateMachine_(groups[i$__11]);\n          } else {\n            newMachine = groups[i$__11];\n          }\n          if (i$__11 === 0)\n            machine = newMachine;\n          else\n            machine = machine.append(newMachine);\n        }\n        return machine;\n      },\n      needsStateMachine_: function(statements) {\n        if (statements instanceof Array) {\n          for (var i = 0; i < statements.length; i++) {\n            if (needsStateMachine(statements[i]))\n              return true;\n          }\n          return false;\n        }\n        assert(statements instanceof SwitchStatement);\n        return needsStateMachine(statements);\n      },\n      transformCaseClause: function(tree) {\n        var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, "transformCaseClause").call(this, tree);\n        var machine = this.transformStatementList_(result.statements);\n        return machine === null ? result : new CaseClause(null, result.expression, [machine]);\n      },\n      transformDoWhileStatement: function(tree) {\n        var $__8;\n        var $__6,\n            $__7;\n        var labels = this.getLabels_();\n        var label = this.clearCurrentLabel_();\n        var machine,\n            condition,\n            body;\n        if (this.expressionNeedsStateMachine(tree.condition)) {\n          (($__6 = this.expressionToStateMachine(tree.condition), machine = $__6.machine, condition = $__6.expression, $__6));\n          body = this.transformAny(tree.body);\n        } else {\n          var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, "transformDoWhileStatement").call(this, tree);\n          (($__7 = result, condition = $__7.condition, body = $__7.body, $__7));\n          if (body.type !== STATE_MACHINE)\n            return result;\n        }\n        var loopBodyMachine = this.ensureTransformed_(body);\n        var startState = loopBodyMachine.startState;\n        var conditionState = loopBodyMachine.fallThroughState;\n        var fallThroughState = this.allocateState();\n        var states = [];\n        this.addLoopBodyStates_(loopBodyMachine, conditionState, fallThroughState, labels, states);\n        if (machine) {\n          machine = machine.replaceStartState(conditionState);\n          conditionState = machine.fallThroughState;\n          ($__8 = states).push.apply($__8, $traceurRuntime.spread(machine.states));\n        }\n        states.push(new ConditionalState(conditionState, startState, fallThroughState, condition));\n        machine = new StateMachine(startState, fallThroughState, states, loopBodyMachine.exceptionBlocks);\n        if (label)\n          machine = machine.replaceStateId(conditionState, label.continueState);\n        return machine;\n      },\n      addLoopBodyStates_: function(loopBodyMachine, continueState, breakState, labels, states) {\n        for (var i = 0; i < loopBodyMachine.states.length; i++) {\n          var state = loopBodyMachine.states[i];\n          states.push(state.transformBreakOrContinue(labels, breakState, continueState));\n        }\n      },\n      transformForStatement: function(tree) {\n        var $__8,\n            $__9,\n            $__10;\n        var labels = this.getLabels_();\n        var label = this.clearCurrentLabel_();\n        var tmp;\n        var initializer = null,\n            initializerMachine;\n        if (tree.initializer) {\n          if (this.expressionNeedsStateMachine(tree.initializer)) {\n            tmp = this.expressionToStateMachine(tree.initializer);\n            initializer = tmp.expression;\n            initializerMachine = tmp.machine;\n          } else {\n            initializer = this.transformAny(tree.initializer);\n          }\n        }\n        var condition = null,\n            conditionMachine;\n        if (tree.condition) {\n          if (this.expressionNeedsStateMachine(tree.condition)) {\n            tmp = this.expressionToStateMachine(tree.condition);\n            condition = tmp.expression;\n            conditionMachine = tmp.machine;\n          } else {\n            condition = this.transformAny(tree.condition);\n          }\n        }\n        var increment = null,\n            incrementMachine;\n        if (tree.increment) {\n          if (this.expressionNeedsStateMachine(tree.increment)) {\n            tmp = this.expressionToStateMachine(tree.increment);\n            increment = tmp.expression;\n            incrementMachine = tmp.machine;\n          } else {\n            increment = this.transformAny(tree.increment);\n          }\n        }\n        var body = this.transformAny(tree.body);\n        if (initializer === tree.initializer && condition === tree.condition && increment === tree.increment && body === tree.body) {\n          return tree;\n        }\n        if (!initializerMachine && !conditionMachine && !incrementMachine && body.type !== STATE_MACHINE) {\n          return new ForStatement(tree.location, initializer, condition, increment, body);\n        }\n        var loopBodyMachine = this.ensureTransformed_(body);\n        var bodyFallThroughId = loopBodyMachine.fallThroughState;\n        var fallThroughId = this.allocateState();\n        var startId;\n        var initializerStartId = initializer ? this.allocateState() : State.INVALID_STATE;\n        var conditionStartId = increment ? this.allocateState() : bodyFallThroughId;\n        var loopStartId = loopBodyMachine.startState;\n        var incrementStartId = bodyFallThroughId;\n        var states = [];\n        if (initializer) {\n          startId = initializerStartId;\n          var initialiserFallThroughId;\n          if (condition)\n            initialiserFallThroughId = conditionStartId;\n          else\n            initialiserFallThroughId = loopStartId;\n          var tmpId = initializerStartId;\n          if (initializerMachine) {\n            initializerMachine = initializerMachine.replaceStartState(initializerStartId);\n            tmpId = initializerMachine.fallThroughState;\n            ($__8 = states).push.apply($__8, $traceurRuntime.spread(initializerMachine.states));\n          }\n          states.push(new FallThroughState(tmpId, initialiserFallThroughId, [createExpressionStatement(initializer)]));\n        }\n        if (condition) {\n          if (!initializer)\n            startId = conditionStartId;\n          var tmpId$__12 = conditionStartId;\n          if (conditionMachine) {\n            conditionMachine = conditionMachine.replaceStartState(conditionStartId);\n            tmpId$__12 = conditionMachine.fallThroughState;\n            ($__9 = states).push.apply($__9, $traceurRuntime.spread(conditionMachine.states));\n          }\n          states.push(new ConditionalState(tmpId$__12, loopStartId, fallThroughId, condition));\n        }\n        if (increment) {\n          var incrementFallThroughId;\n          if (condition)\n            incrementFallThroughId = conditionStartId;\n          else\n            incrementFallThroughId = loopStartId;\n          var tmpId$__13 = incrementStartId;\n          if (incrementMachine) {\n            incrementMachine = incrementMachine.replaceStartState(incrementStartId);\n            tmpId$__13 = incrementMachine.fallThroughState;\n            ($__10 = states).push.apply($__10, $traceurRuntime.spread(incrementMachine.states));\n          }\n          states.push(new FallThroughState(tmpId$__13, incrementFallThroughId, [createExpressionStatement(increment)]));\n        }\n        if (!initializer && !condition)\n          startId = loopStartId;\n        var continueId;\n        if (increment)\n          continueId = incrementStartId;\n        else if (condition)\n          continueId = conditionStartId;\n        else\n          continueId = loopStartId;\n        if (!increment && !condition) {\n          loopBodyMachine = loopBodyMachine.replaceFallThroughState(loopBodyMachine.startState);\n        }\n        this.addLoopBodyStates_(loopBodyMachine, continueId, fallThroughId, labels, states);\n        var machine = new StateMachine(startId, fallThroughId, states, loopBodyMachine.exceptionBlocks);\n        if (label)\n          machine = machine.replaceStateId(continueId, label.continueState);\n        return machine;\n      },\n      transformForInStatement: function(tree) {\n        return tree;\n      },\n      transformForOfStatement: function(tree) {\n        throw new Error(\'for of statements should be transformed before this pass\');\n      },\n      transformIfStatement: function(tree) {\n        var $__8,\n            $__9,\n            $__10;\n        var $__6,\n            $__7;\n        var machine,\n            condition,\n            ifClause,\n            elseClause;\n        if (this.expressionNeedsStateMachine(tree.condition)) {\n          (($__6 = this.expressionToStateMachine(tree.condition), machine = $__6.machine, condition = $__6.expression, $__6));\n          ifClause = this.transformAny(tree.ifClause);\n          elseClause = this.transformAny(tree.elseClause);\n        } else {\n          var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, "transformIfStatement").call(this, tree);\n          (($__7 = result, condition = $__7.condition, ifClause = $__7.ifClause, elseClause = $__7.elseClause, $__7));\n          if (ifClause.type !== STATE_MACHINE && (elseClause === null || elseClause.type !== STATE_MACHINE)) {\n            return result;\n          }\n        }\n        ifClause = this.ensureTransformed_(ifClause);\n        elseClause = this.ensureTransformed_(elseClause);\n        var startState = this.allocateState();\n        var fallThroughState = ifClause.fallThroughState;\n        var ifState = ifClause.startState;\n        var elseState = elseClause === null ? fallThroughState : elseClause.startState;\n        var states = [];\n        var exceptionBlocks = [];\n        states.push(new ConditionalState(startState, ifState, elseState, condition));\n        ($__8 = states).push.apply($__8, $traceurRuntime.spread(ifClause.states));\n        ($__9 = exceptionBlocks).push.apply($__9, $traceurRuntime.spread(ifClause.exceptionBlocks));\n        if (elseClause !== null) {\n          this.replaceAndAddStates_(elseClause.states, elseClause.fallThroughState, fallThroughState, states);\n          ($__10 = exceptionBlocks).push.apply($__10, $traceurRuntime.spread(State.replaceAllStates(elseClause.exceptionBlocks, elseClause.fallThroughState, fallThroughState)));\n        }\n        var ifMachine = new StateMachine(startState, fallThroughState, states, exceptionBlocks);\n        if (machine)\n          ifMachine = machine.append(ifMachine);\n        return ifMachine;\n      },\n      removeEmptyStates: function(oldStates) {\n        var emptyStates = [],\n            newStates = [];\n        for (var i = 0; i < oldStates.length; i++) {\n          if (oldStates[i] instanceof FallThroughState && oldStates[i].statements.length === 0) {\n            emptyStates.push(oldStates[i]);\n          } else {\n            newStates.push(oldStates[i]);\n          }\n        }\n        for (var i$__14 = 0; i$__14 < newStates.length; i$__14++) {\n          newStates[i$__14] = emptyStates.reduce(function(state, $__6) {\n            var $__7 = $__6,\n                id = $__7.id,\n                fallThroughState = $__7.fallThroughState;\n            return state.replaceState(id, fallThroughState);\n          }, newStates[i$__14]);\n        }\n        return newStates;\n      },\n      replaceAndAddStates_: function(oldStates, oldState, newState, newStates) {\n        for (var i = 0; i < oldStates.length; i++) {\n          newStates.push(oldStates[i].replaceState(oldState, newState));\n        }\n      },\n      transformLabelledStatement: function(tree) {\n        var startState = this.allocateState();\n        var continueState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        var label = new LabelState(tree.name.value, continueState, fallThroughState);\n        var oldLabels = this.addLabel_(label);\n        this.currentLabel_ = label;\n        var result = this.transformAny(tree.statement);\n        if (result === tree.statement) {\n          result = tree;\n        } else if (result.type === STATE_MACHINE) {\n          result = result.replaceStartState(startState);\n          result = result.replaceFallThroughState(fallThroughState);\n        }\n        this.restoreLabels_(oldLabels);\n        return result;\n      },\n      getLabels_: function() {\n        return this.labelSet_;\n      },\n      restoreLabels_: function(oldLabels) {\n        this.labelSet_ = oldLabels;\n      },\n      addLabel_: function(label) {\n        var $__5 = this;\n        var oldLabels = this.labelSet_;\n        var labelSet = new StringMap();\n        this.labelSet_.forEach(function(k) {\n          return labelSet[k] = $__5.labelSet_[k];\n        });\n        labelSet.set(label.name, label);\n        this.labelSet_ = labelSet;\n        return oldLabels;\n      },\n      clearLabels_: function() {\n        var result = this.labelSet_;\n        this.labelSet_ = new StringMap();\n        return result;\n      },\n      clearCurrentLabel_: function() {\n        var result = this.currentLabel_;\n        this.currentLabel_ = null;\n        return result;\n      },\n      transformSwitchStatement: function(tree) {\n        var $__6,\n            $__7;\n        var labels = this.getLabels_();\n        var expression,\n            machine,\n            caseClauses;\n        if (this.expressionNeedsStateMachine(tree.expression)) {\n          (($__6 = this.expressionToStateMachine(tree.expression), expression = $__6.expression, machine = $__6.machine, $__6));\n          caseClauses = this.transformList(tree.caseClauses);\n        } else {\n          var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, "transformSwitchStatement").call(this, tree);\n          if (!needsStateMachine(result))\n            return result;\n          (($__7 = result, expression = $__7.expression, caseClauses = $__7.caseClauses, $__7));\n        }\n        var startState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        var nextState = fallThroughState;\n        var states = [];\n        var clauses = [];\n        var tryStates = [];\n        var hasDefault = false;\n        for (var index = caseClauses.length - 1; index >= 0; index--) {\n          var clause = caseClauses[index];\n          if (clause.type === CASE_CLAUSE) {\n            var caseClause = clause;\n            nextState = this.addSwitchClauseStates_(nextState, fallThroughState, labels, caseClause.statements, states, tryStates);\n            clauses.push(new SwitchClause(caseClause.expression, nextState));\n          } else {\n            hasDefault = true;\n            var defaultClause = clause;\n            nextState = this.addSwitchClauseStates_(nextState, fallThroughState, labels, defaultClause.statements, states, tryStates);\n            clauses.push(new SwitchClause(null, nextState));\n          }\n        }\n        if (!hasDefault) {\n          clauses.push(new SwitchClause(null, fallThroughState));\n        }\n        states.push(new SwitchState(startState, expression, clauses.reverse()));\n        var switchMachine = new StateMachine(startState, fallThroughState, states.reverse(), tryStates);\n        if (machine)\n          switchMachine = machine.append(switchMachine);\n        return switchMachine;\n      },\n      addSwitchClauseStates_: function(nextState, fallThroughState, labels, statements, states, tryStates) {\n        var $__8;\n        var machine = this.ensureTransformedList_(statements);\n        for (var i = 0; i < machine.states.length; i++) {\n          var state = machine.states[i];\n          var transformedState = state.transformBreak(labels, fallThroughState);\n          states.push(transformedState.replaceState(machine.fallThroughState, nextState));\n        }\n        ($__8 = tryStates).push.apply($__8, $traceurRuntime.spread(machine.exceptionBlocks));\n        return machine.startState;\n      },\n      transformTryStatement: function(tree) {\n        var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, "transformTryStatement").call(this, tree);\n        var $__6 = result,\n            body = $__6.body,\n            catchBlock = $__6.catchBlock,\n            finallyBlock = $__6.finallyBlock;\n        if (body.type !== STATE_MACHINE && (catchBlock === null || catchBlock.catchBody.type !== STATE_MACHINE) && (finallyBlock === null || finallyBlock.block.type !== STATE_MACHINE)) {\n          return result;\n        }\n        var outerCatchState = this.allocateState();\n        var outerFinallyState = this.allocateState();\n        var pushTryState = this.statementToStateMachine_(parseStatement($traceurRuntime.getTemplateObject(["$ctx.pushTry(\\n            ", ",\\n            ", ");"]), (catchBlock && outerCatchState), (finallyBlock && outerFinallyState)));\n        var tryMachine = this.ensureTransformed_(body);\n        tryMachine = pushTryState.append(tryMachine);\n        if (catchBlock !== null) {\n          var popTry = this.statementToStateMachine_(parseStatement($traceurRuntime.getTemplateObject(["$ctx.popTry();"])));\n          tryMachine = tryMachine.append(popTry);\n          var exceptionName = catchBlock.binding.identifierToken.value;\n          var catchMachine = this.ensureTransformed_(catchBlock.catchBody);\n          var catchStart = this.allocateState();\n          this.addMachineVariable(exceptionName);\n          var states = $traceurRuntime.spread(tryMachine.states, [new FallThroughState(catchStart, catchMachine.startState, parseStatements($traceurRuntime.getTemplateObject(["\\n              $ctx.popTry();\\n              $ctx.maybeUncatchable(); // see RETURN_SENTINEL in runtime\\n              ", " = $ctx.storedException;"]), id(exceptionName)))]);\n          this.replaceAndAddStates_(catchMachine.states, catchMachine.fallThroughState, tryMachine.fallThroughState, states);\n          tryMachine = new StateMachine(tryMachine.startState, tryMachine.fallThroughState, states, [new CatchState(exceptionName, catchStart, tryMachine.fallThroughState, tryMachine.getAllStateIDs(), tryMachine.exceptionBlocks)]);\n          tryMachine = tryMachine.replaceStateId(catchStart, outerCatchState);\n        }\n        if (finallyBlock !== null) {\n          var finallyMachine = this.ensureTransformed_(finallyBlock.block);\n          var popTry$__15 = this.statementToStateMachine_(parseStatement($traceurRuntime.getTemplateObject(["$ctx.popTry();"])));\n          finallyMachine = popTry$__15.append(finallyMachine);\n          var states$__16 = $traceurRuntime.spread(tryMachine.states, finallyMachine.states, [new FinallyFallThroughState(finallyMachine.fallThroughState)]);\n          tryMachine = new StateMachine(tryMachine.startState, tryMachine.fallThroughState, states$__16, [new FinallyState(finallyMachine.startState, finallyMachine.fallThroughState, tryMachine.getAllStateIDs(), tryMachine.exceptionBlocks)]);\n          tryMachine = tryMachine.replaceStateId(finallyMachine.startState, outerFinallyState);\n        }\n        return tryMachine;\n      },\n      transformWhileStatement: function(tree) {\n        var $__8;\n        var $__6,\n            $__7;\n        var labels = this.getLabels_();\n        var label = this.clearCurrentLabel_();\n        var condition,\n            machine,\n            body;\n        if (this.expressionNeedsStateMachine(tree.condition)) {\n          (($__6 = this.expressionToStateMachine(tree.condition), machine = $__6.machine, condition = $__6.expression, $__6));\n          body = this.transformAny(tree.body);\n        } else {\n          var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, "transformWhileStatement").call(this, tree);\n          (($__7 = result, condition = $__7.condition, body = $__7.body, $__7));\n          if (body.type !== STATE_MACHINE)\n            return result;\n        }\n        var loopBodyMachine = this.ensureTransformed_(body);\n        var startState = loopBodyMachine.fallThroughState;\n        var fallThroughState = this.allocateState();\n        var states = [];\n        var conditionStart = startState;\n        if (machine) {\n          machine = machine.replaceStartState(startState);\n          conditionStart = machine.fallThroughState;\n          ($__8 = states).push.apply($__8, $traceurRuntime.spread(machine.states));\n        }\n        states.push(new ConditionalState(conditionStart, loopBodyMachine.startState, fallThroughState, condition));\n        this.addLoopBodyStates_(loopBodyMachine, startState, fallThroughState, labels, states);\n        machine = new StateMachine(startState, fallThroughState, states, loopBodyMachine.exceptionBlocks);\n        if (label)\n          machine = machine.replaceStateId(startState, label.continueState);\n        return machine;\n      },\n      transformWithStatement: function(tree) {\n        var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, "transformWithStatement").call(this, tree);\n        if (result.body.type !== STATE_MACHINE) {\n          return result;\n        }\n        throw new Error(\'Unreachable - with statement not allowed in strict mode/harmony\');\n      },\n      generateMachineInnerFunction: function(machine) {\n        var enclosingFinallyState = machine.getEnclosingFinallyMap();\n        var SwitchStatement = createSwitchStatement(createMemberExpression(\'$ctx\', \'state\'), this.transformMachineStates(machine, State.END_STATE, State.RETHROW_STATE, enclosingFinallyState));\n        return parseExpression($traceurRuntime.getTemplateObject(["function($ctx) {\\n      while (true) ", "\\n    }"]), SwitchStatement);\n      },\n      addTempVar: function() {\n        var name = this.getTempIdentifier();\n        this.addMachineVariable(name);\n        return name;\n      },\n      addMachineVariable: function(name) {\n        this.hoistVariablesTransformer_.addVariable(name);\n      },\n      transformCpsFunctionBody: function(tree, runtimeMethod) {\n        var $__8;\n        var functionRef = arguments[2];\n        var alphaRenamedTree = AlphaRenamer.rename(tree, \'arguments\', \'$arguments\');\n        var hasArguments = alphaRenamedTree !== tree;\n        var hoistedTree = this.hoistVariablesTransformer_.transformAny(alphaRenamedTree);\n        var maybeMachine = this.transformAny(hoistedTree);\n        if (this.reporter.hadError())\n          return tree;\n        var machine;\n        if (maybeMachine.type !== STATE_MACHINE) {\n          machine = this.statementsToStateMachine_(maybeMachine.statements);\n        } else {\n          machine = new StateMachine(maybeMachine.startState, maybeMachine.fallThroughState, this.removeEmptyStates(maybeMachine.states), maybeMachine.exceptionBlocks);\n        }\n        machine = machine.replaceFallThroughState(State.END_STATE).replaceStartState(State.START_STATE);\n        var statements = [];\n        if (this.hoistVariablesTransformer_.hasFunctions())\n          ($__8 = statements).push.apply($__8, $traceurRuntime.spread(this.hoistVariablesTransformer_.getFunctions()));\n        if (this.hoistVariablesTransformer_.hasVariables())\n          statements.push(this.hoistVariablesTransformer_.getVariableStatement());\n        if (hasArguments)\n          statements.push(parseStatement($traceurRuntime.getTemplateObject(["var $arguments = arguments;"])));\n        if (functionRef) {\n          statements.push(parseStatement($traceurRuntime.getTemplateObject(["return ", "(\\n              ", ",\\n              ", ", this);"]), runtimeMethod, this.generateMachineInnerFunction(machine), functionRef));\n        } else {\n          statements.push(parseStatement($traceurRuntime.getTemplateObject(["return ", "(\\n              ", ", this);"]), runtimeMethod, this.generateMachineInnerFunction(machine)));\n        }\n        return createFunctionBody(statements);\n      },\n      transformFunctionDeclaration: function(tree) {\n        return tree;\n      },\n      transformFunctionExpression: function(tree) {\n        return tree;\n      },\n      transformGetAccessor: function(tree) {\n        return tree;\n      },\n      transformSetAccessor: function(tree) {\n        return tree;\n      },\n      transformArrowFunction: function(tree) {\n        return tree;\n      },\n      transformStateMachine: function(tree) {\n        return tree;\n      },\n      statementToStateMachine_: function(statement) {\n        var statements;\n        if (statement.type === BLOCK)\n          statements = statement.statements;\n        else\n          statements = [statement];\n        return this.statementsToStateMachine_(statements);\n      },\n      statementsToStateMachine_: function(statements) {\n        var startState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        return this.stateToStateMachine_(new FallThroughState(startState, fallThroughState, statements), fallThroughState);\n      },\n      stateToStateMachine_: function(newState, fallThroughState) {\n        return new StateMachine(newState.id, fallThroughState, [newState], []);\n      },\n      transformMachineStates: function(machine, machineEndState, rethrowState, enclosingFinallyState) {\n        var cases = [];\n        for (var i = 0; i < machine.states.length; i++) {\n          var state = machine.states[i];\n          var stateCase = state.transformMachineState(enclosingFinallyState[state.id], machineEndState, this.reporter);\n          if (stateCase !== null) {\n            cases.push(stateCase);\n          }\n        }\n        this.addFinallyFallThroughDispatches(null, machine.exceptionBlocks, cases);\n        cases.push(createDefaultClause(parseStatements($traceurRuntime.getTemplateObject(["return $ctx.end()"]))));\n        return cases;\n      },\n      addFinallyFallThroughDispatches: function(enclosingFinallyState, tryStates, cases) {\n        for (var i = 0; i < tryStates.length; i++) {\n          var tryState = tryStates[i];\n          if (tryState.kind === TryState.Kind.FINALLY) {\n            var finallyState = tryState;\n            if (enclosingFinallyState !== null) {\n              var caseClauses = [];\n              var index = 0;\n              for (var j = 0; j < enclosingFinallyState.tryStates.length; j++) {\n                var destination = enclosingFinallyState.tryStates[j];\n                index++;\n                var statements = void 0;\n                if (index < enclosingFinallyState.tryStates.length) {\n                  statements = [];\n                } else {\n                  statements = parseStatements($traceurRuntime.getTemplateObject(["\\n                  $ctx.state = $ctx.finallyFallThrough;\\n                  $ctx.finallyFallThrough = ", ";\\n                  break;"]), State.INVALID_STATE);\n                }\n                caseClauses.push(createCaseClause(createNumberLiteral(destination), statements));\n              }\n              caseClauses.push(createDefaultClause([createAssignStateStatement(enclosingFinallyState.finallyState), createBreakStatement()]));\n              cases.push(createCaseClause(createNumberLiteral(finallyState.fallThroughState), [createSwitchStatement(createMemberExpression(\'$ctx\', \'finallyFallThrough\'), caseClauses), createBreakStatement()]));\n            } else {\n              cases.push(createCaseClause(createNumberLiteral(finallyState.fallThroughState), parseStatements($traceurRuntime.getTemplateObject(["\\n                      $ctx.state = $ctx.finallyFallThrough;\\n                      break;"]))));\n            }\n            this.addFinallyFallThroughDispatches(finallyState, finallyState.nestedTrys, cases);\n          } else {\n            this.addFinallyFallThroughDispatches(enclosingFinallyState, tryState.nestedTrys, cases);\n          }\n        }\n      },\n      transformVariableDeclarationList: function(tree) {\n        this.reporter.reportError(tree.location, \'Traceur: const/let declarations in a block containing a yield are \' + \'not yet implemented\');\n        return tree;\n      },\n      maybeTransformStatement_: function(maybeTransformedStatement) {\n        var breakContinueTransformed = new BreakContinueTransformer(this.stateAllocator_).transformAny(maybeTransformedStatement);\n        if (breakContinueTransformed !== maybeTransformedStatement) {\n          breakContinueTransformed = this.transformAny(breakContinueTransformed);\n        }\n        return breakContinueTransformed;\n      },\n      ensureTransformed_: function(statement) {\n        if (statement === null) {\n          return null;\n        }\n        var maybeTransformed = this.maybeTransformStatement_(statement);\n        return maybeTransformed.type === STATE_MACHINE ? maybeTransformed : this.statementToStateMachine_(maybeTransformed);\n      },\n      ensureTransformedList_: function(statements) {\n        var maybeTransformedStatements = [];\n        var foundMachine = false;\n        for (var i = 0; i < statements.length; i++) {\n          var statement = statements[i];\n          var maybeTransformedStatement = this.maybeTransformStatement_(statement);\n          maybeTransformedStatements.push(maybeTransformedStatement);\n          if (maybeTransformedStatement.type === STATE_MACHINE) {\n            foundMachine = true;\n          }\n        }\n        if (!foundMachine) {\n          return this.statementsToStateMachine_(statements);\n        }\n        return this.transformStatementList_(maybeTransformedStatements);\n      },\n      expressionToStateMachine: function(tree) {\n        var commaExpression = new ExplodeExpressionTransformer(this).transformAny(tree);\n        var statements = new NormalizeCommaExpressionToStatementTransformer().transformAny(commaExpression).statements;\n        var lastStatement = statements.pop();\n        assert(lastStatement.type === EXPRESSION_STATEMENT);\n        var expression = lastStatement.expression;\n        statements = $traceurRuntime.superGet(this, CPSTransformer.prototype, "transformList").call(this, statements);\n        var machine = this.transformStatementList_(statements);\n        return {\n          expression: expression,\n          machine: machine\n        };\n      }\n    }, {}, $__super);\n  }(TempVarTransformer);\n  var NormalizeCommaExpressionToStatementTransformer = function($__super) {\n    function NormalizeCommaExpressionToStatementTransformer() {\n      $traceurRuntime.superConstructor(NormalizeCommaExpressionToStatementTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(NormalizeCommaExpressionToStatementTransformer, {\n      transformCommaExpression: function(tree) {\n        var $__5 = this;\n        var statements = tree.expressions.map(function(expr) {\n          if (expr.type === CONDITIONAL_EXPRESSION)\n            return $__5.transformAny(expr);\n          return createExpressionStatement(expr);\n        });\n        return new AnonBlock(tree.location, statements);\n      },\n      transformConditionalExpression: function(tree) {\n        var ifBlock = this.transformAny(tree.left);\n        var elseBlock = this.transformAny(tree.right);\n        return new IfStatement(tree.location, tree.condition, anonBlockToBlock(ifBlock), anonBlockToBlock(elseBlock));\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  function anonBlockToBlock(tree) {\n    if (tree.type === PAREN_EXPRESSION)\n      return anonBlockToBlock(tree.expression);\n    return new Block(tree.location, tree.statements);\n  }\n  return {get CPSTransformer() {\n      return CPSTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/EndState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/EndState.js";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/EndState.js")).State;\n  var EndState = function($__super) {\n    function EndState() {\n      $traceurRuntime.superConstructor(EndState).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(EndState, {\n      replaceState: function(oldState, newState) {\n        return new EndState(State.replaceStateId(this.id, oldState, newState));\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        return State.generateJump(enclosingFinally, machineEndState);\n      }\n    }, {}, $__super);\n  }(State);\n  return {get EndState() {\n      return EndState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js";\n  var AwaitState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AwaitState.js", "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js")).AwaitState;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js")),\n      BinaryExpression = $__4.BinaryExpression,\n      ExpressionStatement = $__4.ExpressionStatement;\n  var CPSTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CPSTransformer.js", "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js")).CPSTransformer;\n  var EndState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./EndState.js", "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js")).EndState;\n  var FallThroughState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FallThroughState.js", "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js")).FallThroughState;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js")).default;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js")),\n      AWAIT_EXPRESSION = $__9.AWAIT_EXPRESSION,\n      BINARY_EXPRESSION = $__9.BINARY_EXPRESSION,\n      STATE_MACHINE = $__9.STATE_MACHINE;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js")),\n      parseExpression = $__10.parseExpression,\n      parseStatement = $__10.parseStatement,\n      parseStatements = $__10.parseStatements;\n  var StateMachine = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/StateMachine.js", "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js")).StateMachine;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../FindInFunctionScope.js", "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js")).FindInFunctionScope;\n  var createUndefinedExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js")).createUndefinedExpression;\n  function isAwaitAssign(tree) {\n    return tree.type === BINARY_EXPRESSION && tree.operator.isAssignmentOperator() && tree.right.type === AWAIT_EXPRESSION && tree.left.isLeftHandSideExpression();\n  }\n  var AwaitFinder = function($__super) {\n    function AwaitFinder() {\n      $traceurRuntime.superConstructor(AwaitFinder).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(AwaitFinder, {visitAwaitExpression: function(tree) {\n        this.found = true;\n      }}, {}, $__super);\n  }(FindInFunctionScope);\n  function scopeContainsAwait(tree) {\n    var visitor = new AwaitFinder();\n    visitor.visitAny(tree);\n    return visitor.found;\n  }\n  var AsyncTransformer = function($__super) {\n    function AsyncTransformer() {\n      $traceurRuntime.superConstructor(AsyncTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(AsyncTransformer, {\n      expressionNeedsStateMachine: function(tree) {\n        if (tree === null)\n          return false;\n        return scopeContainsAwait(tree);\n      },\n      transformExpressionStatement: function(tree) {\n        var expression = tree.expression;\n        if (expression.type === AWAIT_EXPRESSION)\n          return this.transformAwaitExpression_(expression);\n        if (isAwaitAssign(expression))\n          return this.transformAwaitAssign_(expression);\n        if (this.expressionNeedsStateMachine(expression)) {\n          return this.expressionToStateMachine(expression).machine;\n        }\n        return $traceurRuntime.superGet(this, AsyncTransformer.prototype, "transformExpressionStatement").call(this, tree);\n      },\n      transformAwaitExpression: function(tree) {\n        throw new Error(\'Internal error\');\n      },\n      transformAwaitExpression_: function(tree) {\n        return this.transformAwait_(tree, tree.expression, null, null);\n      },\n      transformAwaitAssign_: function(tree) {\n        return this.transformAwait_(tree, tree.right.expression, tree.left, tree.operator);\n      },\n      transformAwait_: function(tree, inExpression, left, operator) {\n        var $__2;\n        var expression,\n            machine;\n        if (this.expressionNeedsStateMachine(inExpression)) {\n          (($__2 = this.expressionToStateMachine(inExpression), expression = $__2.expression, machine = $__2.machine, $__2));\n        } else {\n          expression = this.transformAny(inExpression);\n        }\n        var createTaskState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        var callbackState = left ? this.allocateState() : fallThroughState;\n        var states = [];\n        states.push(new AwaitState(createTaskState, callbackState, expression));\n        if (left) {\n          var statement = new ExpressionStatement(tree.location, new BinaryExpression(tree.location, left, operator, parseExpression($traceurRuntime.getTemplateObject(["$ctx.value"]))));\n          states.push(new FallThroughState(callbackState, fallThroughState, [statement]));\n        }\n        var awaitMachine = new StateMachine(createTaskState, fallThroughState, states, []);\n        if (machine) {\n          awaitMachine = machine.append(awaitMachine);\n        }\n        return awaitMachine;\n      },\n      transformFinally: function(tree) {\n        var result = $traceurRuntime.superGet(this, AsyncTransformer.prototype, "transformFinally").call(this, tree);\n        if (result.block.type !== STATE_MACHINE) {\n          return result;\n        }\n        this.reporter.reportError(tree.location, \'await not permitted within a finally block.\');\n        return result;\n      },\n      transformReturnStatement: function(tree) {\n        var $__2;\n        var expression,\n            machine;\n        if (this.expressionNeedsStateMachine(tree.expression)) {\n          (($__2 = this.expressionToStateMachine(tree.expression), expression = $__2.expression, machine = $__2.machine, $__2));\n        } else {\n          expression = tree.expression || createUndefinedExpression();\n        }\n        var startState = this.allocateState();\n        var endState = this.allocateState();\n        var completeState = new FallThroughState(startState, endState, parseStatements($traceurRuntime.getTemplateObject(["$ctx.returnValue = ", ""]), expression));\n        var end = new EndState(endState);\n        var returnMachine = new StateMachine(startState, this.allocateState(), [completeState, end], []);\n        if (machine)\n          returnMachine = machine.append(returnMachine);\n        return returnMachine;\n      },\n      createCompleteTask_: function(result) {\n        return parseStatement($traceurRuntime.getTemplateObject(["$ctx.resolve(", ")"]), result);\n      },\n      transformAsyncBody: function(tree) {\n        var asyncWrap = this.getRuntimeExpression(\'asyncWrap\');\n        return this.transformCpsFunctionBody(tree, asyncWrap);\n      }\n    }, {transformAsyncBody: function(identifierGenerator, reporter, options, body) {\n        return new AsyncTransformer(identifierGenerator, reporter, options).transformAsyncBody(body);\n      }}, $__super);\n  }(ImportRuntimeTrait(CPSTransformer));\n  ;\n  return {get AsyncTransformer() {\n      return AsyncTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js";\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js")),\n      BLOCK = $__3.BLOCK,\n      VARIABLE_DECLARATION_LIST = $__3.VARIABLE_DECLARATION_LIST,\n      IDENTIFIER_EXPRESSION = $__3.IDENTIFIER_EXPRESSION;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js")),\n      LENGTH = $__4.LENGTH,\n      PUSH = $__4.PUSH;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js")).TempVarTransformer;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js")),\n      BANG = $__6.BANG,\n      IN = $__6.IN,\n      OPEN_ANGLE = $__6.OPEN_ANGLE,\n      PLUS_PLUS = $__6.PLUS_PLUS,\n      VAR = $__6.VAR;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js")),\n      createArgumentList = $__7.createArgumentList,\n      createAssignmentStatement = $__7.createAssignmentStatement,\n      createBinaryExpression = $__7.createBinaryExpression,\n      createBlock = $__7.createBlock,\n      createCallStatement = $__7.createCallStatement,\n      createContinueStatement = $__7.createContinueStatement,\n      createEmptyArrayLiteral = $__7.createEmptyArrayLiteral,\n      createForInStatement = $__7.createForInStatement,\n      createForStatement = $__7.createForStatement,\n      createIdentifierExpression = $__7.createIdentifierExpression,\n      createIfStatement = $__7.createIfStatement,\n      createMemberExpression = $__7.createMemberExpression,\n      createMemberLookupExpression = $__7.createMemberLookupExpression,\n      createNumberLiteral = $__7.createNumberLiteral,\n      createOperatorToken = $__7.createOperatorToken,\n      createParenExpression = $__7.createParenExpression,\n      createPostfixExpression = $__7.createPostfixExpression,\n      createUnaryExpression = $__7.createUnaryExpression,\n      createVariableDeclarationList = $__7.createVariableDeclarationList,\n      createVariableStatement = $__7.createVariableStatement;\n  var ForInTransformPass = function($__super) {\n    function ForInTransformPass() {\n      $traceurRuntime.superConstructor(ForInTransformPass).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ForInTransformPass, {transformForInStatement: function(tree) {\n        var $__1,\n            $__2;\n        var bodyStatements = [];\n        var body = this.transformAny(tree.body);\n        if (body.type === BLOCK) {\n          ($__1 = bodyStatements).push.apply($__1, $traceurRuntime.spread(body.statements));\n        } else {\n          bodyStatements.push(body);\n        }\n        var elements = [];\n        var keys = this.getTempIdentifier();\n        elements.push(createVariableStatement(VAR, keys, createEmptyArrayLiteral()));\n        var collection = this.getTempIdentifier();\n        elements.push(createVariableStatement(VAR, collection, tree.collection));\n        var p = this.getTempIdentifier();\n        elements.push(createForInStatement(createVariableDeclarationList(VAR, p, null), createIdentifierExpression(collection), createCallStatement(createMemberExpression(keys, PUSH), createArgumentList([createIdentifierExpression(p)]))));\n        var i = this.getTempIdentifier();\n        var lookup = createMemberLookupExpression(createIdentifierExpression(keys), createIdentifierExpression(i));\n        var originalKey,\n            assignOriginalKey;\n        if (tree.initializer.type === VARIABLE_DECLARATION_LIST) {\n          var decList = tree.initializer;\n          originalKey = createIdentifierExpression(decList.declarations[0].lvalue);\n          assignOriginalKey = createVariableStatement(decList.declarationType, originalKey.identifierToken, lookup);\n        } else if (tree.initializer.type === IDENTIFIER_EXPRESSION) {\n          originalKey = tree.initializer;\n          assignOriginalKey = createAssignmentStatement(tree.initializer, lookup);\n        } else {\n          throw new Error(\'Invalid left hand side of for in loop\');\n        }\n        var innerBlock = [];\n        innerBlock.push(assignOriginalKey);\n        innerBlock.push(createIfStatement(createUnaryExpression(createOperatorToken(BANG), createParenExpression(createBinaryExpression(originalKey, createOperatorToken(IN), createIdentifierExpression(collection)))), createContinueStatement(), null));\n        ($__2 = innerBlock).push.apply($__2, $traceurRuntime.spread(bodyStatements));\n        elements.push(createForStatement(createVariableDeclarationList(VAR, i, createNumberLiteral(0)), createBinaryExpression(createIdentifierExpression(i), createOperatorToken(OPEN_ANGLE), createMemberExpression(keys, LENGTH)), createPostfixExpression(createIdentifierExpression(i), createOperatorToken(PLUS_PLUS)), createBlock(innerBlock)));\n        return createBlock(elements);\n      }}, {}, $__super);\n  }(TempVarTransformer);\n  return {get ForInTransformPass() {\n      return ForInTransformPass;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/YieldState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/YieldState.js";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/YieldState.js")).State;\n  var createReturnStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/generator/YieldState.js")).createReturnStatement;\n  var YieldState = function($__super) {\n    function YieldState(id, fallThroughState, expression) {\n      $traceurRuntime.superConstructor(YieldState).call(this, id);\n      this.fallThroughState = fallThroughState;\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(YieldState, {\n      replaceState: function(oldState, newState) {\n        return new this.constructor(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.expression);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        return $traceurRuntime.spread(State.generateAssignState(enclosingFinally, this.fallThroughState), [createReturnStatement(this.expression)]);\n      }\n    }, {}, $__super);\n  }(State);\n  return {get YieldState() {\n      return YieldState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/ReturnState.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/ReturnState.js";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../semantics/util.js", "traceur@0.0.111/src/codegeneration/generator/ReturnState.js")),\n      isUndefined = $__2.isUndefined,\n      isVoidExpression = $__2.isVoidExpression;\n  var YieldState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./YieldState.js", "traceur@0.0.111/src/codegeneration/generator/ReturnState.js")).YieldState;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./State.js", "traceur@0.0.111/src/codegeneration/generator/ReturnState.js")).State;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/generator/ReturnState.js")).parseStatement;\n  var ReturnState = function($__super) {\n    function ReturnState() {\n      $traceurRuntime.superConstructor(ReturnState).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ReturnState, {transform: function(enclosingFinally, machineEndState, reporter) {\n        var $__1;\n        var e = this.expression;\n        var statements = [];\n        if (e && !isUndefined(e) && !isVoidExpression(e))\n          statements.push(parseStatement($traceurRuntime.getTemplateObject(["$ctx.returnValue = ", ""]), this.expression));\n        ($__1 = statements).push.apply($__1, $traceurRuntime.spread(State.generateJump(enclosingFinally, machineEndState)));\n        return statements;\n      }}, {}, $__super);\n  }(YieldState);\n  return {get ReturnState() {\n      return ReturnState;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js";\n  var CPSTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CPSTransformer.js", "traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js")).CPSTransformer;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js")),\n      BINARY_EXPRESSION = $__4.BINARY_EXPRESSION,\n      YIELD_EXPRESSION = $__4.YIELD_EXPRESSION;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js")),\n      BinaryExpression = $__5.BinaryExpression,\n      ExpressionStatement = $__5.ExpressionStatement;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../FindInFunctionScope.js", "traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js")).FindInFunctionScope;\n  var ReturnState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ReturnState.js", "traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js")).ReturnState;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js")).default;\n  var YieldState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./YieldState.js", "traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js")).YieldState;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js")),\n      id = $__10.createIdentifierExpression,\n      createMemberExpression = $__10.createMemberExpression,\n      createUndefinedExpression = $__10.createUndefinedExpression;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js")),\n      parseExpression = $__11.parseExpression,\n      parseStatement = $__11.parseStatement,\n      parseStatements = $__11.parseStatements;\n  function isYieldAssign(tree) {\n    return tree.type === BINARY_EXPRESSION && tree.operator.isAssignmentOperator() && tree.right.type === YIELD_EXPRESSION && tree.left.isLeftHandSideExpression();\n  }\n  var YieldFinder = function($__super) {\n    function YieldFinder() {\n      $traceurRuntime.superConstructor(YieldFinder).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(YieldFinder, {visitYieldExpression: function(tree) {\n        this.found = true;\n      }}, {}, $__super);\n  }(FindInFunctionScope);\n  function scopeContainsYield(tree) {\n    var finder = new YieldFinder();\n    finder.visitAny(tree);\n    return finder.found;\n  }\n  var GeneratorTransformer = function($__super) {\n    function GeneratorTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(GeneratorTransformer).call(this, identifierGenerator, reporter, options);\n      this.shouldAppendThrowCloseState_ = true;\n    }\n    return ($traceurRuntime.createClass)(GeneratorTransformer, {\n      expressionNeedsStateMachine: function(tree) {\n        if (tree === null)\n          return false;\n        return scopeContainsYield(tree);\n      },\n      transformYieldExpression_: function(tree) {\n        var $__2;\n        var expression,\n            machine;\n        if (this.expressionNeedsStateMachine(tree.expression)) {\n          (($__2 = this.expressionToStateMachine(tree.expression), expression = $__2.expression, machine = $__2.machine, $__2));\n        } else {\n          expression = this.transformAny(tree.expression);\n        }\n        if (tree.isYieldFor)\n          return this.transformYieldForExpression_(expression, machine);\n        var startState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        var yieldMachine = this.stateToStateMachine_(new YieldState(startState, fallThroughState, expression), fallThroughState);\n        if (machine)\n          yieldMachine = machine.append(yieldMachine);\n        if (this.shouldAppendThrowCloseState_)\n          yieldMachine = yieldMachine.append(this.createThrowCloseState_());\n        return yieldMachine;\n      },\n      transformYieldForExpression_: function(expression) {\n        var machine = arguments[1];\n        var gName = this.getTempIdentifier();\n        this.addMachineVariable(gName);\n        var g = id(gName);\n        var nextName = this.getTempIdentifier();\n        this.addMachineVariable(nextName);\n        var next = id(nextName);\n        var statements = parseStatements($traceurRuntime.getTemplateObject(["\\n        ", " = $ctx.wrapYieldStar(", "[Symbol.iterator]());\\n        // received = void 0;\\n        $ctx.sent = void 0;\\n        // send = true; // roughly equivalent\\n        $ctx.action = \'next\';\\n\\n        for (;;) {\\n          ", " = ", "[$ctx.action]($ctx.sentIgnoreThrow);\\n          if (", ".done) {\\n            $ctx.sent = ", ".value;\\n            break;\\n          }\\n          yield ", ".value;\\n        }"]), g, expression, next, g, next, next, next);\n        var shouldAppendThrowCloseState = this.shouldAppendThrowCloseState_;\n        this.shouldAppendThrowCloseState_ = false;\n        statements = this.transformList(statements);\n        var yieldMachine = this.transformStatementList_(statements);\n        this.shouldAppendThrowCloseState_ = shouldAppendThrowCloseState;\n        if (machine)\n          yieldMachine = machine.append(yieldMachine);\n        return yieldMachine;\n      },\n      transformYieldExpression: function(tree) {\n        this.reporter.reportError(tree.location, \'Only \\\'a = yield b\\\' and \\\'var a = yield b\\\' currently supported.\');\n        return tree;\n      },\n      transformYieldAssign_: function(tree) {\n        var shouldAppendThrowCloseState = this.shouldAppendThrowCloseState_;\n        this.shouldAppendThrowCloseState_ = false;\n        var machine = this.transformYieldExpression_(tree.right);\n        var left = this.transformAny(tree.left);\n        var sentExpression = tree.right.isYieldFor ? parseExpression($traceurRuntime.getTemplateObject(["$ctx.sentIgnoreThrow"])) : parseExpression($traceurRuntime.getTemplateObject(["$ctx.sent"]));\n        var statement = new ExpressionStatement(tree.location, new BinaryExpression(tree.location, left, tree.operator, sentExpression));\n        var assignMachine = this.statementToStateMachine_(statement);\n        this.shouldAppendThrowCloseState_ = shouldAppendThrowCloseState;\n        return machine.append(assignMachine);\n      },\n      createThrowCloseState_: function() {\n        return this.statementToStateMachine_(parseStatement($traceurRuntime.getTemplateObject(["$ctx.maybeThrow()"])));\n      },\n      transformExpressionStatement: function(tree) {\n        var expression = tree.expression;\n        if (expression.type === YIELD_EXPRESSION)\n          return this.transformYieldExpression_(expression);\n        if (isYieldAssign(expression))\n          return this.transformYieldAssign_(expression);\n        if (this.expressionNeedsStateMachine(expression)) {\n          return this.expressionToStateMachine(expression).machine;\n        }\n        return $traceurRuntime.superGet(this, GeneratorTransformer.prototype, "transformExpressionStatement").call(this, tree);\n      },\n      transformAwaitStatement: function(tree) {\n        this.reporter.reportError(tree.location, \'Generator function may not have an await statement.\');\n        return tree;\n      },\n      transformReturnStatement: function(tree) {\n        var $__2;\n        var expression,\n            machine;\n        if (this.expressionNeedsStateMachine(tree.expression))\n          (($__2 = this.expressionToStateMachine(tree.expression), expression = $__2.expression, machine = $__2.machine, $__2));\n        else\n          expression = tree.expression;\n        var startState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        var returnMachine = this.stateToStateMachine_(new ReturnState(startState, fallThroughState, this.transformAny(expression)), fallThroughState);\n        if (machine)\n          return machine.append(returnMachine);\n        return returnMachine;\n      },\n      transformGeneratorBody: function(tree, name) {\n        var createGeneratorInstance = this.getRuntimeExpression(\'createGeneratorInstance\');\n        return this.transformCpsFunctionBody(tree, createGeneratorInstance, name);\n      }\n    }, {transformGeneratorBody: function(identifierGenerator, reporter, options, body, name) {\n        return new GeneratorTransformer(identifierGenerator, reporter, options).transformGeneratorBody(body, name);\n      }}, $__super);\n  }(ImportRuntimeTrait(CPSTransformer));\n  ;\n  return {get GeneratorTransformer() {\n      return GeneratorTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js";\n  var ArrowFunctionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ArrowFunctionTransformer.js", "traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js")).ArrowFunctionTransformer;\n  var AsyncTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generator/AsyncTransformer.js", "traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js")).AsyncTransformer;\n  var ForInTransformPass = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generator/ForInTransformPass.js", "traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js")).ForInTransformPass;\n  var GeneratorTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generator/GeneratorTransformer.js", "traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js")).GeneratorTransformer;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js")),\n      parseExpression = $__8.parseExpression,\n      parseStatement = $__8.parseStatement;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js")).TempVarTransformer;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js")).default;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindInFunctionScope.js", "traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js")).FindInFunctionScope;\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js")),\n      AnonBlock = $__12.AnonBlock,\n      FunctionDeclaration = $__12.FunctionDeclaration,\n      FunctionExpression = $__12.FunctionExpression;\n  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js")),\n      createBindingIdentifier = $__13.createBindingIdentifier,\n      id = $__13.createIdentifierExpression,\n      createIdentifierToken = $__13.createIdentifierToken;\n  var ForInFinder = function($__super) {\n    function ForInFinder() {\n      $traceurRuntime.superConstructor(ForInFinder).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ForInFinder, {visitForInStatement: function(tree) {\n        this.found = true;\n      }}, {}, $__super);\n  }(FindInFunctionScope);\n  function needsTransform(tree, transformOptions) {\n    return transformOptions.generators && tree.isGenerator() || transformOptions.asyncFunctions && tree.isAsyncFunction();\n  }\n  var GeneratorTransformPass = function($__super) {\n    function GeneratorTransformPass(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(GeneratorTransformPass).call(this, identifierGenerator, reporter, options);\n      this.tranformOptions_ = options.transformOptions;\n      this.inBlock_ = false;\n    }\n    return ($traceurRuntime.createClass)(GeneratorTransformPass, {\n      transformFunctionDeclaration: function(tree) {\n        if (!needsTransform(tree, this.tranformOptions_))\n          return $traceurRuntime.superGet(this, GeneratorTransformPass.prototype, "transformFunctionDeclaration").call(this, tree);\n        if (tree.isGenerator())\n          return this.transformGeneratorDeclaration_(tree);\n        return this.transformFunction_(tree, FunctionDeclaration, null);\n      },\n      transformGeneratorDeclaration_: function(tree) {\n        var nameIdExpression = id(tree.name.identifierToken);\n        var initGeneratorFunction = this.getRuntimeExpression(\'initGeneratorFunction\');\n        var setupPrototypeExpression = parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), initGeneratorFunction, nameIdExpression);\n        var tmpVar = id(this.inBlock_ ? this.getTempIdentifier() : this.addTempVar(setupPrototypeExpression));\n        var funcDecl = this.transformFunction_(tree, FunctionDeclaration, tmpVar);\n        if (!this.inBlock_)\n          return funcDecl;\n        return new AnonBlock(null, [funcDecl, parseStatement($traceurRuntime.getTemplateObject(["var ", " = ", ""]), tmpVar, setupPrototypeExpression)]);\n      },\n      transformFunctionExpression: function(tree) {\n        if (!needsTransform(tree, this.tranformOptions_))\n          return $traceurRuntime.superGet(this, GeneratorTransformPass.prototype, "transformFunctionExpression").call(this, tree);\n        if (tree.isGenerator())\n          return this.transformGeneratorExpression_(tree);\n        return this.transformFunction_(tree, FunctionExpression, null);\n      },\n      transformGeneratorExpression_: function(tree) {\n        var name;\n        if (!tree.name) {\n          name = createIdentifierToken(this.getTempIdentifier());\n          tree = new FunctionExpression(tree.location, createBindingIdentifier(name), tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n        } else {\n          name = tree.name.identifierToken;\n        }\n        var functionExpression = this.transformFunction_(tree, FunctionExpression, id(name));\n        var initGeneratorFunction = this.getRuntimeExpression(\'initGeneratorFunction\');\n        return parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), initGeneratorFunction, functionExpression);\n      },\n      transformFunction_: function(tree, constructor, nameExpression) {\n        var $__2 = this;\n        var body = $traceurRuntime.superGet(this, GeneratorTransformPass.prototype, "transformAny").call(this, tree.body);\n        var finder = new ForInFinder();\n        finder.visitAny(body);\n        if (finder.found) {\n          body = new ForInTransformPass(this.identifierGenerator, this.reporter, this.options).transformAny(body);\n        }\n        if (this.tranformOptions_.generators && tree.isGenerator()) {\n          var transformer = new GeneratorTransformer(this.identifierGenerator, this.reporter, this.options);\n          body = transformer.transformGeneratorBody(body, nameExpression);\n          transformer.requiredNames.forEach(function(n) {\n            $__2.addImportedName(n);\n          });\n        } else if (this.tranformOptions_.asyncFunctions && tree.isAsyncFunction()) {\n          var transformer$__3 = new AsyncTransformer(this.identifierGenerator, this.reporter, this.options);\n          body = transformer$__3.transformAsyncBody(body, nameExpression);\n          transformer$__3.requiredNames.forEach(function(n) {\n            $__2.addImportedName(n);\n          });\n        }\n        var functionKind = null;\n        return new constructor(tree.location, tree.name, functionKind, tree.parameterList, tree.typeAnnotation || null, tree.annotations || null, body);\n      },\n      transformArrowFunction: function(tree) {\n        if (!tree.isAsyncFunction())\n          return $traceurRuntime.superGet(this, GeneratorTransformPass.prototype, "transformArrowFunction").call(this, tree);\n        return this.transformAny(ArrowFunctionTransformer.transform(this, tree));\n      },\n      transformBlock: function(tree) {\n        var inBlock = this.inBlock_;\n        this.inBlock_ = true;\n        var rv = $traceurRuntime.superGet(this, GeneratorTransformPass.prototype, "transformBlock").call(this, tree);\n        this.inBlock_ = inBlock;\n        return rv;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get GeneratorTransformPass() {\n      return GeneratorTransformPass;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/InlineModuleTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/InlineModuleTransformer.js";\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/InlineModuleTransformer.js")).VAR;\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModuleTransformer.js", "traceur@0.0.111/src/codegeneration/InlineModuleTransformer.js")).ModuleTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/InlineModuleTransformer.js")),\n      createBindingIdentifier = $__3.createBindingIdentifier,\n      createEmptyStatement = $__3.createEmptyStatement,\n      createFunctionBody = $__3.createFunctionBody,\n      createImmediatelyInvokedFunctionExpression = $__3.createImmediatelyInvokedFunctionExpression,\n      createVariableStatement = $__3.createVariableStatement;\n  var anonInlineModules = 0;\n  var InlineModuleTransformer = function($__super) {\n    function InlineModuleTransformer() {\n      $traceurRuntime.superConstructor(InlineModuleTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(InlineModuleTransformer, {\n      wrapModule: function(statements) {\n        var seed = this.moduleName || \'anon_\' + ++anonInlineModules;\n        var idName = this.getTempVarNameForModuleName(seed);\n        var body = createFunctionBody(statements);\n        var moduleExpression = createImmediatelyInvokedFunctionExpression(body);\n        return [createVariableStatement(VAR, idName, moduleExpression)];\n      },\n      transformNamedExport: function(tree) {\n        return createEmptyStatement();\n      },\n      transformModuleSpecifier: function(tree) {\n        return createBindingIdentifier(this.getTempVarNameForModuleSpecifier(tree));\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  return {get InlineModuleTransformer() {\n      return InlineModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js";\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js")),\n      AnonBlock = $__10.AnonBlock,\n      ArrayLiteral = $__10.ArrayLiteral,\n      ClassExpression = $__10.ClassExpression,\n      CommaExpression = $__10.CommaExpression,\n      ExpressionStatement = $__10.ExpressionStatement,\n      VariableDeclaration = $__10.VariableDeclaration;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js")),\n      ANON_BLOCK = $__11.ANON_BLOCK,\n      CLASS_DECLARATION = $__11.CLASS_DECLARATION,\n      FUNCTION_DECLARATION = $__11.FUNCTION_DECLARATION,\n      IDENTIFIER_EXPRESSION = $__11.IDENTIFIER_EXPRESSION,\n      IMPORT_SPECIFIER_SET = $__11.IMPORT_SPECIFIER_SET,\n      NAME_SPACE_IMPORT = $__11.NAME_SPACE_IMPORT;\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/ParseTreeVisitor.js", "traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js")).ParseTreeVisitor;\n  var ScopeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ScopeTransformer.js", "traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js")).ScopeTransformer;\n  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js")),\n      createEmptyParameterList = $__14.createEmptyParameterList,\n      createFunctionBody = $__14.createFunctionBody,\n      createFunctionExpression = $__14.createFunctionExpression,\n      id = $__14.createIdentifierExpression,\n      createObjectLiteralForDescriptor = $__14.createObjectLiteralForDescriptor,\n      createUseStrictDirective = $__14.createUseStrictDirective,\n      createVariableDeclarationList = $__14.createVariableDeclarationList,\n      createVariableStatement = $__14.createVariableStatement;\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModuleTransformer.js", "traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js")).ModuleTransformer;\n  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js")),\n      MINUS_MINUS = $__16.MINUS_MINUS,\n      PLUS_PLUS = $__16.PLUS_PLUS,\n      VAR = $__16.VAR;\n  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js")),\n      parseExpression = $__17.parseExpression,\n      parseStatement = $__17.parseStatement,\n      parseStatements = $__17.parseStatements;\n  var HoistVariablesTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./HoistVariablesTransformer.js", "traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js")).default;\n  function flattenAnonBlocks(statements) {\n    var $__9;\n    var result = [];\n    for (var i = 0; i < statements.length; i++) {\n      var statement = statements[i];\n      if (statement.type === ANON_BLOCK) {\n        ($__9 = result).push.apply($__9, $traceurRuntime.spread(statement.statements));\n      } else {\n        result.push(statement);\n      }\n    }\n    return result;\n  }\n  var ExportBindingsVisitor = function($__super) {\n    function ExportBindingsVisitor() {\n      $traceurRuntime.superConstructor(ExportBindingsVisitor).call(this);\n      this.bindings = [];\n    }\n    return ($traceurRuntime.createClass)(ExportBindingsVisitor, {\n      visitVariableDeclaration: function(tree) {\n        this.visitAny(tree.lvalue);\n      },\n      visitBindingIdentifier: function(tree) {\n        this.bindings.push(tree);\n      },\n      visitBindingElement: function(tree) {\n        this.visitAny(tree.binding);\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  var DeclarationExtractionTransformer = function($__super) {\n    function DeclarationExtractionTransformer() {\n      $traceurRuntime.superConstructor(DeclarationExtractionTransformer).call(this);\n      this.declarations_ = [];\n    }\n    return ($traceurRuntime.createClass)(DeclarationExtractionTransformer, {\n      getDeclarationStatements: function() {\n        return flattenAnonBlocks($traceurRuntime.spread([this.getVariableStatement()], this.declarations_));\n      },\n      addDeclaration: function(tree) {\n        this.declarations_.push(tree);\n      },\n      transformFunctionDeclaration: function(tree) {\n        this.addDeclaration(tree);\n        return new AnonBlock(null, []);\n      },\n      transformClassDeclaration: function(tree) {\n        this.addVariable(tree.name.identifierToken.value);\n        tree = new ClassExpression(tree.location, tree.name, tree.superClass, tree.elements, tree.annotations, tree.typeParameters);\n        return parseStatement($traceurRuntime.getTemplateObject(["", " = ", ""]), tree.name.identifierToken, tree);\n      }\n    }, {}, $__super);\n  }(HoistVariablesTransformer);\n  var ModuleNameIdentifierTransformer = function($__super) {\n    function ModuleNameIdentifierTransformer() {\n      $traceurRuntime.superConstructor(ModuleNameIdentifierTransformer).call(this, \'__moduleName\');\n      this.usesModuleName = false;\n    }\n    return ($traceurRuntime.createClass)(ModuleNameIdentifierTransformer, {transformIdentifierExpression: function(tree) {\n        if (tree.identifierToken.value === \'__moduleName\') {\n          this.usesModuleName = true;\n          return parseExpression($traceurRuntime.getTemplateObject(["$__moduleContext.id"]));\n        }\n        return $traceurRuntime.superGet(this, ModuleNameIdentifierTransformer.prototype, "transformIdentifierExpression").call(this, tree);\n      }}, {}, $__super);\n  }(ScopeTransformer);\n  var InsertBindingAssignmentTransformer = function($__super) {\n    function InsertBindingAssignmentTransformer(exportName, bindingName) {\n      $traceurRuntime.superConstructor(InsertBindingAssignmentTransformer).call(this, bindingName);\n      this.bindingName_ = bindingName;\n      this.exportName_ = exportName;\n    }\n    return ($traceurRuntime.createClass)(InsertBindingAssignmentTransformer, {\n      matchesBindingName_: function(binding) {\n        return binding.type === IDENTIFIER_EXPRESSION && binding.identifierToken.value === this.bindingName_;\n      },\n      transformUnaryExpression: function(tree) {\n        if (!this.matchesBindingName_(tree.operand))\n          return $traceurRuntime.superGet(this, InsertBindingAssignmentTransformer.prototype, "transformUnaryExpression").call(this, tree);\n        var operatorType = tree.operator.type;\n        if (operatorType !== PLUS_PLUS && operatorType !== MINUS_MINUS)\n          return $traceurRuntime.superGet(this, InsertBindingAssignmentTransformer.prototype, "transformUnaryExpression").call(this, tree);\n        var operand = this.transformAny(tree.operand);\n        if (operand !== tree.operand)\n          tree = new UnaryExpression(tree.location, tree.operator, operand);\n        return parseExpression($traceurRuntime.getTemplateObject(["$__export(", ", ", ")"]), this.exportName_, tree);\n      },\n      transformPostfixExpression: function(tree) {\n        tree = $traceurRuntime.superGet(this, InsertBindingAssignmentTransformer.prototype, "transformPostfixExpression").call(this, tree);\n        if (!this.matchesBindingName_(tree.operand))\n          return tree;\n        switch (tree.operator.type) {\n          case PLUS_PLUS:\n            return parseExpression($traceurRuntime.getTemplateObject(["($__export(", ", ", " + 1), ", ")"]), this.exportName_, tree.operand, tree);\n          case MINUS_MINUS:\n            return parseExpression($traceurRuntime.getTemplateObject(["($__export(", ", ", " - 1), ", ")"]), this.exportName_, tree.operand, tree);\n        }\n        return tree;\n      },\n      transformBinaryExpression: function(tree) {\n        tree = $traceurRuntime.superGet(this, InsertBindingAssignmentTransformer.prototype, "transformBinaryExpression").call(this, tree);\n        if (!tree.operator.isAssignmentOperator())\n          return tree;\n        if (!this.matchesBindingName_(tree.left))\n          return tree;\n        return parseExpression($traceurRuntime.getTemplateObject(["$__export(", ", ", ")}"]), this.exportName_, tree);\n      }\n    }, {}, $__super);\n  }(ScopeTransformer);\n  var InstantiateModuleTransformer = function($__super) {\n    function InstantiateModuleTransformer(identifierGenerator, reporter) {\n      var options = arguments[2];\n      $traceurRuntime.superConstructor(InstantiateModuleTransformer).call(this, identifierGenerator, reporter, options);\n      this.anonymousModule = options && !options.bundle && options.moduleName !== true;\n      this.usesModuleName = false;\n      this.inExport_ = false;\n      this.curDepIndex_ = null;\n      this.dependencies = [];\n      this.externalExportBindings = [];\n      this.importBindings = [];\n      this.localExportBindings = [];\n      this.functionDeclarations = [];\n      this.moduleBindings = [];\n      this.exportStarBindings = [];\n    }\n    return ($traceurRuntime.createClass)(InstantiateModuleTransformer, {\n      getModuleName: function(tree) {\n        if (this.anonymousModule)\n          return null;\n        return tree.moduleName;\n      },\n      moduleProlog: function() {\n        return [];\n      },\n      wrapModule: function(statements) {\n        var prolog = [createUseStrictDirective()];\n        statements = prolog.concat(statements);\n        if (this.usesModuleName) {\n          if (this.moduleName) {\n            return parseStatements($traceurRuntime.getTemplateObject(["System.register(", ",\\n            ", ", function($__export, $__moduleContext) {\\n              ", "\\n            });"]), this.moduleName, this.dependencies, statements);\n          }\n          return parseStatements($traceurRuntime.getTemplateObject(["System.register(", ", function($__export, $__moduleContext) {\\n            ", "\\n          });"]), this.dependencies, statements);\n        }\n        if (this.moduleName) {\n          return parseStatements($traceurRuntime.getTemplateObject(["System.register(", ",\\n          ", ", function($__export) {\\n            ", "\\n          });"]), this.moduleName, this.dependencies, statements);\n        }\n        return parseStatements($traceurRuntime.getTemplateObject(["System.register(", ", function($__export) {\\n          ", "\\n        });"]), this.dependencies, statements);\n      },\n      addExportStatement: function(statements) {\n        var $__6 = this;\n        var declarationExtractionTransformer = new DeclarationExtractionTransformer();\n        var moduleNameIdentifierTransformer = new ModuleNameIdentifierTransformer();\n        statements = moduleNameIdentifierTransformer.transformList(statements);\n        if (moduleNameIdentifierTransformer.usesModuleName)\n          this.usesModuleName = true;\n        this.localExportBindings.forEach(function(binding) {\n          statements = new InsertBindingAssignmentTransformer(binding.exportName, binding.localName).transformList(statements);\n        });\n        var executionStatements = declarationExtractionTransformer.transformList(statements);\n        var executionFunction = createFunctionExpression(createEmptyParameterList(), createFunctionBody(executionStatements));\n        var declarationStatements = declarationExtractionTransformer.getDeclarationStatements();\n        var setterFunctions = this.dependencies.map(function(dep, index) {\n          var importBindings = $__6.importBindings[index];\n          var externalExportBindings = $__6.externalExportBindings[index];\n          var exportStarBinding = $__6.exportStarBindings[index];\n          var moduleBinding = $__6.moduleBindings[index];\n          var setterStatements = [];\n          if (importBindings) {\n            importBindings.forEach(function(binding) {\n              setterStatements.push(parseStatement($traceurRuntime.getTemplateObject(["", " = $__m.", ";"]), id(binding.variableName), binding.exportName));\n            });\n          }\n          if (externalExportBindings) {\n            var reexports = Object.create(null);\n            externalExportBindings.forEach(function($__7) {\n              var $__8 = $__7,\n                  exportName = $__8.exportName,\n                  importName = $__8.importName;\n              reexports[exportName] = importName === null ? parseExpression($traceurRuntime.getTemplateObject(["$__m"])) : parseExpression($traceurRuntime.getTemplateObject(["$__m.", ""]), importName);\n            });\n            setterStatements.push(parseStatement($traceurRuntime.getTemplateObject(["$__export(", ")"]), createObjectLiteralForDescriptor(reexports)));\n          }\n          if (moduleBinding) {\n            setterStatements.push(parseStatement($traceurRuntime.getTemplateObject(["", " = $__m;"]), id(moduleBinding)));\n          }\n          if (exportStarBinding) {\n            setterStatements = setterStatements.concat(parseStatements($traceurRuntime.getTemplateObject(["\\n          var exportObj = Object.create(null);\\n          Object.keys($__m).forEach(function(p) {\\n            if (p !== \'default\' && !$__exportNames[p])\\n              exportObj[p] = $__m[p];\\n          });\\n          $__export(exportObj);\\n        "])));\n            var exportNames = {};\n            $__6.localExportBindings.concat($__6.externalExportBindings).forEach(function(binding) {\n              exportNames[binding.exportName] = true;\n            });\n            declarationStatements.push(parseStatement($traceurRuntime.getTemplateObject(["\\n          var $__exportNames = ", ";\\n        "]), createObjectLiteralForDescriptor(exportNames)));\n          }\n          if (setterStatements.length) {\n            return parseExpression($traceurRuntime.getTemplateObject(["function($__m) {\\n          ", "\\n        }"]), setterStatements);\n          }\n          return parseExpression($traceurRuntime.getTemplateObject(["function($__m) {}"]));\n        });\n        declarationStatements = declarationStatements.concat(this.functionDeclarations.map(function(binding) {\n          return parseStatement($traceurRuntime.getTemplateObject(["$__export(", ", ", ")"]), binding.exportName, id(binding.functionName));\n        }));\n        declarationStatements.push(parseStatement($traceurRuntime.getTemplateObject(["return {\\n      setters: ", ",\\n      execute: ", "\\n    }"]), new ArrayLiteral(null, setterFunctions), executionFunction));\n        return declarationStatements;\n      },\n      addLocalExportBinding: function(exportName) {\n        var localName = arguments[1] !== (void 0) ? arguments[1] : exportName;\n        this.localExportBindings.push({\n          exportName: exportName,\n          localName: localName\n        });\n      },\n      addImportBinding: function(depIndex, variableName, exportName) {\n        this.importBindings[depIndex] = this.importBindings[depIndex] || [];\n        this.importBindings[depIndex].push({\n          variableName: variableName,\n          exportName: exportName\n        });\n      },\n      addExternalExportBinding: function(depIndex, exportName, importName) {\n        this.externalExportBindings[depIndex] = this.externalExportBindings[depIndex] || [];\n        this.externalExportBindings[depIndex].push({\n          exportName: exportName,\n          importName: importName\n        });\n      },\n      addExportStarBinding: function(depIndex) {\n        this.exportStarBindings[depIndex] = true;\n      },\n      addModuleBinding: function(depIndex, variableName) {\n        this.moduleBindings[depIndex] = variableName;\n      },\n      addExportFunction: function(exportName) {\n        var functionName = arguments[1] !== (void 0) ? arguments[1] : exportName;\n        this.functionDeclarations.push({\n          exportName: exportName,\n          functionName: functionName\n        });\n      },\n      getOrCreateDependencyIndex: function(moduleSpecifier) {\n        var name = moduleSpecifier.token.processedValue;\n        var depIndex = this.dependencies.indexOf(name);\n        if (depIndex === -1) {\n          depIndex = this.dependencies.length;\n          this.dependencies.push(name);\n        }\n        return depIndex;\n      },\n      transformExportDeclaration: function(tree) {\n        this.inExport_ = true;\n        if (tree.declaration.moduleSpecifier) {\n          this.curDepIndex_ = this.getOrCreateDependencyIndex(tree.declaration.moduleSpecifier);\n        } else {\n          this.curDepIndex_ = null;\n        }\n        var transformed = this.transformAny(tree.declaration);\n        this.inExport_ = false;\n        return transformed;\n      },\n      transformVariableStatement: function(tree) {\n        if (!this.inExport_)\n          return $traceurRuntime.superGet(this, InstantiateModuleTransformer.prototype, "transformVariableStatement").call(this, tree);\n        this.inExport_ = false;\n        var bindingVisitor = new ExportBindingsVisitor();\n        bindingVisitor.visitAny(tree);\n        var statements = [];\n        for (var i = 0; i < bindingVisitor.bindings.length; i++) {\n          var identifierToken = bindingVisitor.bindings[i].identifierToken;\n          var name = identifierToken.value;\n          this.addLocalExportBinding(name);\n          statements.push(parseStatement($traceurRuntime.getTemplateObject(["$__export(", ", ", ")"]), name, id(identifierToken)));\n        }\n        statements.unshift($traceurRuntime.superGet(this, InstantiateModuleTransformer.prototype, "transformAny").call(this, tree));\n        return new AnonBlock(null, statements);\n      },\n      transformExportStar: function(tree) {\n        this.inExport_ = false;\n        this.addExportStarBinding(this.curDepIndex_);\n        return new AnonBlock(null, []);\n      },\n      transformClassDeclaration: function(tree) {\n        if (!this.inExport_)\n          return $traceurRuntime.superGet(this, InstantiateModuleTransformer.prototype, "transformClassDeclaration").call(this, tree);\n        this.inExport_ = false;\n        var identifierToken = tree.name.identifierToken;\n        var name = identifierToken.value;\n        this.addLocalExportBinding(name);\n        var statements = [$traceurRuntime.superGet(this, InstantiateModuleTransformer.prototype, "transformClassDeclaration").call(this, tree), parseStatement($traceurRuntime.getTemplateObject(["$__export(", ", ", ")"]), name, id(identifierToken))];\n        return new AnonBlock(null, statements);\n      },\n      transformFunctionDeclaration: function(tree) {\n        if (this.inExport_) {\n          var name = tree.name.getStringValue();\n          this.addLocalExportBinding(name);\n          this.addExportFunction(name);\n          this.inExport_ = false;\n        }\n        return $traceurRuntime.superGet(this, InstantiateModuleTransformer.prototype, "transformFunctionDeclaration").call(this, tree);\n      },\n      transformNamedExport: function(tree) {\n        this.transformAny(tree.moduleSpecifier);\n        var exportClause = this.transformAny(tree.exportClause);\n        if (this.curDepIndex_ === null) {\n          return exportClause;\n        }\n        return new AnonBlock(null, []);\n      },\n      transformImportDeclaration: function(tree) {\n        this.curDepIndex_ = this.getOrCreateDependencyIndex(tree.moduleSpecifier);\n        var initializer = this.transformAny(tree.moduleSpecifier);\n        if (!tree.importClause) {\n          return new AnonBlock(null, []);\n        }\n        var importClause = this.transformAny(tree.importClause);\n        if (tree.importClause.type === NAME_SPACE_IMPORT) {\n          var bindingIdentifier = tree.importClause.binding.binding;\n          var name = bindingIdentifier.getStringValue();\n          this.addModuleBinding(this.curDepIndex_, name);\n          return parseStatement($traceurRuntime.getTemplateObject(["var ", ";"]), bindingIdentifier);\n        }\n        if (tree.importClause.type === IMPORT_SPECIFIER_SET) {\n          return importClause;\n        }\n        var bindingName = tree.importClause.binding.getStringValue();\n        this.addImportBinding(this.curDepIndex_, bindingName, \'default\');\n        return parseStatement($traceurRuntime.getTemplateObject(["var ", ";"]), bindingName);\n      },\n      transformImportSpecifierSet: function(tree) {\n        return createVariableStatement(createVariableDeclarationList(VAR, this.transformList(tree.specifiers)));\n      },\n      transformExportDefault: function(tree) {\n        this.inExport_ = false;\n        var expression = this.transformAny(tree.expression);\n        this.addLocalExportBinding(\'default\');\n        if (expression.type === CLASS_DECLARATION) {\n          expression = new ClassExpression(expression.location, expression.name, expression.superClass, expression.elements, expression.annotations, expression.typeParameters);\n        }\n        if (expression.type === FUNCTION_DECLARATION) {\n          this.addExportFunction(\'default\', expression.name.identifierToken.value);\n          return expression;\n        } else {\n          return parseStatement($traceurRuntime.getTemplateObject(["$__export(\'default\', ", ");"]), expression);\n        }\n      },\n      transformExportSpecifier: function(tree) {\n        var exportName;\n        var bindingName;\n        if (tree.rhs) {\n          exportName = tree.rhs.value;\n          bindingName = tree.lhs.value;\n        } else {\n          exportName = tree.lhs.value;\n          bindingName = exportName;\n        }\n        if (this.curDepIndex_ !== null) {\n          this.addExternalExportBinding(this.curDepIndex_, exportName, bindingName);\n        } else {\n          this.addLocalExportBinding(exportName, bindingName);\n          return parseExpression($traceurRuntime.getTemplateObject(["$__export(", ", ", ");"]), exportName, id(bindingName));\n        }\n      },\n      transformExportSpecifierSet: function(tree) {\n        var specifiers = this.transformList(tree.specifiers);\n        return new ExpressionStatement(tree.location, new CommaExpression(tree.location, specifiers.filter(function(specifier) {\n          return specifier;\n        })));\n      },\n      transformNameSpaceExport: function(tree) {\n        this.addExternalExportBinding(this.curDepIndex_, tree.name.value, null);\n        return tree;\n      },\n      transformForwardDefaultExport: function(tree) {\n        this.addExternalExportBinding(this.curDepIndex_, tree.name.value, \'default\');\n        return tree;\n      },\n      transformImportSpecifier: function(tree) {\n        var localBinding = tree.binding.binding;\n        var localBindingToken = localBinding.identifierToken;\n        var importName = (tree.name || localBindingToken).value;\n        this.addImportBinding(this.curDepIndex_, localBindingToken.value, importName);\n        return new VariableDeclaration(tree.location, localBinding, null, null);\n      },\n      transformModuleSpecifier: function(tree) {\n        this.curDepIndex_ = this.getOrCreateDependencyIndex(tree);\n        return tree;\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  return {get InstantiateModuleTransformer() {\n      return InstantiateModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js";\n  var SPREAD_EXPRESSION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js")).SPREAD_EXPRESSION;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js")),\n      createObjectLiteral = $__2.createObjectLiteral,\n      createArgumentList = $__2.createArgumentList;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js")).parseExpression;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js")).default;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js")).ParseTreeTransformer;\n  function hasSpread(trees) {\n    return trees.some(function(tree) {\n      return tree && tree.type === SPREAD_EXPRESSION;\n    });\n  }\n  var SpreadPropertiesTransformer = function($__super) {\n    function SpreadPropertiesTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(SpreadPropertiesTransformer).call(this, identifierGenerator, reporter, options);\n      this.options = options;\n    }\n    return ($traceurRuntime.createClass)(SpreadPropertiesTransformer, {transformObjectLiteral: function(tree) {\n        if (!hasSpread(tree.propertyNameAndValues)) {\n          return $traceurRuntime.superGet(this, SpreadPropertiesTransformer.prototype, "transformObjectLiteral").call(this, tree);\n        }\n        var properties = this.transformList(tree.propertyNameAndValues);\n        return spreadProperties(properties, this);\n      }}, {}, $__super);\n  }(ImportRuntimeTrait(ParseTreeTransformer));\n  function spreadProperties(properties, self) {\n    var args = [];\n    var accummulatedProps = null;\n    for (var i = 0; i < properties.length; i++) {\n      var property = properties[i];\n      if (property.type === SPREAD_EXPRESSION) {\n        if (accummulatedProps) {\n          args.push(createObjectLiteral(accummulatedProps));\n          accummulatedProps = null;\n        }\n        args.push(property.expression);\n      } else {\n        if (!accummulatedProps) {\n          accummulatedProps = [];\n        }\n        accummulatedProps.push(property);\n      }\n    }\n    if (accummulatedProps) {\n      args.push(createObjectLiteral(accummulatedProps));\n    }\n    var runtime = self.getRuntimeExpression(\'spreadProperties\');\n    return parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), runtime, createArgumentList(args));\n  }\n  return {\n    get SpreadPropertiesTransformer() {\n      return SpreadPropertiesTransformer;\n    },\n    get spreadProperties() {\n      return spreadProperties;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/JsxTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/JsxTransformer.js";\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/JsxTransformer.js")),\n      JSX_ELEMENT = $__4.JSX_ELEMENT,\n      JSX_PLACEHOLDER = $__4.JSX_PLACEHOLDER,\n      JSX_SPREAD_ATTRIBUTE = $__4.JSX_SPREAD_ATTRIBUTE,\n      JSX_TEXT = $__4.JSX_TEXT,\n      LITERAL_EXPRESSION = $__4.LITERAL_EXPRESSION;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/JsxTransformer.js")),\n      JsxText = $__5.JsxText,\n      LiteralExpression = $__5.LiteralExpression,\n      LiteralPropertyName = $__5.LiteralPropertyName,\n      SpreadExpression = $__5.SpreadExpression;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/LiteralToken.js", "traceur@0.0.111/src/codegeneration/JsxTransformer.js")).LiteralToken;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/JsxTransformer.js")).ParseTreeTransformer;\n  var STRING = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/JsxTransformer.js")).STRING;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/JsxTransformer.js")),\n      createArgumentList = $__9.createArgumentList,\n      createIdentifierExpression = $__9.createIdentifierExpression,\n      createIdentifierToken = $__9.createIdentifierToken,\n      createMemberExpression = $__9.createMemberExpression,\n      createNullLiteral = $__9.createNullLiteral,\n      createObjectLiteral = $__9.createObjectLiteral,\n      createPropertyNameAssignment = $__9.createPropertyNameAssignment,\n      createStringLiteral = $__9.createStringLiteral,\n      createStringLiteralToken = $__9.createStringLiteralToken,\n      createTrueLiteral = $__9.createTrueLiteral;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/JsxTransformer.js")).parseExpression;\n  var spreadProperties = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SpreadPropertiesTransformer.js", "traceur@0.0.111/src/codegeneration/JsxTransformer.js")).spreadProperties;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/JsxTransformer.js")).default;\n  var JsxTransformer = function($__super) {\n    function JsxTransformer(idGen, reporter, options) {\n      $traceurRuntime.superConstructor(JsxTransformer).call(this);\n      this.options = options;\n      this.jsxFunction_ = null;\n    }\n    return ($traceurRuntime.createClass)(JsxTransformer, {\n      getJsxFunction_: function() {\n        if (!this.jsxFunction_) {\n          var jsx = this.options.jsx;\n          if (typeof jsx === \'string\') {\n            this.jsxFunction_ = parseExpression([jsx]);\n          } else {\n            this.jsxFunction_ = parseExpression($traceurRuntime.getTemplateObject(["React.createElement"]));\n          }\n        }\n        return this.jsxFunction_;\n      },\n      transformJsxElement: function(tree) {\n        var name = this.transformAny(tree.name);\n        var props = this.transformJsxAttributes_(tree);\n        var children = this.transformJsxChildren_(tree.children);\n        var args = createArgumentList($traceurRuntime.spread([name, props], children));\n        return parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), this.getJsxFunction_(), args);\n      },\n      transformJsxAttributes_: function(tree) {\n        var attrs = this.transformList(tree.attributes);\n        if (attrs.length === 0) {\n          return createNullLiteral();\n        }\n        if (tree.attributes.some(function(a) {\n          return a.type === JSX_SPREAD_ATTRIBUTE;\n        })) {\n          return spreadProperties(attrs, this);\n        }\n        return createObjectLiteral(attrs);\n      },\n      transformJsxElementName: function(tree) {\n        if (tree.names.length === 1) {\n          var value = tree.names[0].value;\n          if (value[0] === value[0].toUpperCase()) {\n            return createIdentifierExpression(value);\n            ;\n          }\n          return createStringLiteral(value);\n        }\n        var names = tree.names.map(jsxIdentifierToToken);\n        var operand = names[0];\n        if (operand.type === STRING) {\n          names[0] = new LiteralExpression(operand.location, operand);\n        }\n        return createMemberExpression.apply((void 0), $traceurRuntime.spread(names));\n      },\n      transformJsxAttribute: function(tree) {\n        var name = new LiteralPropertyName(tree.name.location, jsxIdentifierToToken(tree.name));\n        var value;\n        if (tree.value === null) {\n          value = createTrueLiteral();\n        } else if (tree.value.type === LITERAL_EXPRESSION) {\n          var literalToken = tree.value.literalToken;\n          var v = literalToken.value;\n          var location = literalToken.location;\n          var lit = new LiteralToken(STRING, normalizeAttributeValue(v), location);\n          value = new LiteralExpression(location, lit);\n        } else {\n          value = this.transformAny(tree.value);\n        }\n        return createPropertyNameAssignment(name, value);\n      },\n      transformJsxPlaceholder: function(tree) {\n        return this.transformAny(tree.expression);\n      },\n      transformJsxSpreadAttribute: function(tree) {\n        return new SpreadExpression(tree.location, this.transformAny(tree.expression));\n      },\n      transformJsxText: function(tree) {\n        return createStringLiteral(tree.value.value);\n      },\n      transformJsxChildren_: function(trees) {\n        var $__1 = this;\n        var rv = [];\n        trees.forEach(function(tree) {\n          var newTree;\n          switch (tree.type) {\n            case JSX_ELEMENT:\n              newTree = $__1.transformAny(tree);\n              break;\n            case JSX_PLACEHOLDER:\n              if (tree.expression === null) {\n                return;\n              }\n              newTree = $__1.transformAny(tree);\n              break;\n            case JSX_TEXT:\n              {\n                var s = tree.value.value;\n                s = s.replace(/\\t/g, \' \');\n                if (!/[\\n\\r]/.test(s)) {\n                  newTree = createStringLiteral(s);\n                } else {\n                  s = s.replace(/^[ \\t]*[\\n\\r]\\s*/, \'\');\n                  s = s.replace(/[ \\t]*[\\n\\r]\\s*$/, \'\');\n                  if (s === \'\') {\n                    return;\n                  }\n                  newTree = createStringLiteral(s);\n                }\n                break;\n              }\n          }\n          rv.push(newTree);\n        });\n        return rv;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(ParseTreeTransformer));\n  function jsxIdentifierToToken(token) {\n    var value = token.value;\n    if (value.indexOf(\'-\') !== -1) {\n      return createStringLiteralToken(value);\n    }\n    return createIdentifierToken(value);\n  }\n  function normalizeAttributeValue(s) {\n    return JSON.stringify(s.slice(1, -1).replace(/\\n\\s+/g, \' \'));\n  }\n  return {get JsxTransformer() {\n      return JsxTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js";\n  var Method = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js")).Method;\n  var SUPER_EXPRESSION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js")).SUPER_EXPRESSION;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js")).ParseTreeTransformer;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js")),\n      createCommaExpression = $__4.createCommaExpression,\n      createExpressionStatement = $__4.createExpressionStatement,\n      createFunctionBody = $__4.createFunctionBody,\n      createParenExpression = $__4.createParenExpression,\n      createThisExpression = $__4.createThisExpression;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js")).prependStatements;\n  function transformConstructor(constructor, initExpression, superClass) {\n    if (superClass) {\n      var transformer = new SuperCallTransformer(initExpression);\n      return transformer.transformAny(constructor);\n    }\n    var statements = constructor.body.statements;\n    var initStatement = createExpressionStatement(initExpression);\n    statements = prependStatements(statements, initStatement);\n    return new Method(constructor.location, false, constructor.functionKind, constructor.name, constructor.parameterList, constructor.typeAnnotation, constructor.annotations, createFunctionBody(statements), constructor.debugName);\n  }\n  var SuperCallTransformer = function($__super) {\n    function SuperCallTransformer(expression) {\n      $traceurRuntime.superConstructor(SuperCallTransformer).call(this);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(SuperCallTransformer, {\n      transformCallExpression: function(tree) {\n        if (tree.operand.type === SUPER_EXPRESSION) {\n          var thisExpression = createThisExpression();\n          return createParenExpression(createCommaExpression([tree, this.expression, thisExpression]));\n        }\n        return $traceurRuntime.superGet(this, SuperCallTransformer.prototype, "transformCallExpression").call(this, tree);\n      },\n      transformClassDeclaration: function(tree) {\n        return tree;\n      },\n      transformClassExpression: function(tree) {\n        return tree;\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get transformConstructor() {\n      return transformConstructor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js";\n  var CONSTRUCTOR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js")).CONSTRUCTOR;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js")),\n      AnonBlock = $__5.AnonBlock,\n      ClassDeclaration = $__5.ClassDeclaration,\n      ClassExpression = $__5.ClassExpression,\n      FormalParameterList = $__5.FormalParameterList,\n      IdentifierExpression = $__5.IdentifierExpression,\n      Method = $__5.Method,\n      ReturnStatement = $__5.ReturnStatement;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js")),\n      GET_ACCESSOR = $__6.GET_ACCESSOR,\n      METHOD = $__6.METHOD,\n      PROPERTY_VARIABLE_DECLARATION = $__6.PROPERTY_VARIABLE_DECLARATION,\n      SET_ACCESSOR = $__6.SET_ACCESSOR;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js")).TempVarTransformer;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js")),\n      createCommaExpression = $__8.createCommaExpression,\n      createFunctionBody = $__8.createFunctionBody,\n      createIdentifierToken = $__8.createIdentifierToken,\n      createImmediatelyInvokedFunctionExpression = $__8.createImmediatelyInvokedFunctionExpression,\n      createLiteralPropertyName = $__8.createLiteralPropertyName,\n      createRestParameter = $__8.createRestParameter;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js")),\n      parsePropertyDefinition = $__9.parsePropertyDefinition,\n      parseStatement = $__9.parseStatement;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js")).parseExpression;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js")).prependStatements;\n  var propName = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../staticsemantics/PropName.js", "traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js")).propName;\n  var transformConstructor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MemberVariableConstructorTransformer.js", "traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js")).transformConstructor;\n  var MemberVariableTransformer = function($__super) {\n    function MemberVariableTransformer() {\n      $traceurRuntime.superConstructor(MemberVariableTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(MemberVariableTransformer, {\n      transformClassElements_: function(tree) {\n        var $__2 = this;\n        var elements = [];\n        var initInstanceVars = [],\n            initStaticVars = [];\n        var constructor;\n        var constructorIndex = 0;\n        tree.elements.forEach(function(tree) {\n          var initVars;\n          if (tree.isStatic) {\n            initVars = initStaticVars;\n          } else {\n            initVars = initInstanceVars;\n          }\n          switch (tree.type) {\n            case GET_ACCESSOR:\n            case SET_ACCESSOR:\n              elements.push($__2.transformAny(tree));\n              break;\n            case METHOD:\n              if (!tree.isStatic && propName(tree) === CONSTRUCTOR) {\n                constructor = tree;\n                constructorIndex = elements.length;\n              } else {\n                elements.push($__2.transformAny(tree));\n              }\n              break;\n            case PROPERTY_VARIABLE_DECLARATION:\n              tree = $__2.transformAny(tree);\n              if (tree.initializer !== null) {\n                initVars.push(tree);\n              }\n              break;\n            default:\n              throw new Error(("Unexpected class element: " + tree.type));\n          }\n        });\n        if (initInstanceVars.length > 0) {\n          var initExpression = getInstanceInitExpression(initInstanceVars);\n          if (!constructor) {\n            constructor = this.getDefaultConstructor_(tree);\n          }\n          constructor = transformConstructor(constructor, initExpression, tree.superClass);\n        }\n        if (constructor) {\n          elements.splice(constructorIndex, 0, constructor);\n        }\n        return {\n          elements: elements,\n          initStaticVars: initStaticVars\n        };\n      },\n      transformClassDeclaration: function(tree) {\n        var $__3 = this.transformClassElements_(tree),\n            elements = $__3.elements,\n            initStaticVars = $__3.initStaticVars;\n        var superClass = this.transformAny(tree.superClass);\n        var classDecl = new ClassDeclaration(tree.location, tree.name, superClass, elements, tree.annotations, tree.typeParameters);\n        if (initStaticVars.length === 0) {\n          return classDecl;\n        }\n        var statements = createStaticInitializerStatements(tree.name.identifierToken, initStaticVars);\n        statements = prependStatements(statements, classDecl);\n        return new AnonBlock(null, statements);\n      },\n      transformClassExpression: function(tree) {\n        var $__3 = this.transformClassElements_(tree),\n            elements = $__3.elements,\n            initStaticVars = $__3.initStaticVars;\n        var superClass = this.transformAny(tree.superClass);\n        var classExpression = new ClassExpression(tree.location, tree.name, superClass, elements, tree.annotations, tree.typeParameters);\n        if (initStaticVars.length === 0) {\n          return classExpression;\n        }\n        this.pushTempScope();\n        var id = this.getTempIdentifier();\n        var idToken = createIdentifierToken(id);\n        var idExpression = new IdentifierExpression(idToken.location, idToken);\n        var statements = $traceurRuntime.spread([parseStatement($traceurRuntime.getTemplateObject(["let ", " = ", ""]), id, classExpression)], createStaticInitializerStatements(idToken, initStaticVars), [new ReturnStatement(null, idExpression)]);\n        var body = createFunctionBody(statements);\n        this.popTempScope();\n        return createImmediatelyInvokedFunctionExpression(body);\n      },\n      getDefaultConstructor_: function(tree) {\n        if (tree.superClass) {\n          var param = createRestParameter(createIdentifierToken(\'args\'));\n          var paramList = new FormalParameterList(null, [param]);\n          var body = createFunctionBody([parseStatement($traceurRuntime.getTemplateObject(["super(...args)"]))]);\n          var name = createLiteralPropertyName(CONSTRUCTOR);\n          return new Method(tree.location, false, null, name, paramList, null, [], body, null);\n        }\n        return parsePropertyDefinition($traceurRuntime.getTemplateObject(["constructor() {}"]));\n      }\n    }, {}, $__super);\n  }(TempVarTransformer);\n  function createStaticInitializerStatements(idToken, initStaticMemberVars) {\n    var className = new IdentifierExpression(idToken.location, idToken);\n    return initStaticMemberVars.map(function(mv) {\n      var propName = mv.name.literalToken.value;\n      return parseStatement($traceurRuntime.getTemplateObject(["Object.defineProperty(", ", ", ", {enumerable: true,\\n        configurable: true, value: ", ", writable: true})"]), className, propName, mv.initializer);\n    });\n  }\n  function getInstanceInitExpression(initInstanceVars) {\n    var expressions = initInstanceVars.map(function(mv) {\n      var name = mv.name.literalToken;\n      return parseExpression($traceurRuntime.getTemplateObject(["this.", " = ", ""]), name, mv.initializer);\n    });\n    return createCommaExpression(expressions);\n  }\n  return {get MemberVariableTransformer() {\n      return MemberVariableTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js";\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js")),\n      BLOCK = $__4.BLOCK,\n      CLASS_DECLARATION = $__4.CLASS_DECLARATION,\n      FUNCTION_DECLARATION = $__4.FUNCTION_DECLARATION,\n      IF_STATEMENT = $__4.IF_STATEMENT,\n      LITERAL_EXPRESSION = $__4.LITERAL_EXPRESSION,\n      POSTFIX_EXPRESSION = $__4.POSTFIX_EXPRESSION,\n      UNARY_EXPRESSION = $__4.UNARY_EXPRESSION;\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/ParseTreeVisitor.js", "traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js")).ParseTreeVisitor;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js")),\n      AS = $__6.AS,\n      ASYNC = $__6.ASYNC,\n      AWAIT = $__6.AWAIT,\n      FROM = $__6.FROM,\n      GET = $__6.GET,\n      OF = $__6.OF,\n      ON = $__6.ON,\n      SET = $__6.SET,\n      TYPE = $__6.TYPE;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/Scanner.js", "traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js")),\n      isIdentifierPart = $__7.isIdentifierPart,\n      isWhitespace = $__7.isWhitespace;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js")),\n      ARROW = $__8.ARROW,\n      AT = $__8.AT,\n      BACK_QUOTE = $__8.BACK_QUOTE,\n      BAR = $__8.BAR,\n      BREAK = $__8.BREAK,\n      CASE = $__8.CASE,\n      CATCH = $__8.CATCH,\n      CLASS = $__8.CLASS,\n      CLOSE_ANGLE = $__8.CLOSE_ANGLE,\n      CLOSE_CURLY = $__8.CLOSE_CURLY,\n      CLOSE_PAREN = $__8.CLOSE_PAREN,\n      CLOSE_SQUARE = $__8.CLOSE_SQUARE,\n      COLON = $__8.COLON,\n      COMMA = $__8.COMMA,\n      CONTINUE = $__8.CONTINUE,\n      DEBUGGER = $__8.DEBUGGER,\n      DEFAULT = $__8.DEFAULT,\n      DO = $__8.DO,\n      DOT_DOT_DOT = $__8.DOT_DOT_DOT,\n      ELSE = $__8.ELSE,\n      EQUAL = $__8.EQUAL,\n      EXPORT = $__8.EXPORT,\n      EXTENDS = $__8.EXTENDS,\n      FINALLY = $__8.FINALLY,\n      FOR = $__8.FOR,\n      FUNCTION = $__8.FUNCTION,\n      IF = $__8.IF,\n      IMPORT = $__8.IMPORT,\n      IN = $__8.IN,\n      INTERFACE = $__8.INTERFACE,\n      MINUS = $__8.MINUS,\n      MINUS_MINUS = $__8.MINUS_MINUS,\n      NEW = $__8.NEW,\n      NUMBER = $__8.NUMBER,\n      OPEN_ANGLE = $__8.OPEN_ANGLE,\n      OPEN_CURLY = $__8.OPEN_CURLY,\n      OPEN_PAREN = $__8.OPEN_PAREN,\n      OPEN_SQUARE = $__8.OPEN_SQUARE,\n      PERIOD = $__8.PERIOD,\n      PLUS = $__8.PLUS,\n      PLUS_PLUS = $__8.PLUS_PLUS,\n      QUESTION = $__8.QUESTION,\n      RETURN = $__8.RETURN,\n      SEMI_COLON = $__8.SEMI_COLON,\n      SLASH = $__8.SLASH,\n      STAR = $__8.STAR,\n      STATIC = $__8.STATIC,\n      SUPER = $__8.SUPER,\n      SWITCH = $__8.SWITCH,\n      THIS = $__8.THIS,\n      THROW = $__8.THROW,\n      TRY = $__8.TRY,\n      WHILE = $__8.WHILE,\n      WITH = $__8.WITH,\n      YIELD = $__8.YIELD;\n  var NEW_LINE = \'\\n\';\n  var LINE_LENGTH = 80;\n  var ParseTreeWriter = function($__super) {\n    function ParseTreeWriter() {\n      var $__3;\n      var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},\n          prettyPrint = ($__3 = $__2.prettyPrint) === void 0 ? true : $__3;\n      $traceurRuntime.superConstructor(ParseTreeWriter).call(this);\n      this.prettyPrint_ = prettyPrint;\n      this.result_ = \'\';\n      this.currentLine_ = \'\';\n      this.lastCode_ = -1;\n      this.indentDepth_ = 0;\n      this.currentParameterTypeAnnotation_ = null;\n    }\n    return ($traceurRuntime.createClass)(ParseTreeWriter, {\n      toString: function() {\n        if (this.currentLine_.length > 0) {\n          this.result_ += this.currentLine_;\n          this.currentLine_ = \'\';\n          this.lastCode_ = -1;\n        }\n        return this.result_;\n      },\n      visitAnnotation: function(tree) {\n        this.write_(AT);\n        this.visitAny(tree.name);\n        if (tree.args !== null) {\n          this.write_(OPEN_PAREN);\n          this.writeList_(tree.args.args, COMMA, false);\n          this.write_(CLOSE_PAREN);\n        }\n      },\n      visitArgumentList: function(tree) {\n        this.write_(OPEN_PAREN);\n        this.writeList_(tree.args, COMMA, false);\n        this.write_(CLOSE_PAREN);\n      },\n      visitArrayComprehension: function(tree) {\n        this.write_(OPEN_SQUARE);\n        this.visitList(tree.comprehensionList);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_SQUARE);\n      },\n      visitArrayLiteral: function(tree) {\n        this.write_(OPEN_SQUARE);\n        this.writeList_(tree.elements, COMMA, false);\n        if (tree.elements[tree.elements.length - 1] === null) {\n          this.write_(COMMA);\n          this.writeSpace_();\n        }\n        this.write_(CLOSE_SQUARE);\n      },\n      visitArrayPattern: function(tree) {\n        this.write_(OPEN_SQUARE);\n        this.writeList_(tree.elements, COMMA, false);\n        if (tree.elements[tree.elements.length - 1] === null) {\n          this.write_(COMMA);\n          this.writeSpace_();\n        }\n        this.write_(CLOSE_SQUARE);\n      },\n      visitArrayType: function(tree) {\n        this.visitAny(tree.elementType);\n        this.write_(OPEN_SQUARE);\n        this.write_(CLOSE_SQUARE);\n      },\n      visitArrowFunction: function(tree) {\n        if (tree.functionKind) {\n          this.writeToken_(tree.functionKind);\n          this.writeSpace_();\n        }\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.write_(ARROW);\n        this.writeSpace_();\n        this.visitAny(tree.body);\n      },\n      visitAssignmentElement: function(tree) {\n        this.visitAny(tree.assignment);\n        if (tree.initializer) {\n          this.writeSpace_();\n          this.write_(EQUAL);\n          this.writeSpace_();\n          this.visitAny(tree.initializer);\n        }\n      },\n      visitAwaitExpression: function(tree) {\n        this.write_(AWAIT);\n        this.writeSpace_();\n        this.visitAny(tree.expression);\n      },\n      visitBinaryExpression: function(tree) {\n        var left = tree.left;\n        this.visitAny(left);\n        var operator = tree.operator;\n        if (left.type === POSTFIX_EXPRESSION && requiresSpaceBetween(left.operator.type, operator.type)) {\n          this.writeRequiredSpace_();\n        } else {\n          this.writeSpace_();\n        }\n        this.writeToken_(operator);\n        var right = tree.right;\n        if (right.type === UNARY_EXPRESSION && requiresSpaceBetween(operator.type, right.operator.type)) {\n          this.writeRequiredSpace_();\n        } else {\n          this.writeSpace_();\n        }\n        this.visitAny(right);\n      },\n      visitBindingElement: function(tree) {\n        var typeAnnotation = this.currentParameterTypeAnnotation_;\n        this.currentParameterTypeAnnotation_ = null;\n        this.visitAny(tree.binding);\n        this.writeTypeAnnotation_(typeAnnotation);\n        if (tree.initializer) {\n          this.writeSpace_();\n          this.write_(EQUAL);\n          this.writeSpace_();\n          this.visitAny(tree.initializer);\n        }\n      },\n      visitBindingIdentifier: function(tree) {\n        this.writeToken_(tree.identifierToken);\n      },\n      visitBlock: function(tree) {\n        this.writeOpenCurly_();\n        this.writelnList_(tree.statements, null);\n        this.writeCloseCurly_();\n      },\n      visitBreakStatement: function(tree) {\n        this.write_(BREAK);\n        if (tree.name !== null) {\n          this.writeSpace_();\n          this.writeToken_(tree.name);\n        }\n        this.write_(SEMI_COLON);\n      },\n      visitCallExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.visitAny(tree.args);\n      },\n      visitCallSignature: function(tree) {\n        if (tree.typeParameters) {\n          this.visitAny(tree.typeParameters);\n        }\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeTypeAnnotation_(tree.returnType);\n      },\n      visitCaseClause: function(tree) {\n        this.write_(CASE);\n        this.writeSpace_();\n        this.visitAny(tree.expression);\n        this.write_(COLON);\n        this.indentDepth_++;\n        this.writelnList_(tree.statements, null);\n        this.indentDepth_--;\n      },\n      visitCatch: function(tree) {\n        this.write_(CATCH);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.binding);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.visitAny(tree.catchBody);\n      },\n      visitClassShared_: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        this.write_(CLASS);\n        this.writeSpace_();\n        this.visitAny(tree.name);\n        if (tree.typeParameters !== null) {\n          this.visitAny(tree.typeParameters);\n        }\n        if (tree.superClass !== null) {\n          this.writeSpace_();\n          this.write_(EXTENDS);\n          this.writeSpace_();\n          this.visitAny(tree.superClass);\n        }\n        this.writeSpace_();\n        this.writeOpenCurly_();\n        this.writelnList_(tree.elements, null);\n        this.writeCloseCurly_();\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitClassShared_(tree);\n      },\n      visitClassExpression: function(tree) {\n        this.visitClassShared_(tree);\n      },\n      visitCommaExpression: function(tree) {\n        this.writeList_(tree.expressions, COMMA, false);\n      },\n      visitComprehensionFor: function(tree) {\n        this.write_(FOR);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.left);\n        this.writeSpace_();\n        this.write_(OF);\n        this.writeSpace_();\n        this.visitAny(tree.iterator);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n      },\n      visitComprehensionIf: function(tree) {\n        this.write_(IF);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n      },\n      visitComputedPropertyName: function(tree) {\n        this.write_(OPEN_SQUARE);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_SQUARE);\n      },\n      visitConstructSignature: function(tree) {\n        this.write_(NEW);\n        this.writeSpace_();\n        this.visitCallSignature(tree);\n      },\n      visitConstructorType: function(tree) {\n        this.write_(NEW);\n        this.writeSpace_();\n        this.visitFunctionType(tree);\n      },\n      visitConditionalExpression: function(tree) {\n        this.visitAny(tree.condition);\n        this.writeSpace_();\n        this.write_(QUESTION);\n        this.writeSpace_();\n        this.visitAny(tree.left);\n        this.writeSpace_();\n        this.write_(COLON);\n        this.writeSpace_();\n        this.visitAny(tree.right);\n      },\n      visitContinueStatement: function(tree) {\n        this.write_(CONTINUE);\n        if (tree.name !== null) {\n          this.writeSpace_();\n          this.writeToken_(tree.name);\n        }\n        this.write_(SEMI_COLON);\n      },\n      visitCoverInitializedName: function(tree) {\n        this.writeToken_(tree.name);\n        this.writeSpace_();\n        this.writeToken_(tree.equalToken);\n        this.writeSpace_();\n        this.visitAny(tree.initializer);\n      },\n      visitDebuggerStatement: function(tree) {\n        this.write_(DEBUGGER);\n        this.write_(SEMI_COLON);\n      },\n      visitDefaultClause: function(tree) {\n        this.write_(DEFAULT);\n        this.write_(COLON);\n        this.indentDepth_++;\n        this.writelnList_(tree.statements, null);\n        this.indentDepth_--;\n      },\n      visitDoWhileStatement: function(tree) {\n        this.write_(DO);\n        this.visitAnyBlockOrIndent_(tree.body);\n        this.writeSpace_();\n        this.write_(WHILE);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.condition);\n        this.write_(CLOSE_PAREN);\n        this.write_(SEMI_COLON);\n      },\n      visitEmptyStatement: function(tree) {\n        this.write_(SEMI_COLON);\n      },\n      visitExportDeclaration: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        this.write_(EXPORT);\n        this.writeSpace_();\n        this.visitAny(tree.declaration);\n      },\n      visitExportDefault: function(tree) {\n        this.write_(DEFAULT);\n        this.writeSpace_();\n        this.visitAny(tree.expression);\n        switch (tree.expression.type) {\n          case CLASS_DECLARATION:\n          case FUNCTION_DECLARATION:\n            break;\n          default:\n            this.write_(SEMI_COLON);\n        }\n      },\n      visitNameSpaceExport: function(tree) {\n        this.write_(STAR);\n        this.writeSpace_();\n        this.write_(AS);\n        this.writeSpace_();\n        this.writeToken_(tree.name);\n      },\n      visitNameSpaceImport: function(tree) {\n        this.write_(STAR);\n        this.writeSpace_();\n        this.write_(AS);\n        this.writeSpace_();\n        this.visitAny(tree.binding);\n      },\n      visitNamedExport: function(tree) {\n        this.visitAny(tree.exportClause);\n        if (tree.moduleSpecifier) {\n          this.writeSpace_();\n          this.write_(FROM);\n          this.writeSpace_();\n          this.visitAny(tree.moduleSpecifier);\n        }\n        this.write_(SEMI_COLON);\n      },\n      visitExportSpecifier: function(tree) {\n        this.writeToken_(tree.lhs);\n        if (tree.rhs) {\n          this.writeSpace_();\n          this.write_(AS);\n          this.writeSpace_();\n          this.writeToken_(tree.rhs);\n        }\n      },\n      visitExportSpecifierSet: function(tree) {\n        this.writeOpenCurly_();\n        this.writeList_(tree.specifiers, COMMA, false);\n        this.writeCloseCurly_();\n      },\n      visitExportStar: function(tree) {\n        this.write_(STAR);\n      },\n      visitExpressionStatement: function(tree) {\n        this.visitAny(tree.expression);\n        this.write_(SEMI_COLON);\n      },\n      visitFinally: function(tree) {\n        this.write_(FINALLY);\n        this.writeSpace_();\n        this.visitAny(tree.block);\n      },\n      visitForOfStatement: function(tree) {\n        this.write_(FOR);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.initializer);\n        this.writeSpace_();\n        this.write_(OF);\n        this.writeSpace_();\n        this.visitAny(tree.collection);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.body);\n      },\n      visitForOnStatement: function(tree) {\n        this.write_(FOR);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.initializer);\n        this.writeSpace_();\n        this.write_(ON);\n        this.writeSpace_();\n        this.visitAny(tree.observable);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.body);\n      },\n      visitForInStatement: function(tree) {\n        this.write_(FOR);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.initializer);\n        this.writeSpace_();\n        this.write_(IN);\n        this.writeSpace_();\n        this.visitAny(tree.collection);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.body);\n      },\n      visitForStatement: function(tree) {\n        this.write_(FOR);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.initializer);\n        this.write_(SEMI_COLON);\n        this.writeSpace_();\n        this.visitAny(tree.condition);\n        this.write_(SEMI_COLON);\n        this.writeSpace_();\n        this.visitAny(tree.increment);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.body);\n      },\n      visitFormalParameterList: function(tree) {\n        var first = true;\n        for (var i = 0; i < tree.parameters.length; i++) {\n          var parameter = tree.parameters[i];\n          if (first) {\n            first = false;\n          } else {\n            this.write_(COMMA);\n            this.writeSpace_();\n          }\n          this.visitAny(parameter);\n        }\n      },\n      visitFormalParameter: function(tree) {\n        this.writeAnnotations_(tree.annotations, false);\n        this.currentParameterTypeAnnotation_ = tree.typeAnnotation;\n        this.visitAny(tree.parameter);\n        this.currentParameterTypeAnnotation_ = null;\n      },\n      visitForwardDefaultExport: function(tree) {\n        this.writeToken_(tree.name);\n      },\n      visitFunctionBody: function(tree) {\n        this.writeOpenCurly_();\n        this.writelnList_(tree.statements, null);\n        this.writeCloseCurly_();\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitFunctionExpression: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitFunction_: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        if (tree.isAsyncGenerator()) {\n          this.write_(ASYNC);\n        }\n        if (tree.isAsyncFunction())\n          this.writeToken_(tree.functionKind);\n        this.write_(FUNCTION);\n        if (tree.isAsyncGenerator()) {\n          this.write_(STAR);\n        }\n        if (tree.isGenerator())\n          this.writeToken_(tree.functionKind);\n        if (tree.name) {\n          this.writeSpace_();\n          this.visitAny(tree.name);\n        }\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        this.writeSpace_();\n        this.visitAny(tree.body);\n      },\n      visitFunctionType: function(tree) {\n        if (tree.typeParameters !== null) {\n          this.visitAny(tree.typeParameters);\n        }\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.write_(ARROW);\n        this.writeSpace_();\n        this.visitAny(tree.returnType);\n      },\n      visitGeneratorComprehension: function(tree) {\n        this.write_(OPEN_PAREN);\n        this.visitList(tree.comprehensionList);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_PAREN);\n      },\n      visitGetAccessor: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        if (tree.isStatic) {\n          this.write_(STATIC);\n          this.writeSpace_();\n        }\n        this.write_(GET);\n        this.writeSpace_();\n        this.visitAny(tree.name);\n        this.write_(OPEN_PAREN);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        this.visitAny(tree.body);\n      },\n      visitIdentifierExpression: function(tree) {\n        this.writeToken_(tree.identifierToken);\n      },\n      visitIfStatement: function(tree) {\n        this.write_(IF);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.condition);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.ifClause);\n        if (tree.elseClause) {\n          if (tree.ifClause.type === BLOCK)\n            this.writeSpace_();\n          this.write_(ELSE);\n          if (tree.elseClause.type === IF_STATEMENT) {\n            this.writeSpace_();\n            this.visitAny(tree.elseClause);\n          } else {\n            this.visitAnyBlockOrIndent_(tree.elseClause);\n          }\n        }\n      },\n      visitIndexSignature: function(tree) {\n        this.write_(OPEN_SQUARE);\n        this.writeToken_(tree.name);\n        this.write_(COLON);\n        this.writeSpace_();\n        this.visitAny(tree.indexType);\n        this.write_(CLOSE_SQUARE);\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        this.write_(SEMI_COLON);\n      },\n      visitInterfaceDeclaration: function(tree) {\n        this.write_(INTERFACE);\n        this.writeSpace_();\n        this.writeToken_(tree.name);\n        if (tree.typeParameters) {\n          this.visitAny(tree.typeParameters);\n        }\n        if (tree.extendsClause.length > 0) {\n          this.writeSpace_();\n          this.write_(EXTENDS);\n          this.writeSpace_();\n          this.writeList_(tree.extendsClause, COMMA, false);\n        }\n        this.writeSpace_();\n        this.visitAny(tree.objectType);\n      },\n      visitAnyBlockOrIndent_: function(tree) {\n        if (tree.type === BLOCK) {\n          this.writeSpace_();\n          this.visitAny(tree);\n        } else {\n          this.visitAnyIndented_(tree);\n        }\n      },\n      visitAnyIndented_: function(tree) {\n        var indent = arguments[1] !== (void 0) ? arguments[1] : 1;\n        if (this.prettyPrint_) {\n          this.indentDepth_ += indent;\n          this.writeln_();\n        }\n        this.visitAny(tree);\n        if (this.prettyPrint_) {\n          this.indentDepth_ -= indent;\n          this.writeln_();\n        }\n      },\n      visitImportClausePair: function(tree) {\n        this.visitAny(tree.first);\n        this.write_(COMMA);\n        this.writeSpace_();\n        this.visitAny(tree.second);\n      },\n      visitImportDeclaration: function(tree) {\n        this.write_(IMPORT);\n        this.writeSpace_();\n        if (tree.importClause) {\n          this.visitAny(tree.importClause);\n          this.writeSpace_();\n          this.write_(FROM);\n          this.writeSpace_();\n        }\n        this.visitAny(tree.moduleSpecifier);\n        this.write_(SEMI_COLON);\n      },\n      visitImportSpecifier: function(tree) {\n        if (tree.name) {\n          this.writeToken_(tree.name);\n          this.writeSpace_();\n          this.write_(AS);\n          this.writeSpace_();\n        }\n        this.visitAny(tree.binding);\n      },\n      visitImportSpecifierSet: function(tree) {\n        if (tree.specifiers.type === STAR) {\n          this.write_(STAR);\n        } else {\n          this.writeOpenCurly_();\n          this.writelnList_(tree.specifiers, COMMA);\n          this.writeCloseCurly_();\n        }\n      },\n      visitImportTypeClause: function(tree) {\n        this.write_(TYPE);\n        this.writeSpace_();\n        this.visitAny(tree.clause);\n      },\n      visitJsxAttribute: function(tree) {\n        this.writeToken_(tree.name);\n        if (tree.value !== null) {\n          this.write_(EQUAL);\n          this.visitAny(tree.value);\n        }\n      },\n      visitJsxElement: function(tree) {\n        this.write_(OPEN_ANGLE);\n        this.visitAny(tree.name);\n        for (var i = 0; i < tree.attributes.length; i++) {\n          this.writeSpace_();\n          this.visitAny(tree.attributes[i]);\n        }\n        if (tree.children.length === 0) {\n          this.write_(SLASH);\n          this.write_(CLOSE_ANGLE);\n        } else {\n          this.write_(CLOSE_ANGLE);\n          this.visitList(tree.children);\n          this.write_(OPEN_ANGLE);\n          this.write_(SLASH);\n          this.lastCode_ = -1;\n          this.visitAny(tree.name);\n          this.write_(CLOSE_ANGLE);\n        }\n      },\n      visitJsxElementName: function(tree) {\n        for (var i = 0; i < tree.names.length; i++) {\n          if (i > 0) {\n            this.write_(PERIOD);\n          }\n          this.writeToken_(tree.names[i]);\n        }\n      },\n      visitJsxPlaceholder: function(tree) {\n        this.write_(OPEN_CURLY);\n        if (tree.expression !== null) {\n          this.visitAny(tree.expression);\n        }\n        this.write_(CLOSE_CURLY);\n      },\n      visitJsxSpreadAttribute: function(tree) {\n        this.write_(OPEN_CURLY);\n        this.write_(DOT_DOT_DOT);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_CURLY);\n      },\n      visitJsxText: function(tree) {\n        this.writeToken_(tree.value);\n      },\n      visitLabelledStatement: function(tree) {\n        this.writeToken_(tree.name);\n        this.write_(COLON);\n        this.writeSpace_();\n        this.visitAny(tree.statement);\n      },\n      visitLiteralExpression: function(tree) {\n        this.writeToken_(tree.literalToken);\n      },\n      visitLiteralPropertyName: function(tree) {\n        this.writeToken_(tree.literalToken);\n      },\n      visitMemberExpression: function(tree) {\n        this.visitAny(tree.operand);\n        if (tree.operand.type === LITERAL_EXPRESSION && tree.operand.literalToken.type === NUMBER) {\n          if (!/\\.|e|E/.test(tree.operand.literalToken.value))\n            this.writeRequiredSpace_();\n        }\n        this.write_(PERIOD);\n        this.writeToken_(tree.memberName);\n      },\n      visitMemberLookupExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.write_(OPEN_SQUARE);\n        this.visitAny(tree.memberExpression);\n        this.write_(CLOSE_SQUARE);\n      },\n      visitMethodSignature: function(tree) {\n        this.visitAny(tree.name);\n        if (tree.optional) {\n          this.write_(QUESTION);\n        }\n        this.visitAny(tree.callSignature);\n        this.write_(SEMI_COLON);\n      },\n      visitSyntaxErrorTree: function(tree) {\n        this.write_(\'(function() {\' + ("throw SyntaxError(" + JSON.stringify(tree.message) + ");") + \'})()\');\n      },\n      visitModule: function(tree) {\n        this.writelnList_(tree.scriptItemList, null);\n      },\n      visitModuleSpecifier: function(tree) {\n        this.writeToken_(tree.token);\n      },\n      visitNewExpression: function(tree) {\n        this.write_(NEW);\n        this.writeSpace_();\n        this.visitAny(tree.operand);\n        this.visitAny(tree.args);\n      },\n      visitObjectLiteral: function(tree) {\n        this.writeOpenCurly_();\n        if (tree.propertyNameAndValues.length > 1)\n          this.writeln_();\n        this.writelnList_(tree.propertyNameAndValues, COMMA);\n        if (tree.propertyNameAndValues.length > 1)\n          this.writeln_();\n        this.writeCloseCurly_();\n      },\n      visitObjectPattern: function(tree) {\n        this.writeOpenCurly_();\n        this.writelnList_(tree.fields, COMMA);\n        this.writeCloseCurly_();\n      },\n      visitObjectPatternField: function(tree) {\n        this.visitAny(tree.name);\n        if (tree.element !== null) {\n          this.write_(COLON);\n          this.writeSpace_();\n          this.visitAny(tree.element);\n        }\n      },\n      visitObjectType: function(tree) {\n        this.writeOpenCurly_();\n        this.writelnList_(tree.typeMembers, null);\n        this.writeCloseCurly_();\n      },\n      visitParenExpression: function(tree) {\n        this.write_(OPEN_PAREN);\n        $traceurRuntime.superGet(this, ParseTreeWriter.prototype, "visitParenExpression").call(this, tree);\n        this.write_(CLOSE_PAREN);\n      },\n      visitPostfixExpression: function(tree) {\n        this.visitAny(tree.operand);\n        if (tree.operand.type === POSTFIX_EXPRESSION && tree.operand.operator.type === tree.operator.type) {\n          this.writeRequiredSpace_();\n        }\n        this.writeToken_(tree.operator);\n      },\n      visitPredefinedType: function(tree) {\n        this.writeToken_(tree.typeToken);\n      },\n      visitScript: function(tree) {\n        this.writelnList_(tree.scriptItemList, null);\n      },\n      visitMethod: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        if (tree.isStatic) {\n          this.write_(STATIC);\n          this.writeSpace_();\n        }\n        if (tree.isAsyncFunction() || tree.isAsyncGenerator())\n          this.write_(ASYNC);\n        if (tree.isGenerator() || tree.isAsyncGenerator())\n          this.write_(STAR);\n        if (tree.isAsyncGenerator())\n          this.writeSpace_();\n        this.visitAny(tree.name);\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        this.visitAny(tree.body);\n      },\n      visitPropertyNameAssignment: function(tree) {\n        this.visitAny(tree.name);\n        this.write_(COLON);\n        this.writeSpace_();\n        this.visitAny(tree.value);\n      },\n      visitPropertyNameShorthand: function(tree) {\n        this.writeToken_(tree.name);\n      },\n      visitPropertyVariableDeclaration: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        if (tree.isStatic) {\n          this.write_(STATIC);\n          this.writeSpace_();\n        }\n        this.visitAny(tree.name);\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        if (tree.initalizer) {\n          this.writeSpace_();\n          this.write_(EQUAL);\n          this.writeSpace_();\n          this.visitAny(tree.initializer);\n        }\n        this.write_(SEMI_COLON);\n      },\n      visitPropertySignature: function(tree) {\n        this.visitAny(tree.name);\n        if (tree.optional) {\n          this.write_(QUESTION);\n        }\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        this.write_(SEMI_COLON);\n      },\n      visitTemplateLiteralExpression: function(tree) {\n        if (tree.operand) {\n          this.visitAny(tree.operand);\n          this.writeSpace_();\n        }\n        this.writeRaw_(BACK_QUOTE);\n        this.visitList(tree.elements);\n        this.writeRaw_(BACK_QUOTE);\n      },\n      visitTemplateLiteralPortion: function(tree) {\n        this.writeToken_(tree.value);\n      },\n      visitTemplateSubstitution: function(tree) {\n        this.writeRaw_(\'$\');\n        this.writeRaw_(OPEN_CURLY);\n        this.visitAny(tree.expression);\n        this.writeRaw_(CLOSE_CURLY);\n      },\n      visitReturnStatement: function(tree) {\n        this.write_(RETURN);\n        if (tree.expression) {\n          this.writeSpace_(tree.expression);\n          this.visitAny(tree.expression);\n        }\n        this.write_(SEMI_COLON);\n      },\n      visitRestParameter: function(tree) {\n        this.write_(DOT_DOT_DOT);\n        this.visitAny(tree.identifier);\n      },\n      visitSetAccessor: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        if (tree.isStatic) {\n          this.write_(STATIC);\n          this.writeSpace_();\n        }\n        this.write_(SET);\n        this.writeSpace_();\n        this.visitAny(tree.name);\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.visitAny(tree.body);\n      },\n      visitSpreadExpression: function(tree) {\n        this.write_(DOT_DOT_DOT);\n        this.visitAny(tree.expression);\n      },\n      visitSpreadPatternElement: function(tree) {\n        this.write_(DOT_DOT_DOT);\n        this.visitAny(tree.lvalue);\n      },\n      visitStateMachine: function(tree) {\n        throw new Error(\'State machines cannot be converted to source\');\n      },\n      visitSuperExpression: function(tree) {\n        this.write_(SUPER);\n      },\n      visitSwitchStatement: function(tree) {\n        this.write_(SWITCH);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.writeOpenCurly_();\n        this.writelnList_(tree.caseClauses, null);\n        this.writeCloseCurly_();\n      },\n      visitThisExpression: function(tree) {\n        this.write_(THIS);\n      },\n      visitThrowStatement: function(tree) {\n        this.write_(THROW);\n        this.writeSpace_();\n        this.visitAny(tree.value);\n        this.write_(SEMI_COLON);\n      },\n      visitTryStatement: function(tree) {\n        this.write_(TRY);\n        this.writeSpace_();\n        this.visitAny(tree.body);\n        if (tree.catchBlock) {\n          this.writeSpace_();\n          this.visitAny(tree.catchBlock);\n        }\n        if (tree.finallyBlock) {\n          this.writeSpace_();\n          this.visitAny(tree.finallyBlock);\n        }\n      },\n      visitTypeAliasDeclaration: function(tree) {\n        this.write_(TYPE);\n        this.writeRequiredSpace_();\n        this.writeToken_(tree.name);\n        this.writeSpace_();\n        this.write_(EQUAL);\n        this.writeSpace_();\n        this.visitAny(tree.value);\n        this.write_(SEMI_COLON);\n      },\n      visitTypeArguments: function(tree) {\n        this.write_(OPEN_ANGLE);\n        var args = tree.args;\n        this.visitAny(args[0]);\n        for (var i = 1; i < args.length; i++) {\n          this.write_(COMMA);\n          this.writeSpace_();\n          this.visitAny(args[i]);\n        }\n        this.write_(CLOSE_ANGLE);\n      },\n      visitTypeName: function(tree) {\n        if (tree.moduleName) {\n          this.visitAny(tree.moduleName);\n          this.write_(PERIOD);\n        }\n        this.writeToken_(tree.name);\n      },\n      visitTypeParameter: function(tree) {\n        this.writeToken_(tree.identifierToken);\n        if (tree.extendsType) {\n          this.writeSpace_();\n          this.write_(EXTENDS);\n          this.writeSpace_();\n          this.visitAny(tree.extendsType);\n        }\n      },\n      visitTypeParameters: function(tree) {\n        this.write_(OPEN_ANGLE);\n        this.writeList_(tree.parameters, COMMA, false);\n        this.write_(CLOSE_ANGLE);\n      },\n      visitUnaryExpression: function(tree) {\n        var op = tree.operator;\n        this.writeToken_(op);\n        var operand = tree.operand;\n        if (operand.type === UNARY_EXPRESSION && requiresSpaceBetween(op.type, operand.operator.type)) {\n          this.writeRequiredSpace_();\n        }\n        this.visitAny(operand);\n      },\n      visitUnionType: function(tree) {\n        this.visitAny(tree.types[0]);\n        for (var i = 1; i < tree.types.length; i++) {\n          this.writeSpace_();\n          this.write_(BAR);\n          this.writeSpace_();\n          this.visitAny(tree.types[i]);\n        }\n      },\n      visitVariableDeclarationList: function(tree) {\n        this.write_(tree.declarationType);\n        this.writeSpace_();\n        this.writeList_(tree.declarations, COMMA, true, 2);\n      },\n      visitVariableDeclaration: function(tree) {\n        this.visitAny(tree.lvalue);\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        if (tree.initializer !== null) {\n          this.writeSpace_();\n          this.write_(EQUAL);\n          this.writeSpace_();\n          this.visitAny(tree.initializer);\n        }\n      },\n      visitVariableStatement: function(tree) {\n        $traceurRuntime.superGet(this, ParseTreeWriter.prototype, "visitVariableStatement").call(this, tree);\n        this.write_(SEMI_COLON);\n      },\n      visitWhileStatement: function(tree) {\n        this.write_(WHILE);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.condition);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.body);\n      },\n      visitWithStatement: function(tree) {\n        this.write_(WITH);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.visitAny(tree.body);\n      },\n      visitYieldExpression: function(tree) {\n        this.write_(YIELD);\n        if (tree.isYieldFor)\n          this.write_(STAR);\n        if (tree.expression) {\n          this.writeSpace_();\n          this.visitAny(tree.expression);\n        }\n      },\n      writeCurrentln_: function() {\n        this.result_ += this.currentLine_ + NEW_LINE;\n      },\n      writeln_: function() {\n        if (this.currentLine_)\n          this.writeCurrentln_();\n        this.currentLine_ = \'\';\n        this.lastCode_ = -1;\n      },\n      writelnList_: function(list, delimiter) {\n        if (delimiter !== null) {\n          this.writeList_(list, delimiter, true);\n        } else {\n          if (list.length > 0)\n            this.writeln_();\n          this.writeList_(list, \'\', true);\n          if (list.length > 0)\n            this.writeln_();\n        }\n      },\n      writeList_: function(list, delimiter, writeNewLine) {\n        var indent = arguments[3] !== (void 0) ? arguments[3] : 0;\n        var first = true;\n        for (var i = 0; i < list.length; i++) {\n          if (first) {\n            first = false;\n          } else {\n            if (delimiter !== \'\') {\n              this.write_(delimiter);\n              if (!writeNewLine)\n                this.writeSpace_();\n            }\n            if (writeNewLine) {\n              if (i === 1)\n                this.indentDepth_ += indent;\n              this.writeln_();\n            }\n          }\n          this.visitAny(list[i]);\n        }\n        if (writeNewLine && list.length > 1)\n          this.indentDepth_ -= indent;\n      },\n      writeRaw_: function(value) {\n        this.currentLine_ += value;\n        this.lastCode_ = value.charCodeAt(value.length - 1);\n      },\n      writeToken_: function(token) {\n        this.write_(token.toString());\n      },\n      write_: function(value) {\n        if (this.prettyPrint_ && this.currentLine_.length === 0) {\n          for (var i = 0,\n              indent = this.indentDepth_; i < indent; i++) {\n            this.writeRaw_(\'  \');\n          }\n        }\n        if (this.needsSpace_(value)) {\n          this.writeRaw_(\' \');\n        }\n        this.writeRaw_(value);\n      },\n      writeCloseCurly_: function() {\n        this.indentDepth_--;\n        this.write_(CLOSE_CURLY);\n      },\n      writeOpenCurly_: function() {\n        this.write_(OPEN_CURLY);\n        this.indentDepth_++;\n      },\n      writeSpace_: function() {\n        if (this.prettyPrint_ && !isWhitespace(this.lastCode_)) {\n          this.writeRaw_(\' \');\n        }\n      },\n      writeRequiredSpace_: function() {\n        if (!isWhitespace(this.lastCode_)) {\n          this.writeRaw_(\' \');\n        }\n      },\n      writeTypeAnnotation_: function(typeAnnotation) {\n        if (typeAnnotation !== null) {\n          this.write_(COLON);\n          this.writeSpace_();\n          this.visitAny(typeAnnotation);\n        }\n      },\n      writeAnnotations_: function(annotations) {\n        var writeNewLine = arguments[1] !== (void 0) ? arguments[1] : this.prettyPrint_;\n        if (annotations.length > 0) {\n          this.writeList_(annotations, \'\', writeNewLine);\n          if (writeNewLine)\n            this.writeln_();\n        }\n      },\n      needsSpace_: function(token) {\n        var lastCode = this.lastCode_;\n        if (isWhitespace(lastCode))\n          return false;\n        var firstCode = token.toString().charCodeAt(0);\n        return isIdentifierPart(firstCode) && (isIdentifierPart(lastCode) || lastCode === 47);\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  function requiresSpaceBetween(first, second) {\n    return (first === MINUS || first === MINUS_MINUS) && (second === MINUS || second === MINUS_MINUS) || (first === PLUS || first === PLUS_PLUS) && (second === PLUS || second === PLUS_PLUS);\n  }\n  return {get ParseTreeWriter() {\n      return ParseTreeWriter;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/outputgeneration/ParseTreeMapWriter.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/outputgeneration/ParseTreeMapWriter.js";\n  var ParseTreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeWriter.js", "traceur@0.0.111/src/outputgeneration/ParseTreeMapWriter.js")).ParseTreeWriter;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringSet.js", "traceur@0.0.111/src/outputgeneration/ParseTreeMapWriter.js")).StringSet;\n  var ParseTreeMapWriter = function($__super) {\n    function ParseTreeMapWriter(sourceMapConfiguration) {\n      var options = arguments[1];\n      $traceurRuntime.superConstructor(ParseTreeMapWriter).call(this, options);\n      this.sourceMapGenerator_ = sourceMapConfiguration.sourceMapGenerator;\n      this.lowResolution_ = sourceMapConfiguration.lowResolution;\n      this.basepath_ = sourceMapConfiguration.basepath;\n      this.outputLineCount_ = 1;\n      this.isFirstMapping_ = true;\n      this.sourcesInMap_ = new StringSet();\n      this.relativeSourceName_ = \'\';\n      this.generated_ = null;\n      this.original_ = null;\n      this.previousMapping_ = null;\n    }\n    return ($traceurRuntime.createClass)(ParseTreeMapWriter, {\n      visitAny: function(tree) {\n        if (tree === null) {\n          return;\n        }\n        if (tree.location !== null)\n          this.enterBranch(tree.location);\n        $traceurRuntime.superGet(this, ParseTreeMapWriter.prototype, "visitAny").call(this, tree);\n        if (tree.location !== null)\n          this.exitBranch(tree.location);\n      },\n      writeCurrentln_: function() {\n        $traceurRuntime.superGet(this, ParseTreeMapWriter.prototype, "writeCurrentln_").call(this);\n        this.flushMappings();\n        this.outputLineCount_++;\n        this.generated_ = {\n          line: this.outputLineCount_,\n          column: 0\n        };\n        this.flushMappings();\n      },\n      write_: function(value) {\n        this.generate();\n        $traceurRuntime.superGet(this, ParseTreeMapWriter.prototype, "write_").call(this, value);\n        this.generate();\n      },\n      generate: function() {\n        var length = this.currentLine_.length;\n        var column = length ? length - 1 : 0;\n        this.generated_ = {\n          line: this.outputLineCount_,\n          column: column\n        };\n        this.flushMappings();\n      },\n      enterBranch: function(location) {\n        var $__2 = location.start,\n            line = $__2.line,\n            column = $__2.column,\n            source = $__2.source;\n        this.originate(line, column, source);\n      },\n      exitBranch: function(location) {\n        var $__2 = location.end,\n            line = $__2.line,\n            column = $__2.column,\n            source = $__2.source;\n        this.originate(line, column ? column - 1 : 0, source);\n      },\n      originate: function(line, column, source) {\n        line++;\n        if (this.original_ && this.original_.line !== line)\n          this.flushMappings();\n        this.original_ = {\n          line: line,\n          column: column\n        };\n        var name = source.name;\n        if (name && !this.sourcesInMap_.has(name)) {\n          this.sourcesInMap_.add(name);\n          this.relativeSourceName_ = relativePath(name, this.basepath_);\n          this.sourceMapGenerator_.setSourceContent(this.relativeSourceName_, source.contents);\n        }\n        this.flushMappings();\n      },\n      flushMappings: function() {\n        if (this.original_ && this.generated_) {\n          this.addMapping();\n          this.original_ = null;\n          this.generated_ = null;\n        }\n      },\n      isSame: function(lhs, rhs) {\n        return lhs.line === rhs.line && lhs.column === rhs.column;\n      },\n      skipMapping: function() {\n        if (!this.previousMapping_)\n          return false;\n        if (this.lowResolution_ && this.previousMapping_.generated.line === this.generated_.line)\n          return true;\n        if (this.isSame(this.previousMapping_.generated, this.generated_) && this.isSame(this.previousMapping_.original, this.original_))\n          return true;\n      },\n      addMapping: function() {\n        if (this.skipMapping())\n          return;\n        var mapping = {\n          generated: this.generated_,\n          original: this.original_,\n          source: this.relativeSourceName_\n        };\n        this.sourceMapGenerator_.addMapping(mapping);\n        this.previousMapping_ = mapping;\n      }\n    }, {}, $__super);\n  }(ParseTreeWriter);\n  function relativePath(name, sourceRoot) {\n    var $__3;\n    if (!name || name[0] === \'@\')\n      return name;\n    if (!sourceRoot)\n      return name;\n    var nameSegments = name.split(\'/\');\n    var rootSegments = sourceRoot.split(\'/\');\n    if (rootSegments[rootSegments.length - 1]) {\n      throw new Error(\'rootPath must end in /\');\n    }\n    var commonSegmentsLength = 0;\n    var uniqueSegments = [];\n    var foundUnique = false;\n    nameSegments.forEach(function(segment, index) {\n      if (!foundUnique && segment === rootSegments[index]) {\n        commonSegmentsLength++;\n        return;\n      }\n      foundUnique = true;\n      uniqueSegments.push(segment);\n    });\n    if (commonSegmentsLength < 1 || commonSegmentsLength === rootSegments.length)\n      return name;\n    var dotDotSegments = rootSegments.length - commonSegmentsLength - 1;\n    var segments = [];\n    while (dotDotSegments--) {\n      segments.push(\'..\');\n    }\n    ($__3 = segments).push.apply($__3, $traceurRuntime.spread(uniqueSegments));\n    return segments.join(\'/\');\n  }\n  return {\n    get ParseTreeMapWriter() {\n      return ParseTreeMapWriter;\n    },\n    get relativePath() {\n      return relativePath;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/outputgeneration/SourceMapIntegration.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/outputgeneration/SourceMapIntegration.js";\n  function makeDefine(mapping, id) {\n    var require = function(id) {\n      return mapping[id];\n    };\n    var exports = mapping[id] = {};\n    var module = null;\n    return function(factory) {\n      factory(require, exports, module);\n    };\n  }\n  var define,\n      m = {};\n  define = makeDefine(m, \'./util\');\n  if (typeof define !== \'function\') {\n    var define = require(\'amdefine\')(module, require);\n  }\n  define(function(require, exports, module) {\n    function getArg(aArgs, aName, aDefaultValue) {\n      if (aName in aArgs) {\n        return aArgs[aName];\n      } else if (arguments.length === 3) {\n        return aDefaultValue;\n      } else {\n        throw new Error(\'"\' + aName + \'" is a required argument.\');\n      }\n    }\n    exports.getArg = getArg;\n    var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n    var dataUrlRegexp = /^data:.+\\,.+$/;\n    function urlParse(aUrl) {\n      var match = aUrl.match(urlRegexp);\n      if (!match) {\n        return null;\n      }\n      return {\n        scheme: match[1],\n        auth: match[2],\n        host: match[3],\n        port: match[4],\n        path: match[5]\n      };\n    }\n    exports.urlParse = urlParse;\n    function urlGenerate(aParsedUrl) {\n      var url = \'\';\n      if (aParsedUrl.scheme) {\n        url += aParsedUrl.scheme + \':\';\n      }\n      url += \'//\';\n      if (aParsedUrl.auth) {\n        url += aParsedUrl.auth + \'@\';\n      }\n      if (aParsedUrl.host) {\n        url += aParsedUrl.host;\n      }\n      if (aParsedUrl.port) {\n        url += ":" + aParsedUrl.port;\n      }\n      if (aParsedUrl.path) {\n        url += aParsedUrl.path;\n      }\n      return url;\n    }\n    exports.urlGenerate = urlGenerate;\n    function normalize(aPath) {\n      var path = aPath;\n      var url = urlParse(aPath);\n      if (url) {\n        if (!url.path) {\n          return aPath;\n        }\n        path = url.path;\n      }\n      var isAbsolute = (path.charAt(0) === \'/\');\n      var parts = path.split(/\\/+/);\n      for (var part = void 0,\n          up = 0,\n          i = parts.length - 1; i >= 0; i--) {\n        part = parts[i];\n        if (part === \'.\') {\n          parts.splice(i, 1);\n        } else if (part === \'..\') {\n          up++;\n        } else if (up > 0) {\n          if (part === \'\') {\n            parts.splice(i + 1, up);\n            up = 0;\n          } else {\n            parts.splice(i, 2);\n            up--;\n          }\n        }\n      }\n      path = parts.join(\'/\');\n      if (path === \'\') {\n        path = isAbsolute ? \'/\' : \'.\';\n      }\n      if (url) {\n        url.path = path;\n        return urlGenerate(url);\n      }\n      return path;\n    }\n    exports.normalize = normalize;\n    function join(aRoot, aPath) {\n      if (aRoot === "") {\n        aRoot = ".";\n      }\n      if (aPath === "") {\n        aPath = ".";\n      }\n      var aPathUrl = urlParse(aPath);\n      var aRootUrl = urlParse(aRoot);\n      if (aRootUrl) {\n        aRoot = aRootUrl.path || \'/\';\n      }\n      if (aPathUrl && !aPathUrl.scheme) {\n        if (aRootUrl) {\n          aPathUrl.scheme = aRootUrl.scheme;\n        }\n        return urlGenerate(aPathUrl);\n      }\n      if (aPathUrl || aPath.match(dataUrlRegexp)) {\n        return aPath;\n      }\n      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n        aRootUrl.host = aPath;\n        return urlGenerate(aRootUrl);\n      }\n      var joined = aPath.charAt(0) === \'/\' ? aPath : normalize(aRoot.replace(/\\/+$/, \'\') + \'/\' + aPath);\n      if (aRootUrl) {\n        aRootUrl.path = joined;\n        return urlGenerate(aRootUrl);\n      }\n      return joined;\n    }\n    exports.join = join;\n    function relative(aRoot, aPath) {\n      if (aRoot === "") {\n        aRoot = ".";\n      }\n      aRoot = aRoot.replace(/\\/$/, \'\');\n      var url = urlParse(aRoot);\n      if (aPath.charAt(0) == "/" && url && url.path == "/") {\n        return aPath.slice(1);\n      }\n      return aPath.indexOf(aRoot + \'/\') === 0 ? aPath.substr(aRoot.length + 1) : aPath;\n    }\n    exports.relative = relative;\n    function toSetString(aStr) {\n      return \'$\' + aStr;\n    }\n    exports.toSetString = toSetString;\n    function fromSetString(aStr) {\n      return aStr.substr(1);\n    }\n    exports.fromSetString = fromSetString;\n    function strcmp(aStr1, aStr2) {\n      var s1 = aStr1 || "";\n      var s2 = aStr2 || "";\n      return (s1 > s2) - (s1 < s2);\n    }\n    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n      var cmp;\n      cmp = strcmp(mappingA.source, mappingB.source);\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.originalLine - mappingB.originalLine;\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.originalColumn - mappingB.originalColumn;\n      if (cmp || onlyCompareOriginal) {\n        return cmp;\n      }\n      cmp = strcmp(mappingA.name, mappingB.name);\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.generatedLine - mappingB.generatedLine;\n      if (cmp) {\n        return cmp;\n      }\n      return mappingA.generatedColumn - mappingB.generatedColumn;\n    }\n    ;\n    exports.compareByOriginalPositions = compareByOriginalPositions;\n    function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {\n      var cmp;\n      cmp = mappingA.generatedLine - mappingB.generatedLine;\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n      if (cmp || onlyCompareGenerated) {\n        return cmp;\n      }\n      cmp = strcmp(mappingA.source, mappingB.source);\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.originalLine - mappingB.originalLine;\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.originalColumn - mappingB.originalColumn;\n      if (cmp) {\n        return cmp;\n      }\n      return strcmp(mappingA.name, mappingB.name);\n    }\n    ;\n    exports.compareByGeneratedPositions = compareByGeneratedPositions;\n  });\n  define = makeDefine(m, \'./array-set\');\n  if (typeof define !== \'function\') {\n    var define = require(\'amdefine\')(module, require);\n  }\n  define(function(require, exports, module) {\n    var util = require(\'./util\');\n    function ArraySet() {\n      this._array = [];\n      this._set = {};\n    }\n    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n      var set = new ArraySet();\n      for (var i = 0,\n          len = aArray.length; i < len; i++) {\n        set.add(aArray[i], aAllowDuplicates);\n      }\n      return set;\n    };\n    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n      var isDuplicate = this.has(aStr);\n      var idx = this._array.length;\n      if (!isDuplicate || aAllowDuplicates) {\n        this._array.push(aStr);\n      }\n      if (!isDuplicate) {\n        this._set[util.toSetString(aStr)] = idx;\n      }\n    };\n    ArraySet.prototype.has = function ArraySet_has(aStr) {\n      return Object.prototype.hasOwnProperty.call(this._set, util.toSetString(aStr));\n    };\n    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n      if (this.has(aStr)) {\n        return this._set[util.toSetString(aStr)];\n      }\n      throw new Error(\'"\' + aStr + \'" is not in the set.\');\n    };\n    ArraySet.prototype.at = function ArraySet_at(aIdx) {\n      if (aIdx >= 0 && aIdx < this._array.length) {\n        return this._array[aIdx];\n      }\n      throw new Error(\'No element indexed by \' + aIdx);\n    };\n    ArraySet.prototype.toArray = function ArraySet_toArray() {\n      return this._array.slice();\n    };\n    exports.ArraySet = ArraySet;\n  });\n  define = makeDefine(m, \'./base64\');\n  if (typeof define !== \'function\') {\n    var define = require(\'amdefine\')(module, require);\n  }\n  define(function(require, exports, module) {\n    var charToIntMap = {};\n    var intToCharMap = {};\n    \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\'.split(\'\').forEach(function(ch, index) {\n      charToIntMap[ch] = index;\n      intToCharMap[index] = ch;\n    });\n    exports.encode = function base64_encode(aNumber) {\n      if (aNumber in intToCharMap) {\n        return intToCharMap[aNumber];\n      }\n      throw new TypeError("Must be between 0 and 63: " + aNumber);\n    };\n    exports.decode = function base64_decode(aChar) {\n      if (aChar in charToIntMap) {\n        return charToIntMap[aChar];\n      }\n      throw new TypeError("Not a valid base 64 digit: " + aChar);\n    };\n  });\n  define = makeDefine(m, \'./base64-vlq\');\n  if (typeof define !== \'function\') {\n    var define = require(\'amdefine\')(module, require);\n  }\n  define(function(require, exports, module) {\n    var base64 = require(\'./base64\');\n    var VLQ_BASE_SHIFT = 5;\n    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n    var VLQ_BASE_MASK = VLQ_BASE - 1;\n    var VLQ_CONTINUATION_BIT = VLQ_BASE;\n    function toVLQSigned(aValue) {\n      return aValue < 0 ? ((-aValue) << 1) + 1 : (aValue << 1) + 0;\n    }\n    function fromVLQSigned(aValue) {\n      var isNegative = (aValue & 1) === 1;\n      var shifted = aValue >> 1;\n      return isNegative ? -shifted : shifted;\n    }\n    exports.encode = function base64VLQ_encode(aValue) {\n      var encoded = "";\n      var digit;\n      var vlq = toVLQSigned(aValue);\n      do {\n        digit = vlq & VLQ_BASE_MASK;\n        vlq >>>= VLQ_BASE_SHIFT;\n        if (vlq > 0) {\n          digit |= VLQ_CONTINUATION_BIT;\n        }\n        encoded += base64.encode(digit);\n      } while (vlq > 0);\n      return encoded;\n    };\n    exports.decode = function base64VLQ_decode(aStr, aOutParam) {\n      var i = 0;\n      var strLen = aStr.length;\n      var result = 0;\n      var shift = 0;\n      var continuation,\n          digit;\n      do {\n        if (i >= strLen) {\n          throw new Error("Expected more digits in base 64 VLQ value.");\n        }\n        digit = base64.decode(aStr.charAt(i++));\n        continuation = !!(digit & VLQ_CONTINUATION_BIT);\n        digit &= VLQ_BASE_MASK;\n        result = result + (digit << shift);\n        shift += VLQ_BASE_SHIFT;\n      } while (continuation);\n      aOutParam.value = fromVLQSigned(result);\n      aOutParam.rest = aStr.slice(i);\n    };\n  });\n  define = makeDefine(m, \'./binary-search\');\n  if (typeof define !== \'function\') {\n    var define = require(\'amdefine\')(module, require);\n  }\n  define(function(require, exports, module) {\n    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {\n      var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n      var cmp = aCompare(aNeedle, aHaystack[mid], true);\n      if (cmp === 0) {\n        return mid;\n      } else if (cmp > 0) {\n        if (aHigh - mid > 1) {\n          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);\n        }\n        return mid;\n      } else {\n        if (mid - aLow > 1) {\n          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);\n        }\n        return aLow < 0 ? -1 : aLow;\n      }\n    }\n    exports.search = function search(aNeedle, aHaystack, aCompare) {\n      if (aHaystack.length === 0) {\n        return -1;\n      }\n      return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare);\n    };\n  });\n  define = makeDefine(m, \'./mapping-list\');\n  if (typeof define !== \'function\') {\n    var define = require(\'amdefine\')(module, require);\n  }\n  define(function(require, exports, module) {\n    var util = require(\'./util\');\n    function generatedPositionAfter(mappingA, mappingB) {\n      var lineA = mappingA.generatedLine;\n      var lineB = mappingB.generatedLine;\n      var columnA = mappingA.generatedColumn;\n      var columnB = mappingB.generatedColumn;\n      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositions(mappingA, mappingB) <= 0;\n    }\n    function MappingList() {\n      this._array = [];\n      this._sorted = true;\n      this._last = {\n        generatedLine: -1,\n        generatedColumn: 0\n      };\n    }\n    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {\n      this._array.forEach(aCallback, aThisArg);\n    };\n    MappingList.prototype.add = function MappingList_add(aMapping) {\n      var mapping;\n      if (generatedPositionAfter(this._last, aMapping)) {\n        this._last = aMapping;\n        this._array.push(aMapping);\n      } else {\n        this._sorted = false;\n        this._array.push(aMapping);\n      }\n    };\n    MappingList.prototype.toArray = function MappingList_toArray() {\n      if (!this._sorted) {\n        this._array.sort(util.compareByGeneratedPositions);\n        this._sorted = true;\n      }\n      return this._array;\n    };\n    exports.MappingList = MappingList;\n  });\n  define = makeDefine(m, \'./source-map-generator\');\n  if (typeof define !== \'function\') {\n    var define = require(\'amdefine\')(module, require);\n  }\n  define(function(require, exports, module) {\n    var base64VLQ = require(\'./base64-vlq\');\n    var util = require(\'./util\');\n    var ArraySet = require(\'./array-set\').ArraySet;\n    var MappingList = require(\'./mapping-list\').MappingList;\n    function SourceMapGenerator(aArgs) {\n      if (!aArgs) {\n        aArgs = {};\n      }\n      this._file = util.getArg(aArgs, \'file\', null);\n      this._sourceRoot = util.getArg(aArgs, \'sourceRoot\', null);\n      this._skipValidation = util.getArg(aArgs, \'skipValidation\', false);\n      this._sources = new ArraySet();\n      this._names = new ArraySet();\n      this._mappings = new MappingList();\n      this._sourcesContents = null;\n    }\n    SourceMapGenerator.prototype._version = 3;\n    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n      var sourceRoot = aSourceMapConsumer.sourceRoot;\n      var generator = new SourceMapGenerator({\n        file: aSourceMapConsumer.file,\n        sourceRoot: sourceRoot\n      });\n      aSourceMapConsumer.eachMapping(function(mapping) {\n        var newMapping = {generated: {\n            line: mapping.generatedLine,\n            column: mapping.generatedColumn\n          }};\n        if (mapping.source != null) {\n          newMapping.source = mapping.source;\n          if (sourceRoot != null) {\n            newMapping.source = util.relative(sourceRoot, newMapping.source);\n          }\n          newMapping.original = {\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n          };\n          if (mapping.name != null) {\n            newMapping.name = mapping.name;\n          }\n        }\n        generator.addMapping(newMapping);\n      });\n      aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          generator.setSourceContent(sourceFile, content);\n        }\n      });\n      return generator;\n    };\n    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n      var generated = util.getArg(aArgs, \'generated\');\n      var original = util.getArg(aArgs, \'original\', null);\n      var source = util.getArg(aArgs, \'source\', null);\n      var name = util.getArg(aArgs, \'name\', null);\n      if (!this._skipValidation) {\n        this._validateMapping(generated, original, source, name);\n      }\n      if (source != null && !this._sources.has(source)) {\n        this._sources.add(source);\n      }\n      if (name != null && !this._names.has(name)) {\n        this._names.add(name);\n      }\n      this._mappings.add({\n        generatedLine: generated.line,\n        generatedColumn: generated.column,\n        originalLine: original != null && original.line,\n        originalColumn: original != null && original.column,\n        source: source,\n        name: name\n      });\n    };\n    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n      var source = aSourceFile;\n      if (this._sourceRoot != null) {\n        source = util.relative(this._sourceRoot, source);\n      }\n      if (aSourceContent != null) {\n        if (!this._sourcesContents) {\n          this._sourcesContents = {};\n        }\n        this._sourcesContents[util.toSetString(source)] = aSourceContent;\n      } else if (this._sourcesContents) {\n        delete this._sourcesContents[util.toSetString(source)];\n        if (Object.keys(this._sourcesContents).length === 0) {\n          this._sourcesContents = null;\n        }\n      }\n    };\n    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n      var sourceFile = aSourceFile;\n      if (aSourceFile == null) {\n        if (aSourceMapConsumer.file == null) {\n          throw new Error(\'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \' + \'or the source map\\\'s "file" property. Both were omitted.\');\n        }\n        sourceFile = aSourceMapConsumer.file;\n      }\n      var sourceRoot = this._sourceRoot;\n      if (sourceRoot != null) {\n        sourceFile = util.relative(sourceRoot, sourceFile);\n      }\n      var newSources = new ArraySet();\n      var newNames = new ArraySet();\n      this._mappings.unsortedForEach(function(mapping) {\n        if (mapping.source === sourceFile && mapping.originalLine != null) {\n          var original = aSourceMapConsumer.originalPositionFor({\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n          });\n          if (original.source != null) {\n            mapping.source = original.source;\n            if (aSourceMapPath != null) {\n              mapping.source = util.join(aSourceMapPath, mapping.source);\n            }\n            if (sourceRoot != null) {\n              mapping.source = util.relative(sourceRoot, mapping.source);\n            }\n            mapping.originalLine = original.line;\n            mapping.originalColumn = original.column;\n            if (original.name != null) {\n              mapping.name = original.name;\n            }\n          }\n        }\n        var source = mapping.source;\n        if (source != null && !newSources.has(source)) {\n          newSources.add(source);\n        }\n        var name = mapping.name;\n        if (name != null && !newNames.has(name)) {\n          newNames.add(name);\n        }\n      }, this);\n      this._sources = newSources;\n      this._names = newNames;\n      aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          if (aSourceMapPath != null) {\n            sourceFile = util.join(aSourceMapPath, sourceFile);\n          }\n          if (sourceRoot != null) {\n            sourceFile = util.relative(sourceRoot, sourceFile);\n          }\n          this.setSourceContent(sourceFile, content);\n        }\n      }, this);\n    };\n    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n      if (aGenerated && \'line\' in aGenerated && \'column\' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n        return;\n      } else if (aGenerated && \'line\' in aGenerated && \'column\' in aGenerated && aOriginal && \'line\' in aOriginal && \'column\' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n        return;\n      } else {\n        throw new Error(\'Invalid mapping: \' + JSON.stringify({\n          generated: aGenerated,\n          source: aSource,\n          original: aOriginal,\n          name: aName\n        }));\n      }\n    };\n    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n      var previousGeneratedColumn = 0;\n      var previousGeneratedLine = 1;\n      var previousOriginalColumn = 0;\n      var previousOriginalLine = 0;\n      var previousName = 0;\n      var previousSource = 0;\n      var result = \'\';\n      var mapping;\n      var mappings = this._mappings.toArray();\n      for (var i = 0,\n          len = mappings.length; i < len; i++) {\n        mapping = mappings[i];\n        if (mapping.generatedLine !== previousGeneratedLine) {\n          previousGeneratedColumn = 0;\n          while (mapping.generatedLine !== previousGeneratedLine) {\n            result += \';\';\n            previousGeneratedLine++;\n          }\n        } else {\n          if (i > 0) {\n            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {\n              continue;\n            }\n            result += \',\';\n          }\n        }\n        result += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n        previousGeneratedColumn = mapping.generatedColumn;\n        if (mapping.source != null) {\n          result += base64VLQ.encode(this._sources.indexOf(mapping.source) - previousSource);\n          previousSource = this._sources.indexOf(mapping.source);\n          result += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n          previousOriginalLine = mapping.originalLine - 1;\n          result += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n          previousOriginalColumn = mapping.originalColumn;\n          if (mapping.name != null) {\n            result += base64VLQ.encode(this._names.indexOf(mapping.name) - previousName);\n            previousName = this._names.indexOf(mapping.name);\n          }\n        }\n      }\n      return result;\n    };\n    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n      return aSources.map(function(source) {\n        if (!this._sourcesContents) {\n          return null;\n        }\n        if (aSourceRoot != null) {\n          source = util.relative(aSourceRoot, source);\n        }\n        var key = util.toSetString(source);\n        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n      }, this);\n    };\n    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n      var map = {\n        version: this._version,\n        sources: this._sources.toArray(),\n        names: this._names.toArray(),\n        mappings: this._serializeMappings()\n      };\n      if (this._file != null) {\n        map.file = this._file;\n      }\n      if (this._sourceRoot != null) {\n        map.sourceRoot = this._sourceRoot;\n      }\n      if (this._sourcesContents) {\n        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n      }\n      return map;\n    };\n    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n      return JSON.stringify(this);\n    };\n    exports.SourceMapGenerator = SourceMapGenerator;\n  });\n  define = makeDefine(m, \'./source-map-consumer\');\n  if (typeof define !== \'function\') {\n    var define = require(\'amdefine\')(module, require);\n  }\n  define(function(require, exports, module) {\n    var util = require(\'./util\');\n    var binarySearch = require(\'./binary-search\');\n    var ArraySet = require(\'./array-set\').ArraySet;\n    var base64VLQ = require(\'./base64-vlq\');\n    function SourceMapConsumer(aSourceMap) {\n      var sourceMap = aSourceMap;\n      if (typeof aSourceMap === \'string\') {\n        sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}\'/, \'\'));\n      }\n      var version = util.getArg(sourceMap, \'version\');\n      var sources = util.getArg(sourceMap, \'sources\');\n      var names = util.getArg(sourceMap, \'names\', []);\n      var sourceRoot = util.getArg(sourceMap, \'sourceRoot\', null);\n      var sourcesContent = util.getArg(sourceMap, \'sourcesContent\', null);\n      var mappings = util.getArg(sourceMap, \'mappings\');\n      var file = util.getArg(sourceMap, \'file\', null);\n      if (version != this._version) {\n        throw new Error(\'Unsupported version: \' + version);\n      }\n      sources = sources.map(util.normalize);\n      this._names = ArraySet.fromArray(names, true);\n      this._sources = ArraySet.fromArray(sources, true);\n      this.sourceRoot = sourceRoot;\n      this.sourcesContent = sourcesContent;\n      this._mappings = mappings;\n      this.file = file;\n    }\n    SourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {\n      var smc = Object.create(SourceMapConsumer.prototype);\n      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n      smc.sourceRoot = aSourceMap._sourceRoot;\n      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n      smc.file = aSourceMap._file;\n      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();\n      smc.__originalMappings = aSourceMap._mappings.toArray().slice().sort(util.compareByOriginalPositions);\n      return smc;\n    };\n    SourceMapConsumer.prototype._version = 3;\n    Object.defineProperty(SourceMapConsumer.prototype, \'sources\', {get: function() {\n        return this._sources.toArray().map(function(s) {\n          return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n        }, this);\n      }});\n    SourceMapConsumer.prototype.__generatedMappings = null;\n    Object.defineProperty(SourceMapConsumer.prototype, \'_generatedMappings\', {get: function() {\n        if (!this.__generatedMappings) {\n          this.__generatedMappings = [];\n          this.__originalMappings = [];\n          this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__generatedMappings;\n      }});\n    SourceMapConsumer.prototype.__originalMappings = null;\n    Object.defineProperty(SourceMapConsumer.prototype, \'_originalMappings\', {get: function() {\n        if (!this.__originalMappings) {\n          this.__generatedMappings = [];\n          this.__originalMappings = [];\n          this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__originalMappings;\n      }});\n    SourceMapConsumer.prototype._nextCharIsMappingSeparator = function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {\n      var c = aStr.charAt(0);\n      return c === ";" || c === ",";\n    };\n    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n      var generatedLine = 1;\n      var previousGeneratedColumn = 0;\n      var previousOriginalLine = 0;\n      var previousOriginalColumn = 0;\n      var previousSource = 0;\n      var previousName = 0;\n      var str = aStr;\n      var temp = {};\n      var mapping;\n      while (str.length > 0) {\n        if (str.charAt(0) === \';\') {\n          generatedLine++;\n          str = str.slice(1);\n          previousGeneratedColumn = 0;\n        } else if (str.charAt(0) === \',\') {\n          str = str.slice(1);\n        } else {\n          mapping = {};\n          mapping.generatedLine = generatedLine;\n          base64VLQ.decode(str, temp);\n          mapping.generatedColumn = previousGeneratedColumn + temp.value;\n          previousGeneratedColumn = mapping.generatedColumn;\n          str = temp.rest;\n          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n            base64VLQ.decode(str, temp);\n            mapping.source = this._sources.at(previousSource + temp.value);\n            previousSource += temp.value;\n            str = temp.rest;\n            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n              throw new Error(\'Found a source, but no line and column\');\n            }\n            base64VLQ.decode(str, temp);\n            mapping.originalLine = previousOriginalLine + temp.value;\n            previousOriginalLine = mapping.originalLine;\n            mapping.originalLine += 1;\n            str = temp.rest;\n            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n              throw new Error(\'Found a source and line, but no column\');\n            }\n            base64VLQ.decode(str, temp);\n            mapping.originalColumn = previousOriginalColumn + temp.value;\n            previousOriginalColumn = mapping.originalColumn;\n            str = temp.rest;\n            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n              base64VLQ.decode(str, temp);\n              mapping.name = this._names.at(previousName + temp.value);\n              previousName += temp.value;\n              str = temp.rest;\n            }\n          }\n          this.__generatedMappings.push(mapping);\n          if (typeof mapping.originalLine === \'number\') {\n            this.__originalMappings.push(mapping);\n          }\n        }\n      }\n      this.__generatedMappings.sort(util.compareByGeneratedPositions);\n      this.__originalMappings.sort(util.compareByOriginalPositions);\n    };\n    SourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator) {\n      if (aNeedle[aLineName] <= 0) {\n        throw new TypeError(\'Line must be greater than or equal to 1, got \' + aNeedle[aLineName]);\n      }\n      if (aNeedle[aColumnName] < 0) {\n        throw new TypeError(\'Column must be greater than or equal to 0, got \' + aNeedle[aColumnName]);\n      }\n      return binarySearch.search(aNeedle, aMappings, aComparator);\n    };\n    SourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n      for (var index = 0; index < this._generatedMappings.length; ++index) {\n        var mapping = this._generatedMappings[index];\n        if (index + 1 < this._generatedMappings.length) {\n          var nextMapping = this._generatedMappings[index + 1];\n          if (mapping.generatedLine === nextMapping.generatedLine) {\n            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n            continue;\n          }\n        }\n        mapping.lastGeneratedColumn = Infinity;\n      }\n    };\n    SourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n      var needle = {\n        generatedLine: util.getArg(aArgs, \'line\'),\n        generatedColumn: util.getArg(aArgs, \'column\')\n      };\n      var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositions);\n      if (index >= 0) {\n        var mapping = this._generatedMappings[index];\n        if (mapping.generatedLine === needle.generatedLine) {\n          var source = util.getArg(mapping, \'source\', null);\n          if (source != null && this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n          return {\n            source: source,\n            line: util.getArg(mapping, \'originalLine\', null),\n            column: util.getArg(mapping, \'originalColumn\', null),\n            name: util.getArg(mapping, \'name\', null)\n          };\n        }\n      }\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    };\n    SourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource) {\n      if (!this.sourcesContent) {\n        return null;\n      }\n      if (this.sourceRoot != null) {\n        aSource = util.relative(this.sourceRoot, aSource);\n      }\n      if (this._sources.has(aSource)) {\n        return this.sourcesContent[this._sources.indexOf(aSource)];\n      }\n      var url;\n      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n        var fileUriAbsPath = aSource.replace(/^file:\\/\\//, "");\n        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {\n          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n        }\n        if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {\n          return this.sourcesContent[this._sources.indexOf("/" + aSource)];\n        }\n      }\n      throw new Error(\'"\' + aSource + \'" is not in the SourceMap.\');\n    };\n    SourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n      var needle = {\n        source: util.getArg(aArgs, \'source\'),\n        originalLine: util.getArg(aArgs, \'line\'),\n        originalColumn: util.getArg(aArgs, \'column\')\n      };\n      if (this.sourceRoot != null) {\n        needle.source = util.relative(this.sourceRoot, needle.source);\n      }\n      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions);\n      if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        return {\n          line: util.getArg(mapping, \'generatedLine\', null),\n          column: util.getArg(mapping, \'generatedColumn\', null),\n          lastColumn: util.getArg(mapping, \'lastGeneratedColumn\', null)\n        };\n      }\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    };\n    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n      var needle = {\n        source: util.getArg(aArgs, \'source\'),\n        originalLine: util.getArg(aArgs, \'line\'),\n        originalColumn: Infinity\n      };\n      if (this.sourceRoot != null) {\n        needle.source = util.relative(this.sourceRoot, needle.source);\n      }\n      var mappings = [];\n      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions);\n      if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        while (mapping && mapping.originalLine === needle.originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, \'generatedLine\', null),\n            column: util.getArg(mapping, \'generatedColumn\', null),\n            lastColumn: util.getArg(mapping, \'lastGeneratedColumn\', null)\n          });\n          mapping = this._originalMappings[--index];\n        }\n      }\n      return mappings.reverse();\n    };\n    SourceMapConsumer.GENERATED_ORDER = 1;\n    SourceMapConsumer.ORIGINAL_ORDER = 2;\n    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n      var context = aContext || null;\n      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n      var mappings;\n      switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          mappings = this._generatedMappings;\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          mappings = this._originalMappings;\n          break;\n        default:\n          throw new Error("Unknown order of iteration.");\n      }\n      var sourceRoot = this.sourceRoot;\n      mappings.map(function(mapping) {\n        var source = mapping.source;\n        if (source != null && sourceRoot != null) {\n          source = util.join(sourceRoot, source);\n        }\n        return {\n          source: source,\n          generatedLine: mapping.generatedLine,\n          generatedColumn: mapping.generatedColumn,\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: mapping.name\n        };\n      }).forEach(aCallback, context);\n    };\n    exports.SourceMapConsumer = SourceMapConsumer;\n  });\n  define = makeDefine(m, \'./source-node\');\n  if (typeof define !== \'function\') {\n    var define = require(\'amdefine\')(module, require);\n  }\n  define(function(require, exports, module) {\n    var SourceMapGenerator = require(\'./source-map-generator\').SourceMapGenerator;\n    var util = require(\'./util\');\n    var REGEX_NEWLINE = /(\\r?\\n)/;\n    var NEWLINE_CODE = 10;\n    var isSourceNode = "$$$isSourceNode$$$";\n    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n      this.children = [];\n      this.sourceContents = {};\n      this.line = aLine == null ? null : aLine;\n      this.column = aColumn == null ? null : aColumn;\n      this.source = aSource == null ? null : aSource;\n      this.name = aName == null ? null : aName;\n      this[isSourceNode] = true;\n      if (aChunks != null)\n        this.add(aChunks);\n    }\n    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n      var node = new SourceNode();\n      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n      var shiftNextLine = function() {\n        var lineContents = remainingLines.shift();\n        var newLine = remainingLines.shift() || "";\n        return lineContents + newLine;\n      };\n      var lastGeneratedLine = 1,\n          lastGeneratedColumn = 0;\n      var lastMapping = null;\n      aSourceMapConsumer.eachMapping(function(mapping) {\n        if (lastMapping !== null) {\n          if (lastGeneratedLine < mapping.generatedLine) {\n            var code = "";\n            addMappingWithCode(lastMapping, shiftNextLine());\n            lastGeneratedLine++;\n            lastGeneratedColumn = 0;\n          } else {\n            var nextLine = remainingLines[0];\n            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n            remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n            addMappingWithCode(lastMapping, code);\n            lastMapping = mapping;\n            return;\n          }\n        }\n        while (lastGeneratedLine < mapping.generatedLine) {\n          node.add(shiftNextLine());\n          lastGeneratedLine++;\n        }\n        if (lastGeneratedColumn < mapping.generatedColumn) {\n          var nextLine = remainingLines[0];\n          node.add(nextLine.substr(0, mapping.generatedColumn));\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n        }\n        lastMapping = mapping;\n      }, this);\n      if (remainingLines.length > 0) {\n        if (lastMapping) {\n          addMappingWithCode(lastMapping, shiftNextLine());\n        }\n        node.add(remainingLines.join(""));\n      }\n      aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          if (aRelativePath != null) {\n            sourceFile = util.join(aRelativePath, sourceFile);\n          }\n          node.setSourceContent(sourceFile, content);\n        }\n      });\n      return node;\n      function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n          node.add(code);\n        } else {\n          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n        }\n      }\n    };\n    SourceNode.prototype.add = function SourceNode_add(aChunk) {\n      if (Array.isArray(aChunk)) {\n        aChunk.forEach(function(chunk) {\n          this.add(chunk);\n        }, this);\n      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {\n        if (aChunk) {\n          this.children.push(aChunk);\n        }\n      } else {\n        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);\n      }\n      return this;\n    };\n    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n      if (Array.isArray(aChunk)) {\n        for (var i = aChunk.length - 1; i >= 0; i--) {\n          this.prepend(aChunk[i]);\n        }\n      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {\n        this.children.unshift(aChunk);\n      } else {\n        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);\n      }\n      return this;\n    };\n    SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n      var chunk;\n      for (var i = 0,\n          len = this.children.length; i < len; i++) {\n        chunk = this.children[i];\n        if (chunk[isSourceNode]) {\n          chunk.walk(aFn);\n        } else {\n          if (chunk !== \'\') {\n            aFn(chunk, {\n              source: this.source,\n              line: this.line,\n              column: this.column,\n              name: this.name\n            });\n          }\n        }\n      }\n    };\n    SourceNode.prototype.join = function SourceNode_join(aSep) {\n      var newChildren;\n      var i;\n      var len = this.children.length;\n      if (len > 0) {\n        newChildren = [];\n        for (i = 0; i < len - 1; i++) {\n          newChildren.push(this.children[i]);\n          newChildren.push(aSep);\n        }\n        newChildren.push(this.children[i]);\n        this.children = newChildren;\n      }\n      return this;\n    };\n    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n      var lastChild = this.children[this.children.length - 1];\n      if (lastChild[isSourceNode]) {\n        lastChild.replaceRight(aPattern, aReplacement);\n      } else if (typeof lastChild === \'string\') {\n        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n      } else {\n        this.children.push(\'\'.replace(aPattern, aReplacement));\n      }\n      return this;\n    };\n    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n    };\n    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n      for (var i = 0,\n          len = this.children.length; i < len; i++) {\n        if (this.children[i][isSourceNode]) {\n          this.children[i].walkSourceContents(aFn);\n        }\n      }\n      var sources = Object.keys(this.sourceContents);\n      for (var i = 0,\n          len = sources.length; i < len; i++) {\n        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n      }\n    };\n    SourceNode.prototype.toString = function SourceNode_toString() {\n      var str = "";\n      this.walk(function(chunk) {\n        str += chunk;\n      });\n      return str;\n    };\n    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n      var generated = {\n        code: "",\n        line: 1,\n        column: 0\n      };\n      var map = new SourceMapGenerator(aArgs);\n      var sourceMappingActive = false;\n      var lastOriginalSource = null;\n      var lastOriginalLine = null;\n      var lastOriginalColumn = null;\n      var lastOriginalName = null;\n      this.walk(function(chunk, original) {\n        generated.code += chunk;\n        if (original.source !== null && original.line !== null && original.column !== null) {\n          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n          lastOriginalSource = original.source;\n          lastOriginalLine = original.line;\n          lastOriginalColumn = original.column;\n          lastOriginalName = original.name;\n          sourceMappingActive = true;\n        } else if (sourceMappingActive) {\n          map.addMapping({generated: {\n              line: generated.line,\n              column: generated.column\n            }});\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        }\n        for (var idx = 0,\n            length = chunk.length; idx < length; idx++) {\n          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n            generated.line++;\n            generated.column = 0;\n            if (idx + 1 === length) {\n              lastOriginalSource = null;\n              sourceMappingActive = false;\n            } else if (sourceMappingActive) {\n              map.addMapping({\n                source: original.source,\n                original: {\n                  line: original.line,\n                  column: original.column\n                },\n                generated: {\n                  line: generated.line,\n                  column: generated.column\n                },\n                name: original.name\n              });\n            }\n          } else {\n            generated.column++;\n          }\n        }\n      });\n      this.walkSourceContents(function(sourceFile, sourceContent) {\n        map.setSourceContent(sourceFile, sourceContent);\n      });\n      return {\n        code: generated.code,\n        map: map\n      };\n    };\n    exports.SourceNode = SourceNode;\n  });\n  var SourceMapGenerator = m[\'./source-map-generator\'].SourceMapGenerator;\n  var SourceMapConsumer = m[\'./source-map-consumer\'].SourceMapConsumer;\n  var SourceNode = m[\'./source-node\'].SourceNode;\n  var join = m[\'./util\'].join;\n  return {\n    get SourceMapGenerator() {\n      return SourceMapGenerator;\n    },\n    get SourceMapConsumer() {\n      return SourceMapConsumer;\n    },\n    get SourceNode() {\n      return SourceNode;\n    },\n    get join() {\n      return join;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/outputgeneration/toSource.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/outputgeneration/toSource.js";\n  var ParseTreeMapWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeMapWriter.js", "traceur@0.0.111/src/outputgeneration/toSource.js")).ParseTreeMapWriter;\n  var ParseTreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeWriter.js", "traceur@0.0.111/src/outputgeneration/toSource.js")).ParseTreeWriter;\n  var SourceMapGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SourceMapIntegration.js", "traceur@0.0.111/src/outputgeneration/toSource.js")).SourceMapGenerator;\n  function toSource(tree) {\n    var options = arguments[1];\n    var outputName = arguments[2] !== (void 0) ? arguments[2] : \'<toSourceOutput>\';\n    var sourceRoot = arguments[3];\n    var sourceMapGenerator = options && options.sourceMapGenerator;\n    var sourcemaps = options && options.sourceMaps;\n    if (!sourceMapGenerator && sourcemaps) {\n      sourceMapGenerator = new SourceMapGenerator({\n        file: outputName,\n        sourceRoot: sourceRoot,\n        skipValidation: true\n      });\n    }\n    var sourceMapConfiguration = {\n      sourceMapGenerator: sourceMapGenerator,\n      sourceRoot: sourceRoot,\n      lowResolution: options && options.lowResolutionSourceMap\n    };\n    var writer;\n    if (sourceMapGenerator)\n      writer = new ParseTreeMapWriter(sourceMapConfiguration, options);\n    else\n      writer = new ParseTreeWriter(options);\n    writer.visitAny(tree);\n    return [writer.toString(), sourceMapGenerator && sourceMapGenerator.toString()];\n  }\n  return {get toSource() {\n      return toSource;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/outputgeneration/TreeWriter.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/outputgeneration/TreeWriter.js";\n  var toSource = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./toSource.js", "traceur@0.0.111/src/outputgeneration/TreeWriter.js")).toSource;\n  function write(tree) {\n    var $__2,\n        $__3;\n    var options = arguments[1];\n    var outputName = arguments[2] !== (void 0) ? arguments[2] : \'<TreeWriter-output>\';\n    var sourceRoot = arguments[3];\n    var $__1 = toSource(tree, options, outputName, sourceRoot),\n        result = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),\n        sourceMap = ($__3 = $__2.next()).done ? void 0 : $__3.value;\n    if (sourceMap)\n      options.generatedSourceMap = sourceMap;\n    return result;\n  }\n  var TreeWriter = function() {\n    function TreeWriter() {}\n    return ($traceurRuntime.createClass)(TreeWriter, {}, {});\n  }();\n  TreeWriter.write = write;\n  return {\n    get write() {\n      return write;\n    },\n    get TreeWriter() {\n      return TreeWriter;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/syntax/ParseTreeValidator.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/syntax/ParseTreeValidator.js";\n  var NewExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/syntax/ParseTreeValidator.js")).NewExpression;\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeVisitor.js", "traceur@0.0.111/src/syntax/ParseTreeValidator.js")).ParseTreeVisitor;\n  var TreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../outputgeneration/TreeWriter.js", "traceur@0.0.111/src/syntax/ParseTreeValidator.js")).TreeWriter;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TokenType.js", "traceur@0.0.111/src/syntax/ParseTreeValidator.js")),\n      AMPERSAND = $__7.AMPERSAND,\n      AMPERSAND_EQUAL = $__7.AMPERSAND_EQUAL,\n      AND = $__7.AND,\n      BAR = $__7.BAR,\n      BAR_EQUAL = $__7.BAR_EQUAL,\n      CARET = $__7.CARET,\n      CARET_EQUAL = $__7.CARET_EQUAL,\n      CLOSE_ANGLE = $__7.CLOSE_ANGLE,\n      EQUAL = $__7.EQUAL,\n      EQUAL_EQUAL = $__7.EQUAL_EQUAL,\n      EQUAL_EQUAL_EQUAL = $__7.EQUAL_EQUAL_EQUAL,\n      GREATER_EQUAL = $__7.GREATER_EQUAL,\n      IDENTIFIER = $__7.IDENTIFIER,\n      IN = $__7.IN,\n      INSTANCEOF = $__7.INSTANCEOF,\n      LEFT_SHIFT = $__7.LEFT_SHIFT,\n      LEFT_SHIFT_EQUAL = $__7.LEFT_SHIFT_EQUAL,\n      LESS_EQUAL = $__7.LESS_EQUAL,\n      MINUS = $__7.MINUS,\n      MINUS_EQUAL = $__7.MINUS_EQUAL,\n      NOT_EQUAL = $__7.NOT_EQUAL,\n      NOT_EQUAL_EQUAL = $__7.NOT_EQUAL_EQUAL,\n      NUMBER = $__7.NUMBER,\n      OPEN_ANGLE = $__7.OPEN_ANGLE,\n      OR = $__7.OR,\n      PERCENT = $__7.PERCENT,\n      PERCENT_EQUAL = $__7.PERCENT_EQUAL,\n      PLUS = $__7.PLUS,\n      PLUS_EQUAL = $__7.PLUS_EQUAL,\n      RIGHT_SHIFT = $__7.RIGHT_SHIFT,\n      RIGHT_SHIFT_EQUAL = $__7.RIGHT_SHIFT_EQUAL,\n      SLASH = $__7.SLASH,\n      SLASH_EQUAL = $__7.SLASH_EQUAL,\n      STAR = $__7.STAR,\n      STAR_EQUAL = $__7.STAR_EQUAL,\n      STAR_STAR = $__7.STAR_STAR,\n      STAR_STAR_EQUAL = $__7.STAR_STAR_EQUAL,\n      STRING = $__7.STRING,\n      UNSIGNED_RIGHT_SHIFT = $__7.UNSIGNED_RIGHT_SHIFT,\n      UNSIGNED_RIGHT_SHIFT_EQUAL = $__7.UNSIGNED_RIGHT_SHIFT_EQUAL,\n      YIELD = $__7.YIELD;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./trees/ParseTreeType.js", "traceur@0.0.111/src/syntax/ParseTreeValidator.js")),\n      ARRAY_PATTERN = $__8.ARRAY_PATTERN,\n      ASSIGNMENT_ELEMENT = $__8.ASSIGNMENT_ELEMENT,\n      BINDING_ELEMENT = $__8.BINDING_ELEMENT,\n      BINDING_IDENTIFIER = $__8.BINDING_IDENTIFIER,\n      BLOCK = $__8.BLOCK,\n      CASE_CLAUSE = $__8.CASE_CLAUSE,\n      CATCH = $__8.CATCH,\n      CLASS_DECLARATION = $__8.CLASS_DECLARATION,\n      COMPUTED_PROPERTY_NAME = $__8.COMPUTED_PROPERTY_NAME,\n      DEFAULT_CLAUSE = $__8.DEFAULT_CLAUSE,\n      EXPORT_DEFAULT = $__8.EXPORT_DEFAULT,\n      EXPORT_SPECIFIER = $__8.EXPORT_SPECIFIER,\n      EXPORT_SPECIFIER_SET = $__8.EXPORT_SPECIFIER_SET,\n      EXPORT_STAR = $__8.EXPORT_STAR,\n      FINALLY = $__8.FINALLY,\n      FORMAL_PARAMETER = $__8.FORMAL_PARAMETER,\n      FORMAL_PARAMETER_LIST = $__8.FORMAL_PARAMETER_LIST,\n      FORWARD_DEFAULT_EXPORT = $__8.FORWARD_DEFAULT_EXPORT,\n      FUNCTION_BODY = $__8.FUNCTION_BODY,\n      FUNCTION_DECLARATION = $__8.FUNCTION_DECLARATION,\n      GET_ACCESSOR = $__8.GET_ACCESSOR,\n      IDENTIFIER_EXPRESSION = $__8.IDENTIFIER_EXPRESSION,\n      IMPORTED_BINDING = $__8.IMPORTED_BINDING,\n      IMPORT_CLAUSE_PAIR = $__8.IMPORT_CLAUSE_PAIR,\n      IMPORT_SPECIFIER_SET = $__8.IMPORT_SPECIFIER_SET,\n      IMPORT_TYPE_CLAUSE = $__8.IMPORT_TYPE_CLAUSE,\n      JSX_ATTRIBUTE = $__8.JSX_ATTRIBUTE,\n      JSX_ELEMENT_NAME = $__8.JSX_ELEMENT_NAME,\n      JSX_ELEMENT = $__8.JSX_ELEMENT,\n      JSX_PLACEHOLDER = $__8.JSX_PLACEHOLDER,\n      JSX_SPREAD_ATTRIBUTE = $__8.JSX_SPREAD_ATTRIBUTE,\n      JSX_TEXT = $__8.JSX_TEXT,\n      LITERAL_PROPERTY_NAME = $__8.LITERAL_PROPERTY_NAME,\n      METHOD = $__8.METHOD,\n      MODULE_SPECIFIER = $__8.MODULE_SPECIFIER,\n      NAMED_EXPORT = $__8.NAMED_EXPORT,\n      NAME_SPACE_EXPORT = $__8.NAME_SPACE_EXPORT,\n      NAME_SPACE_IMPORT = $__8.NAME_SPACE_IMPORT,\n      OBJECT_PATTERN = $__8.OBJECT_PATTERN,\n      OBJECT_PATTERN_FIELD = $__8.OBJECT_PATTERN_FIELD,\n      PROPERTY_NAME_ASSIGNMENT = $__8.PROPERTY_NAME_ASSIGNMENT,\n      PROPERTY_NAME_SHORTHAND = $__8.PROPERTY_NAME_SHORTHAND,\n      PROPERTY_VARIABLE_DECLARATION = $__8.PROPERTY_VARIABLE_DECLARATION,\n      REST_PARAMETER = $__8.REST_PARAMETER,\n      SET_ACCESSOR = $__8.SET_ACCESSOR,\n      SPREAD_EXPRESSION = $__8.SPREAD_EXPRESSION,\n      TEMPLATE_LITERAL_PORTION = $__8.TEMPLATE_LITERAL_PORTION,\n      TEMPLATE_SUBSTITUTION = $__8.TEMPLATE_SUBSTITUTION,\n      TYPE_ALIAS_DECLARATION = $__8.TYPE_ALIAS_DECLARATION,\n      TYPE_ARGUMENTS = $__8.TYPE_ARGUMENTS,\n      TYPE_NAME = $__8.TYPE_NAME,\n      TYPE_PARAMETER = $__8.TYPE_PARAMETER,\n      TYPE_PARAMETERS = $__8.TYPE_PARAMETERS,\n      VARIABLE_DECLARATION_LIST = $__8.VARIABLE_DECLARATION_LIST,\n      VARIABLE_STATEMENT = $__8.VARIABLE_STATEMENT;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/assert.js", "traceur@0.0.111/src/syntax/ParseTreeValidator.js")).assert;\n  var ValidationError = function($__super) {\n    function ValidationError(tree, message) {\n      $traceurRuntime.superConstructor(ValidationError).call(this);\n      this.tree = tree;\n      this.message = message;\n    }\n    return ($traceurRuntime.createClass)(ValidationError, {}, {}, $__super);\n  }(Error);\n  var ParseTreeValidator = function($__super) {\n    function ParseTreeValidator() {\n      $traceurRuntime.superConstructor(ParseTreeValidator).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ParseTreeValidator, {\n      fail_: function(tree, message) {\n        throw new ValidationError(tree, message);\n      },\n      check_: function(condition, tree, message) {\n        if (!condition) {\n          this.fail_(tree, message);\n        }\n      },\n      checkVisit_: function(condition, tree, message) {\n        this.check_(condition, tree, message);\n        this.visitAny(tree);\n      },\n      checkType_: function(type, tree, message) {\n        this.checkVisit_(tree.type === type, tree, message);\n      },\n      visitArgumentList: function(tree) {\n        for (var i = 0; i < tree.args.length; i++) {\n          var argument = tree.args[i];\n          this.checkVisit_(argument.isAssignmentOrSpread(), argument, \'assignment or spread expected\');\n        }\n      },\n      visitArrayLiteral: function(tree) {\n        for (var i = 0; i < tree.elements.length; i++) {\n          var element = tree.elements[i];\n          this.checkVisit_(element === null || element.isAssignmentOrSpread(), element, \'assignment or spread expected\');\n        }\n      },\n      visitArrayPattern: function(tree) {\n        for (var i = 0; i < tree.elements.length; i++) {\n          var element = tree.elements[i];\n          this.checkVisit_(element === null || element.type === BINDING_ELEMENT || element.type === ASSIGNMENT_ELEMENT || element.isLeftHandSideExpression() || element.isPattern() || element.isSpreadPatternElement(), element, \'null, sub pattern, left hand side expression or spread expected\');\n          if (element && element.isSpreadPatternElement()) {\n            this.check_(i === (tree.elements.length - 1), element, \'spread in array patterns must be the last element\');\n          }\n        }\n      },\n      visitBinaryExpression: function(tree) {\n        switch (tree.operator.type) {\n          case EQUAL:\n          case STAR_EQUAL:\n          case STAR_STAR_EQUAL:\n          case SLASH_EQUAL:\n          case PERCENT_EQUAL:\n          case PLUS_EQUAL:\n          case MINUS_EQUAL:\n          case LEFT_SHIFT_EQUAL:\n          case RIGHT_SHIFT_EQUAL:\n          case UNSIGNED_RIGHT_SHIFT_EQUAL:\n          case AMPERSAND_EQUAL:\n          case CARET_EQUAL:\n          case BAR_EQUAL:\n            this.check_(tree.left.isLeftHandSideExpression() || tree.left.isPattern(), tree.left, \'left hand side expression or pattern expected\');\n            this.check_(tree.right.isAssignmentExpression(), tree.right, \'assignment expression expected\');\n            break;\n          case AND:\n          case OR:\n          case BAR:\n          case CARET:\n          case AMPERSAND:\n          case EQUAL_EQUAL:\n          case NOT_EQUAL:\n          case EQUAL_EQUAL_EQUAL:\n          case NOT_EQUAL_EQUAL:\n          case OPEN_ANGLE:\n          case CLOSE_ANGLE:\n          case GREATER_EQUAL:\n          case LESS_EQUAL:\n          case INSTANCEOF:\n          case IN:\n          case LEFT_SHIFT:\n          case RIGHT_SHIFT:\n          case UNSIGNED_RIGHT_SHIFT:\n          case PLUS:\n          case MINUS:\n          case STAR:\n          case SLASH:\n          case PERCENT:\n          case STAR_STAR:\n            this.check_(tree.left.isAssignmentExpression(), tree.left, \'assignment expression expected\');\n            this.check_(tree.right.isAssignmentExpression(), tree.right, \'assignment expression expected\');\n            break;\n          default:\n            this.fail_(tree, \'unexpected binary operator\');\n        }\n        this.visitAny(tree.left);\n        this.visitAny(tree.right);\n      },\n      visitBindingElement: function(tree) {\n        var binding = tree.binding;\n        this.checkVisit_(binding.type === BINDING_IDENTIFIER || binding.type === OBJECT_PATTERN || binding.type === ARRAY_PATTERN, binding, \'expected valid binding element\');\n        this.visitAny(tree.initializer);\n      },\n      visitAssignmentElement: function(tree) {\n        var assignment = tree.assignment;\n        this.checkVisit_(assignment.type === OBJECT_PATTERN || assignment.type === ARRAY_PATTERN || assignment.isLeftHandSideExpression(), assignment, \'expected valid assignment element\');\n        this.visitAny(tree.initializer);\n      },\n      visitBlock: function(tree) {\n        for (var i = 0; i < tree.statements.length; i++) {\n          var statement = tree.statements[i];\n          this.checkVisit_(statement.isStatementListItem(), statement, \'statement or function declaration expected\');\n        }\n      },\n      visitCallExpression: function(tree) {\n        this.check_(tree.operand.isMemberExpression(), tree.operand, \'member expression expected\');\n        if (tree.operand instanceof NewExpression) {\n          this.check_(tree.operand.args !== null, tree.operand, \'new args expected\');\n        }\n        this.visitAny(tree.operand);\n        this.visitAny(tree.args);\n      },\n      visitCaseClause: function(tree) {\n        this.checkVisit_(tree.expression.isExpression(), tree.expression, \'expression expected\');\n        for (var i = 0; i < tree.statements.length; i++) {\n          var statement = tree.statements[i];\n          this.checkVisit_(statement.isStatementListItem(), statement, \'statement expected\');\n        }\n      },\n      visitCatch: function(tree) {\n        this.checkVisit_(tree.binding.isPattern() || tree.binding.type === BINDING_IDENTIFIER, tree.binding, \'binding identifier expected\');\n        this.checkVisit_(tree.catchBody.type === BLOCK, tree.catchBody, \'block expected\');\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitClassShared_(tree);\n      },\n      visitClassExpression: function(tree) {\n        this.visitClassShared_(tree);\n      },\n      visitClassShared_: function(tree) {\n        if (tree.typeParameters) {\n          this.checkVisit_(tree.typeParameters.type === TYPE_PARAMETERS, tree.typeParameters, \'type parameters expected\');\n        }\n        for (var i = 0; i < tree.elements.length; i++) {\n          var element = tree.elements[i];\n          switch (element.type) {\n            case GET_ACCESSOR:\n            case SET_ACCESSOR:\n            case METHOD:\n            case PROPERTY_VARIABLE_DECLARATION:\n              break;\n            default:\n              this.fail_(element, \'class element expected\');\n          }\n          this.visitAny(element);\n        }\n      },\n      visitCommaExpression: function(tree) {\n        for (var i = 0; i < tree.expressions.length; i++) {\n          var expression = tree.expressions[i];\n          this.checkVisit_(expression.isExpression(), expression, \'expression expected\');\n        }\n      },\n      visitConditionalExpression: function(tree) {\n        this.checkVisit_(tree.condition.isAssignmentExpression(), tree.condition, \'expression expected\');\n        this.checkVisit_(tree.left.isAssignmentExpression(), tree.left, \'expression expected\');\n        this.checkVisit_(tree.right.isAssignmentExpression(), tree.right, \'expression expected\');\n      },\n      visitCoverFormals: function(tree) {\n        this.fail_(tree, \'CoverFormals should have been removed\');\n      },\n      visitCoverInitializedName: function(tree) {\n        this.fail_(tree, \'CoverInitializedName should have been removed\');\n      },\n      visitDefaultClause: function(tree) {\n        for (var i = 0; i < tree.statements.length; i++) {\n          var statement = tree.statements[i];\n          this.checkVisit_(statement.isStatementListItem(), statement, \'statement expected\');\n        }\n      },\n      visitDoWhileStatement: function(tree) {\n        this.checkVisit_(tree.body.isStatement(), tree.body, \'statement expected\');\n        this.checkVisit_(tree.condition.isExpression(), tree.condition, \'expression expected\');\n      },\n      visitExportDeclaration: function(tree) {\n        var declType = tree.declaration.type;\n        this.checkVisit_(declType === VARIABLE_STATEMENT || declType === FUNCTION_DECLARATION || declType === CLASS_DECLARATION || declType === NAMED_EXPORT || declType === EXPORT_DEFAULT || declType === TYPE_ALIAS_DECLARATION, tree.declaration, \'expected valid export tree\');\n      },\n      visitNamedExport: function(tree) {\n        var specifierType = tree.exportClause.type;\n        this.checkVisit_(specifierType === EXPORT_SPECIFIER || specifierType === EXPORT_SPECIFIER_SET || specifierType === EXPORT_STAR || specifierType === FORWARD_DEFAULT_EXPORT || specifierType === NAME_SPACE_EXPORT, tree.exportClause, \'Invalid export clause\');\n        if (tree.moduleSpecifier) {\n          this.checkVisit_(tree.moduleSpecifier.type === MODULE_SPECIFIER, tree.moduleSpecifier, \'module expression expected\');\n        }\n      },\n      visitExportSpecifierSet: function(tree) {\n        this.check_(tree.specifiers.length > 0, tree, \'expected at least one identifier\');\n        for (var i = 0; i < tree.specifiers.length; i++) {\n          var specifier = tree.specifiers[i];\n          this.checkVisit_(specifier.type === EXPORT_SPECIFIER || specifier.type === IDENTIFIER_EXPRESSION, specifier, \'expected valid export specifier\');\n        }\n      },\n      visitExpressionStatement: function(tree) {\n        this.checkVisit_(tree.expression.isExpression(), tree.expression, \'expression expected\');\n      },\n      visitFinally: function(tree) {\n        this.checkVisit_(tree.block.type === BLOCK, tree.block, \'block expected\');\n      },\n      visitForOfStatement: function(tree) {\n        this.checkVisit_(tree.initializer.isPattern() || tree.initializer.type === IDENTIFIER_EXPRESSION || tree.initializer.type === VARIABLE_DECLARATION_LIST && tree.initializer.declarations.length === 1, tree.initializer, \'for-each statement may not have more than one variable declaration\');\n        this.checkVisit_(tree.collection.isExpression(), tree.collection, \'expression expected\');\n        this.checkVisit_(tree.body.isStatement(), tree.body, \'statement expected\');\n      },\n      visitForInStatement: function(tree) {\n        if (tree.initializer.type === VARIABLE_DECLARATION_LIST) {\n          this.checkVisit_(tree.initializer.declarations.length <= 1, tree.initializer, \'for-in statement may not have more than one variable declaration\');\n        } else {\n          this.checkVisit_(tree.initializer.isPattern() || tree.initializer.isExpression(), tree.initializer, \'variable declaration, expression or \' + \'pattern expected\');\n        }\n        this.checkVisit_(tree.collection.isExpression(), tree.collection, \'expression expected\');\n        this.checkVisit_(tree.body.isStatement(), tree.body, \'statement expected\');\n      },\n      visitFormalParameterList: function(tree) {\n        for (var i = 0; i < tree.parameters.length; i++) {\n          var parameter = tree.parameters[i];\n          assert(parameter.type === FORMAL_PARAMETER);\n          parameter = parameter.parameter;\n          switch (parameter.type) {\n            case BINDING_ELEMENT:\n              break;\n            case REST_PARAMETER:\n              this.checkVisit_(i === tree.parameters.length - 1, parameter, \'rest parameters must be the last parameter in a parameter list\');\n              this.checkType_(BINDING_IDENTIFIER, parameter.identifier, \'binding identifier expected\');\n              break;\n            default:\n              this.fail_(parameter, \'parameters must be identifiers or rest\' + (" parameters. Found: " + parameter.type));\n              break;\n          }\n          this.visitAny(parameter);\n        }\n      },\n      visitForStatement: function(tree) {\n        if (tree.initializer !== null) {\n          this.checkVisit_(tree.initializer.isExpression() || tree.initializer.type === VARIABLE_DECLARATION_LIST, tree.initializer, \'variable declaration list or expression expected\');\n        }\n        if (tree.condition !== null) {\n          this.checkVisit_(tree.condition.isExpression(), tree.condition, \'expression expected\');\n        }\n        if (tree.increment !== null) {\n          this.checkVisit_(tree.increment.isExpression(), tree.increment, \'expression expected\');\n        }\n        this.checkVisit_(tree.body.isStatement(), tree.body, \'statement expected\');\n      },\n      visitFunctionBody: function(tree) {\n        for (var i = 0; i < tree.statements.length; i++) {\n          var statement = tree.statements[i];\n          this.checkVisit_(statement.isStatementListItem(), statement, \'statement expected\');\n        }\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.checkType_(BINDING_IDENTIFIER, tree.name, \'binding identifier expected\');\n        this.visitFunction_(tree);\n      },\n      visitFunctionExpression: function(tree) {\n        if (tree.name !== null) {\n          this.checkType_(BINDING_IDENTIFIER, tree.name, \'binding identifier expected\');\n        }\n        this.visitFunction_(tree);\n      },\n      visitFunction_: function(tree) {\n        this.checkType_(FORMAL_PARAMETER_LIST, tree.parameterList, \'formal parameters expected\');\n        this.checkType_(FUNCTION_BODY, tree.body, \'function body expected\');\n      },\n      visitGetAccessor: function(tree) {\n        this.checkPropertyName_(tree.name);\n        this.checkType_(FUNCTION_BODY, tree.body, \'function body expected\');\n      },\n      visitIfStatement: function(tree) {\n        this.checkVisit_(tree.condition.isExpression(), tree.condition, \'expression expected\');\n        this.checkVisit_(tree.ifClause.isStatement(), tree.ifClause, \'statement expected\');\n        if (tree.elseClause !== null) {\n          this.checkVisit_(tree.elseClause.isStatement(), tree.elseClause, \'statement expected\');\n        }\n      },\n      visitImportDeclaration: function(tree) {\n        if (tree.importClause !== null) {\n          this.check_(tree.importClause.type === NAME_SPACE_IMPORT || tree.importClause.type === IMPORTED_BINDING || tree.importClause.type === IMPORT_SPECIFIER_SET || tree.importClause.type === IMPORT_CLAUSE_PAIR || tree.importClause.type === IMPORT_TYPE_CLAUSE, tree.importClause, \'Invalid import clause\');\n        }\n        this.checkType_(MODULE_SPECIFIER, tree.moduleSpecifier, \'module specifier expected\');\n      },\n      visitImportSpecifier: function(tree) {\n        this.checkType_(IMPORTED_BINDING, tree.binding, \'ImportedBinding expected\');\n      },\n      visitImportedBinding: function(tree) {\n        this.checkType_(BINDING_IDENTIFIER, tree.binding, \'binding identifier expected\');\n      },\n      visitImportClausePair: function(tree) {\n        this.checkType_(IMPORTED_BINDING, tree.first, \'ImportedBinding expected\');\n        this.check_(tree.second.type === NAME_SPACE_IMPORT || tree.second.type === IMPORT_SPECIFIER_SET, tree.second, \'Invalid import clause\');\n      },\n      visitJsxElement: function(tree) {\n        this.checkType_(JSX_ELEMENT_NAME, tree.name, \'JSX Element Name expected\');\n        for (var i = 0; i < tree.attributes.length; i++) {\n          var attr = tree.attributes[i];\n          this.checkVisit_(attr.type === JSX_ATTRIBUTE || attr.type === JSX_SPREAD_ATTRIBUTE, attr, \'JSX Attribute expected\');\n        }\n        for (var i$__3 = 0; i$__3 < tree.children.length; i$__3++) {\n          var child = tree.children[i$__3];\n          this.checkVisit_(child.type === JSX_ELEMENT || child.type === JSX_PLACEHOLDER || child.type === JSX_TEXT, child, \'JSX child expected\');\n        }\n      },\n      visitLabelledStatement: function(tree) {\n        this.checkVisit_(tree.statement.isStatement(), tree.statement, \'statement expected\');\n      },\n      visitMemberExpression: function(tree) {\n        this.check_(tree.operand.isMemberExpression(), tree.operand, \'member expression expected\');\n        if (tree.operand instanceof NewExpression) {\n          this.check_(tree.operand.args !== null, tree.operand, \'new args expected\');\n        }\n        this.visitAny(tree.operand);\n      },\n      visitMemberLookupExpression: function(tree) {\n        this.check_(tree.operand.isMemberExpression(), tree.operand, \'member expression expected\');\n        if (tree.operand instanceof NewExpression) {\n          this.check_(tree.operand.args !== null, tree.operand, \'new args expected\');\n        }\n        this.visitAny(tree.operand);\n      },\n      visitSyntaxErrorTree: function(tree) {\n        this.fail_(tree, ("parse tree contains SyntaxError: " + tree.message));\n      },\n      visitModuleSpecifier: function(tree) {\n        this.check_(tree.token.type === STRING, tree, \'string or identifier expected\');\n      },\n      visitNewExpression: function(tree) {\n        this.checkVisit_(tree.operand.isMemberExpression(), tree.operand, \'member expression expected\');\n        this.visitAny(tree.args);\n      },\n      visitObjectLiteral: function(tree) {\n        for (var i = 0; i < tree.propertyNameAndValues.length; i++) {\n          var propertyNameAndValue = tree.propertyNameAndValues[i];\n          switch (propertyNameAndValue.type) {\n            case GET_ACCESSOR:\n            case SET_ACCESSOR:\n            case METHOD:\n              this.check_(!propertyNameAndValue.isStatic, propertyNameAndValue, \'static is not allowed in object literal expression\');\n              break;\n            case PROPERTY_NAME_ASSIGNMENT:\n            case PROPERTY_NAME_SHORTHAND:\n            case SPREAD_EXPRESSION:\n              break;\n            default:\n              this.fail_(propertyNameAndValue, \'accessor, property name \' + \'assignment or property method assigment expected\');\n          }\n          this.visitAny(propertyNameAndValue);\n        }\n      },\n      visitObjectPattern: function(tree) {\n        for (var i = 0; i < tree.fields.length; i++) {\n          var field = tree.fields[i];\n          this.checkVisit_(field.type === OBJECT_PATTERN_FIELD || field.type === ASSIGNMENT_ELEMENT || field.type === BINDING_ELEMENT, field, \'object pattern field expected\');\n        }\n      },\n      visitObjectPatternField: function(tree) {\n        this.checkPropertyName_(tree.name);\n        this.checkVisit_(tree.element.type === ASSIGNMENT_ELEMENT || tree.element.type === BINDING_ELEMENT || tree.element.isPattern() || tree.element.isLeftHandSideExpression(), tree.element, \'binding element expected\');\n      },\n      visitParenExpression: function(tree) {\n        if (tree.expression.isPattern()) {\n          this.visitAny(tree.expression);\n        } else {\n          this.checkVisit_(tree.expression.isExpression(), tree.expression, \'expression expected\');\n        }\n      },\n      visitPostfixExpression: function(tree) {\n        this.checkVisit_(tree.operand.isAssignmentExpression(), tree.operand, \'assignment expression expected\');\n      },\n      visitPredefinedType: function(tree) {},\n      visitScript: function(tree) {\n        for (var i = 0; i < tree.scriptItemList.length; i++) {\n          var scriptItemList = tree.scriptItemList[i];\n          this.checkVisit_(scriptItemList.isScriptElement(), scriptItemList, \'global script item expected\');\n        }\n      },\n      checkPropertyName_: function(tree) {\n        this.checkVisit_(tree.type === LITERAL_PROPERTY_NAME || tree.type === COMPUTED_PROPERTY_NAME, tree, \'property name expected\');\n      },\n      visitPropertyNameAssignment: function(tree) {\n        this.checkPropertyName_(tree.name);\n        this.checkVisit_(tree.value.isAssignmentExpression(), tree.value, \'assignment expression expected\');\n      },\n      visitPropertyNameShorthand: function(tree) {\n        this.check_(tree.name.type === IDENTIFIER || tree.name.type === YIELD || tree.name.isStrictKeyword(), tree, \'identifier token expected\');\n      },\n      visitLiteralPropertyName: function(tree) {\n        var type = tree.literalToken.type;\n        this.check_(tree.literalToken.isKeyword() || type === IDENTIFIER || type === NUMBER || type === STRING, tree, \'Unexpected token in literal property name\');\n      },\n      visitTemplateLiteralExpression: function(tree) {\n        if (tree.operand) {\n          this.checkVisit_(tree.operand.isMemberExpression(), tree.operand, \'member or call expression expected\');\n        }\n        for (var i = 0; i < tree.elements.length; i++) {\n          var element = tree.elements[i];\n          if (i % 2) {\n            this.checkType_(TEMPLATE_SUBSTITUTION, element, \'Template literal substitution expected\');\n          } else {\n            this.checkType_(TEMPLATE_LITERAL_PORTION, element, \'Template literal portion expected\');\n          }\n        }\n      },\n      visitReturnStatement: function(tree) {\n        if (tree.expression !== null) {\n          this.checkVisit_(tree.expression.isExpression(), tree.expression, \'expression expected\');\n        }\n      },\n      visitSetAccessor: function(tree) {\n        this.checkPropertyName_(tree.name);\n        this.checkType_(FUNCTION_BODY, tree.body, \'function body expected\');\n      },\n      visitSpreadExpression: function(tree) {\n        this.checkVisit_(tree.expression.isAssignmentExpression(), tree.expression, \'assignment expression expected\');\n      },\n      visitStateMachine: function(tree) {\n        this.fail_(tree, \'State machines are never valid outside of the \' + \'GeneratorTransformer pass.\');\n      },\n      visitSwitchStatement: function(tree) {\n        this.checkVisit_(tree.expression.isExpression(), tree.expression, \'expression expected\');\n        var defaultCount = 0;\n        for (var i = 0; i < tree.caseClauses.length; i++) {\n          var caseClause = tree.caseClauses[i];\n          if (caseClause.type === DEFAULT_CLAUSE) {\n            ++defaultCount;\n            this.checkVisit_(defaultCount <= 1, caseClause, \'no more than one default clause allowed\');\n          } else {\n            this.checkType_(CASE_CLAUSE, caseClause, \'case or default clause expected\');\n          }\n        }\n      },\n      visitThrowStatement: function(tree) {\n        if (tree.value === null) {\n          return;\n        }\n        this.checkVisit_(tree.value.isExpression(), tree.value, \'expression expected\');\n      },\n      visitTryStatement: function(tree) {\n        this.checkType_(BLOCK, tree.body, \'block expected\');\n        if (tree.catchBlock !== null) {\n          this.checkType_(CATCH, tree.catchBlock, \'catch block expected\');\n        }\n        if (tree.finallyBlock !== null) {\n          this.checkType_(FINALLY, tree.finallyBlock, \'finally block expected\');\n        }\n        if (tree.catchBlock === null && tree.finallyBlock === null) {\n          this.fail_(tree, \'either catch or finally must be present\');\n        }\n      },\n      visitTypeArguments: function(tree) {\n        var args = tree.args;\n        for (var i = 0; i < args.length; i++) {\n          this.checkVisit_(args[i].isType(), args[i], \'Type arguments must be type expressions\');\n        }\n      },\n      visitTypeName: function(tree) {\n        this.checkVisit_(tree.moduleName === null || tree.moduleName.type === TYPE_NAME, tree.moduleName, \'moduleName must be null or a TypeName\');\n        this.check_(tree.name.type === IDENTIFIER, tree, \'name must be an identifier\');\n      },\n      visitTypeReference: function(tree) {\n        this.checkType_(TYPE_NAME, tree.typeName, \'typeName must be a TypeName\');\n        this.checkType_(TYPE_ARGUMENTS, tree.args, \'args must be a TypeArguments\');\n      },\n      visitTypeParameters: function(tree) {\n        var parameters = tree.parameters;\n        for (var i = 0; i < parameters.length; i++) {\n          this.checkType_(TYPE_PARAMETER, parameters[i], \'Type parameters must all be type parameters\');\n        }\n      },\n      visitTypeParameter: function(tree) {\n        this.check_(tree.identifierToken.type === IDENTIFIER, tree, \'Type parameter must be an identifier token\');\n        if (tree.extendsType) {\n          this.checkVisit_(tree.extendsType.isType(), tree.extendsType, \'extends type must be a type expression\');\n        }\n      },\n      visitUnaryExpression: function(tree) {\n        this.checkVisit_(tree.operand.isAssignmentExpression(), tree.operand, \'assignment expression expected\');\n      },\n      visitVariableDeclaration: function(tree) {\n        this.checkVisit_(tree.lvalue.isPattern() || tree.lvalue.type === BINDING_IDENTIFIER, tree.lvalue, \'binding identifier expected, found: \' + tree.lvalue.type);\n        if (tree.initializer !== null) {\n          this.checkVisit_(tree.initializer.isAssignmentExpression(), tree.initializer, \'assignment expression expected\');\n        }\n      },\n      visitWhileStatement: function(tree) {\n        this.checkVisit_(tree.condition.isExpression(), tree.condition, \'expression expected\');\n        this.checkVisit_(tree.body.isStatement(), tree.body, \'statement expected\');\n      },\n      visitWithStatement: function(tree) {\n        this.checkVisit_(tree.expression.isExpression(), tree.expression, \'expression expected\');\n        this.checkVisit_(tree.body.isStatement(), tree.body, \'statement expected\');\n      },\n      visitYieldExpression: function(tree) {\n        if (tree.expression !== null) {\n          this.checkVisit_(tree.expression.isExpression(), tree.expression, \'expression expected\');\n        }\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  ParseTreeValidator.validate = function(tree) {\n    var validator = new ParseTreeValidator();\n    try {\n      validator.visitAny(tree);\n    } catch (e) {\n      if (!(e instanceof ValidationError)) {\n        throw e;\n      }\n      var location = null;\n      if (e.tree !== null) {\n        location = e.tree.location;\n      }\n      if (location === null) {\n        location = tree.location;\n      }\n      var locationString = location !== null ? location.start.toString() : \'(unknown)\';\n      throw new Error(("Parse tree validation failure \'" + e.message + "\' at " + locationString + ":") + ("\\n\\n" + TreeWriter.write(tree) + "\\n"));\n    }\n  };\n  return {get ParseTreeValidator() {\n      return ParseTreeValidator;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/MultiTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/MultiTransformer.js";\n  var ParseTreeValidator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/ParseTreeValidator.js", "traceur@0.0.111/src/codegeneration/MultiTransformer.js")).ParseTreeValidator;\n  var MultiTransformer = function() {\n    function MultiTransformer(reporter, validate) {\n      this.reporter_ = reporter;\n      this.validate_ = validate;\n      this.treeTransformers_ = [];\n    }\n    return ($traceurRuntime.createClass)(MultiTransformer, {\n      append: function(treeTransformer) {\n        this.treeTransformers_.push(treeTransformer);\n      },\n      transform: function(tree) {\n        var reporter = this.reporter_;\n        var validate = this.validate_;\n        this.treeTransformers_.every(function(transformTree) {\n          tree = transformTree(tree);\n          if (reporter.hadError())\n            return false;\n          if (validate)\n            ParseTreeValidator.validate(tree);\n          return true;\n        });\n        return tree;\n      }\n    }, {});\n  }();\n  return {get MultiTransformer() {\n      return MultiTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js")).ParseTreeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js")),\n      LiteralExpression = $__2.LiteralExpression,\n      LiteralPropertyName = $__2.LiteralPropertyName;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/LiteralToken.js", "traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js")).LiteralToken;\n  var NUMBER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js")).NUMBER;\n  function needsTransform(token) {\n    return token.type === NUMBER && /^0[bBoO]/.test(token.value);\n  }\n  function transformToken(token) {\n    return new LiteralToken(NUMBER, String(token.processedValue), token.location);\n  }\n  var NumericLiteralTransformer = function($__super) {\n    function NumericLiteralTransformer() {\n      $traceurRuntime.superConstructor(NumericLiteralTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(NumericLiteralTransformer, {\n      transformLiteralExpression: function(tree) {\n        var token = tree.literalToken;\n        if (needsTransform(token))\n          return new LiteralExpression(tree.location, transformToken(token));\n        return tree;\n      },\n      transformLiteralPropertyName: function(tree) {\n        var token = tree.literalToken;\n        if (needsTransform(token))\n          return new LiteralPropertyName(tree.location, transformToken(token));\n        return tree;\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get NumericLiteralTransformer() {\n      return NumericLiteralTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js";\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./FindVisitor.js", "traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js")).FindVisitor;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js")),\n      FunctionExpression = $__4.FunctionExpression,\n      IdentifierExpression = $__4.IdentifierExpression,\n      LiteralExpression = $__4.LiteralExpression;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js")).TempVarTransformer;\n  var IDENTIFIER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js")).IDENTIFIER;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js")),\n      COMPUTED_PROPERTY_NAME = $__7.COMPUTED_PROPERTY_NAME,\n      LITERAL_PROPERTY_NAME = $__7.LITERAL_PROPERTY_NAME;\n  var StringMap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/StringMap.js", "traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js")).StringMap;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js")),\n      createAssignmentExpression = $__9.createAssignmentExpression,\n      createCommaExpression = $__9.createCommaExpression,\n      createDefineProperty = $__9.createDefineProperty,\n      createEmptyParameterList = $__9.createEmptyParameterList,\n      createFunctionExpression = $__9.createFunctionExpression,\n      createIdentifierExpression = $__9.createIdentifierExpression,\n      createObjectCreate = $__9.createObjectCreate,\n      createObjectLiteral = $__9.createObjectLiteral,\n      createParenExpression = $__9.createParenExpression,\n      createPropertyNameAssignment = $__9.createPropertyNameAssignment,\n      createStringLiteral = $__9.createStringLiteral;\n  var propName = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../staticsemantics/PropName.js", "traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js")).propName;\n  var FindAdvancedProperty = function($__super) {\n    function FindAdvancedProperty(transformOptions) {\n      $traceurRuntime.superConstructor(FindAdvancedProperty).call(this, true);\n      this.transformOptions_ = transformOptions;\n      this.protoExpression = null;\n    }\n    return ($traceurRuntime.createClass)(FindAdvancedProperty, {\n      visitPropertyNameAssignment: function(tree) {\n        if (isProtoName(tree.name))\n          this.protoExpression = tree.value;\n        else\n          this.visitAny(tree.name);\n      },\n      visitMethod: function(tree) {\n        this.visitAny(tree.name);\n      },\n      visitGetAccessor: function(tree) {\n        if (this.transformOptions_.properTailCalls) {\n          this.found = true;\n        } else {\n          this.visitAny(tree.name);\n        }\n      },\n      visitSetAccessor: function(tree) {\n        if (this.transformOptions_.properTailCalls) {\n          this.found = true;\n        } else {\n          this.visitAny(tree.name);\n        }\n      },\n      visitComputedPropertyName: function(tree) {\n        if (this.transformOptions_.computedPropertyNames)\n          this.found = true;\n      }\n    }, {}, $__super);\n  }(FindVisitor);\n  function isProtoName(tree) {\n    return propName(tree) === \'__proto__\';\n  }\n  var ObjectLiteralTransformer = function($__super) {\n    function ObjectLiteralTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(ObjectLiteralTransformer).call(this, identifierGenerator, reporter, options);\n      this.transformOptions_ = options.transformOptions;\n      this.protoExpression = null;\n      this.needsAdvancedTransform = false;\n      this.seenAccessors = null;\n    }\n    return ($traceurRuntime.createClass)(ObjectLiteralTransformer, {\n      findSeenAccessor_: function(name) {\n        if (name.type === COMPUTED_PROPERTY_NAME)\n          return null;\n        var s = propName(name);\n        return this.seenAccessors.get(s);\n      },\n      removeSeenAccessor_: function(name) {\n        if (name.type === COMPUTED_PROPERTY_NAME)\n          return;\n        var s = propName(name);\n        this.seenAccessors.delete(s);\n      },\n      addSeenAccessor_: function(name, descr) {\n        if (name.type === COMPUTED_PROPERTY_NAME)\n          return;\n        var s = propName(name);\n        this.seenAccessors.set(s, descr);\n      },\n      createProperty_: function(name, descr) {\n        var expression;\n        if (name.type === LITERAL_PROPERTY_NAME) {\n          if (this.needsAdvancedTransform)\n            expression = this.getPropertyName_(name);\n          else\n            expression = name;\n        } else {\n          expression = name.expression;\n        }\n        if (descr.get || descr.set) {\n          var oldAccessor = this.findSeenAccessor_(name);\n          if (oldAccessor) {\n            oldAccessor.get = descr.get || oldAccessor.get;\n            oldAccessor.set = descr.set || oldAccessor.set;\n            this.removeSeenAccessor_(name);\n            return null;\n          } else {\n            this.addSeenAccessor_(name, descr);\n          }\n        }\n        return [expression, descr];\n      },\n      getPropertyName_: function(nameTree) {\n        var token = nameTree.literalToken;\n        switch (token.type) {\n          case IDENTIFIER:\n            return createStringLiteral(token.value);\n          default:\n            if (token.isKeyword())\n              return createStringLiteral(token.type);\n            return new LiteralExpression(token.location, token);\n        }\n      },\n      transformClassDeclaration: function(tree) {\n        return tree;\n      },\n      transformClassExpression: function(tree) {\n        return tree;\n      },\n      transformObjectLiteral: function(tree) {\n        var oldNeedsTransform = this.needsAdvancedTransform;\n        var oldSeenAccessors = this.seenAccessors;\n        var transformed = this.transformObjectLiteralInner_(tree);\n        this.needsAdvancedTransform = oldNeedsTransform;\n        this.seenAccessors = oldSeenAccessors;\n        return transformed;\n      },\n      transformObjectLiteralInner_: function(tree) {\n        var finder = new FindAdvancedProperty(this.transformOptions_);\n        finder.visitAny(tree);\n        if (!finder.found) {\n          this.needsAdvancedTransform = false;\n          return $traceurRuntime.superGet(this, ObjectLiteralTransformer.prototype, "transformObjectLiteral").call(this, tree);\n        }\n        this.needsAdvancedTransform = true;\n        this.seenAccessors = new StringMap();\n        var properties = this.transformList(tree.propertyNameAndValues);\n        properties = properties.filter(function(tree) {\n          return tree;\n        });\n        var tempVar = this.addTempVar();\n        var tempVarIdentifierExpression = createIdentifierExpression(tempVar);\n        var expressions = properties.map(function(property) {\n          var expression = property[0];\n          var descr = property[1];\n          return createDefineProperty(tempVarIdentifierExpression, expression, descr);\n        });\n        var protoExpression = this.transformAny(finder.protoExpression);\n        var objectExpression;\n        if (protoExpression)\n          objectExpression = createObjectCreate(protoExpression);\n        else\n          objectExpression = createObjectLiteral([]);\n        expressions.unshift(createAssignmentExpression(tempVarIdentifierExpression, objectExpression));\n        expressions.push(tempVarIdentifierExpression);\n        return createParenExpression(createCommaExpression(expressions));\n      },\n      transformPropertyNameAssignment: function(tree) {\n        if (!this.needsAdvancedTransform)\n          return $traceurRuntime.superGet(this, ObjectLiteralTransformer.prototype, "transformPropertyNameAssignment").call(this, tree);\n        if (isProtoName(tree.name))\n          return null;\n        return this.createProperty_(tree.name, {\n          value: this.transformAny(tree.value),\n          configurable: true,\n          enumerable: true,\n          writable: true\n        });\n      },\n      transformGetAccessor: function(tree) {\n        if (!this.needsAdvancedTransform)\n          return $traceurRuntime.superGet(this, ObjectLiteralTransformer.prototype, "transformGetAccessor").call(this, tree);\n        var body = this.transformAny(tree.body);\n        var func = createFunctionExpression(createEmptyParameterList(), body);\n        return this.createProperty_(tree.name, {\n          get: func,\n          configurable: true,\n          enumerable: true\n        });\n      },\n      transformSetAccessor: function(tree) {\n        if (!this.needsAdvancedTransform)\n          return $traceurRuntime.superGet(this, ObjectLiteralTransformer.prototype, "transformSetAccessor").call(this, tree);\n        var body = this.transformAny(tree.body);\n        var parameterList = this.transformAny(tree.parameterList);\n        var func = createFunctionExpression(parameterList, body);\n        return this.createProperty_(tree.name, {\n          set: func,\n          configurable: true,\n          enumerable: true\n        });\n      },\n      transformMethod: function(tree) {\n        var func = new FunctionExpression(tree.location, tree.debugName, tree.functionKind, this.transformAny(tree.parameterList), tree.typeAnnotation, [], this.transformAny(tree.body));\n        if (!this.needsAdvancedTransform) {\n          return createPropertyNameAssignment(tree.name, func);\n        }\n        var expression = this.transformAny(tree.name);\n        return this.createProperty_(tree.name, {\n          value: func,\n          configurable: true,\n          enumerable: true,\n          writable: true\n        });\n      },\n      transformPropertyNameShorthand: function(tree) {\n        if (!this.needsAdvancedTransform)\n          return $traceurRuntime.superGet(this, ObjectLiteralTransformer.prototype, "transformPropertyNameShorthand").call(this, tree);\n        var expression = this.transformAny(tree.name);\n        return this.createProperty_(tree.name, {\n          value: new IdentifierExpression(tree.location, tree.name.identifierToken),\n          configurable: true,\n          enumerable: false,\n          writable: true\n        });\n      }\n    }, {}, $__super);\n  }(TempVarTransformer);\n  return {get ObjectLiteralTransformer() {\n      return ObjectLiteralTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js")).ParseTreeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js")),\n      ArgumentList = $__2.ArgumentList,\n      BinaryExpression = $__2.BinaryExpression,\n      CallExpression = $__2.CallExpression,\n      ConditionalExpression = $__2.ConditionalExpression,\n      MemberExpression = $__2.MemberExpression,\n      MemberLookupExpression = $__2.MemberLookupExpression;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js")),\n      createArrayLiteral = $__3.createArrayLiteral,\n      createAssignmentExpression = $__3.createAssignmentExpression,\n      createCommaExpression = $__3.createCommaExpression,\n      createMemberExpression = $__3.createMemberExpression,\n      id = $__3.createIdentifierExpression,\n      createNullLiteral = $__3.createNullLiteral,\n      createParenExpression = $__3.createParenExpression;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js")),\n      COMMA_EXPRESSION = $__4.COMMA_EXPRESSION,\n      MEMBER_EXPRESSION = $__4.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__4.MEMBER_LOOKUP_EXPRESSION,\n      IDENTIFIER_EXPRESSION = $__4.IDENTIFIER_EXPRESSION,\n      PAREN_EXPRESSION = $__4.PAREN_EXPRESSION,\n      THIS_EXPRESSION = $__4.THIS_EXPRESSION;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js")),\n      AND = $__5.AND,\n      OR = $__5.OR;\n  function createCall(tree, operand, thisArg, importRuntimeTransformer) {\n    var argList = tree.args;\n    var argArray = argList ? argList.args : [];\n    argArray = argArray.map(function(arg) {\n      if (arg.type === COMMA_EXPRESSION) {\n        return createParenExpression(arg.type);\n      }\n      return arg;\n    });\n    var continuation = importRuntimeTransformer.getRuntimeExpression(\'continuation\');\n    return new CallExpression(tree.location, continuation, new ArgumentList(argList ? argList.location : null, [operand, thisArg, createArrayLiteral(argArray)]));\n  }\n  var RewriteTailExpressionsTransformer = function($__super) {\n    function RewriteTailExpressionsTransformer(bodyTransformer) {\n      $traceurRuntime.superConstructor(RewriteTailExpressionsTransformer).call(this);\n      this.bodyTransformer_ = bodyTransformer;\n    }\n    return ($traceurRuntime.createClass)(RewriteTailExpressionsTransformer, {\n      transformBinaryExpression: function(tree) {\n        var operator = tree.operator;\n        if (operator.type !== AND && operator.type !== OR) {\n          return tree;\n        }\n        var right = this.transformAny(tree.right);\n        if (right !== tree.right) {\n          return new BinaryExpression(tree.location, tree.left, operator, right);\n        }\n        return tree;\n      },\n      transformCallExpression: function(tree) {\n        var operand = tree.operand;\n        while (operand.type === PAREN_EXPRESSION) {\n          operand = operand.expression;\n        }\n        switch (operand.type) {\n          case IDENTIFIER_EXPRESSION:\n            return createCall(tree, operand, createNullLiteral(), this.bodyTransformer_);\n          case MEMBER_EXPRESSION:\n          case MEMBER_LOOKUP_EXPRESSION:\n            return this.transformMemberExpressionCall_(tree, operand);\n        }\n        return tree;\n      },\n      transformMemberExpressionCall_: function(tree, operand) {\n        var object = operand.operand;\n        var thisArg;\n        var assignment;\n        if (object.type === IDENTIFIER_EXPRESSION || object.type === THIS_EXPRESSION) {\n          thisArg = object;\n        } else {\n          thisArg = id(this.bodyTransformer_.addTempVar());\n          assignment = createAssignmentExpression(thisArg, operand.operand);\n        }\n        if (operand.type === MEMBER_EXPRESSION) {\n          operand = new MemberExpression(operand.location, thisArg, operand.memberName);\n        } else {\n          operand = new MemberLookupExpression(operand.location, thisArg, operand.memberExpression);\n        }\n        if (assignment) {\n          return createParenExpression(createCommaExpression([assignment, createCall(tree, operand, thisArg, this.bodyTransformer_)]));\n        } else {\n          return createCall(tree, operand, thisArg, this.bodyTransformer_);\n        }\n      },\n      transformCommaExpression: function(tree) {\n        var expressions = tree.expressions;\n        var expression = expressions[expressions.length - 1];\n        var transformedExpression = this.transformAny(expression);\n        if (expression !== transformedExpression) {\n          expressions = expressions.slice(0, -1);\n          expressions.push(transformedExpression);\n          return new CommaExpression(tree.location, expressions);\n        }\n        return tree;\n      },\n      transformConditionalExpression: function(tree) {\n        var left = this.transformAny(tree.left);\n        var right = this.transformAny(tree.right);\n        if (left !== tree.left || right !== tree.right) {\n          return new ConditionalExpression(tree.location, tree.condition, left, right);\n        }\n        return tree;\n      },\n      transformNewExpression: function(tree) {\n        var construct = this.bodyTransformer_.getRuntimeExpression(\'construct\');\n        return createCall(tree, construct, tree.operand, this.bodyTransformer_);\n      },\n      transformArrayLiteral: function(tree) {\n        return tree;\n      },\n      transformArrowFunction: function(tree) {\n        return tree;\n      },\n      transformFunctionExpression: function(tree) {\n        return tree;\n      },\n      transformIdentifierExpression: function(tree) {\n        return tree;\n      },\n      transformLiteralExpression: function(tree) {\n        return tree;\n      },\n      transformMemberExpression: function(tree) {\n        return tree;\n      },\n      transformMemberLookupExpression: function(tree) {\n        return tree;\n      },\n      transformPostfixExpression: function(tree) {\n        return tree;\n      },\n      transformObjectLiteral: function(tree) {\n        return tree;\n      },\n      transformUnaryExpression: function(tree) {\n        return tree;\n      }\n    }, {transform: function(bodyTransformer, tree) {\n        return new RewriteTailExpressionsTransformer(bodyTransformer).transformAny(tree);\n      }}, $__super);\n  }(ParseTreeTransformer);\n  return {get RewriteTailExpressionsTransformer() {\n      return RewriteTailExpressionsTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js")).ParseTreeTransformer;\n  var RewriteTailExpressionsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./RewriteTailExpressionsTransformer.js", "traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js")).RewriteTailExpressionsTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js")),\n      ReturnStatement = $__3.ReturnStatement,\n      TryStatement = $__3.TryStatement;\n  var SkipFunctionsTransformerTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SkipFunctionsTransformerTrait.js", "traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js")).default;\n  var RewriteTailCallsTransformer = function($__super) {\n    function RewriteTailCallsTransformer(bodyTransformer) {\n      $traceurRuntime.superConstructor(RewriteTailCallsTransformer).call(this);\n      this.bodyTransformer_ = bodyTransformer;\n    }\n    return ($traceurRuntime.createClass)(RewriteTailCallsTransformer, {\n      transformReturnStatement: function(tree) {\n        var expression = tree.expression;\n        if (expression !== null) {\n          expression = RewriteTailExpressionsTransformer.transform(this.bodyTransformer_, expression);\n          if (expression !== tree.expression) {\n            return new ReturnStatement(tree.location, expression);\n          }\n        }\n        return tree;\n      },\n      transformTryStatement: function(tree) {\n        var block;\n        if (tree.finallyBlock !== null) {\n          block = this.transformAny(tree.finallyBlock);\n          if (block !== tree.finallyBlock) {\n            return new TryStatement(tree.location, tree.body, tree.catchBlock, block);\n          }\n        } else {\n          block = this.transformAny(tree.catchBlock);\n          if (block !== tree.catchBlock) {\n            return new TryStatement(tree.location, tree.body, block, tree.finallyBlock);\n          }\n        }\n        return tree;\n      },\n      transformForInStatement: function(tree) {\n        return tree;\n      },\n      transformForOfStatement: function(tree) {\n        return tree;\n      },\n      transformForOnStatement: function(tree) {\n        return tree;\n      },\n      transformClassDeclaration: function(tree) {\n        return tree;\n      },\n      transformClassExpression: function(tree) {\n        return tree;\n      },\n      transformExpressionStatement: function(tree) {\n        return tree;\n      },\n      transformComprehensionFor: function(tree) {\n        return tree;\n      },\n      transformVariableStatement: function(tree) {\n        return tree;\n      }\n    }, {transform: function(bodyTransformer, tree) {\n        return new RewriteTailCallsTransformer(bodyTransformer).transformAny(tree);\n      }}, $__super);\n  }(SkipFunctionsTransformerTrait(ParseTreeTransformer));\n  return {get RewriteTailCallsTransformer() {\n      return RewriteTailCallsTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js";\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js")).TempVarTransformer;\n  var RewriteTailCallsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./RewriteTailCallsTransformer.js", "traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js")).RewriteTailCallsTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js")),\n      createFunctionBody = $__3.createFunctionBody,\n      createFunctionExpression = $__3.createFunctionExpression,\n      id = $__3.createIdentifierExpression;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js")),\n      parseExpression = $__4.parseExpression,\n      parseStatement = $__4.parseStatement,\n      parseStatements = $__4.parseStatements;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js")),\n      AnonBlock = $__5.AnonBlock,\n      FunctionDeclaration = $__5.FunctionDeclaration,\n      FunctionExpression = $__5.FunctionExpression;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js")).default;\n  var ProperTailCallTransformer = function($__super) {\n    function ProperTailCallTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(ProperTailCallTransformer).call(this, identifierGenerator, reporter, options);\n      this.inBlock_ = false;\n      this.options = options;\n    }\n    return ($traceurRuntime.createClass)(ProperTailCallTransformer, {\n      transformFunctionDeclaration: function(tree) {\n        tree = $traceurRuntime.superGet(this, ProperTailCallTransformer.prototype, "transformFunctionDeclaration").call(this, tree);\n        if (tree.functionKind !== null) {\n          return tree;\n        }\n        var nameIdExpression = id(tree.name.identifierToken);\n        var initTailRecursiveFunction = this.getRuntimeExpression(\'initTailRecursiveFunction\');\n        var setupFlagExpression = parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), initTailRecursiveFunction, nameIdExpression);\n        var funcDecl = this.transformFunction_(tree, FunctionDeclaration);\n        if (funcDecl === tree) {\n          return tree;\n        }\n        var tmpVar = id(this.inBlock_ ? this.getTempIdentifier() : this.addTempVar(setupFlagExpression));\n        if (!this.inBlock_) {\n          return funcDecl;\n        }\n        return new AnonBlock(null, [funcDecl, parseStatement($traceurRuntime.getTemplateObject(["var ", " = ", ";"]), tmpVar, setupFlagExpression)]);\n      },\n      transformFunctionExpression: function(tree) {\n        tree = $traceurRuntime.superGet(this, ProperTailCallTransformer.prototype, "transformFunctionExpression").call(this, tree);\n        if (tree.functionKind) {\n          return tree;\n        }\n        var functionExpression = this.transformFunction_(tree, FunctionExpression);\n        if (functionExpression === tree) {\n          return tree;\n        }\n        var initTailRecursiveFunction = this.getRuntimeExpression(\'initTailRecursiveFunction\');\n        return parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), initTailRecursiveFunction, functionExpression);\n      },\n      transformFunction_: function(tree, constructor) {\n        var body = RewriteTailCallsTransformer.transform(this, tree.body);\n        if (body === tree.body) {\n          return tree;\n        }\n        var func = id(this.getTempIdentifier());\n        var innerFunction = createFunctionExpression(tree.parameterList, body);\n        var call = this.getRuntimeExpression(\'call\');\n        var outerBody = createFunctionBody(parseStatements($traceurRuntime.getTemplateObject(["\\n        return ", "(", ", this, arguments);"]), call, innerFunction));\n        return new constructor(tree.location, tree.name, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, outerBody);\n      },\n      transformBlock: function(tree) {\n        var inBlock = this.inBlock_;\n        this.inBlock_ = true;\n        var rv = $traceurRuntime.superGet(this, ProperTailCallTransformer.prototype, "transformBlock").call(this, tree);\n        this.inBlock_ = inBlock;\n        return rv;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get ProperTailCallTransformer() {\n      return ProperTailCallTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/PropertyNameShorthandTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/PropertyNameShorthandTransformer.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/PropertyNameShorthandTransformer.js")),\n      IdentifierExpression = $__1.IdentifierExpression,\n      LiteralPropertyName = $__1.LiteralPropertyName,\n      PropertyNameAssignment = $__1.PropertyNameAssignment;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/PropertyNameShorthandTransformer.js")).ParseTreeTransformer;\n  var PropertyNameShorthandTransformer = function($__super) {\n    function PropertyNameShorthandTransformer() {\n      $traceurRuntime.superConstructor(PropertyNameShorthandTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(PropertyNameShorthandTransformer, {transformPropertyNameShorthand: function(tree) {\n        return new PropertyNameAssignment(tree.location, new LiteralPropertyName(tree.location, tree.name), new IdentifierExpression(tree.location, tree.name));\n      }}, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get PropertyNameShorthandTransformer() {\n      return PropertyNameShorthandTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/outputgeneration/regexpuRewritePattern.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/outputgeneration/regexpuRewritePattern.js";\n  var modules = {};\n  var module = {};\n  var exports = module.exports = {};\n  var require = function(id) {\n    return modules[id];\n  };\n  ;\n  (function(root) {\n    var freeExports = typeof exports == \'object\' && exports;\n    var freeModule = typeof module == \'object\' && module && module.exports == freeExports && module;\n    var freeGlobal = typeof global == \'object\' && global;\n    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n      root = freeGlobal;\n    }\n    var ERRORS = {\n      \'rangeOrder\': \'A range\\u2019s `stop` value must be greater than or equal \' + \'to the `start` value.\',\n      \'codePointRange\': \'Invalid code point value. Code points range from \' + \'U+000000 to U+10FFFF.\'\n    };\n    var HIGH_SURROGATE_MIN = 0xD800;\n    var HIGH_SURROGATE_MAX = 0xDBFF;\n    var LOW_SURROGATE_MIN = 0xDC00;\n    var LOW_SURROGATE_MAX = 0xDFFF;\n    var regexNull = /\\\\x00([^0123456789]|$)/g;\n    var object = {};\n    var hasOwnProperty = object.hasOwnProperty;\n    var extend = function(destination, source) {\n      var key;\n      for (key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          destination[key] = source[key];\n        }\n      }\n      return destination;\n    };\n    var forEach = function(array, callback) {\n      var index = -1;\n      var length = array.length;\n      while (++index < length) {\n        callback(array[index], index);\n      }\n    };\n    var toString = object.toString;\n    var isArray = function(value) {\n      return toString.call(value) == \'[object Array]\';\n    };\n    var isNumber = function(value) {\n      return typeof value == \'number\' || toString.call(value) == \'[object Number]\';\n    };\n    var zeroes = \'0000\';\n    var pad = function(number, totalCharacters) {\n      var string = String(number);\n      return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;\n    };\n    var hex = function(number) {\n      return Number(number).toString(16).toUpperCase();\n    };\n    var slice = [].slice;\n    var dataFromCodePoints = function(codePoints) {\n      var index = -1;\n      var length = codePoints.length;\n      var max = length - 1;\n      var result = [];\n      var isStart = true;\n      var tmp;\n      var previous = 0;\n      while (++index < length) {\n        tmp = codePoints[index];\n        if (isStart) {\n          result.push(tmp);\n          previous = tmp;\n          isStart = false;\n        } else {\n          if (tmp == previous + 1) {\n            if (index != max) {\n              previous = tmp;\n              continue;\n            } else {\n              isStart = true;\n              result.push(tmp + 1);\n            }\n          } else {\n            result.push(previous + 1, tmp);\n            previous = tmp;\n          }\n        }\n      }\n      if (!isStart) {\n        result.push(tmp + 1);\n      }\n      return result;\n    };\n    var dataRemove = function(data, codePoint) {\n      var index = 0;\n      var start;\n      var end;\n      var length = data.length;\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1];\n        if (codePoint >= start && codePoint < end) {\n          if (codePoint == start) {\n            if (end == start + 1) {\n              data.splice(index, 2);\n              return data;\n            } else {\n              data[index] = codePoint + 1;\n              return data;\n            }\n          } else if (codePoint == end - 1) {\n            data[index + 1] = codePoint;\n            return data;\n          } else {\n            data.splice(index, 2, start, codePoint, codePoint + 1, end);\n            return data;\n          }\n        }\n        index += 2;\n      }\n      return data;\n    };\n    var dataRemoveRange = function(data, rangeStart, rangeEnd) {\n      if (rangeEnd < rangeStart) {\n        throw Error(ERRORS.rangeOrder);\n      }\n      var index = 0;\n      var start;\n      var end;\n      while (index < data.length) {\n        start = data[index];\n        end = data[index + 1] - 1;\n        if (start > rangeEnd) {\n          return data;\n        }\n        if (rangeStart <= start && rangeEnd >= end) {\n          data.splice(index, 2);\n          continue;\n        }\n        if (rangeStart >= start && rangeEnd < end) {\n          if (rangeStart == start) {\n            data[index] = rangeEnd + 1;\n            data[index + 1] = end + 1;\n            return data;\n          }\n          data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);\n          return data;\n        }\n        if (rangeStart >= start && rangeStart <= end) {\n          data[index + 1] = rangeStart;\n        } else if (rangeEnd >= start && rangeEnd <= end) {\n          data[index] = rangeEnd + 1;\n          return data;\n        }\n        index += 2;\n      }\n      return data;\n    };\n    var dataAdd = function(data, codePoint) {\n      var index = 0;\n      var start;\n      var end;\n      var lastIndex = null;\n      var length = data.length;\n      if (codePoint < 0x0 || codePoint > 0x10FFFF) {\n        throw RangeError(ERRORS.codePointRange);\n      }\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1];\n        if (codePoint >= start && codePoint < end) {\n          return data;\n        }\n        if (codePoint == start - 1) {\n          data[index] = codePoint;\n          return data;\n        }\n        if (start > codePoint) {\n          data.splice(lastIndex != null ? lastIndex + 2 : 0, 0, codePoint, codePoint + 1);\n          return data;\n        }\n        if (codePoint == end) {\n          if (codePoint + 1 == data[index + 2]) {\n            data.splice(index, 4, start, data[index + 3]);\n            return data;\n          }\n          data[index + 1] = codePoint + 1;\n          return data;\n        }\n        lastIndex = index;\n        index += 2;\n      }\n      data.push(codePoint, codePoint + 1);\n      return data;\n    };\n    var dataAddData = function(dataA, dataB) {\n      var index = 0;\n      var start;\n      var end;\n      var data = dataA.slice();\n      var length = dataB.length;\n      while (index < length) {\n        start = dataB[index];\n        end = dataB[index + 1] - 1;\n        if (start == end) {\n          data = dataAdd(data, start);\n        } else {\n          data = dataAddRange(data, start, end);\n        }\n        index += 2;\n      }\n      return data;\n    };\n    var dataRemoveData = function(dataA, dataB) {\n      var index = 0;\n      var start;\n      var end;\n      var data = dataA.slice();\n      var length = dataB.length;\n      while (index < length) {\n        start = dataB[index];\n        end = dataB[index + 1] - 1;\n        if (start == end) {\n          data = dataRemove(data, start);\n        } else {\n          data = dataRemoveRange(data, start, end);\n        }\n        index += 2;\n      }\n      return data;\n    };\n    var dataAddRange = function(data, rangeStart, rangeEnd) {\n      if (rangeEnd < rangeStart) {\n        throw Error(ERRORS.rangeOrder);\n      }\n      if (rangeStart < 0x0 || rangeStart > 0x10FFFF || rangeEnd < 0x0 || rangeEnd > 0x10FFFF) {\n        throw RangeError(ERRORS.codePointRange);\n      }\n      var index = 0;\n      var start;\n      var end;\n      var added = false;\n      var length = data.length;\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1];\n        if (added) {\n          if (start == rangeEnd + 1) {\n            data.splice(index - 1, 2);\n            return data;\n          }\n          if (start > rangeEnd) {\n            return data;\n          }\n          if (start >= rangeStart && start <= rangeEnd) {\n            if (end > rangeStart && end - 1 <= rangeEnd) {\n              data.splice(index, 2);\n              index -= 2;\n            } else {\n              data.splice(index - 1, 2);\n              index -= 2;\n            }\n          }\n        } else if (start == rangeEnd + 1) {\n          data[index] = rangeStart;\n          return data;\n        } else if (start > rangeEnd) {\n          data.splice(index, 0, rangeStart, rangeEnd + 1);\n          return data;\n        } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {\n          return data;\n        } else if ((rangeStart >= start && rangeStart < end) || end == rangeStart) {\n          data[index + 1] = rangeEnd + 1;\n          added = true;\n        } else if (rangeStart <= start && rangeEnd + 1 >= end) {\n          data[index] = rangeStart;\n          data[index + 1] = rangeEnd + 1;\n          added = true;\n        }\n        index += 2;\n      }\n      if (!added) {\n        data.push(rangeStart, rangeEnd + 1);\n      }\n      return data;\n    };\n    var dataContains = function(data, codePoint) {\n      var index = 0;\n      var length = data.length;\n      var start = data[index];\n      var end = data[length - 1];\n      if (length >= 2) {\n        if (codePoint < start || codePoint > end) {\n          return false;\n        }\n      }\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1];\n        if (codePoint >= start && codePoint < end) {\n          return true;\n        }\n        index += 2;\n      }\n      return false;\n    };\n    var dataIntersection = function(data, codePoints) {\n      var index = 0;\n      var length = codePoints.length;\n      var codePoint;\n      var result = [];\n      while (index < length) {\n        codePoint = codePoints[index];\n        if (dataContains(data, codePoint)) {\n          result.push(codePoint);\n        }\n        ++index;\n      }\n      return dataFromCodePoints(result);\n    };\n    var dataIsEmpty = function(data) {\n      return !data.length;\n    };\n    var dataIsSingleton = function(data) {\n      return data.length == 2 && data[0] + 1 == data[1];\n    };\n    var dataToArray = function(data) {\n      var index = 0;\n      var start;\n      var end;\n      var result = [];\n      var length = data.length;\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1];\n        while (start < end) {\n          result.push(start);\n          ++start;\n        }\n        index += 2;\n      }\n      return result;\n    };\n    var floor = Math.floor;\n    var highSurrogate = function(codePoint) {\n      return parseInt(floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN, 10);\n    };\n    var lowSurrogate = function(codePoint) {\n      return parseInt((codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN, 10);\n    };\n    var stringFromCharCode = String.fromCharCode;\n    var codePointToString = function(codePoint) {\n      var string;\n      if (codePoint == 0x09) {\n        string = \'\\\\t\';\n      } else if (codePoint == 0x0A) {\n        string = \'\\\\n\';\n      } else if (codePoint == 0x0C) {\n        string = \'\\\\f\';\n      } else if (codePoint == 0x0D) {\n        string = \'\\\\r\';\n      } else if (codePoint == 0x5C) {\n        string = \'\\\\\\\\\';\n      } else if (codePoint == 0x24 || (codePoint >= 0x28 && codePoint <= 0x2B) || codePoint == 0x2D || codePoint == 0x2E || codePoint == 0x3F || (codePoint >= 0x5B && codePoint <= 0x5E) || (codePoint >= 0x7B && codePoint <= 0x7D)) {\n        string = \'\\\\\' + stringFromCharCode(codePoint);\n      } else if (codePoint >= 0x20 && codePoint <= 0x7E) {\n        string = stringFromCharCode(codePoint);\n      } else if (codePoint <= 0xFF) {\n        string = \'\\\\x\' + pad(hex(codePoint), 2);\n      } else {\n        string = \'\\\\u\' + pad(hex(codePoint), 4);\n      }\n      return string;\n    };\n    var symbolToCodePoint = function(symbol) {\n      var length = symbol.length;\n      var first = symbol.charCodeAt(0);\n      var second;\n      if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1) {\n        second = symbol.charCodeAt(1);\n        return (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;\n      }\n      return first;\n    };\n    var createBMPCharacterClasses = function(data) {\n      var result = \'\';\n      var index = 0;\n      var start;\n      var end;\n      var length = data.length;\n      if (dataIsSingleton(data)) {\n        return codePointToString(data[0]);\n      }\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1] - 1;\n        if (start == end) {\n          result += codePointToString(start);\n        } else if (start + 1 == end) {\n          result += codePointToString(start) + codePointToString(end);\n        } else {\n          result += codePointToString(start) + \'-\' + codePointToString(end);\n        }\n        index += 2;\n      }\n      return \'[\' + result + \']\';\n    };\n    var splitAtBMP = function(data) {\n      var loneHighSurrogates = [];\n      var loneLowSurrogates = [];\n      var bmp = [];\n      var astral = [];\n      var index = 0;\n      var start;\n      var end;\n      var length = data.length;\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1] - 1;\n        if (start < HIGH_SURROGATE_MIN) {\n          if (end < HIGH_SURROGATE_MIN) {\n            bmp.push(start, end + 1);\n          }\n          if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {\n            bmp.push(start, HIGH_SURROGATE_MIN);\n            loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);\n          }\n          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n            bmp.push(start, HIGH_SURROGATE_MIN);\n            loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);\n            loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);\n          }\n          if (end > LOW_SURROGATE_MAX) {\n            bmp.push(start, HIGH_SURROGATE_MIN);\n            loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);\n            loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);\n            if (end <= 0xFFFF) {\n              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n            } else {\n              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n              astral.push(0xFFFF + 1, end + 1);\n            }\n          }\n        } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {\n          if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {\n            loneHighSurrogates.push(start, end + 1);\n          }\n          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n            loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);\n            loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);\n          }\n          if (end > LOW_SURROGATE_MAX) {\n            loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);\n            loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);\n            if (end <= 0xFFFF) {\n              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n            } else {\n              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n              astral.push(0xFFFF + 1, end + 1);\n            }\n          }\n        } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {\n          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n            loneLowSurrogates.push(start, end + 1);\n          }\n          if (end > LOW_SURROGATE_MAX) {\n            loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);\n            if (end <= 0xFFFF) {\n              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n            } else {\n              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n              astral.push(0xFFFF + 1, end + 1);\n            }\n          }\n        } else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {\n          if (end <= 0xFFFF) {\n            bmp.push(start, end + 1);\n          } else {\n            bmp.push(start, 0xFFFF + 1);\n            astral.push(0xFFFF + 1, end + 1);\n          }\n        } else {\n          astral.push(start, end + 1);\n        }\n        index += 2;\n      }\n      return {\n        \'loneHighSurrogates\': loneHighSurrogates,\n        \'loneLowSurrogates\': loneLowSurrogates,\n        \'bmp\': bmp,\n        \'astral\': astral\n      };\n    };\n    var optimizeSurrogateMappings = function(surrogateMappings) {\n      var result = [];\n      var tmpLow = [];\n      var addLow = false;\n      var mapping;\n      var nextMapping;\n      var highSurrogates;\n      var lowSurrogates;\n      var nextHighSurrogates;\n      var nextLowSurrogates;\n      var index = -1;\n      var length = surrogateMappings.length;\n      while (++index < length) {\n        mapping = surrogateMappings[index];\n        nextMapping = surrogateMappings[index + 1];\n        if (!nextMapping) {\n          result.push(mapping);\n          continue;\n        }\n        highSurrogates = mapping[0];\n        lowSurrogates = mapping[1];\n        nextHighSurrogates = nextMapping[0];\n        nextLowSurrogates = nextMapping[1];\n        tmpLow = lowSurrogates;\n        while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {\n          if (dataIsSingleton(nextLowSurrogates)) {\n            tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);\n          } else {\n            tmpLow = dataAddRange(tmpLow, nextLowSurrogates[0], nextLowSurrogates[1] - 1);\n          }\n          ++index;\n          mapping = surrogateMappings[index];\n          highSurrogates = mapping[0];\n          lowSurrogates = mapping[1];\n          nextMapping = surrogateMappings[index + 1];\n          nextHighSurrogates = nextMapping && nextMapping[0];\n          nextLowSurrogates = nextMapping && nextMapping[1];\n          addLow = true;\n        }\n        result.push([highSurrogates, addLow ? tmpLow : lowSurrogates]);\n        addLow = false;\n      }\n      return optimizeByLowSurrogates(result);\n    };\n    var optimizeByLowSurrogates = function(surrogateMappings) {\n      if (surrogateMappings.length == 1) {\n        return surrogateMappings;\n      }\n      var index = -1;\n      var innerIndex = -1;\n      while (++index < surrogateMappings.length) {\n        var mapping = surrogateMappings[index];\n        var lowSurrogates = mapping[1];\n        var lowSurrogateStart = lowSurrogates[0];\n        var lowSurrogateEnd = lowSurrogates[1];\n        innerIndex = index;\n        while (++innerIndex < surrogateMappings.length) {\n          var otherMapping = surrogateMappings[innerIndex];\n          var otherLowSurrogates = otherMapping[1];\n          var otherLowSurrogateStart = otherLowSurrogates[0];\n          var otherLowSurrogateEnd = otherLowSurrogates[1];\n          if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd) {\n            if (dataIsSingleton(otherMapping[0])) {\n              mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);\n            } else {\n              mapping[0] = dataAddRange(mapping[0], otherMapping[0][0], otherMapping[0][1] - 1);\n            }\n            surrogateMappings.splice(innerIndex, 1);\n            --innerIndex;\n          }\n        }\n      }\n      return surrogateMappings;\n    };\n    var surrogateSet = function(data) {\n      if (!data.length) {\n        return [];\n      }\n      var index = 0;\n      var start;\n      var end;\n      var startHigh;\n      var startLow;\n      var prevStartHigh = 0;\n      var prevEndHigh = 0;\n      var tmpLow = [];\n      var endHigh;\n      var endLow;\n      var surrogateMappings = [];\n      var length = data.length;\n      var dataHigh = [];\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1] - 1;\n        startHigh = highSurrogate(start);\n        startLow = lowSurrogate(start);\n        endHigh = highSurrogate(end);\n        endLow = lowSurrogate(end);\n        var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;\n        var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;\n        var complete = false;\n        if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {\n          surrogateMappings.push([[startHigh, endHigh + 1], [startLow, endLow + 1]]);\n          complete = true;\n        } else {\n          surrogateMappings.push([[startHigh, startHigh + 1], [startLow, LOW_SURROGATE_MAX + 1]]);\n        }\n        if (!complete && startHigh + 1 < endHigh) {\n          if (endsWithHighestLowSurrogate) {\n            surrogateMappings.push([[startHigh + 1, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);\n            complete = true;\n          } else {\n            surrogateMappings.push([[startHigh + 1, endHigh], [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]]);\n          }\n        }\n        if (!complete) {\n          surrogateMappings.push([[endHigh, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);\n        }\n        prevStartHigh = startHigh;\n        prevEndHigh = endHigh;\n        index += 2;\n      }\n      return optimizeSurrogateMappings(surrogateMappings);\n    };\n    var createSurrogateCharacterClasses = function(surrogateMappings) {\n      var result = [];\n      forEach(surrogateMappings, function(surrogateMapping) {\n        var highSurrogates = surrogateMapping[0];\n        var lowSurrogates = surrogateMapping[1];\n        result.push(createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates));\n      });\n      return result.join(\'|\');\n    };\n    var createCharacterClassesFromData = function(data, bmpOnly) {\n      var result = [];\n      var parts = splitAtBMP(data);\n      var loneHighSurrogates = parts.loneHighSurrogates;\n      var loneLowSurrogates = parts.loneLowSurrogates;\n      var bmp = parts.bmp;\n      var astral = parts.astral;\n      var hasAstral = !dataIsEmpty(parts.astral);\n      var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);\n      var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);\n      var surrogateMappings = surrogateSet(astral);\n      if (bmpOnly) {\n        bmp = dataAddData(bmp, loneHighSurrogates);\n        hasLoneHighSurrogates = false;\n        bmp = dataAddData(bmp, loneLowSurrogates);\n        hasLoneLowSurrogates = false;\n      }\n      if (!dataIsEmpty(bmp)) {\n        result.push(createBMPCharacterClasses(bmp));\n      }\n      if (surrogateMappings.length) {\n        result.push(createSurrogateCharacterClasses(surrogateMappings));\n      }\n      if (hasLoneHighSurrogates) {\n        result.push(createBMPCharacterClasses(loneHighSurrogates) + \'(?![\\\\uDC00-\\\\uDFFF])\');\n      }\n      if (hasLoneLowSurrogates) {\n        result.push(\'(?:[^\\\\uD800-\\\\uDBFF]|^)\' + createBMPCharacterClasses(loneLowSurrogates));\n      }\n      return result.join(\'|\');\n    };\n    var regenerate = function(value) {\n      if (arguments.length > 1) {\n        value = slice.call(arguments);\n      }\n      if (this instanceof regenerate) {\n        this.data = [];\n        return value ? this.add(value) : this;\n      }\n      return (new regenerate).add(value);\n    };\n    regenerate.version = \'1.2.0\';\n    var proto = regenerate.prototype;\n    extend(proto, {\n      \'add\': function(value) {\n        var $this = this;\n        if (value == null) {\n          return $this;\n        }\n        if (value instanceof regenerate) {\n          $this.data = dataAddData($this.data, value.data);\n          return $this;\n        }\n        if (arguments.length > 1) {\n          value = slice.call(arguments);\n        }\n        if (isArray(value)) {\n          forEach(value, function(item) {\n            $this.add(item);\n          });\n          return $this;\n        }\n        $this.data = dataAdd($this.data, isNumber(value) ? value : symbolToCodePoint(value));\n        return $this;\n      },\n      \'remove\': function(value) {\n        var $this = this;\n        if (value == null) {\n          return $this;\n        }\n        if (value instanceof regenerate) {\n          $this.data = dataRemoveData($this.data, value.data);\n          return $this;\n        }\n        if (arguments.length > 1) {\n          value = slice.call(arguments);\n        }\n        if (isArray(value)) {\n          forEach(value, function(item) {\n            $this.remove(item);\n          });\n          return $this;\n        }\n        $this.data = dataRemove($this.data, isNumber(value) ? value : symbolToCodePoint(value));\n        return $this;\n      },\n      \'addRange\': function(start, end) {\n        var $this = this;\n        $this.data = dataAddRange($this.data, isNumber(start) ? start : symbolToCodePoint(start), isNumber(end) ? end : symbolToCodePoint(end));\n        return $this;\n      },\n      \'removeRange\': function(start, end) {\n        var $this = this;\n        var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);\n        var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);\n        $this.data = dataRemoveRange($this.data, startCodePoint, endCodePoint);\n        return $this;\n      },\n      \'intersection\': function(argument) {\n        var $this = this;\n        var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;\n        $this.data = dataIntersection($this.data, array);\n        return $this;\n      },\n      \'contains\': function(codePoint) {\n        return dataContains(this.data, isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint));\n      },\n      \'clone\': function() {\n        var set = new regenerate;\n        set.data = this.data.slice(0);\n        return set;\n      },\n      \'toString\': function(options) {\n        var result = createCharacterClassesFromData(this.data, options ? options.bmpOnly : false);\n        return result.replace(regexNull, \'\\\\0$1\');\n      },\n      \'toRegExp\': function(flags) {\n        return RegExp(this.toString(), flags || \'\');\n      },\n      \'valueOf\': function() {\n        return dataToArray(this.data);\n      }\n    });\n    proto.toArray = proto.valueOf;\n    if (typeof define == \'function\' && typeof define.amd == \'object\' && define.amd) {\n      define(function() {\n        return regenerate;\n      });\n    } else if (freeExports && !freeExports.nodeType) {\n      if (freeModule) {\n        freeModule.exports = regenerate;\n      } else {\n        freeExports.regenerate = regenerate;\n      }\n    } else {\n      root.regenerate = regenerate;\n    }\n  }((void 0)));\n  modules[\'regenerate\'] = module.exports || window.regenerate;\n  ;\n  (function() {\n    \'use strict\';\n    var objectTypes = {\n      \'function\': true,\n      \'object\': true\n    };\n    var root = (objectTypes[typeof window] && window) || this;\n    var oldRoot = root;\n    var freeExports = objectTypes[typeof exports] && exports;\n    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n    var freeGlobal = freeExports && freeModule && typeof global == \'object\' && global;\n    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n      root = freeGlobal;\n    }\n    var stringFromCharCode = String.fromCharCode;\n    var floor = Math.floor;\n    function fromCodePoint() {\n      var MAX_SIZE = 0x4000;\n      var codeUnits = [];\n      var highSurrogate;\n      var lowSurrogate;\n      var index = -1;\n      var length = arguments.length;\n      if (!length) {\n        return \'\';\n      }\n      var result = \'\';\n      while (++index < length) {\n        var codePoint = Number(arguments[index]);\n        if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {\n          throw RangeError(\'Invalid code point: \' + codePoint);\n        }\n        if (codePoint <= 0xFFFF) {\n          codeUnits.push(codePoint);\n        } else {\n          codePoint -= 0x10000;\n          highSurrogate = (codePoint >> 10) + 0xD800;\n          lowSurrogate = (codePoint % 0x400) + 0xDC00;\n          codeUnits.push(highSurrogate, lowSurrogate);\n        }\n        if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n          result += stringFromCharCode.apply(null, codeUnits);\n          codeUnits.length = 0;\n        }\n      }\n      return result;\n    }\n    function assertType(type, expected) {\n      if (expected.indexOf(\'|\') == -1) {\n        if (type == expected) {\n          return;\n        }\n        throw Error(\'Invalid node type: \' + type);\n      }\n      expected = assertType.hasOwnProperty(expected) ? assertType[expected] : (assertType[expected] = RegExp(\'^(?:\' + expected + \')$\'));\n      if (expected.test(type)) {\n        return;\n      }\n      throw Error(\'Invalid node type: \' + type);\n    }\n    function generate(node) {\n      var type = node.type;\n      if (generate.hasOwnProperty(type) && typeof generate[type] == \'function\') {\n        return generate[type](node);\n      }\n      throw Error(\'Invalid node type: \' + type);\n    }\n    function generateAlternative(node) {\n      assertType(node.type, \'alternative\');\n      var terms = node.body,\n          length = terms ? terms.length : 0;\n      if (length == 1) {\n        return generateTerm(terms[0]);\n      } else {\n        var i = -1,\n            result = \'\';\n        while (++i < length) {\n          result += generateTerm(terms[i]);\n        }\n        return result;\n      }\n    }\n    function generateAnchor(node) {\n      assertType(node.type, \'anchor\');\n      switch (node.kind) {\n        case \'start\':\n          return \'^\';\n        case \'end\':\n          return \'$\';\n        case \'boundary\':\n          return \'\\\\b\';\n        case \'not-boundary\':\n          return \'\\\\B\';\n        default:\n          throw Error(\'Invalid assertion\');\n      }\n    }\n    function generateAtom(node) {\n      assertType(node.type, \'anchor|characterClass|characterClassEscape|dot|group|reference|value\');\n      return generate(node);\n    }\n    function generateCharacterClass(node) {\n      assertType(node.type, \'characterClass\');\n      var classRanges = node.body,\n          length = classRanges ? classRanges.length : 0;\n      var i = -1,\n          result = \'[\';\n      if (node.negative) {\n        result += \'^\';\n      }\n      while (++i < length) {\n        result += generateClassAtom(classRanges[i]);\n      }\n      result += \']\';\n      return result;\n    }\n    function generateCharacterClassEscape(node) {\n      assertType(node.type, \'characterClassEscape\');\n      return \'\\\\\' + node.value;\n    }\n    function generateCharacterClassRange(node) {\n      assertType(node.type, \'characterClassRange\');\n      var min = node.min,\n          max = node.max;\n      if (min.type == \'characterClassRange\' || max.type == \'characterClassRange\') {\n        throw Error(\'Invalid character class range\');\n      }\n      return generateClassAtom(min) + \'-\' + generateClassAtom(max);\n    }\n    function generateClassAtom(node) {\n      assertType(node.type, \'anchor|characterClassEscape|characterClassRange|dot|value\');\n      return generate(node);\n    }\n    function generateDisjunction(node) {\n      assertType(node.type, \'disjunction\');\n      var body = node.body,\n          length = body ? body.length : 0;\n      if (length == 0) {\n        throw Error(\'No body\');\n      } else if (length == 1) {\n        return generate(body[0]);\n      } else {\n        var i = -1,\n            result = \'\';\n        while (++i < length) {\n          if (i != 0) {\n            result += \'|\';\n          }\n          result += generate(body[i]);\n        }\n        return result;\n      }\n    }\n    function generateDot(node) {\n      assertType(node.type, \'dot\');\n      return \'.\';\n    }\n    function generateGroup(node) {\n      assertType(node.type, \'group\');\n      var result = \'(\';\n      switch (node.behavior) {\n        case \'normal\':\n          break;\n        case \'ignore\':\n          result += \'?:\';\n          break;\n        case \'lookahead\':\n          result += \'?=\';\n          break;\n        case \'negativeLookahead\':\n          result += \'?!\';\n          break;\n        default:\n          throw Error(\'Invalid behaviour: \' + node.behaviour);\n      }\n      var body = node.body,\n          length = body ? body.length : 0;\n      if (length == 1) {\n        result += generate(body[0]);\n      } else {\n        var i = -1;\n        while (++i < length) {\n          result += generate(body[i]);\n        }\n      }\n      result += \')\';\n      return result;\n    }\n    function generateQuantifier(node) {\n      assertType(node.type, \'quantifier\');\n      var quantifier = \'\',\n          min = node.min,\n          max = node.max;\n      switch (max) {\n        case undefined:\n        case null:\n          switch (min) {\n            case 0:\n              quantifier = \'*\';\n              break;\n            case 1:\n              quantifier = \'+\';\n              break;\n            default:\n              quantifier = \'{\' + min + \',}\';\n              break;\n          }\n          break;\n        default:\n          if (min == max) {\n            quantifier = \'{\' + min + \'}\';\n          } else if (min == 0 && max == 1) {\n            quantifier = \'?\';\n          } else {\n            quantifier = \'{\' + min + \',\' + max + \'}\';\n          }\n          break;\n      }\n      if (!node.greedy) {\n        quantifier += \'?\';\n      }\n      return generateAtom(node.body[0]) + quantifier;\n    }\n    function generateReference(node) {\n      assertType(node.type, \'reference\');\n      return \'\\\\\' + node.matchIndex;\n    }\n    function generateTerm(node) {\n      assertType(node.type, \'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|value\');\n      return generate(node);\n    }\n    function generateValue(node) {\n      assertType(node.type, \'value\');\n      var kind = node.kind,\n          codePoint = node.codePoint;\n      switch (kind) {\n        case \'controlLetter\':\n          return \'\\\\c\' + fromCodePoint(codePoint + 64);\n        case \'hexadecimalEscape\':\n          return \'\\\\x\' + (\'00\' + codePoint.toString(16).toUpperCase()).slice(-2);\n        case \'identifier\':\n          return \'\\\\\' + fromCodePoint(codePoint);\n        case \'null\':\n          return \'\\\\\' + codePoint;\n        case \'octal\':\n          return \'\\\\\' + codePoint.toString(8);\n        case \'singleEscape\':\n          switch (codePoint) {\n            case 0x0008:\n              return \'\\\\b\';\n            case 0x009:\n              return \'\\\\t\';\n            case 0x00A:\n              return \'\\\\n\';\n            case 0x00B:\n              return \'\\\\v\';\n            case 0x00C:\n              return \'\\\\f\';\n            case 0x00D:\n              return \'\\\\r\';\n            default:\n              throw Error(\'Invalid codepoint: \' + codePoint);\n          }\n        case \'symbol\':\n          return fromCodePoint(codePoint);\n        case \'unicodeEscape\':\n          return \'\\\\u\' + (\'0000\' + codePoint.toString(16).toUpperCase()).slice(-4);\n        case \'unicodeCodePointEscape\':\n          return \'\\\\u{\' + codePoint.toString(16).toUpperCase() + \'}\';\n        default:\n          throw Error(\'Unsupported node kind: \' + kind);\n      }\n    }\n    generate.alternative = generateAlternative;\n    generate.anchor = generateAnchor;\n    generate.characterClass = generateCharacterClass;\n    generate.characterClassEscape = generateCharacterClassEscape;\n    generate.characterClassRange = generateCharacterClassRange;\n    generate.disjunction = generateDisjunction;\n    generate.dot = generateDot;\n    generate.group = generateGroup;\n    generate.quantifier = generateQuantifier;\n    generate.reference = generateReference;\n    generate.value = generateValue;\n    if (typeof define == \'function\' && typeof define.amd == \'object\' && define.amd) {\n      define(function() {\n        return {\'generate\': generate};\n      });\n    } else if (freeExports && freeModule) {\n      freeExports.generate = generate;\n    } else {\n      root.regjsgen = {\'generate\': generate};\n    }\n  }.call((void 0)));\n  modules[\'regjsgen\'] = {generate: exports.generate || window.regjsgen};\n  (function() {\n    function parse(str, flags) {\n      function addRaw(node) {\n        node.raw = str.substring(node.range[0], node.range[1]);\n        return node;\n      }\n      function updateRawStart(node, start) {\n        node.range[0] = start;\n        return addRaw(node);\n      }\n      function createAnchor(kind, rawLength) {\n        return addRaw({\n          type: \'anchor\',\n          kind: kind,\n          range: [pos - rawLength, pos]\n        });\n      }\n      function createValue(kind, codePoint, from, to) {\n        return addRaw({\n          type: \'value\',\n          kind: kind,\n          codePoint: codePoint,\n          range: [from, to]\n        });\n      }\n      function createEscaped(kind, codePoint, value, fromOffset) {\n        fromOffset = fromOffset || 0;\n        return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);\n      }\n      function createCharacter(matches) {\n        var _char = matches[0];\n        var first = _char.charCodeAt(0);\n        if (hasUnicodeFlag) {\n          var second;\n          if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {\n            second = lookahead().charCodeAt(0);\n            if (second >= 0xDC00 && second <= 0xDFFF) {\n              pos++;\n              return createValue(\'symbol\', (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000, pos - 2, pos);\n            }\n          }\n        }\n        return createValue(\'symbol\', first, pos - 1, pos);\n      }\n      function createDisjunction(alternatives, from, to) {\n        return addRaw({\n          type: \'disjunction\',\n          body: alternatives,\n          range: [from, to]\n        });\n      }\n      function createDot() {\n        return addRaw({\n          type: \'dot\',\n          range: [pos - 1, pos]\n        });\n      }\n      function createCharacterClassEscape(value) {\n        return addRaw({\n          type: \'characterClassEscape\',\n          value: value,\n          range: [pos - 2, pos]\n        });\n      }\n      function createReference(matchIndex) {\n        return addRaw({\n          type: \'reference\',\n          matchIndex: parseInt(matchIndex, 10),\n          range: [pos - 1 - matchIndex.length, pos]\n        });\n      }\n      function createGroup(behavior, disjunction, from, to) {\n        return addRaw({\n          type: \'group\',\n          behavior: behavior,\n          body: disjunction,\n          range: [from, to]\n        });\n      }\n      function createQuantifier(min, max, from, to) {\n        if (to == null) {\n          from = pos - 1;\n          to = pos;\n        }\n        return addRaw({\n          type: \'quantifier\',\n          min: min,\n          max: max,\n          greedy: true,\n          body: null,\n          range: [from, to]\n        });\n      }\n      function createAlternative(terms, from, to) {\n        return addRaw({\n          type: \'alternative\',\n          body: terms,\n          range: [from, to]\n        });\n      }\n      function createCharacterClass(classRanges, negative, from, to) {\n        return addRaw({\n          type: \'characterClass\',\n          body: classRanges,\n          negative: negative,\n          range: [from, to]\n        });\n      }\n      function createClassRange(min, max, from, to) {\n        if (min.codePoint > max.codePoint) {\n          bail(\'invalid range in character class\', min.raw + \'-\' + max.raw, from, to);\n        }\n        return addRaw({\n          type: \'characterClassRange\',\n          min: min,\n          max: max,\n          range: [from, to]\n        });\n      }\n      function flattenBody(body) {\n        if (body.type === \'alternative\') {\n          return body.body;\n        } else {\n          return [body];\n        }\n      }\n      function isEmpty(obj) {\n        return obj.type === \'empty\';\n      }\n      function incr(amount) {\n        amount = (amount || 1);\n        var res = str.substring(pos, pos + amount);\n        pos += (amount || 1);\n        return res;\n      }\n      function skip(value) {\n        if (!match(value)) {\n          bail(\'character\', value);\n        }\n      }\n      function match(value) {\n        if (str.indexOf(value, pos) === pos) {\n          return incr(value.length);\n        }\n      }\n      function lookahead() {\n        return str[pos];\n      }\n      function current(value) {\n        return str.indexOf(value, pos) === pos;\n      }\n      function next(value) {\n        return str[pos + 1] === value;\n      }\n      function matchReg(regExp) {\n        var subStr = str.substring(pos);\n        var res = subStr.match(regExp);\n        if (res) {\n          res.range = [];\n          res.range[0] = pos;\n          incr(res[0].length);\n          res.range[1] = pos;\n        }\n        return res;\n      }\n      function parseDisjunction() {\n        var res = [],\n            from = pos;\n        res.push(parseAlternative());\n        while (match(\'|\')) {\n          res.push(parseAlternative());\n        }\n        if (res.length === 1) {\n          return res[0];\n        }\n        return createDisjunction(res, from, pos);\n      }\n      function parseAlternative() {\n        var res = [],\n            from = pos;\n        var term;\n        while (term = parseTerm()) {\n          res.push(term);\n        }\n        if (res.length === 1) {\n          return res[0];\n        }\n        return createAlternative(res, from, pos);\n      }\n      function parseTerm() {\n        if (pos >= str.length || current(\'|\') || current(\')\')) {\n          return null;\n        }\n        var anchor = parseAnchor();\n        if (anchor) {\n          return anchor;\n        }\n        var atom = parseAtom();\n        if (!atom) {\n          bail(\'Expected atom\');\n        }\n        var quantifier = parseQuantifier() || false;\n        if (quantifier) {\n          quantifier.body = flattenBody(atom);\n          updateRawStart(quantifier, atom.range[0]);\n          return quantifier;\n        }\n        return atom;\n      }\n      function parseGroup(matchA, typeA, matchB, typeB) {\n        var type = null,\n            from = pos;\n        if (match(matchA)) {\n          type = typeA;\n        } else if (match(matchB)) {\n          type = typeB;\n        } else {\n          return false;\n        }\n        var body = parseDisjunction();\n        if (!body) {\n          bail(\'Expected disjunction\');\n        }\n        skip(\')\');\n        var group = createGroup(type, flattenBody(body), from, pos);\n        if (type == \'normal\') {\n          if (firstIteration) {\n            closedCaptureCounter++;\n          }\n        }\n        return group;\n      }\n      function parseAnchor() {\n        var res,\n            from = pos;\n        if (match(\'^\')) {\n          return createAnchor(\'start\', 1);\n        } else if (match(\'$\')) {\n          return createAnchor(\'end\', 1);\n        } else if (match(\'\\\\b\')) {\n          return createAnchor(\'boundary\', 2);\n        } else if (match(\'\\\\B\')) {\n          return createAnchor(\'not-boundary\', 2);\n        } else {\n          return parseGroup(\'(?=\', \'lookahead\', \'(?!\', \'negativeLookahead\');\n        }\n      }\n      function parseQuantifier() {\n        var res,\n            from = pos;\n        var quantifier;\n        var min,\n            max;\n        if (match(\'*\')) {\n          quantifier = createQuantifier(0);\n        } else if (match(\'+\')) {\n          quantifier = createQuantifier(1);\n        } else if (match(\'?\')) {\n          quantifier = createQuantifier(0, 1);\n        } else if (res = matchReg(/^\\{([0-9]+)\\}/)) {\n          min = parseInt(res[1], 10);\n          quantifier = createQuantifier(min, min, res.range[0], res.range[1]);\n        } else if (res = matchReg(/^\\{([0-9]+),\\}/)) {\n          min = parseInt(res[1], 10);\n          quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);\n        } else if (res = matchReg(/^\\{([0-9]+),([0-9]+)\\}/)) {\n          min = parseInt(res[1], 10);\n          max = parseInt(res[2], 10);\n          if (min > max) {\n            bail(\'numbers out of order in {} quantifier\', \'\', from, pos);\n          }\n          quantifier = createQuantifier(min, max, res.range[0], res.range[1]);\n        }\n        if (quantifier) {\n          if (match(\'?\')) {\n            quantifier.greedy = false;\n            quantifier.range[1] += 1;\n          }\n        }\n        return quantifier;\n      }\n      function parseAtom() {\n        var res;\n        if (res = matchReg(/^[^^$\\\\.*+?(){[|]/)) {\n          return createCharacter(res);\n        } else if (match(\'.\')) {\n          return createDot();\n        } else if (match(\'\\\\\')) {\n          res = parseAtomEscape();\n          if (!res) {\n            bail(\'atomEscape\');\n          }\n          return res;\n        } else if (res = parseCharacterClass()) {\n          return res;\n        } else {\n          return parseGroup(\'(?:\', \'ignore\', \'(\', \'normal\');\n        }\n      }\n      function parseUnicodeSurrogatePairEscape(firstEscape) {\n        if (hasUnicodeFlag) {\n          var first,\n              second;\n          if (firstEscape.kind == \'unicodeEscape\' && (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF && current(\'\\\\\') && next(\'u\')) {\n            var prevPos = pos;\n            pos++;\n            var secondEscape = parseClassEscape();\n            if (secondEscape.kind == \'unicodeEscape\' && (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {\n              firstEscape.range[1] = secondEscape.range[1];\n              firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n              firstEscape.type = \'value\';\n              firstEscape.kind = \'unicodeCodePointEscape\';\n              addRaw(firstEscape);\n            } else {\n              pos = prevPos;\n            }\n          }\n        }\n        return firstEscape;\n      }\n      function parseClassEscape() {\n        return parseAtomEscape(true);\n      }\n      function parseAtomEscape(insideCharacterClass) {\n        var res,\n            from = pos;\n        res = parseDecimalEscape();\n        if (res) {\n          return res;\n        }\n        if (insideCharacterClass) {\n          if (match(\'b\')) {\n            return createEscaped(\'singleEscape\', 0x0008, \'\\\\b\');\n          } else if (match(\'B\')) {\n            bail(\'\\\\B not possible inside of CharacterClass\', \'\', from);\n          }\n        }\n        res = parseCharacterEscape();\n        return res;\n      }\n      function parseDecimalEscape() {\n        var res,\n            match;\n        if (res = matchReg(/^(?!0)\\d+/)) {\n          match = res[0];\n          var refIdx = parseInt(res[0], 10);\n          if (refIdx <= closedCaptureCounter) {\n            return createReference(res[0]);\n          } else {\n            backrefDenied.push(refIdx);\n            incr(-res[0].length);\n            if (res = matchReg(/^[0-7]{1,3}/)) {\n              return createEscaped(\'octal\', parseInt(res[0], 8), res[0], 1);\n            } else {\n              res = createCharacter(matchReg(/^[89]/));\n              return updateRawStart(res, res.range[0] - 1);\n            }\n          }\n        } else if (res = matchReg(/^[0-7]{1,3}/)) {\n          match = res[0];\n          if (/^0{1,3}$/.test(match)) {\n            return createEscaped(\'null\', 0x0000, \'0\', match.length + 1);\n          } else {\n            return createEscaped(\'octal\', parseInt(match, 8), match, 1);\n          }\n        } else if (res = matchReg(/^[dDsSwW]/)) {\n          return createCharacterClassEscape(res[0]);\n        }\n        return false;\n      }\n      function parseCharacterEscape() {\n        var res;\n        if (res = matchReg(/^[fnrtv]/)) {\n          var codePoint = 0;\n          switch (res[0]) {\n            case \'t\':\n              codePoint = 0x009;\n              break;\n            case \'n\':\n              codePoint = 0x00A;\n              break;\n            case \'v\':\n              codePoint = 0x00B;\n              break;\n            case \'f\':\n              codePoint = 0x00C;\n              break;\n            case \'r\':\n              codePoint = 0x00D;\n              break;\n          }\n          return createEscaped(\'singleEscape\', codePoint, \'\\\\\' + res[0]);\n        } else if (res = matchReg(/^c([a-zA-Z])/)) {\n          return createEscaped(\'controlLetter\', res[1].charCodeAt(0) % 32, res[1], 2);\n        } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {\n          return createEscaped(\'hexadecimalEscape\', parseInt(res[1], 16), res[1], 2);\n        } else if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {\n          return parseUnicodeSurrogatePairEscape(createEscaped(\'unicodeEscape\', parseInt(res[1], 16), res[1], 2));\n        } else if (hasUnicodeFlag && (res = matchReg(/^u\\{([0-9a-fA-F]+)\\}/))) {\n          return createEscaped(\'unicodeCodePointEscape\', parseInt(res[1], 16), res[1], 4);\n        } else {\n          return parseIdentityEscape();\n        }\n      }\n      function isIdentifierPart(ch) {\n        var NonAsciiIdentifierPart = new RegExp(\'[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]\');\n        return (ch === 36) || (ch === 95) || (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122) || (ch >= 48 && ch <= 57) || (ch === 92) || ((ch >= 0x80) && NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n      }\n      function parseIdentityEscape() {\n        var ZWJ = \'\\u200C\';\n        var ZWNJ = \'\\u200D\';\n        var tmp;\n        if (!isIdentifierPart(lookahead())) {\n          tmp = incr();\n          return createEscaped(\'identifier\', tmp.charCodeAt(0), tmp, 1);\n        }\n        if (match(ZWJ)) {\n          return createEscaped(\'identifier\', 0x200C, ZWJ);\n        } else if (match(ZWNJ)) {\n          return createEscaped(\'identifier\', 0x200D, ZWNJ);\n        }\n        return null;\n      }\n      function parseCharacterClass() {\n        var res,\n            from = pos;\n        if (res = matchReg(/^\\[\\^/)) {\n          res = parseClassRanges();\n          skip(\']\');\n          return createCharacterClass(res, true, from, pos);\n        } else if (match(\'[\')) {\n          res = parseClassRanges();\n          skip(\']\');\n          return createCharacterClass(res, false, from, pos);\n        }\n        return null;\n      }\n      function parseClassRanges() {\n        var res;\n        if (current(\']\')) {\n          return [];\n        } else {\n          res = parseNonemptyClassRanges();\n          if (!res) {\n            bail(\'nonEmptyClassRanges\');\n          }\n          return res;\n        }\n      }\n      function parseHelperClassRanges(atom) {\n        var from,\n            to,\n            res;\n        if (current(\'-\') && !next(\']\')) {\n          skip(\'-\');\n          res = parseClassAtom();\n          if (!res) {\n            bail(\'classAtom\');\n          }\n          to = pos;\n          var classRanges = parseClassRanges();\n          if (!classRanges) {\n            bail(\'classRanges\');\n          }\n          from = atom.range[0];\n          if (classRanges.type === \'empty\') {\n            return [createClassRange(atom, res, from, to)];\n          }\n          return [createClassRange(atom, res, from, to)].concat(classRanges);\n        }\n        res = parseNonemptyClassRangesNoDash();\n        if (!res) {\n          bail(\'nonEmptyClassRangesNoDash\');\n        }\n        return [atom].concat(res);\n      }\n      function parseNonemptyClassRanges() {\n        var atom = parseClassAtom();\n        if (!atom) {\n          bail(\'classAtom\');\n        }\n        if (current(\']\')) {\n          return [atom];\n        }\n        return parseHelperClassRanges(atom);\n      }\n      function parseNonemptyClassRangesNoDash() {\n        var res = parseClassAtom();\n        if (!res) {\n          bail(\'classAtom\');\n        }\n        if (current(\']\')) {\n          return res;\n        }\n        return parseHelperClassRanges(res);\n      }\n      function parseClassAtom() {\n        if (match(\'-\')) {\n          return createCharacter(\'-\');\n        } else {\n          return parseClassAtomNoDash();\n        }\n      }\n      function parseClassAtomNoDash() {\n        var res;\n        if (res = matchReg(/^[^\\\\\\]-]/)) {\n          return createCharacter(res[0]);\n        } else if (match(\'\\\\\')) {\n          res = parseClassEscape();\n          if (!res) {\n            bail(\'classEscape\');\n          }\n          return parseUnicodeSurrogatePairEscape(res);\n        }\n      }\n      function bail(message, details, from, to) {\n        from = from == null ? pos : from;\n        to = to == null ? from : to;\n        var contextStart = Math.max(0, from - 10);\n        var contextEnd = Math.min(to + 10, str.length);\n        var context = \'    \' + str.substring(contextStart, contextEnd);\n        var pointer = \'    \' + new Array(from - contextStart + 1).join(\' \') + \'^\';\n        throw SyntaxError(message + \' at position \' + from + (details ? \': \' + details : \'\') + \'\\n\' + context + \'\\n\' + pointer);\n      }\n      var backrefDenied = [];\n      var closedCaptureCounter = 0;\n      var firstIteration = true;\n      var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;\n      var pos = 0;\n      str = String(str);\n      if (str === \'\') {\n        str = \'(?:)\';\n      }\n      var result = parseDisjunction();\n      if (result.range[1] !== str.length) {\n        bail(\'Could not parse entire input - got stuck\', \'\', result.range[1]);\n      }\n      for (var i = 0; i < backrefDenied.length; i++) {\n        if (backrefDenied[i] <= closedCaptureCounter) {\n          pos = 0;\n          firstIteration = false;\n          return parseDisjunction();\n        }\n      }\n      return result;\n    }\n    var regjsparser = {parse: parse};\n    if (typeof module !== \'undefined\' && module.exports) {\n      module.exports = regjsparser;\n    } else {\n      window.regjsparser = regjsparser;\n    }\n  }());\n  modules[\'regjsparser\'] = module.exports || window.regjsparser;\n  modules[\'./data/iu-mappings.json\'] = ({\n    "75": 8490,\n    "83": 383,\n    "107": 8490,\n    "115": 383,\n    "181": 924,\n    "197": 8491,\n    "383": 83,\n    "452": 453,\n    "453": 452,\n    "455": 456,\n    "456": 455,\n    "458": 459,\n    "459": 458,\n    "497": 498,\n    "498": 497,\n    "837": 8126,\n    "914": 976,\n    "917": 1013,\n    "920": 1012,\n    "921": 8126,\n    "922": 1008,\n    "924": 181,\n    "928": 982,\n    "929": 1009,\n    "931": 962,\n    "934": 981,\n    "937": 8486,\n    "962": 931,\n    "976": 914,\n    "977": 1012,\n    "981": 934,\n    "982": 928,\n    "1008": 922,\n    "1009": 929,\n    "1012": [920, 977],\n    "1013": 917,\n    "7776": 7835,\n    "7835": 7776,\n    "8126": [837, 921],\n    "8486": 937,\n    "8490": 75,\n    "8491": 197,\n    "66560": 66600,\n    "66561": 66601,\n    "66562": 66602,\n    "66563": 66603,\n    "66564": 66604,\n    "66565": 66605,\n    "66566": 66606,\n    "66567": 66607,\n    "66568": 66608,\n    "66569": 66609,\n    "66570": 66610,\n    "66571": 66611,\n    "66572": 66612,\n    "66573": 66613,\n    "66574": 66614,\n    "66575": 66615,\n    "66576": 66616,\n    "66577": 66617,\n    "66578": 66618,\n    "66579": 66619,\n    "66580": 66620,\n    "66581": 66621,\n    "66582": 66622,\n    "66583": 66623,\n    "66584": 66624,\n    "66585": 66625,\n    "66586": 66626,\n    "66587": 66627,\n    "66588": 66628,\n    "66589": 66629,\n    "66590": 66630,\n    "66591": 66631,\n    "66592": 66632,\n    "66593": 66633,\n    "66594": 66634,\n    "66595": 66635,\n    "66596": 66636,\n    "66597": 66637,\n    "66598": 66638,\n    "66599": 66639,\n    "66600": 66560,\n    "66601": 66561,\n    "66602": 66562,\n    "66603": 66563,\n    "66604": 66564,\n    "66605": 66565,\n    "66606": 66566,\n    "66607": 66567,\n    "66608": 66568,\n    "66609": 66569,\n    "66610": 66570,\n    "66611": 66571,\n    "66612": 66572,\n    "66613": 66573,\n    "66614": 66574,\n    "66615": 66575,\n    "66616": 66576,\n    "66617": 66577,\n    "66618": 66578,\n    "66619": 66579,\n    "66620": 66580,\n    "66621": 66581,\n    "66622": 66582,\n    "66623": 66583,\n    "66624": 66584,\n    "66625": 66585,\n    "66626": 66586,\n    "66627": 66587,\n    "66628": 66588,\n    "66629": 66589,\n    "66630": 66590,\n    "66631": 66591,\n    "66632": 66592,\n    "66633": 66593,\n    "66634": 66594,\n    "66635": 66595,\n    "66636": 66596,\n    "66637": 66597,\n    "66638": 66598,\n    "66639": 66599,\n    "71840": 71872,\n    "71841": 71873,\n    "71842": 71874,\n    "71843": 71875,\n    "71844": 71876,\n    "71845": 71877,\n    "71846": 71878,\n    "71847": 71879,\n    "71848": 71880,\n    "71849": 71881,\n    "71850": 71882,\n    "71851": 71883,\n    "71852": 71884,\n    "71853": 71885,\n    "71854": 71886,\n    "71855": 71887,\n    "71856": 71888,\n    "71857": 71889,\n    "71858": 71890,\n    "71859": 71891,\n    "71860": 71892,\n    "71861": 71893,\n    "71862": 71894,\n    "71863": 71895,\n    "71864": 71896,\n    "71865": 71897,\n    "71866": 71898,\n    "71867": 71899,\n    "71868": 71900,\n    "71869": 71901,\n    "71870": 71902,\n    "71871": 71903,\n    "71872": 71840,\n    "71873": 71841,\n    "71874": 71842,\n    "71875": 71843,\n    "71876": 71844,\n    "71877": 71845,\n    "71878": 71846,\n    "71879": 71847,\n    "71880": 71848,\n    "71881": 71849,\n    "71882": 71850,\n    "71883": 71851,\n    "71884": 71852,\n    "71885": 71853,\n    "71886": 71854,\n    "71887": 71855,\n    "71888": 71856,\n    "71889": 71857,\n    "71890": 71858,\n    "71891": 71859,\n    "71892": 71860,\n    "71893": 71861,\n    "71894": 71862,\n    "71895": 71863,\n    "71896": 71864,\n    "71897": 71865,\n    "71898": 71866,\n    "71899": 71867,\n    "71900": 71868,\n    "71901": 71869,\n    "71902": 71870,\n    "71903": 71871\n  });\n  var regenerate = require(\'regenerate\');\n  exports.REGULAR = {\n    \'d\': regenerate().addRange(0x30, 0x39),\n    \'D\': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0xFFFF),\n    \'s\': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),\n    \'S\': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x180D).addRange(0x180F, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0xFFFF),\n    \'w\': regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),\n    \'W\': regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0xFFFF)\n  };\n  exports.UNICODE = {\n    \'d\': regenerate().addRange(0x30, 0x39),\n    \'D\': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF),\n    \'s\': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),\n    \'S\': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x180D).addRange(0x180F, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF),\n    \'w\': regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),\n    \'W\': regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)\n  };\n  exports.UNICODE_IGNORE_CASE = {\n    \'d\': regenerate().addRange(0x30, 0x39),\n    \'D\': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF),\n    \'s\': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),\n    \'S\': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x180D).addRange(0x180F, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF),\n    \'w\': regenerate(0x5F, 0x17F, 0x212A).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),\n    \'W\': regenerate(0x4B, 0x53, 0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)\n  };\n  modules[\'./data/character-class-escape-sets.js\'] = {\n    REGULAR: exports.REGULAR,\n    UNICODE: exports.UNICODE,\n    UNICODE_IGNORE_CASE: exports.UNICODE_IGNORE_CASE\n  };\n  var generate = require(\'regjsgen\').generate;\n  var parse = require(\'regjsparser\').parse;\n  var regenerate = require(\'regenerate\');\n  var iuMappings = require(\'./data/iu-mappings.json\');\n  var ESCAPE_SETS = require(\'./data/character-class-escape-sets.js\');\n  function getCharacterClassEscapeSet(character) {\n    if (unicode) {\n      if (ignoreCase) {\n        return ESCAPE_SETS.UNICODE_IGNORE_CASE[character];\n      }\n      return ESCAPE_SETS.UNICODE[character];\n    }\n    return ESCAPE_SETS.REGULAR[character];\n  }\n  var object = {};\n  var hasOwnProperty = object.hasOwnProperty;\n  function has(object, property) {\n    return hasOwnProperty.call(object, property);\n  }\n  var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n  var BMP_SET = regenerate().addRange(0x0, 0xFFFF);\n  var DOT_SET_UNICODE = UNICODE_SET.clone().remove(0x000A, 0x000D, 0x2028, 0x2029);\n  var DOT_SET = DOT_SET_UNICODE.clone().intersection(BMP_SET);\n  regenerate.prototype.iuAddRange = function(min, max) {\n    var $this = this;\n    do {\n      var folded = caseFold(min);\n      if (folded) {\n        $this.add(folded);\n      }\n    } while (++min <= max);\n    return $this;\n  };\n  function assign(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  }\n  function update(item, pattern) {\n    var tree = parse(pattern, \'\');\n    switch (tree.type) {\n      case \'characterClass\':\n      case \'group\':\n      case \'value\':\n        break;\n      default:\n        tree = wrap(tree, pattern);\n    }\n    assign(item, tree);\n  }\n  function wrap(tree, pattern) {\n    return {\n      \'type\': \'group\',\n      \'behavior\': \'ignore\',\n      \'body\': [tree],\n      \'raw\': \'(?:\' + pattern + \')\'\n    };\n  }\n  function caseFold(codePoint) {\n    return has(iuMappings, codePoint) ? iuMappings[codePoint] : false;\n  }\n  var ignoreCase = false;\n  var unicode = false;\n  function processCharacterClass(characterClassItem) {\n    var set = regenerate();\n    var body = characterClassItem.body.forEach(function(item) {\n      switch (item.type) {\n        case \'value\':\n          set.add(item.codePoint);\n          if (ignoreCase && unicode) {\n            var folded = caseFold(item.codePoint);\n            if (folded) {\n              set.add(folded);\n            }\n          }\n          break;\n        case \'characterClassRange\':\n          var min = item.min.codePoint;\n          var max = item.max.codePoint;\n          set.addRange(min, max);\n          if (ignoreCase && unicode) {\n            set.iuAddRange(min, max);\n          }\n          break;\n        case \'characterClassEscape\':\n          set.add(getCharacterClassEscapeSet(item.value));\n          break;\n        default:\n          throw Error(\'Unknown term type: \' + item.type);\n      }\n    });\n    if (characterClassItem.negative) {\n      set = (unicode ? UNICODE_SET : BMP_SET).clone().remove(set);\n    }\n    update(characterClassItem, set.toString());\n    return characterClassItem;\n  }\n  function processTerm(item) {\n    switch (item.type) {\n      case \'dot\':\n        update(item, (unicode ? DOT_SET_UNICODE : DOT_SET).toString());\n        break;\n      case \'characterClass\':\n        item = processCharacterClass(item);\n        break;\n      case \'characterClassEscape\':\n        update(item, getCharacterClassEscapeSet(item.value).toString());\n        break;\n      case \'alternative\':\n      case \'disjunction\':\n      case \'group\':\n      case \'quantifier\':\n        item.body = item.body.map(processTerm);\n        break;\n      case \'value\':\n        var codePoint = item.codePoint;\n        var set = regenerate(codePoint);\n        if (ignoreCase && unicode) {\n          var folded = caseFold(codePoint);\n          if (folded) {\n            set.add(folded);\n          }\n        }\n        update(item, set.toString());\n        break;\n      case \'anchor\':\n      case \'empty\':\n      case \'group\':\n      case \'reference\':\n        break;\n      default:\n        throw Error(\'Unknown term type: \' + item.type);\n    }\n    return item;\n  }\n  ;\n  module.exports = function(pattern, flags) {\n    var tree = parse(pattern, flags);\n    ignoreCase = flags ? flags.indexOf(\'i\') > -1 : false;\n    unicode = flags ? flags.indexOf(\'u\') > -1 : false;\n    assign(tree, processTerm(tree));\n    return generate(tree);\n  };\n  var regexpuRewritePattern = module.exports;\n  return {get regexpuRewritePattern() {\n      return regexpuRewritePattern;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js")).ParseTreeTransformer;\n  var LiteralExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js")).LiteralExpression;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/LiteralToken.js", "traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js")).LiteralToken;\n  var REGULAR_EXPRESSION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js")).REGULAR_EXPRESSION;\n  var regexpuRewritePattern = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../outputgeneration/regexpuRewritePattern.js", "traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js")).regexpuRewritePattern;\n  var RegularExpressionTransformer = function($__super) {\n    function RegularExpressionTransformer() {\n      $traceurRuntime.superConstructor(RegularExpressionTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(RegularExpressionTransformer, {transformLiteralExpression: function(tree) {\n        var token = tree.literalToken;\n        if (token.type === REGULAR_EXPRESSION) {\n          var value = token.value;\n          var lastIndex = value.lastIndexOf(\'/\');\n          var pattern = value.slice(1, lastIndex);\n          var flags = value.slice(lastIndex + 1);\n          if (flags.indexOf(\'u\') !== -1) {\n            var result = \'/\' + regexpuRewritePattern(pattern, flags) + \'/\' + flags.replace(\'u\', \'\');\n            return new LiteralExpression(tree.location, new LiteralToken(REGULAR_EXPRESSION, result, token.location));\n          }\n        }\n        return tree;\n      }}, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get RegularExpressionTransformer() {\n      return RegularExpressionTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/RestParameterTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/RestParameterTransformer.js";\n  var FormalParameterList = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/RestParameterTransformer.js")).FormalParameterList;\n  var ParameterTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParameterTransformer.js", "traceur@0.0.111/src/codegeneration/RestParameterTransformer.js")).ParameterTransformer;\n  var createIdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/RestParameterTransformer.js")).createIdentifierToken;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/RestParameterTransformer.js")).parseStatement;\n  function hasRestParameter(parameterList) {\n    var parameters = parameterList.parameters;\n    return parameters.length > 0 && parameters[parameters.length - 1].isRestParameter();\n  }\n  function getRestParameterLiteralToken(parameterList) {\n    var parameters = parameterList.parameters;\n    return parameters[parameters.length - 1].parameter.identifier.identifierToken;\n  }\n  var RestParameterTransformer = function($__super) {\n    function RestParameterTransformer() {\n      $traceurRuntime.superConstructor(RestParameterTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(RestParameterTransformer, {transformFormalParameterList: function(tree) {\n        var transformed = $traceurRuntime.superGet(this, RestParameterTransformer.prototype, "transformFormalParameterList").call(this, tree);\n        if (hasRestParameter(transformed)) {\n          var parametersWithoutRestParam = new FormalParameterList(transformed.location, transformed.parameters.slice(0, -1));\n          var startIndex = transformed.parameters.length - 1;\n          var i = createIdentifierToken(this.getTempIdentifier());\n          var name = getRestParameterLiteralToken(transformed);\n          var loop;\n          if (startIndex) {\n            loop = parseStatement($traceurRuntime.getTemplateObject(["\\n            for (var ", " = [], ", " = ", ";\\n                 ", " < arguments.length; ", "++)\\n              ", "[", " - ", "] = arguments[", "];"]), name, i, startIndex, i, i, name, i, startIndex, i);\n          } else {\n            loop = parseStatement($traceurRuntime.getTemplateObject(["\\n            for (var ", " = [], ", " = 0;\\n                 ", " < arguments.length; ", "++)\\n              ", "[", "] = arguments[", "];"]), name, i, i, i, name, i, i);\n          }\n          this.parameterStatements.push(loop);\n          return parametersWithoutRestParam;\n        }\n        return transformed;\n      }}, {}, $__super);\n  }(ParameterTransformer);\n  return {get RestParameterTransformer() {\n      return RestParameterTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/SpreadTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/SpreadTransformer.js";\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/PredefinedName.js", "traceur@0.0.111/src/codegeneration/SpreadTransformer.js")),\n      APPLY = $__3.APPLY,\n      BIND = $__3.BIND,\n      FUNCTION = $__3.FUNCTION,\n      PROTOTYPE = $__3.PROTOTYPE;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/SpreadTransformer.js")),\n      MEMBER_EXPRESSION = $__4.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__4.MEMBER_LOOKUP_EXPRESSION,\n      SPREAD_EXPRESSION = $__4.SPREAD_EXPRESSION;\n  var Script = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/SpreadTransformer.js")).Script;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/SpreadTransformer.js")).TempVarTransformer;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/SpreadTransformer.js")).default;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/SpreadTransformer.js")),\n      createArgumentList = $__8.createArgumentList,\n      createArrayLiteral = $__8.createArrayLiteral,\n      createAssignmentExpression = $__8.createAssignmentExpression,\n      createCallExpression = $__8.createCallExpression,\n      createEmptyArgumentList = $__8.createEmptyArgumentList,\n      createIdentifierExpression = $__8.createIdentifierExpression,\n      createMemberExpression = $__8.createMemberExpression,\n      createMemberLookupExpression = $__8.createMemberLookupExpression,\n      createNewExpression = $__8.createNewExpression,\n      createNullLiteral = $__8.createNullLiteral,\n      createParenExpression = $__8.createParenExpression,\n      createVoid0 = $__8.createVoid0;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/SpreadTransformer.js")),\n      parseExpression = $__9.parseExpression,\n      parseStatement = $__9.parseStatement;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PrependStatements.js", "traceur@0.0.111/src/codegeneration/SpreadTransformer.js")).prependStatements;\n  function hasSpreadMember(trees) {\n    return trees.some(function(tree) {\n      return tree && tree.type === SPREAD_EXPRESSION;\n    });\n  }\n  var SpreadTransformer = function($__super) {\n    function SpreadTransformer() {\n      $traceurRuntime.superConstructor(SpreadTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(SpreadTransformer, {\n      createArrayFromElements_: function(elements) {\n        var length = elements.length;\n        var args = [];\n        var lastArray;\n        for (var i = 0; i < length; i++) {\n          if (elements[i] && elements[i].type === SPREAD_EXPRESSION) {\n            if (lastArray) {\n              args.push(createArrayLiteral(lastArray));\n              lastArray = null;\n            }\n            args.push(this.transformAny(elements[i].expression));\n          } else {\n            if (!lastArray)\n              lastArray = [];\n            lastArray.push(this.transformAny(elements[i]));\n          }\n        }\n        if (lastArray)\n          args.push(createArrayLiteral(lastArray));\n        var spread = this.getRuntimeExpression(\'spread\');\n        return parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), spread, createArgumentList(args));\n      },\n      desugarCallSpread_: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var functionObject,\n            contextObject;\n        this.pushTempScope();\n        if (operand.type === MEMBER_EXPRESSION) {\n          var tempIdent = createIdentifierExpression(this.addTempVar());\n          var parenExpression = createParenExpression(createAssignmentExpression(tempIdent, operand.operand));\n          var memberName = operand.memberName;\n          contextObject = tempIdent;\n          functionObject = createMemberExpression(parenExpression, memberName);\n        } else if (tree.operand.type === MEMBER_LOOKUP_EXPRESSION) {\n          var tempIdent$__1 = createIdentifierExpression(this.addTempVar());\n          var parenExpression$__2 = createParenExpression(createAssignmentExpression(tempIdent$__1, operand.operand));\n          var memberExpression = this.transformAny(operand.memberExpression);\n          contextObject = tempIdent$__1;\n          functionObject = createMemberLookupExpression(parenExpression$__2, memberExpression);\n        } else {\n          contextObject = createVoid0();\n          functionObject = operand;\n        }\n        this.popTempScope();\n        var arrayExpression = this.createArrayFromElements_(tree.args.args);\n        return createCallExpression(createMemberExpression(functionObject, APPLY), createArgumentList([contextObject, arrayExpression]));\n      },\n      desugarNewSpread_: function(tree) {\n        var arrayExpression = $traceurRuntime.spread([createNullLiteral()], tree.args.args);\n        arrayExpression = this.createArrayFromElements_(arrayExpression);\n        return createNewExpression(createParenExpression(createCallExpression(createMemberExpression(FUNCTION, PROTOTYPE, BIND, APPLY), createArgumentList([this.transformAny(tree.operand), arrayExpression]))), createEmptyArgumentList());\n      },\n      transformArrayLiteral: function(tree) {\n        if (hasSpreadMember(tree.elements)) {\n          return this.createArrayFromElements_(tree.elements);\n        }\n        return $traceurRuntime.superGet(this, SpreadTransformer.prototype, "transformArrayLiteral").call(this, tree);\n      },\n      transformCallExpression: function(tree) {\n        if (hasSpreadMember(tree.args.args)) {\n          return this.desugarCallSpread_(tree);\n        }\n        return $traceurRuntime.superGet(this, SpreadTransformer.prototype, "transformCallExpression").call(this, tree);\n      },\n      transformNewExpression: function(tree) {\n        if (tree.args !== null && hasSpreadMember(tree.args.args)) {\n          return this.desugarNewSpread_(tree);\n        }\n        return $traceurRuntime.superGet(this, SpreadTransformer.prototype, "transformNewExpression").call(this, tree);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get SpreadTransformer() {\n      return SpreadTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/SuperTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/SuperTransformer.js";\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/SuperTransformer.js")).default;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TempVarTransformer.js", "traceur@0.0.111/src/codegeneration/SuperTransformer.js")).TempVarTransformer;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/SuperTransformer.js")),\n      ArgumentList = $__7.ArgumentList,\n      ClassDeclaration = $__7.ClassDeclaration,\n      ClassExpression = $__7.ClassExpression,\n      GetAccessor = $__7.GetAccessor,\n      MemberExpression = $__7.MemberExpression,\n      Method = $__7.Method,\n      SetAccessor = $__7.SetAccessor;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/SuperTransformer.js")),\n      MEMBER_EXPRESSION = $__8.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__8.MEMBER_LOOKUP_EXPRESSION,\n      SUPER_EXPRESSION = $__8.SUPER_EXPRESSION;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/SuperTransformer.js")),\n      EQUAL = $__9.EQUAL,\n      MINUS_MINUS = $__9.MINUS_MINUS,\n      PLUS_PLUS = $__9.PLUS_PLUS;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/SuperTransformer.js")),\n      createAssignmentExpression = $__10.createAssignmentExpression,\n      createBindingIdentifier = $__10.createBindingIdentifier,\n      createIdentifierExpression = $__10.createIdentifierExpression,\n      createIdentifierToken = $__10.createIdentifierToken,\n      createParenExpression = $__10.createParenExpression,\n      createStringLiteral = $__10.createStringLiteral,\n      createThisExpression = $__10.createThisExpression;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/SuperTransformer.js")).parseExpression;\n  var ExplodeExpressionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ExplodeExpressionTransformer.js", "traceur@0.0.111/src/codegeneration/SuperTransformer.js")).ExplodeExpressionTransformer;\n  function hasSuperMemberExpression(tree) {\n    return (tree.type === MEMBER_EXPRESSION || tree.type === MEMBER_LOOKUP_EXPRESSION) && tree.operand.type === SUPER_EXPRESSION;\n  }\n  var State = function() {\n    function State(transformer, home) {\n      this.transformer = transformer;\n      this.home_ = home;\n      this.tempName = home ? null : transformer.getTempIdentifier();\n      this.hasSuper = false;\n    }\n    return ($traceurRuntime.createClass)(State, {get home() {\n        this.hasSuper = true;\n        if (this.home_ === null) {\n          this.home_ = createIdentifierExpression(createIdentifierToken(this.tempName));\n        }\n        return this.home_;\n      }}, {});\n  }();\n  var ClassState = function($__super) {\n    function ClassState(transformer, tree) {\n      var home = null;\n      if (tree.name !== null) {\n        home = createIdentifierExpression(tree.name.identifierToken);\n      }\n      $traceurRuntime.superConstructor(ClassState).call(this, transformer, home);\n      this.name_ = tree.name;\n    }\n    return ($traceurRuntime.createClass)(ClassState, {get name() {\n        if (this.name_ !== null)\n          return this.name_;\n        if (this.hasSuper) {\n          return createBindingIdentifier(this.home.identifierToken);\n        }\n        return null;\n      }}, {}, $__super);\n  }(State);\n  var PrototypeState = function($__super) {\n    function PrototypeState(transformer, classState) {\n      $traceurRuntime.superConstructor(PrototypeState).call(this, transformer, null);\n      this.classState = classState;\n    }\n    return ($traceurRuntime.createClass)(PrototypeState, {get home() {\n        var ident = this.classState.home;\n        return new MemberExpression(null, ident, createIdentifierToken(\'prototype\'));\n      }}, {}, $__super);\n  }(State);\n  var SuperTransformer = function($__super) {\n    function SuperTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(SuperTransformer).call(this, identifierGenerator, reporter, options);\n      this.stateStack_ = [];\n    }\n    return ($traceurRuntime.createClass)(SuperTransformer, {\n      pushState: function(state) {\n        this.stateStack_.push(state);\n      },\n      popState: function() {\n        return this.stateStack_.pop();\n      },\n      peekState: function() {\n        return this.stateStack_[this.stateStack_.length - 1];\n      },\n      transformObjectLiteral: function(tree) {\n        var state = new State(this, null);\n        this.pushState(state);\n        this.pushState(state);\n        var result = $traceurRuntime.superGet(this, SuperTransformer.prototype, "transformObjectLiteral").call(this, tree);\n        this.popState();\n        this.popState();\n        if (state.hasSuper) {\n          this.registerTempVarName(state.tempName);\n          return createAssignmentExpression(state.home, result);\n        }\n        this.releaseTempName(state.tempName);\n        return result;\n      },\n      transformClassExpression: function(tree) {\n        var superClass = this.transformAny(tree.superClass);\n        var annotations = this.transformList(tree.annotations);\n        var classState = new ClassState(this, tree);\n        var prototypeState = new PrototypeState(this, classState);\n        this.pushState(classState);\n        this.pushState(prototypeState);\n        var elements = this.transformList(tree.elements);\n        this.popState();\n        this.popState();\n        if (tree.name === null && tree.superClass !== null) {\n          classState.home;\n        } else if (tree.superClass === superClass && tree.elements === elements && tree.annotations === annotations) {\n          return tree;\n        }\n        return new ClassExpression(tree.location, classState.name, superClass, elements, tree.annotations, tree.typeParameters);\n      },\n      transformClassDeclaration: function(tree) {\n        var superClass = this.transformAny(tree.superClass);\n        var annotations = this.transformList(tree.annotations);\n        var classState = new ClassState(this, tree);\n        var prototypeState = new PrototypeState(this, classState);\n        this.pushState(classState);\n        this.pushState(prototypeState);\n        var elements = this.transformList(tree.elements);\n        this.popState();\n        this.popState();\n        if (tree.superClass === superClass && tree.elements === elements && tree.annotations === annotations) {\n          return tree;\n        }\n        return new ClassDeclaration(tree.location, tree.name, superClass, elements, tree.annotations, tree.typeParameters);\n      },\n      transformMethod: function(tree) {\n        var name = this.transformAny(tree.name);\n        var prototypeState;\n        if (tree.isStatic) {\n          prototypeState = this.popState();\n        }\n        var parameterList = this.transformAny(tree.parameterList);\n        var body = this.transformAny(tree.body);\n        if (tree.isStatic) {\n          this.pushState(prototypeState);\n        }\n        if (tree.name === name && tree.parameterList === parameterList && tree.body === body) {\n          return tree;\n        }\n        return new Method(tree.location, tree.isStatic, tree.functionKind, name, parameterList, tree.typeAnnotation, tree.annotations, body, tree.debugName);\n      },\n      transformGetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var prototypeState;\n        if (tree.isStatic) {\n          prototypeState = this.popState();\n        }\n        var body = this.transformAny(tree.body);\n        if (tree.isStatic) {\n          this.pushState(prototypeState);\n        }\n        if (tree.name === name && tree.body === body) {\n          return tree;\n        }\n        return new GetAccessor(tree.location, tree.isStatic, name, tree.typeAnnotation, tree.annotations, body);\n      },\n      transformSetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var prototypeState;\n        if (tree.isStatic) {\n          prototypeState = this.popState();\n        }\n        var parameterList = this.transformAny(tree.parameterList);\n        var body = this.transformAny(tree.body);\n        if (tree.isStatic) {\n          this.pushState(prototypeState);\n        }\n        if (tree.name === name && tree.parameterList === parameterList && tree.body === body) {\n          return tree;\n        }\n        return new SetAccessor(tree.location, tree.isStatic, name, parameterList, tree.annotations, body);\n      },\n      transformComputedPropertyName: function(tree) {\n        var s1 = this.popState();\n        var s2 = this.popState();\n        var result = $traceurRuntime.superGet(this, SuperTransformer.prototype, "transformComputedPropertyName").call(this, tree);\n        this.pushState(s2);\n        this.pushState(s1);\n        return result;\n      },\n      transformSuperExpression: function(tree) {\n        throw new Error(\'unreachable\');\n      },\n      transformMemberShared_: function(name) {\n        var home = this.peekState().home;\n        var superGet = this.getRuntimeExpression(\'superGet\');\n        return parseExpression($traceurRuntime.getTemplateObject(["", "(this, ", ", ", ")"]), superGet, home, name);\n      },\n      transformMemberExpression: function(tree) {\n        if (tree.operand.type === SUPER_EXPRESSION) {\n          return this.transformMemberShared_(tree.memberName.value);\n        }\n        return $traceurRuntime.superGet(this, SuperTransformer.prototype, "transformMemberExpression").call(this, tree);\n      },\n      transformMemberLookupExpression: function(tree) {\n        if (tree.operand.type === SUPER_EXPRESSION)\n          return this.transformMemberShared_(tree.memberExpression);\n        return $traceurRuntime.superGet(this, SuperTransformer.prototype, "transformMemberLookupExpression").call(this, tree);\n      },\n      transformCallExpression: function(tree) {\n        var operand,\n            args;\n        if (tree.operand.type === SUPER_EXPRESSION) {\n          args = this.transformAny(tree.args);\n          args = new ArgumentList(tree.location, $traceurRuntime.spread([createThisExpression()], args.args));\n          var home = this.stateStack_[this.stateStack_.length - 2].home;\n          var superConstructor = this.getRuntimeExpression(\'superConstructor\');\n          operand = parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), superConstructor, home);\n        } else if (hasSuperMemberExpression(tree.operand)) {\n          operand = this.transformAny(tree.operand);\n          args = this.transformAny(tree.args);\n          args = new ArgumentList(args.location, $traceurRuntime.spread([createThisExpression()], args.args));\n        } else {\n          return $traceurRuntime.superGet(this, SuperTransformer.prototype, "transformCallExpression").call(this, tree);\n        }\n        return parseExpression($traceurRuntime.getTemplateObject(["", ".call(", ")"]), operand, args);\n      },\n      transformBinaryExpression: function(tree) {\n        if (tree.operator.isAssignmentOperator() && hasSuperMemberExpression(tree.left)) {\n          if (tree.operator.type !== EQUAL) {\n            var exploded = new ExplodeExpressionTransformer(this).transformAny(tree);\n            return this.transformAny(createParenExpression(exploded));\n          }\n          var name = tree.left.type === MEMBER_LOOKUP_EXPRESSION ? tree.left.memberExpression : createStringLiteral(tree.left.memberName.value);\n          var right = this.transformAny(tree.right);\n          var home = this.peekState().home;\n          var superSet = this.getRuntimeExpression(\'superSet\');\n          return parseExpression($traceurRuntime.getTemplateObject(["", "(this, ", ", ", ", ", ")"]), superSet, home, name, right);\n        }\n        return $traceurRuntime.superGet(this, SuperTransformer.prototype, "transformBinaryExpression").call(this, tree);\n      },\n      transformUnaryExpression: function(tree) {\n        var transformed = this.transformIncrementDecrement_(tree);\n        if (transformed)\n          return transformed;\n        return $traceurRuntime.superGet(this, SuperTransformer.prototype, "transformUnaryExpression").call(this, tree);\n      },\n      transformPostfixExpression: function(tree) {\n        var transformed = this.transformIncrementDecrement_(tree);\n        if (transformed)\n          return transformed;\n        return $traceurRuntime.superGet(this, SuperTransformer.prototype, "transformPostfixExpression").call(this, tree);\n      },\n      transformIncrementDecrement_: function(tree) {\n        var operator = tree.operator;\n        var operand = tree.operand;\n        if ((operator.type === PLUS_PLUS || operator.type === MINUS_MINUS) && hasSuperMemberExpression(operand)) {\n          var exploded = new ExplodeExpressionTransformer(this).transformAny(tree);\n          if (exploded !== tree)\n            exploded = createParenExpression(exploded);\n          return this.transformAny(exploded);\n        }\n        return null;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get SuperTransformer() {\n      return SuperTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/SymbolTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/SymbolTransformer.js";\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/SymbolTransformer.js")),\n      BinaryExpression = $__3.BinaryExpression,\n      UnaryExpression = $__3.UnaryExpression;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/SymbolTransformer.js")),\n      IDENTIFIER_EXPRESSION = $__4.IDENTIFIER_EXPRESSION,\n      LITERAL_EXPRESSION = $__4.LITERAL_EXPRESSION,\n      UNARY_EXPRESSION = $__4.UNARY_EXPRESSION;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/SymbolTransformer.js")).ParseTreeTransformer;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/SymbolTransformer.js")).default;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/SymbolTransformer.js")),\n      EQUAL_EQUAL = $__7.EQUAL_EQUAL,\n      EQUAL_EQUAL_EQUAL = $__7.EQUAL_EQUAL_EQUAL,\n      NOT_EQUAL = $__7.NOT_EQUAL,\n      NOT_EQUAL_EQUAL = $__7.NOT_EQUAL_EQUAL,\n      TYPEOF = $__7.TYPEOF;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/SymbolTransformer.js")).parseExpression;\n  function isEqualityExpression(tree) {\n    switch (tree.operator.type) {\n      case EQUAL_EQUAL:\n      case EQUAL_EQUAL_EQUAL:\n      case NOT_EQUAL:\n      case NOT_EQUAL_EQUAL:\n        return true;\n    }\n    return false;\n  }\n  function isTypeof(tree) {\n    return tree.type === UNARY_EXPRESSION && tree.operator.type === TYPEOF;\n  }\n  function isSafeTypeofString(tree) {\n    if (tree.type !== LITERAL_EXPRESSION)\n      return false;\n    var value = tree.literalToken.processedValue;\n    switch (value) {\n      case \'symbol\':\n      case \'object\':\n        return false;\n    }\n    return true;\n  }\n  var SymbolTransformer = function($__super) {\n    function SymbolTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(SymbolTransformer).call(this);\n      this.identifierGenerator = identifierGenerator;\n      this.reporter = reporter;\n      this.options = options;\n    }\n    return ($traceurRuntime.createClass)(SymbolTransformer, {\n      transformTypeofOperand_: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        return new UnaryExpression(tree.location, tree.operator, operand);\n      },\n      transformBinaryExpression: function(tree) {\n        if (isEqualityExpression(tree)) {\n          if (isTypeof(tree.left) && isSafeTypeofString(tree.right)) {\n            var left = this.transformTypeofOperand_(tree.left);\n            var right = tree.right;\n            return new BinaryExpression(tree.location, left, tree.operator, right);\n          }\n          if (isTypeof(tree.right) && isSafeTypeofString(tree.left)) {\n            var left$__1 = tree.left;\n            var right$__2 = this.transformTypeofOperand_(tree.right);\n            return new BinaryExpression(tree.location, left$__1, tree.operator, right$__2);\n          }\n        }\n        return $traceurRuntime.superGet(this, SymbolTransformer.prototype, "transformBinaryExpression").call(this, tree);\n      },\n      transformUnaryExpression: function(tree) {\n        if (tree.operator.type !== TYPEOF)\n          return $traceurRuntime.superGet(this, SymbolTransformer.prototype, "transformUnaryExpression").call(this, tree);\n        var operand = this.transformAny(tree.operand);\n        var expression = this.getRuntimeTypeof(operand);\n        if (operand.type === IDENTIFIER_EXPRESSION) {\n          return parseExpression($traceurRuntime.getTemplateObject(["(typeof ", " === \'undefined\' ?\\n          \'undefined\' : ", ")"]), operand, expression);\n        }\n        return expression;\n      },\n      getRuntimeTypeof: function(operand) {\n        var typeOf = this.getRuntimeExpression(\'typeof\');\n        return parseExpression($traceurRuntime.getTemplateObject(["", "(", ")"]), typeOf, operand);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(ParseTreeTransformer));\n  return {get SymbolTransformer() {\n      return SymbolTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js";\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js")),\n      BINARY_EXPRESSION = $__3.BINARY_EXPRESSION,\n      COMMA_EXPRESSION = $__3.COMMA_EXPRESSION,\n      CONDITIONAL_EXPRESSION = $__3.CONDITIONAL_EXPRESSION,\n      TEMPLATE_LITERAL_PORTION = $__3.TEMPLATE_LITERAL_PORTION,\n      TEMPLATE_LITERAL_EXPRESSION = $__3.TEMPLATE_LITERAL_EXPRESSION;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js")),\n      LiteralExpression = $__4.LiteralExpression,\n      NewExpression = $__4.NewExpression;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/LiteralToken.js", "traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js")).LiteralToken;\n  var ParenTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParenTrait.js", "traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js")).ParenTrait;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js")).ParseTreeTransformer;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ImportRuntimeTrait.js", "traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js")).default;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js")),\n      PERCENT = $__9.PERCENT,\n      PLUS = $__9.PLUS,\n      SLASH = $__9.SLASH,\n      STAR = $__9.STAR,\n      STRING = $__9.STRING;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js")),\n      createArgumentList = $__10.createArgumentList,\n      createArrayLiteral = $__10.createArrayLiteral,\n      createBinaryExpression = $__10.createBinaryExpression,\n      createCallExpression = $__10.createCallExpression,\n      createMemberExpression = $__10.createMemberExpression,\n      createOperatorToken = $__10.createOperatorToken,\n      createParenExpression = $__10.createParenExpression;\n  function createStringLiteralExpression(loc, str) {\n    return new LiteralExpression(loc, new LiteralToken(STRING, str, loc));\n  }\n  function createGetTemplateObject(elements, getTemplateObject) {\n    var cooked = [];\n    var raw = [];\n    var same = true;\n    for (var i = 0; i < elements.length; i += 2) {\n      var loc = elements[i].location;\n      var str = elements[i].value.value;\n      var cookedStr = toCookedString(str);\n      var rawStr = toRawString(str);\n      var cookedLiteral$__1 = createStringLiteralExpression(loc, cookedStr);\n      cooked.push(cookedLiteral$__1);\n      if (cookedStr !== rawStr) {\n        same = false;\n        var rawLiteral = createStringLiteralExpression(loc, rawStr);\n        raw.push(rawLiteral);\n      } else {\n        raw.push(cookedLiteral$__1);\n      }\n    }\n    maybeAddEmptyStringAtEnd(elements, cooked);\n    var cookedLiteral = createArrayLiteral(cooked);\n    var args = [cookedLiteral];\n    if (!same) {\n      maybeAddEmptyStringAtEnd(elements, raw);\n      var rawLiteral$__2 = createArrayLiteral(raw);\n      args.unshift(rawLiteral$__2);\n    }\n    return createCallExpression(getTemplateObject, createArgumentList(args));\n  }\n  function maybeAddEmptyStringAtEnd(elements, items) {\n    var length = elements.length;\n    if (!length || elements[length - 1].type !== TEMPLATE_LITERAL_PORTION) {\n      items.push(createStringLiteralExpression(null, \'""\'));\n    }\n  }\n  function toRawString(str) {\n    str = str.replace(/\\r\\n?/g, \'\\n\');\n    str = JSON.stringify(str);\n    return str.replace(/\\u2028|\\u2029/g, function(c) {\n      switch (c) {\n        case \'\\u2028\':\n          return \'\\\\u2028\';\n        case \'\\u2029\':\n          return \'\\\\u2029\';\n        default:\n          throw Error(\'Not reachable\');\n      }\n    });\n  }\n  function toCookedString(s) {\n    var sb = [\'"\'];\n    var i = 0,\n        k = 1,\n        c,\n        c2;\n    while (i < s.length) {\n      c = s[i++];\n      switch (c) {\n        case \'\\\\\':\n          c2 = s[i++];\n          switch (c2) {\n            case \'\\n\':\n            case \'\\u2028\':\n            case \'\\u2029\':\n              break;\n            case \'\\r\':\n              if (s[i + 1] === \'\\n\') {\n                i++;\n              }\n              break;\n            default:\n              sb[k++] = c;\n              sb[k++] = c2;\n          }\n          break;\n        case \'"\':\n          sb[k++] = \'\\\\"\';\n          break;\n        case \'\\n\':\n          sb[k++] = \'\\\\n\';\n          break;\n        case \'\\r\':\n          if (s[i] === \'\\n\')\n            i++;\n          sb[k++] = \'\\\\n\';\n          break;\n        case \'\\t\':\n          sb[k++] = \'\\\\t\';\n          break;\n        case \'\\f\':\n          sb[k++] = \'\\\\f\';\n          break;\n        case \'\\b\':\n          sb[k++] = \'\\\\b\';\n          break;\n        case \'\\u2028\':\n          sb[k++] = \'\\\\u2028\';\n          break;\n        case \'\\u2029\':\n          sb[k++] = \'\\\\u2029\';\n          break;\n        default:\n          sb[k++] = c;\n      }\n    }\n    sb[k++] = \'"\';\n    return sb.join(\'\');\n  }\n  var TemplateLiteralTransformer = function($__super) {\n    function TemplateLiteralTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(TemplateLiteralTransformer).call(this);\n      this.options = options;\n    }\n    return ($traceurRuntime.createClass)(TemplateLiteralTransformer, {\n      transformTemplateLiteralExpression: function(tree) {\n        if (!tree.operand) {\n          return this.createDefaultTemplateLiteral(tree);\n        }\n        var operand = this.transformAny(tree.operand);\n        var elements = tree.elements;\n        var getTemplateObject = this.getRuntimeExpression(\'getTemplateObject\');\n        var args = [createGetTemplateObject(tree.elements, getTemplateObject)];\n        for (var i = 1; i < elements.length; i += 2) {\n          args.push(this.transformAny(elements[i]));\n        }\n        return createCallExpression(operand, createArgumentList(args));\n      },\n      transformTemplateSubstitution: function(tree) {\n        var transformedTree = this.transformAny(tree.expression);\n        switch (transformedTree.type) {\n          case BINARY_EXPRESSION:\n            switch (transformedTree.operator.type) {\n              case STAR:\n              case PERCENT:\n              case SLASH:\n                return transformedTree;\n            }\n            return createParenExpression(transformedTree);\n          case COMMA_EXPRESSION:\n          case CONDITIONAL_EXPRESSION:\n            return createParenExpression(transformedTree);\n        }\n        return transformedTree;\n      },\n      transformTemplateLiteralPortion: function(tree) {\n        var str = toCookedString(tree.value.value);\n        return createStringLiteralExpression(tree.location, str);\n      },\n      createDefaultTemplateLiteral: function(tree) {\n        var elements = tree.elements;\n        var length = elements.length;\n        if (length === 0) {\n          return createStringLiteralExpression(tree.location, \'""\');\n        }\n        var firstNonEmpty = elements[0].value.value === \'\';\n        var binaryExpression = this.transformAny(elements[0]);\n        if (length === 1)\n          return binaryExpression;\n        var plusToken = createOperatorToken(PLUS);\n        for (var i = 1; i < length; i++) {\n          var element = elements[i];\n          if (element.type === TEMPLATE_LITERAL_PORTION) {\n            if (element.value.value === \'\') {\n              continue;\n            }\n            if (firstNonEmpty && i === 2) {\n              binaryExpression = binaryExpression.right;\n            }\n          }\n          var transformedTree = this.transformAny(elements[i]);\n          binaryExpression = createBinaryExpression(binaryExpression, plusToken, transformedTree);\n        }\n        return new createParenExpression(binaryExpression);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(ParenTrait(ParseTreeTransformer)));\n  return {get TemplateLiteralTransformer() {\n      return TemplateLiteralTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/TypeToExpressionTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/TypeToExpressionTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/TypeToExpressionTransformer.js")).ParseTreeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/TypeToExpressionTransformer.js")),\n      ArgumentList = $__2.ArgumentList,\n      IdentifierExpression = $__2.IdentifierExpression,\n      MemberExpression = $__2.MemberExpression;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/TypeToExpressionTransformer.js")).parseExpression;\n  var TypeToExpressionTransformer = function($__super) {\n    function TypeToExpressionTransformer() {\n      $traceurRuntime.superConstructor(TypeToExpressionTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(TypeToExpressionTransformer, {\n      transformTypeName: function(tree) {\n        if (tree.moduleName) {\n          var operand = this.transformAny(tree.moduleName);\n          return new MemberExpression(tree.location, operand, tree.name);\n        }\n        return new IdentifierExpression(tree.location, tree.name);\n      },\n      transformPredefinedType: function(tree) {\n        return parseExpression($traceurRuntime.getTemplateObject(["$traceurRuntime.type.", ")"]), tree.typeToken);\n      },\n      transformTypeReference: function(tree) {\n        var typeName = this.transformAny(tree.typeName);\n        var args = this.transformAny(tree.args);\n        var argumentList = new ArgumentList(tree.location, $traceurRuntime.spread([typeName], args));\n        return parseExpression($traceurRuntime.getTemplateObject(["$traceurRuntime.genericType(", ")"]), argumentList);\n      },\n      transformTypeArguments: function(tree) {\n        return this.transformList(tree.args);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get TypeToExpressionTransformer() {\n      return TypeToExpressionTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/TypeTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/TypeTransformer.js";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/TypeTransformer.js")),\n      AnonBlock = $__1.AnonBlock,\n      FormalParameter = $__1.FormalParameter,\n      FunctionDeclaration = $__1.FunctionDeclaration,\n      FunctionExpression = $__1.FunctionExpression,\n      GetAccessor = $__1.GetAccessor,\n      Method = $__1.Method,\n      VariableDeclaration = $__1.VariableDeclaration;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/TypeTransformer.js")),\n      IMPORT_TYPE_CLAUSE = $__2.IMPORT_TYPE_CLAUSE,\n      TYPE_ALIAS_DECLARATION = $__2.TYPE_ALIAS_DECLARATION;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/TypeTransformer.js")).ParseTreeTransformer;\n  var TypeTransformer = function($__super) {\n    function TypeTransformer() {\n      $traceurRuntime.superConstructor(TypeTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(TypeTransformer, {\n      transformVariableDeclaration: function(tree) {\n        if (tree.typeAnnotation) {\n          tree = new VariableDeclaration(tree.location, tree.lvalue, null, tree.initializer);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, "transformVariableDeclaration").call(this, tree);\n      },\n      transformFormalParameter: function(tree) {\n        if (tree.typeAnnotation !== null)\n          return new FormalParameter(tree.location, tree.parameter, null, []);\n        return tree;\n      },\n      transformFunctionDeclaration: function(tree) {\n        if (tree.typeAnnotation) {\n          tree = new FunctionDeclaration(tree.location, tree.name, tree.functionKind, tree.parameterList, null, tree.annotations, tree.body);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, "transformFunctionDeclaration").call(this, tree);\n      },\n      transformFunctionExpression: function(tree) {\n        if (tree.typeAnnotation) {\n          tree = new FunctionExpression(tree.location, tree.name, tree.functionKind, tree.parameterList, null, tree.annotations, tree.body);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, "transformFunctionExpression").call(this, tree);\n      },\n      transformMethod: function(tree) {\n        if (tree.typeAnnotation) {\n          tree = new Method(tree.location, tree.isStatic, tree.functionKind, tree.name, tree.parameterList, null, tree.annotations, tree.body, tree.debugName);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, "transformMethod").call(this, tree);\n      },\n      transformGetAccessor: function(tree) {\n        if (tree.typeAnnotation) {\n          tree = new GetAccessor(tree.location, tree.isStatic, tree.name, null, tree.annotations, tree.body);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, "transformGetAccessor").call(this, tree);\n      },\n      transformInterfaceDeclaration: function(tree) {\n        return new AnonBlock(null, []);\n      },\n      transformExportDeclaration: function(tree) {\n        if (tree.declaration.type === TYPE_ALIAS_DECLARATION) {\n          return new AnonBlock(null, []);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, "transformExportDeclaration").call(this, tree);\n      },\n      transformTypeAliasDeclaration: function(tree) {\n        return new AnonBlock(null, []);\n      },\n      transformImportDeclaration: function(tree) {\n        if (!tree.importClause || tree.importClause.type === IMPORT_TYPE_CLAUSE) {\n          return new AnonBlock(null, []);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, "transformImportDeclaration").call(this, tree);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get TypeTransformer() {\n      return TypeTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js")).ParseTreeTransformer;\n  var LiteralExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js")).LiteralExpression;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/LiteralToken.js", "traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js")).LiteralToken;\n  var STRING = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js")).STRING;\n  var re = /(\\\\*)\\\\u{([0-9a-fA-F]+)}/g;\n  function zeroPad(value) {\n    return \'0000\'.slice(value.length) + value;\n  }\n  function needsTransform(token) {\n    return token.type === STRING && re.test(token.value);\n  }\n  function transformToken(token) {\n    return token.value.replace(re, function(match, backslashes, hexDigits) {\n      var backslashIsEscaped = backslashes.length % 2 === 1;\n      if (backslashIsEscaped) {\n        return match;\n      }\n      var codePoint = parseInt(hexDigits, 16);\n      var value;\n      if (codePoint <= 0xFFFF) {\n        value = \'\\\\u\' + zeroPad(codePoint.toString(16).toUpperCase());\n      } else {\n        var high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;\n        var low = (codePoint - 0x10000) % 0x400 + 0xDC00;\n        value = \'\\\\u\' + high.toString(16).toUpperCase() + \'\\\\u\' + low.toString(16).toUpperCase();\n      }\n      return backslashes + value;\n    });\n  }\n  var UnicodeEscapeSequenceTransformer = function($__super) {\n    function UnicodeEscapeSequenceTransformer() {\n      $traceurRuntime.superConstructor(UnicodeEscapeSequenceTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(UnicodeEscapeSequenceTransformer, {transformLiteralExpression: function(tree) {\n        var token = tree.literalToken;\n        if (needsTransform(token)) {\n          var value = transformToken(token);\n          return new LiteralExpression(tree.location, new LiteralToken(STRING, value, token.location));\n        }\n        return tree;\n      }}, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get UnicodeEscapeSequenceTransformer() {\n      return UnicodeEscapeSequenceTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/UniqueIdentifierGenerator.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/UniqueIdentifierGenerator.js";\n  var UniqueIdentifierGenerator = function() {\n    function UniqueIdentifierGenerator() {\n      this.identifierIndex = 0;\n    }\n    return ($traceurRuntime.createClass)(UniqueIdentifierGenerator, {generateUniqueIdentifier: function() {\n        return ("$__" + this.identifierIndex++);\n      }}, {});\n  }();\n  return {get UniqueIdentifierGenerator() {\n      return UniqueIdentifierGenerator;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/ConstChecker.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/ConstChecker.js";\n  var IDENTIFIER_EXPRESSION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/semantics/ConstChecker.js")).IDENTIFIER_EXPRESSION;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/semantics/ConstChecker.js")),\n      CONST = $__3.CONST,\n      MINUS_MINUS = $__3.MINUS_MINUS,\n      PLUS_PLUS = $__3.PLUS_PLUS;\n  var ScopeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ScopeVisitor.js", "traceur@0.0.111/src/semantics/ConstChecker.js")).ScopeVisitor;\n  var ScopeChainBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ScopeChainBuilder.js", "traceur@0.0.111/src/semantics/ConstChecker.js")).ScopeChainBuilder;\n  var ConstChecker = function($__super) {\n    function ConstChecker(scopeBuilder, reporter) {\n      $traceurRuntime.superConstructor(ConstChecker).call(this);\n      this.scopeBuilder_ = scopeBuilder;\n      this.reporter_ = reporter;\n    }\n    return ($traceurRuntime.createClass)(ConstChecker, {\n      pushScope: function(tree) {\n        return this.scope = this.scopeBuilder_.getScopeForTree(tree);\n      },\n      visitUnaryExpression: function(tree) {\n        if (tree.operand.type === IDENTIFIER_EXPRESSION && (tree.operator.type === PLUS_PLUS || tree.operator.type === MINUS_MINUS)) {\n          this.validateMutation_(tree.operand);\n        }\n        $traceurRuntime.superGet(this, ConstChecker.prototype, "visitUnaryExpression").call(this, tree);\n      },\n      visitPostfixExpression: function(tree) {\n        if (tree.operand.type === IDENTIFIER_EXPRESSION) {\n          this.validateMutation_(tree.operand);\n        }\n        $traceurRuntime.superGet(this, ConstChecker.prototype, "visitPostfixExpression").call(this, tree);\n      },\n      visitBinaryExpression: function(tree) {\n        if (tree.left.type === IDENTIFIER_EXPRESSION && tree.operator.isAssignmentOperator()) {\n          this.validateMutation_(tree.left);\n        }\n        $traceurRuntime.superGet(this, ConstChecker.prototype, "visitBinaryExpression").call(this, tree);\n      },\n      validateMutation_: function(identifierExpression) {\n        if (this.inWithBlock) {\n          return;\n        }\n        var binding = this.scope.getBinding(identifierExpression);\n        if (binding === null) {\n          return;\n        }\n        var $__1 = binding,\n            type = $__1.type,\n            tree = $__1.tree;\n        if (type === CONST) {\n          this.reportError_(identifierExpression.location, (tree.getStringValue() + " is read-only"));\n        }\n      },\n      reportError_: function(location, message) {\n        this.reporter_.reportError(location, message);\n      }\n    }, {}, $__super);\n  }(ScopeVisitor);\n  function validate(tree, reporter) {\n    var builder = new ScopeChainBuilder(reporter);\n    builder.visitAny(tree);\n    var checker = new ConstChecker(builder, reporter);\n    checker.visitAny(tree);\n  }\n  return {\n    get ConstChecker() {\n      return ConstChecker;\n    },\n    get validate() {\n      return validate;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/semantics/FreeVariableChecker.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/semantics/FreeVariableChecker.js";\n  var ScopeChainBuilderWithReferences = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ScopeChainBuilderWithReferences.js", "traceur@0.0.111/src/semantics/FreeVariableChecker.js")).ScopeChainBuilderWithReferences;\n  var FreeVariableChecker = function($__super) {\n    function FreeVariableChecker(reporter, global) {\n      $traceurRuntime.superConstructor(FreeVariableChecker).call(this, reporter);\n      this.global_ = global;\n    }\n    return ($traceurRuntime.createClass)(FreeVariableChecker, {referenceFound: function(tree, name) {\n        if (this.scope.getBinding(tree))\n          return;\n        if (!(name in this.global_)) {\n          this.reporter.reportError(tree.location, (name + " is not defined"));\n        }\n      }}, {}, $__super);\n  }(ScopeChainBuilderWithReferences);\n  function validate(tree, reporter) {\n    var global = arguments[2] !== (void 0) ? arguments[2] : Reflect.global;\n    var checker = new FreeVariableChecker(reporter, global);\n    checker.visitAny(tree);\n  }\n  return {get validate() {\n      return validate;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js";\n  var AmdTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AmdTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).AmdTransformer;\n  var AnnotationsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AnnotationsTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).AnnotationsTransformer;\n  var ArrayComprehensionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ArrayComprehensionTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).ArrayComprehensionTransformer;\n  var ArrowFunctionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ArrowFunctionTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).ArrowFunctionTransformer;\n  var AsyncGeneratorTransformPass = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AsyncGeneratorTransformPass.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).AsyncGeneratorTransformPass;\n  var AsyncToGeneratorTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AsyncToGeneratorTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).AsyncToGeneratorTransformer;\n  var BlockBindingTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./BlockBindingTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).BlockBindingTransformer;\n  var ClassTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ClassTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).ClassTransformer;\n  var ClosureModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ClosureModuleTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).ClosureModuleTransformer;\n  var CommonJsModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./CommonJsModuleTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).CommonJsModuleTransformer;\n  var DefaultParametersTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./DefaultParametersTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).DefaultParametersTransformer;\n  var DestructuringTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./DestructuringTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).DestructuringTransformer;\n  var ExponentiationTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ExponentiationTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).ExponentiationTransformer;\n  var ForOfTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ForOfTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).ForOfTransformer;\n  var ForOnTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ForOnTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).ForOnTransformer;\n  var GeneratorComprehensionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./GeneratorComprehensionTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).GeneratorComprehensionTransformer;\n  var GeneratorTransformPass = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./GeneratorTransformPass.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).GeneratorTransformPass;\n  var InlineModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./InlineModuleTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).InlineModuleTransformer;\n  var InstantiateModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./InstantiateModuleTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).InstantiateModuleTransformer;\n  var JsxTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./JsxTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).JsxTransformer;\n  var MemberVariableTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MemberVariableTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).MemberVariableTransformer;\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModuleTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).ModuleTransformer;\n  var MultiTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MultiTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).MultiTransformer;\n  var NumericLiteralTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./NumericLiteralTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).NumericLiteralTransformer;\n  var ObjectLiteralTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ObjectLiteralTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).ObjectLiteralTransformer;\n  var ProperTailCallTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ProperTailCallTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).ProperTailCallTransformer;\n  var PropertyNameShorthandTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PropertyNameShorthandTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).PropertyNameShorthandTransformer;\n  var RegularExpressionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./RegularExpressionTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).RegularExpressionTransformer;\n  var RestParameterTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./RestParameterTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).RestParameterTransformer;\n  var SpreadPropertiesTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SpreadPropertiesTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).SpreadPropertiesTransformer;\n  var SpreadTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SpreadTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).SpreadTransformer;\n  var SuperTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SuperTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).SuperTransformer;\n  var SymbolTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SymbolTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).SymbolTransformer;\n  var TemplateLiteralTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TemplateLiteralTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).TemplateLiteralTransformer;\n  var TypeToExpressionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TypeToExpressionTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).TypeToExpressionTransformer;\n  var TypeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TypeTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).TypeTransformer;\n  var UnicodeEscapeSequenceTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./UnicodeEscapeSequenceTransformer.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).UnicodeEscapeSequenceTransformer;\n  var UniqueIdentifierGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./UniqueIdentifierGenerator.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).UniqueIdentifierGenerator;\n  var validateConst = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../semantics/ConstChecker.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).validate;\n  var validateFreeVariables = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../semantics/FreeVariableChecker.js", "traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js")).validate;\n  var FromOptionsTransformer = function($__super) {\n    function FromOptionsTransformer(reporter, options) {\n      var $__1;\n      $traceurRuntime.superConstructor(FromOptionsTransformer).call(this, reporter, options.validate);\n      var transformOptions = options.transformOptions;\n      var idGenerator = new UniqueIdentifierGenerator();\n      var append = ($__1 = this, function(transformer) {\n        $__1.append(function(tree) {\n          return new transformer(idGenerator, reporter, options).transformAny(tree);\n        });\n      });\n      if (transformOptions.blockBinding) {\n        this.append(function(tree) {\n          validateConst(tree, reporter);\n          return tree;\n        });\n      }\n      if (options.freeVariableChecker) {\n        this.append(function(tree) {\n          validateFreeVariables(tree, reporter);\n          return tree;\n        });\n      }\n      if (transformOptions.exponentiation)\n        append(ExponentiationTransformer);\n      if (transformOptions.numericLiterals)\n        append(NumericLiteralTransformer);\n      if (transformOptions.unicodeExpressions)\n        append(RegularExpressionTransformer);\n      if (transformOptions.jsx) {\n        append(JsxTransformer);\n      }\n      if (transformOptions.templateLiterals)\n        append(TemplateLiteralTransformer);\n      if (transformOptions.types && transformOptions.annotations) {\n        append(TypeToExpressionTransformer);\n      }\n      if (transformOptions.unicodeEscapeSequences)\n        append(UnicodeEscapeSequenceTransformer);\n      if (transformOptions.annotations)\n        append(AnnotationsTransformer);\n      if (transformOptions.propertyNameShorthand)\n        append(PropertyNameShorthandTransformer);\n      if (transformOptions.memberVariables) {\n        append(MemberVariableTransformer);\n      }\n      if (transformOptions.classes) {\n        append(SuperTransformer);\n      }\n      if (transformOptions.arrowFunctions) {\n        append(ArrowFunctionTransformer);\n      }\n      if (transformOptions.classes) {\n        append(ClassTransformer);\n      }\n      if (transformOptions.spreadProperties) {\n        append(SpreadPropertiesTransformer);\n      }\n      if (transformOptions.propertyMethods || transformOptions.computedPropertyNames || transformOptions.properTailCalls) {\n        append(ObjectLiteralTransformer);\n      }\n      if (transformOptions.generatorComprehension)\n        append(GeneratorComprehensionTransformer);\n      if (transformOptions.arrayComprehension)\n        append(ArrayComprehensionTransformer);\n      if (transformOptions.forOf)\n        append(ForOfTransformer);\n      if (transformOptions.asyncGenerators) {\n        append(AsyncGeneratorTransformPass);\n      }\n      if (transformOptions.forOn)\n        append(ForOnTransformer);\n      if (transformOptions.restParameters)\n        append(RestParameterTransformer);\n      if (transformOptions.defaultParameters)\n        append(DefaultParametersTransformer);\n      if (transformOptions.destructuring)\n        append(DestructuringTransformer);\n      if (transformOptions.types)\n        append(TypeTransformer);\n      if (transformOptions.spread)\n        append(SpreadTransformer);\n      if (transformOptions.blockBinding) {\n        this.append(function(tree) {\n          var transformer = new BlockBindingTransformer(idGenerator, reporter, tree);\n          return transformer.transformAny(tree);\n        });\n      }\n      if (transformOptions.asyncFunctions && options.generators === \'parse\') {\n        append(AsyncToGeneratorTransformer);\n      } else if (transformOptions.generators || transformOptions.asyncFunctions) {\n        append(GeneratorTransformPass);\n      }\n      if (transformOptions.symbols)\n        append(SymbolTransformer);\n      if (transformOptions.properTailCalls) {\n        append(ProperTailCallTransformer);\n      }\n      if (transformOptions.modules) {\n        switch (transformOptions.modules) {\n          case \'commonjs\':\n            append(CommonJsModuleTransformer);\n            break;\n          case \'amd\':\n            append(AmdTransformer);\n            break;\n          case \'closure\':\n            append(ClosureModuleTransformer);\n            break;\n          case \'inline\':\n            append(InlineModuleTransformer);\n            break;\n          case \'instantiate\':\n            append(InstantiateModuleTransformer);\n            break;\n          case \'bootstrap\':\n            append(ModuleTransformer);\n            break;\n          case \'parse\':\n            break;\n          default:\n            throw new Error(\'Invalid modules transform option\');\n        }\n      }\n    }\n    return ($traceurRuntime.createClass)(FromOptionsTransformer, {}, {}, $__super);\n  }(MultiTransformer);\n  return {get FromOptionsTransformer() {\n      return FromOptionsTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/TokenType.js", "traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js")),\n      CONST = $__2.CONST,\n      LET = $__2.LET;\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModuleTransformer.js", "traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js")).ModuleTransformer;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeFactory.js", "traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js")),\n      createAssignmentStatement = $__4.createAssignmentStatement,\n      createArgumentList = $__4.createArgumentList,\n      createBindingIdentifier = $__4.createBindingIdentifier,\n      createCallExpression = $__4.createCallExpression,\n      createExpressionStatement = $__4.createExpressionStatement,\n      createForInStatement = $__4.createForInStatement,\n      createFunctionBody = $__4.createFunctionBody,\n      createIfStatement = $__4.createIfStatement,\n      createImmediatelyInvokedFunctionExpression = $__4.createImmediatelyInvokedFunctionExpression,\n      createIdentifierExpression = $__4.createIdentifierExpression,\n      createMemberLookupExpression = $__4.createMemberLookupExpression,\n      createMemberExpression = $__4.createMemberExpression,\n      createObjectLiteral = $__4.createObjectLiteral,\n      createReturnStatement = $__4.createReturnStatement,\n      createUseStrictDirective = $__4.createUseStrictDirective,\n      createVariableDeclarationList = $__4.createVariableDeclarationList,\n      createVariableStatement = $__4.createVariableStatement;\n  var IMPORT_SPECIFIER_SET = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTreeType.js", "traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js")).IMPORT_SPECIFIER_SET;\n  var AnonBlock = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js")).AnonBlock;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js")).parseStatement;\n  var anonInlineModules = 0;\n  var InlineES6ModuleTransformer = function($__super) {\n    function InlineES6ModuleTransformer(identifierGenerator, reporter, options, metadata) {\n      $traceurRuntime.superConstructor(InlineES6ModuleTransformer).call(this, identifierGenerator, reporter, options);\n      this.metadata_ = metadata;\n    }\n    return ($traceurRuntime.createClass)(InlineES6ModuleTransformer, {\n      moduleProlog: function() {\n        return [createUseStrictDirective()];\n      },\n      wrapModule: function(statements) {\n        var seed = this.moduleName || \'anon_\' + ++anonInlineModules;\n        var idName = this.getTempVarNameForModuleName(seed);\n        if (this.isRootModule) {\n          statements.pop();\n          return statements;\n        }\n        var body = createFunctionBody(statements);\n        var moduleExpression = createImmediatelyInvokedFunctionExpression(body);\n        return [createVariableStatement(CONST, idName, moduleExpression)];\n      },\n      transformExportDeclaration: function(tree) {\n        if (this.isRootModule)\n          return tree;\n        this.exportVisitor.visitAny(tree);\n        return this.transformAny(tree.declaration);\n      },\n      transformImportDeclaration: function(tree) {\n        if (!tree.importClause || (tree.importClause.type === IMPORT_SPECIFIER_SET && tree.importClause.specifiers.length === 0)) {\n          return createExpressionStatement(this.transformAny(tree.moduleSpecifier));\n        }\n        var binding = this.transformAny(tree.importClause);\n        var initializer = this.transformAny(tree.moduleSpecifier);\n        return createVariableStatement(CONST, binding, initializer);\n      },\n      transformNamedExport: function(tree) {\n        return new AnonBlock(null, []);\n      },\n      addExportStatement: function(statements) {\n        var $__1 = this;\n        var exportProperties = this.getExportProperties();\n        var exportObject = createObjectLiteral(exportProperties);\n        if (this.exportVisitor.starExports.length) {\n          var starExports = this.exportVisitor.starExports;\n          var starIdents = starExports.map(function(moduleSpecifier) {\n            return createIdentifierExpression($__1.getTempVarNameForModuleSpecifier(moduleSpecifier));\n          });\n          if (exportProperties.length)\n            starIdents.push(exportObject);\n          var exports = this.getTempIdentifier();\n          statements.push(createVariableStatement(LET, exports, createObjectLiteral("")));\n          var key = this.getTempIdentifier();\n          starIdents.forEach(function(starIdent) {\n            statements.push(createForInStatement(createVariableDeclarationList(LET, key, null), starIdent, createIfStatement(createCallExpression(createMemberExpression(starIdent, \'hasOwnProperty\'), createArgumentList([createIdentifierExpression(key)])), createAssignmentStatement(createMemberLookupExpression(createIdentifierExpression(exports), createIdentifierExpression(key)), createMemberLookupExpression(starIdent, createIdentifierExpression(key))))));\n          });\n          statements.push(createReturnStatement(createIdentifierExpression(exports)));\n          return statements;\n        }\n        statements.push(parseStatement($traceurRuntime.getTemplateObject(["return ", ""]), exportObject));\n        return statements;\n      },\n      transformModuleSpecifier: function(tree) {\n        return createBindingIdentifier(this.getTempVarNameForModuleSpecifier(tree));\n      },\n      get isRootModule() {\n        return this.moduleName === (this.metadata_ && this.metadata_.rootModule);\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  return {get InlineES6ModuleTransformer() {\n      return InlineES6ModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/PureES6Transformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/PureES6Transformer.js";\n  var AnnotationsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AnnotationsTransformer.js", "traceur@0.0.111/src/codegeneration/PureES6Transformer.js")).AnnotationsTransformer;\n  var AsyncToGeneratorTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./AsyncToGeneratorTransformer.js", "traceur@0.0.111/src/codegeneration/PureES6Transformer.js")).AsyncToGeneratorTransformer;\n  var InlineES6ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./InlineES6ModuleTransformer.js", "traceur@0.0.111/src/codegeneration/PureES6Transformer.js")).InlineES6ModuleTransformer;\n  var JsxTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./JsxTransformer.js", "traceur@0.0.111/src/codegeneration/PureES6Transformer.js")).JsxTransformer;\n  var MemberVariableTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MemberVariableTransformer.js", "traceur@0.0.111/src/codegeneration/PureES6Transformer.js")).MemberVariableTransformer;\n  var MultiTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./MultiTransformer.js", "traceur@0.0.111/src/codegeneration/PureES6Transformer.js")).MultiTransformer;\n  var SpreadPropertiesTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./SpreadPropertiesTransformer.js", "traceur@0.0.111/src/codegeneration/PureES6Transformer.js")).SpreadPropertiesTransformer;\n  var TypeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TypeTransformer.js", "traceur@0.0.111/src/codegeneration/PureES6Transformer.js")).TypeTransformer;\n  var UniqueIdentifierGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./UniqueIdentifierGenerator.js", "traceur@0.0.111/src/codegeneration/PureES6Transformer.js")).UniqueIdentifierGenerator;\n  var validateFreeVariables = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../semantics/FreeVariableChecker.js", "traceur@0.0.111/src/codegeneration/PureES6Transformer.js")).validate;\n  var PureES6Transformer = function($__super) {\n    function PureES6Transformer(reporter, options, metadata) {\n      var $__1;\n      $traceurRuntime.superConstructor(PureES6Transformer).call(this, reporter, options.validate);\n      var idGenerator = new UniqueIdentifierGenerator();\n      var append = ($__1 = this, function(transformer) {\n        $__1.append(function(tree) {\n          return new transformer(idGenerator, reporter, options, metadata).transformAny(tree);\n        });\n      });\n      if (options.freeVariableChecker) {\n        this.append(function(tree) {\n          validateFreeVariables(tree, reporter);\n          return tree;\n        });\n      }\n      if (options.jsx) {\n        append(JsxTransformer);\n      }\n      if (options.spreadProperties) {\n        append(SpreadPropertiesTransformer);\n      }\n      if (options.memberVariables) {\n        append(MemberVariableTransformer);\n      }\n      append(AnnotationsTransformer);\n      append(TypeTransformer);\n      append(AsyncToGeneratorTransformer);\n      if (options.modules === \'inline\') {\n        append(InlineES6ModuleTransformer);\n      }\n    }\n    return ($traceurRuntime.createClass)(PureES6Transformer, {}, {}, $__super);\n  }(MultiTransformer);\n  return {get PureES6Transformer() {\n      return PureES6Transformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/Compiler.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/Compiler.js";\n  var AttachModuleNameTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./codegeneration/module/AttachModuleNameTransformer.js", "traceur@0.0.111/src/Compiler.js")).AttachModuleNameTransformer;\n  var FromOptionsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./codegeneration/FromOptionsTransformer.js", "traceur@0.0.111/src/Compiler.js")).FromOptionsTransformer;\n  var Parser = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./syntax/Parser.js", "traceur@0.0.111/src/Compiler.js")).Parser;\n  var PureES6Transformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./codegeneration/PureES6Transformer.js", "traceur@0.0.111/src/Compiler.js")).PureES6Transformer;\n  var SourceFile = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./syntax/SourceFile.js", "traceur@0.0.111/src/Compiler.js")).SourceFile;\n  var CollectingErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./util/CollectingErrorReporter.js", "traceur@0.0.111/src/Compiler.js")).CollectingErrorReporter;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Options.js", "traceur@0.0.111/src/Compiler.js")),\n      Options = $__10.Options,\n      versionLockedOptions = $__10.versionLockedOptions;\n  var ParseTreeMapWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./outputgeneration/ParseTreeMapWriter.js", "traceur@0.0.111/src/Compiler.js")).ParseTreeMapWriter;\n  var ParseTreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./outputgeneration/ParseTreeWriter.js", "traceur@0.0.111/src/Compiler.js")).ParseTreeWriter;\n  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./outputgeneration/SourceMapIntegration.js", "traceur@0.0.111/src/Compiler.js")),\n      SourceMapConsumer = $__13.SourceMapConsumer,\n      SourceMapGenerator = $__13.SourceMapGenerator;\n  function merge() {\n    for (var srcs = [],\n        $__2 = 0; $__2 < arguments.length; $__2++)\n      srcs[$__2] = arguments[$__2];\n    var dest = Object.create(null);\n    srcs.forEach(function(src) {\n      Object.keys(src).forEach(function(key) {\n        dest[key] = src[key];\n      });\n      var srcModules = src.modules;\n      if (typeof srcModules !== \'undefined\') {\n        dest.modules = srcModules;\n      }\n    });\n    return dest;\n  }\n  function basePath(name) {\n    if (!name)\n      return null;\n    var lastSlash = name.lastIndexOf(\'/\');\n    if (lastSlash < 0)\n      return null;\n    return name.substring(0, lastSlash + 1);\n  }\n  var Compiler = function() {\n    function Compiler() {\n      var overridingOptions = arguments[0] !== (void 0) ? arguments[0] : {};\n      this.options_ = new Options(this.defaultOptions());\n      this.options_.setFromObject(overridingOptions);\n      this.sourceMapConfiguration_ = null;\n      this.sourceMapInfo_ = null;\n      this.sourceMapCache_ = null;\n    }\n    return ($traceurRuntime.createClass)(Compiler, {\n      compile: function(content) {\n        var sourceName = arguments[1] !== (void 0) ? arguments[1] : \'<compileSource>\';\n        var outputName = arguments[2] !== (void 0) ? arguments[2] : \'<compileOutput>\';\n        var sourceRoot = arguments[3];\n        sourceName = this.normalize(sourceName);\n        outputName = this.normalize(outputName);\n        var tree = this.parse(content, sourceName);\n        tree = this.transform(tree, sourceName);\n        var sourceURL = sourceName !== outputName ? sourceName : undefined;\n        if (sourceRoot === undefined)\n          sourceRoot = this.options_.sourceRoot;\n        return this.write(tree, outputName, sourceRoot, sourceURL);\n      },\n      throwIfErrors: function(errorReporter) {\n        if (errorReporter.hadError())\n          throw errorReporter.toError();\n      },\n      parse: function(content) {\n        var sourceName = arguments[1] !== (void 0) ? arguments[1] : \'<compiler-parse-input>\';\n        sourceName = this.normalize(sourceName);\n        this.sourceMapCache_ = null;\n        this.sourceMapConfiguration_ = null;\n        var errorReporter = new CollectingErrorReporter();\n        var sourceFile = new SourceFile(sourceName, content);\n        var parser = new Parser(sourceFile, errorReporter, this.options_);\n        var tree = this.options_.script ? parser.parseScript() : parser.parseModule();\n        this.throwIfErrors(errorReporter);\n        return tree;\n      },\n      transform: function(tree) {\n        var candidateModuleName = arguments[1];\n        var metadata = arguments[2];\n        var transformer;\n        if (candidateModuleName) {\n          var transformer$__3 = new AttachModuleNameTransformer(candidateModuleName);\n          tree = transformer$__3.transformAny(tree);\n        }\n        var errorReporter = new CollectingErrorReporter();\n        if (this.options_.outputLanguage.toLowerCase() === \'es6\') {\n          transformer = new PureES6Transformer(errorReporter, this.options_, metadata);\n        } else {\n          transformer = new FromOptionsTransformer(errorReporter, this.options_);\n        }\n        var transformedTree = transformer.transform(tree);\n        this.throwIfErrors(errorReporter);\n        return transformedTree;\n      },\n      createSourceMapConfiguration_: function(outputName) {\n        var sourceRoot = arguments[1];\n        var sourceURL = arguments[2];\n        if (this.options_.sourceMaps) {\n          return {\n            sourceMapGenerator: new SourceMapGenerator({\n              file: outputName,\n              sourceRoot: sourceRoot,\n              skipValidation: true\n            }),\n            basepath: basePath(outputName),\n            inputSourceMap: this.options_.inputSourceMap,\n            sourceURL: sourceURL,\n            outputName: outputName\n          };\n        }\n      },\n      getSourceMap: function() {\n        if (this.sourceMapCache_) {\n          return this.sourceMapCache_;\n        }\n        if (this.sourceMapConfiguration_) {\n          var sourceMap = this.sourceMapConfiguration_.sourceMapGenerator.toString();\n          var inputSourceMap = this.sourceMapConfiguration_.inputSourceMap;\n          if (inputSourceMap) {\n            var generator = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(sourceMap));\n            generator.applySourceMap(new SourceMapConsumer(inputSourceMap));\n            sourceMap = generator.toJSON();\n          }\n          this.sourceMapCache_ = sourceMap;\n          return sourceMap;\n        }\n      },\n      get sourceMapInfo() {\n        if (!this.sourceMapInfo_ && this.sourceMapConfiguration_) {\n          var sourceMap = this.getSourceMap();\n          this.sourceMapInfo_ = {\n            url: this.sourceMapConfiguration_.sourceURL,\n            outputName: this.sourceMapConfiguration_.outputName,\n            map: sourceMap\n          };\n        }\n        return this.sourceMapInfo_;\n      },\n      write: function(tree) {\n        var outputName = arguments[1];\n        var sourceRoot = arguments[2];\n        var sourceURL = arguments[3];\n        outputName = this.normalize(outputName);\n        if (sourceRoot === undefined)\n          sourceRoot = this.options_.sourceRoot;\n        if (sourceRoot === true)\n          sourceRoot = basePath(outputName);\n        else if (!sourceRoot)\n          sourceRoot = undefined;\n        else\n          sourceRoot = this.normalize(sourceRoot);\n        var writer;\n        this.sourceMapCache_ = null;\n        this.sourceMapConfiguration_ = this.createSourceMapConfiguration_(outputName, sourceRoot, sourceURL);\n        if (this.sourceMapConfiguration_) {\n          this.sourceMapConfiguration_.lowResolution = this.options_.lowResolutionSourceMap;\n          writer = new ParseTreeMapWriter(this.sourceMapConfiguration_, this.options_);\n        } else {\n          writer = new ParseTreeWriter(this.options_);\n        }\n        writer.visitAny(tree);\n        var compiledCode = writer.toString();\n        var link = this.debuggerLink(sourceURL, outputName);\n        if (link) {\n          compiledCode += link;\n        }\n        return compiledCode;\n      },\n      debuggerLink: function(sourceURL, outputName) {\n        if (this.sourceMapConfiguration_) {\n          if (this.options_.sourceMaps === \'memory\') {\n            return;\n          }\n          var sourceMappingURL = this.sourceMappingURL(sourceURL || outputName || \'unnamed.js\');\n          return \'//# sourceMappingURL=\' + sourceMappingURL + \'\\n\';\n        } else {\n          if (sourceURL) {\n            return \'//# sourceURL=\' + sourceURL + \'\\n\';\n          }\n        }\n      },\n      sourceName: function(filename) {\n        return filename;\n      },\n      sourceMappingURL: function(path) {\n        if (this.options_.sourceMaps === \'inline\') {\n          if (Reflect.global.btoa) {\n            return \'data:application/json;base64,\' + btoa(unescape(encodeURIComponent(this.getSourceMap())));\n          }\n        }\n        path = path || \'unamed.js\';\n        path = path.split(\'/\').pop();\n        return path + \'.map\';\n      },\n      sourceNameFromTree: function(tree) {\n        return tree.location.start.source.name;\n      },\n      defaultOptions: function() {\n        return versionLockedOptions;\n      },\n      normalize: function(name) {\n        return name && name.replace(/\\\\/g, \'/\');\n      }\n    }, {\n      script: function(content) {\n        var options = arguments[1] !== (void 0) ? arguments[1] : {};\n        options = new Options(options);\n        options.script = true;\n        return new Compiler(options).compile(content);\n      },\n      module: function(content) {\n        var options = arguments[1] !== (void 0) ? arguments[1] : {};\n        options = new Options(options);\n        options.modules = \'bootstrap\';\n        return new Compiler(options).compile(content);\n      },\n      amdOptions: function() {\n        var options = arguments[0] !== (void 0) ? arguments[0] : {};\n        var amdOptions = {\n          modules: \'amd\',\n          sourceMaps: false,\n          moduleName: false\n        };\n        return merge(amdOptions, options);\n      },\n      closureOptions: function() {\n        var options = arguments[0] !== (void 0) ? arguments[0] : {};\n        var closureOptions = {\n          modules: \'closure\',\n          sourceMaps: false,\n          moduleName: true\n        };\n        return merge(closureOptions, options);\n      },\n      commonJSOptions: function() {\n        var options = arguments[0] !== (void 0) ? arguments[0] : {};\n        var commonjsOptions = {\n          modules: \'commonjs\',\n          sourceMaps: false,\n          moduleName: false\n        };\n        return merge(commonjsOptions, options);\n      }\n    });\n  }();\n  return {get Compiler() {\n      return Compiler;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/CloneTreeTransformer.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/CloneTreeTransformer.js";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ParseTreeTransformer.js", "traceur@0.0.111/src/codegeneration/CloneTreeTransformer.js")).ParseTreeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/codegeneration/CloneTreeTransformer.js")),\n      BindingIdentifier = $__2.BindingIdentifier,\n      BreakStatement = $__2.BreakStatement,\n      ContinueStatement = $__2.ContinueStatement,\n      DebuggerStatement = $__2.DebuggerStatement,\n      EmptyStatement = $__2.EmptyStatement,\n      ExportSpecifier = $__2.ExportSpecifier,\n      ExportStar = $__2.ExportStar,\n      IdentifierExpression = $__2.IdentifierExpression,\n      LiteralExpression = $__2.LiteralExpression,\n      ModuleSpecifier = $__2.ModuleSpecifier,\n      PredefinedType = $__2.PredefinedType,\n      PropertyNameShorthand = $__2.PropertyNameShorthand,\n      TemplateLiteralPortion = $__2.TemplateLiteralPortion,\n      SuperExpression = $__2.SuperExpression,\n      ThisExpression = $__2.ThisExpression;\n  var CloneTreeTransformer = function($__super) {\n    function CloneTreeTransformer() {\n      $traceurRuntime.superConstructor(CloneTreeTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(CloneTreeTransformer, {\n      transformBindingIdentifier: function(tree) {\n        return new BindingIdentifier(tree.location, tree.identifierToken);\n      },\n      transformBreakStatement: function(tree) {\n        return new BreakStatement(tree.location, tree.name);\n      },\n      transformContinueStatement: function(tree) {\n        return new ContinueStatement(tree.location, tree.name);\n      },\n      transformDebuggerStatement: function(tree) {\n        return new DebuggerStatement(tree.location);\n      },\n      transformEmptyStatement: function(tree) {\n        return new EmptyStatement(tree.location);\n      },\n      transformExportSpecifier: function(tree) {\n        return new ExportSpecifier(tree.location, tree.lhs, tree.rhs);\n      },\n      transformExportStar: function(tree) {\n        return new ExportStar(tree.location);\n      },\n      transformIdentifierExpression: function(tree) {\n        return new IdentifierExpression(tree.location, tree.identifierToken);\n      },\n      transformList: function(list) {\n        if (!list) {\n          return null;\n        } else if (list.length === 0) {\n          return [];\n        } else {\n          return $traceurRuntime.superGet(this, CloneTreeTransformer.prototype, "transformList").call(this, list);\n        }\n      },\n      transformLiteralExpression: function(tree) {\n        return new LiteralExpression(tree.location, tree.literalToken);\n      },\n      transformModuleSpecifier: function(tree) {\n        return new ModuleSpecifier(tree.location, tree.token);\n      },\n      transformPredefinedType: function(tree) {\n        return new PredefinedType(tree.location, tree.typeToken);\n      },\n      transformPropertyNameShorthand: function(tree) {\n        return new PropertyNameShorthand(tree.location, tree.name);\n      },\n      transformTemplateLiteralPortion: function(tree) {\n        return new TemplateLiteralPortion(tree.location, tree.value);\n      },\n      transformSuperExpression: function(tree) {\n        return new SuperExpression(tree.location);\n      },\n      transformThisExpression: function(tree) {\n        return new ThisExpression(tree.location);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  CloneTreeTransformer.cloneTree = function(tree) {\n    return new CloneTreeTransformer().transformAny(tree);\n  };\n  return {get CloneTreeTransformer() {\n      return CloneTreeTransformer;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/module/createModuleEvaluationStatement.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/module/createModuleEvaluationStatement.js";\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../PlaceholderParser.js", "traceur@0.0.111/src/codegeneration/module/createModuleEvaluationStatement.js")).parseStatement;\n  function createModuleEvaluationStatement(normalizedName) {\n    return parseStatement($traceurRuntime.getTemplateObject(["$traceurRuntime.getModule(", " +\'\')"]), normalizedName);\n  }\n  return {get createModuleEvaluationStatement() {\n      return createModuleEvaluationStatement;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/compiler-imports.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/compiler-imports.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_Compiler_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Compiler.js", "traceur@0.0.111/src/compiler-imports.js"));\n  var Parser = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./syntax/Parser.js", "traceur@0.0.111/src/compiler-imports.js")).Parser;\n  var Script = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./syntax/trees/ParseTrees.js", "traceur@0.0.111/src/compiler-imports.js")).Script;\n  var SourceFile = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./syntax/SourceFile.js", "traceur@0.0.111/src/compiler-imports.js")).SourceFile;\n  var syntax = {\n    Parser: Parser,\n    SourceFile: SourceFile,\n    trees: {Script: Script}\n  };\n  var ParseTreeMapWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./outputgeneration/ParseTreeMapWriter.js", "traceur@0.0.111/src/compiler-imports.js")).ParseTreeMapWriter;\n  var ParseTreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./outputgeneration/ParseTreeWriter.js", "traceur@0.0.111/src/compiler-imports.js")).ParseTreeWriter;\n  var regexpuRewritePattern = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./outputgeneration/regexpuRewritePattern.js", "traceur@0.0.111/src/compiler-imports.js")).regexpuRewritePattern;\n  var SourceMapConsumer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./outputgeneration/SourceMapIntegration.js", "traceur@0.0.111/src/compiler-imports.js")).SourceMapConsumer;\n  var SourceMapGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./outputgeneration/SourceMapIntegration.js", "traceur@0.0.111/src/compiler-imports.js")).SourceMapGenerator;\n  var TreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./outputgeneration/TreeWriter.js", "traceur@0.0.111/src/compiler-imports.js")).TreeWriter;\n  var outputgeneration = {\n    ParseTreeMapWriter: ParseTreeMapWriter,\n    ParseTreeWriter: ParseTreeWriter,\n    regexpuRewritePattern: regexpuRewritePattern,\n    SourceMapConsumer: SourceMapConsumer,\n    SourceMapGenerator: SourceMapGenerator,\n    TreeWriter: TreeWriter\n  };\n  var AttachModuleNameTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./codegeneration/module/AttachModuleNameTransformer.js", "traceur@0.0.111/src/compiler-imports.js")).AttachModuleNameTransformer;\n  var CloneTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./codegeneration/CloneTreeTransformer.js", "traceur@0.0.111/src/compiler-imports.js")).CloneTreeTransformer;\n  var FromOptionsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./codegeneration/FromOptionsTransformer.js", "traceur@0.0.111/src/compiler-imports.js")).FromOptionsTransformer;\n  var PureES6Transformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./codegeneration/PureES6Transformer.js", "traceur@0.0.111/src/compiler-imports.js")).PureES6Transformer;\n  var createModuleEvaluationStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./codegeneration/module/createModuleEvaluationStatement.js", "traceur@0.0.111/src/compiler-imports.js")).createModuleEvaluationStatement;\n  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./codegeneration/PlaceholderParser.js", "traceur@0.0.111/src/compiler-imports.js")),\n      parseExpression = $__16.parseExpression,\n      parseModule = $__16.parseModule,\n      parseScript = $__16.parseScript,\n      parseStatement = $__16.parseStatement;\n  var codegeneration = {\n    CloneTreeTransformer: CloneTreeTransformer,\n    FromOptionsTransformer: FromOptionsTransformer,\n    PureES6Transformer: PureES6Transformer,\n    parseExpression: parseExpression,\n    parseModule: parseModule,\n    parseScript: parseScript,\n    parseStatement: parseStatement,\n    module: {\n      AttachModuleNameTransformer: AttachModuleNameTransformer,\n      createModuleEvaluationStatement: createModuleEvaluationStatement\n    }\n  };\n  return {\n    get Compiler() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_Compiler_46_js__.Compiler;\n    },\n    get syntax() {\n      return syntax;\n    },\n    get outputgeneration() {\n      return outputgeneration;\n    },\n    get codegeneration() {\n      return codegeneration;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/module/ValidationVisitor.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/module/ValidationVisitor.js";\n  var ModuleVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ModuleVisitor.js", "traceur@0.0.111/src/codegeneration/module/ValidationVisitor.js")).ModuleVisitor;\n  var ValidationVisitor = function($__super) {\n    function ValidationVisitor() {\n      $traceurRuntime.superConstructor(ValidationVisitor).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ValidationVisitor, {\n      checkExport_: function(tree, name) {\n        var description = this.validatingModuleDescription_;\n        if (description && !description.getExport(name)) {\n          var moduleName = description.normalizedName;\n          this.reportError(tree, ("\'" + name + "\' is not exported by \'" + moduleName + "\'"));\n        }\n      },\n      checkImport_: function(tree, name) {\n        var existingImport = this.moduleSymbol.getImport(name);\n        if (existingImport) {\n          this.reportError(tree, ("\'" + name + "\' was previously imported at " + existingImport.location.start));\n        } else {\n          this.moduleSymbol.addImport(name, tree);\n        }\n      },\n      visitAndValidate_: function(moduleDescription, tree) {\n        var validatingModuleDescription = this.validatingModuleDescription_;\n        this.validatingModuleDescription_ = moduleDescription;\n        this.visitAny(tree);\n        this.validatingModuleDescription_ = validatingModuleDescription;\n      },\n      visitNamedExport: function(tree) {\n        if (tree.moduleSpecifier) {\n          var name = tree.moduleSpecifier.token.processedValue;\n          var moduleDescription = this.getExportsListForModuleSpecifier(name);\n          this.visitAndValidate_(moduleDescription, tree.exportClause);\n        }\n      },\n      visitExportSpecifier: function(tree) {\n        this.checkExport_(tree, tree.lhs.value);\n      },\n      visitForwardDefaultExport: function(tree) {\n        this.checkExport_(tree, \'default\');\n      },\n      visitImportDeclaration: function(tree) {\n        var name = tree.moduleSpecifier.token.processedValue;\n        var moduleDescription = this.getExportsListForModuleSpecifier(name);\n        this.visitAndValidate_(moduleDescription, tree.importClause);\n      },\n      visitImportSpecifier: function(tree) {\n        var importName = tree.binding.getStringValue();\n        var exportName = tree.name ? tree.name.value : importName;\n        this.checkImport_(tree, importName);\n        this.checkExport_(tree, exportName);\n      },\n      visitImportedBinding: function(tree) {\n        var importName = tree.binding.getStringValue();\n        this.checkImport_(tree, importName);\n        this.checkExport_(tree, \'default\');\n      },\n      visitNameSpaceImport: function(tree) {\n        var importName = tree.binding.binding.getStringValue();\n        this.checkImport_(tree, importName);\n      }\n    }, {}, $__super);\n  }(ModuleVisitor);\n  return {get ValidationVisitor() {\n      return ValidationVisitor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/module/ExportListBuilder.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/module/ExportListBuilder.js";\n  var ExportVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ExportVisitor.js", "traceur@0.0.111/src/codegeneration/module/ExportListBuilder.js")).ExportVisitor;\n  var ValidationVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ValidationVisitor.js", "traceur@0.0.111/src/codegeneration/module/ExportListBuilder.js")).ValidationVisitor;\n  function buildExportList(deps, loader, reporter) {\n    function doVisit(ctor) {\n      for (var i = 0; i < deps.length; i++) {\n        var visitor = new ctor(reporter, loader, deps[i]);\n        visitor.visitAny(deps[i].tree);\n      }\n    }\n    function reverseVisit(ctor) {\n      for (var i = deps.length - 1; i >= 0; i--) {\n        var visitor = new ctor(reporter, loader, deps[i]);\n        visitor.visitAny(deps[i].tree);\n      }\n    }\n    reverseVisit(ExportVisitor);\n    doVisit(ValidationVisitor);\n  }\n  return {get buildExportList() {\n      return buildExportList;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/codegeneration/module/ModuleSpecifierVisitor.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/codegeneration/module/ModuleSpecifierVisitor.js";\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../syntax/ParseTreeVisitor.js", "traceur@0.0.111/src/codegeneration/module/ModuleSpecifierVisitor.js")).ParseTreeVisitor;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../util/StringSet.js", "traceur@0.0.111/src/codegeneration/module/ModuleSpecifierVisitor.js")).StringSet;\n  var ModuleSpecifierVisitor = function($__super) {\n    function ModuleSpecifierVisitor(options) {\n      $traceurRuntime.superConstructor(ModuleSpecifierVisitor).call(this);\n      this.options_ = options;\n      this.moduleSpecifiers_ = new StringSet();\n    }\n    return ($traceurRuntime.createClass)(ModuleSpecifierVisitor, {\n      get moduleSpecifiers() {\n        return this.moduleSpecifiers_.valuesAsArray();\n      },\n      visitModuleSpecifier: function(tree) {\n        this.moduleSpecifiers_.add(tree.token.processedValue);\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  return {get ModuleSpecifierVisitor() {\n      return ModuleSpecifierVisitor;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/loader/system-map.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/loader/system-map.js";\n  function prefixMatchLength(name, prefix) {\n    var prefixParts = prefix.split(\'/\');\n    var nameParts = name.split(\'/\');\n    if (prefixParts.length > nameParts.length)\n      return 0;\n    for (var i = 0; i < prefixParts.length; i++) {\n      if (nameParts[i] != prefixParts[i])\n        return 0;\n    }\n    return prefixParts.length;\n  }\n  function applyMap(map, name, parentName) {\n    var curMatch,\n        curMatchLength = 0;\n    var curParent,\n        curParentMatchLength = 0;\n    if (parentName) {\n      var mappedName;\n      Object.getOwnPropertyNames(map).some(function(p) {\n        var curMap = map[p];\n        if (curMap && typeof curMap === \'object\') {\n          if (prefixMatchLength(parentName, p) <= curParentMatchLength)\n            return;\n          Object.getOwnPropertyNames(curMap).forEach(function(q) {\n            if (prefixMatchLength(name, q) > curMatchLength) {\n              curMatch = q;\n              curMatchLength = q.split(\'/\').length;\n              curParent = p;\n              curParentMatchLength = p.split(\'/\').length;\n            }\n          });\n        }\n        if (curMatch) {\n          var subPath = name.split(\'/\').splice(curMatchLength).join(\'/\');\n          mappedName = map[curParent][curMatch] + (subPath ? \'/\' + subPath : \'\');\n          return mappedName;\n        }\n      });\n    }\n    if (mappedName)\n      return mappedName;\n    Object.getOwnPropertyNames(map).forEach(function(p) {\n      var curMap = map[p];\n      if (curMap && typeof curMap === \'string\') {\n        if (prefixMatchLength(name, p) > curMatchLength) {\n          curMatch = p;\n          curMatchLength = p.split(\'/\').length;\n        }\n      }\n    });\n    if (!curMatch)\n      return name;\n    var subPath = name.split(\'/\').splice(curMatchLength).join(\'/\');\n    return map[curMatch] + (subPath ? \'/\' + subPath : \'\');\n  }\n  var systemjs = {applyMap: applyMap};\n  return {get systemjs() {\n      return systemjs;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/loader/LoaderCompiler.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/loader/LoaderCompiler.js";\n  var buildExportList = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../codegeneration/module/ExportListBuilder.js", "traceur@0.0.111/src/loader/LoaderCompiler.js")).buildExportList;\n  var CollectingErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/CollectingErrorReporter.js", "traceur@0.0.111/src/loader/LoaderCompiler.js")).CollectingErrorReporter;\n  var Compiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Compiler.js", "traceur@0.0.111/src/loader/LoaderCompiler.js")).Compiler;\n  var ModuleSpecifierVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../codegeneration/module/ModuleSpecifierVisitor.js", "traceur@0.0.111/src/loader/LoaderCompiler.js")).ModuleSpecifierVisitor;\n  var ModuleSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../codegeneration/module/ModuleSymbol.js", "traceur@0.0.111/src/loader/LoaderCompiler.js")).ModuleSymbol;\n  var Parser = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/Parser.js", "traceur@0.0.111/src/loader/LoaderCompiler.js")).Parser;\n  var SourceFile = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/SourceFile.js", "traceur@0.0.111/src/loader/LoaderCompiler.js")).SourceFile;\n  var systemjs = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./system-map.js", "traceur@0.0.111/src/loader/LoaderCompiler.js")).systemjs;\n  var UniqueIdentifierGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../codegeneration/UniqueIdentifierGenerator.js", "traceur@0.0.111/src/loader/LoaderCompiler.js")).UniqueIdentifierGenerator;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/url.js", "traceur@0.0.111/src/loader/LoaderCompiler.js")),\n      isAbsolute = $__10.isAbsolute,\n      resolveUrl = $__10.resolveUrl;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/assert.js", "traceur@0.0.111/src/loader/LoaderCompiler.js")).assert;\n  var NOT_STARTED = 0;\n  var LOADING = 1;\n  var LOADED = 2;\n  var PARSED = 3;\n  var TRANSFORMING = 4;\n  var TRANSFORMED = 5;\n  var COMPLETE = 6;\n  var ERROR = 7;\n  var identifierGenerator = new UniqueIdentifierGenerator();\n  var anonymousSourcesSeen = 0;\n  var LoaderCompiler = function() {\n    function LoaderCompiler() {}\n    return ($traceurRuntime.createClass)(LoaderCompiler, {\n      getModuleSpecifiers: function(codeUnit) {\n        this.parse(codeUnit);\n        var moduleSpecifierVisitor = new ModuleSpecifierVisitor(codeUnit.metadata.traceurOptions);\n        moduleSpecifierVisitor.visit(codeUnit.metadata.tree);\n        return moduleSpecifierVisitor.moduleSpecifiers;\n      },\n      parse: function(codeUnit) {\n        assert(!codeUnit.metadata.tree);\n        var metadata = codeUnit.metadata;\n        var options = metadata.traceurOptions;\n        if (codeUnit.type === \'script\')\n          options.script = true;\n        metadata.compiler = new Compiler(options);\n        var sourceName = codeUnit.metadata.sourceName = codeUnit.address || codeUnit.normalizedName || \'(unnamed)#\' + String(++anonymousSourcesSeen);\n        metadata.tree = metadata.compiler.parse(codeUnit.source, sourceName);\n      },\n      transform: function(codeUnit) {\n        var metadata = codeUnit.metadata;\n        metadata.transformedTree = metadata.compiler.transform(metadata.tree, codeUnit.normalizedName, metadata);\n      },\n      write: function(codeUnit) {\n        var metadata = codeUnit.metadata;\n        var outputName = metadata.outputName || metadata.sourceName || \'<loaderOutput>\';\n        var sourceRoot = metadata.sourceRoot;\n        var sourceURL = metadata.sourceName || codeUnit.normalizedName || codeUnit.address;\n        metadata.transcoded = metadata.compiler.write(metadata.transformedTree, outputName, undefined, sourceURL);\n      },\n      evaluateCodeUnit: function(codeUnit) {\n        var result = (\'global\', eval)(codeUnit.metadata.transcoded);\n        codeUnit.metadata.transformedTree = null;\n        return result;\n      },\n      analyzeDependencies: function(dependencies, loader) {\n        var deps = [];\n        for (var i = 0; i < dependencies.length; i++) {\n          var codeUnit = dependencies[i];\n          assert(codeUnit.state >= PARSED);\n          if (codeUnit.state == PARSED) {\n            var symbol = codeUnit.metadata.moduleSymbol = new ModuleSymbol(codeUnit.metadata.tree, codeUnit.normalizedName);\n            deps.push(symbol);\n          }\n        }\n        this.checkForErrors(function(reporter) {\n          return buildExportList(deps, loader, reporter);\n        });\n      },\n      checkForErrors: function(fncOfReporter) {\n        var reporter = new CollectingErrorReporter();\n        var result = fncOfReporter(reporter);\n        if (reporter.hadError())\n          throw reporter.toError();\n        return result;\n      }\n    }, {});\n  }();\n  return {get LoaderCompiler() {\n      return LoaderCompiler;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/loader/InternalLoader.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/loader/InternalLoader.js";\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/assert.js", "traceur@0.0.111/src/loader/InternalLoader.js")).assert;\n  var LoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./LoaderCompiler.js", "traceur@0.0.111/src/loader/InternalLoader.js")).LoaderCompiler;\n  var ExportsList = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../codegeneration/module/ModuleSymbol.js", "traceur@0.0.111/src/loader/InternalLoader.js")).ExportsList;\n  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/url.js", "traceur@0.0.111/src/loader/InternalLoader.js")),\n      isAbsolute = $__13.isAbsolute,\n      resolveUrl = $__13.resolveUrl;\n  var Options = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Options.js", "traceur@0.0.111/src/loader/InternalLoader.js")).Options;\n  var NOT_STARTED = 0;\n  var LOADING = 1;\n  var LOADED = 2;\n  var PARSED = 3;\n  var TRANSFORMING = 4;\n  var TRANSFORMED = 5;\n  var COMPLETE = 6;\n  var ERROR = 7;\n  function mapToValues(map) {\n    var array = [];\n    map.forEach(function(v) {\n      array.push(v);\n    });\n    return array;\n  }\n  var LoaderError = function($__super) {\n    function LoaderError(msg, tree) {\n      $traceurRuntime.superConstructor(LoaderError).call(this);\n      this.message = msg;\n      this.tree = tree;\n      this.name = \'LoaderError\';\n    }\n    return ($traceurRuntime.createClass)(LoaderError, {}, {}, $__super);\n  }(Error);\n  var CodeUnit = function() {\n    function CodeUnit(loaderCompiler, normalizedName, type, state, name, referrerName, address) {\n      var $__8 = this;\n      this.promise = new Promise(function(res, rej) {\n        $__8.loaderCompiler = loaderCompiler;\n        $__8.normalizedName = normalizedName;\n        $__8.type = type;\n        $__8.name_ = name;\n        $__8.referrerName_ = referrerName;\n        $__8.address = address;\n        $__8.state_ = state || NOT_STARTED;\n        $__8.error = null;\n        $__8.result = null;\n        $__8.metadata_ = {};\n        $__8.dependencies = [];\n        $__8.resolve = res;\n        $__8.reject = rej;\n      });\n    }\n    return ($traceurRuntime.createClass)(CodeUnit, {\n      get state() {\n        return this.state_;\n      },\n      set state(value) {\n        if (value < this.state_) {\n          throw new Error(\'Invalid state change\');\n        }\n        this.state_ = value;\n      },\n      get metadata() {\n        return this.metadata_;\n      },\n      set metadata(value) {\n        assert(value);\n        this.metadata_ = value;\n      },\n      nameTrace: function() {\n        var trace = this.specifiedAs();\n        if (isAbsolute(this.name_)) {\n          return trace + \'An absolute name.\\n\';\n        }\n        if (this.referrerName_) {\n          return trace + this.importedBy() + this.normalizesTo();\n        }\n        return trace + this.normalizesTo();\n      },\n      specifiedAs: function() {\n        return ("Specified as " + this.name_ + ".\\n");\n      },\n      importedBy: function() {\n        return ("Imported by " + this.referrerName_ + ".\\n");\n      },\n      normalizesTo: function() {\n        return \'Normalizes to \' + this.normalizedName + \'\\n\';\n      }\n    }, {});\n  }();\n  var PreCompiledCodeUnit = function($__super) {\n    function PreCompiledCodeUnit(loaderCompiler, normalizedName, name, referrerName, address, module) {\n      $traceurRuntime.superConstructor(PreCompiledCodeUnit).call(this, loaderCompiler, normalizedName, \'module\', COMPLETE, name, referrerName, address);\n      this.result = module;\n      this.resolve(this.result);\n    }\n    return ($traceurRuntime.createClass)(PreCompiledCodeUnit, {}, {}, $__super);\n  }(CodeUnit);\n  var BundledCodeUnit = function($__super) {\n    function BundledCodeUnit(loaderCompiler, normalizedName, name, referrerName, address, deps, execute, setModule) {\n      $traceurRuntime.superConstructor(BundledCodeUnit).call(this, loaderCompiler, normalizedName, \'module\', TRANSFORMED, name, referrerName, address);\n      this.deps = deps;\n      this.execute = execute;\n    }\n    return ($traceurRuntime.createClass)(BundledCodeUnit, {\n      getModuleSpecifiers: function() {\n        return this.deps;\n      },\n      evaluate: function() {\n        var $__8 = this;\n        var normalizedNames = this.deps.map(function(name) {\n          return $__8.loader_.normalize(name);\n        });\n        var module = this.execute.apply(Reflect.global, normalizedNames);\n        setModule(this.normalizedName, module);\n        return module;\n      }\n    }, {}, $__super);\n  }(CodeUnit);\n  var HookedCodeUnit = function($__super) {\n    function HookedCodeUnit() {\n      $traceurRuntime.superConstructor(HookedCodeUnit).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(HookedCodeUnit, {\n      getModuleSpecifiers: function() {\n        return this.loaderCompiler.getModuleSpecifiers(this);\n      },\n      evaluate: function() {\n        return this.loaderCompiler.evaluateCodeUnit(this);\n      }\n    }, {}, $__super);\n  }(CodeUnit);\n  var LoadCodeUnit = function($__super) {\n    function LoadCodeUnit(loaderCompiler, normalizedName, name, referrerName, address) {\n      $traceurRuntime.superConstructor(LoadCodeUnit).call(this, loaderCompiler, normalizedName, \'module\', NOT_STARTED, name, referrerName, address);\n    }\n    return ($traceurRuntime.createClass)(LoadCodeUnit, {}, {}, $__super);\n  }(HookedCodeUnit);\n  var EvalCodeUnit = function($__super) {\n    function EvalCodeUnit(loaderCompiler, code) {\n      var type = arguments[2] !== (void 0) ? arguments[2] : \'script\';\n      var normalizedName = arguments[3];\n      var referrerName = arguments[4];\n      var address = arguments[5];\n      $traceurRuntime.superConstructor(EvalCodeUnit).call(this, loaderCompiler, normalizedName, type, LOADED, null, referrerName, address);\n      this.source = code;\n    }\n    return ($traceurRuntime.createClass)(EvalCodeUnit, {}, {}, $__super);\n  }(HookedCodeUnit);\n  var uniqueNameCount = 0;\n  var InternalLoader = function() {\n    function InternalLoader(loader, loaderCompiler) {\n      assert(loaderCompiler);\n      this.loader_ = loader;\n      this.loaderCompiler = loaderCompiler;\n      this.cache = new Map();\n      this.urlToKey = Object.create(null);\n      this.sync_ = false;\n      this.sourceMapsByURL_ = Object.create(null);\n      this.sourceMapsByOutputName_ = Object.create(null);\n    }\n    return ($traceurRuntime.createClass)(InternalLoader, {\n      defaultMetadata_: function() {\n        var metadata = arguments[0] !== (void 0) ? arguments[0] : {};\n        var incoming = metadata.traceurOptions;\n        if (incoming && !(incoming instanceof Options)) {\n          var unknown = Options.listUnknownOptions(incoming);\n          if (unknown.length) {\n            console.warn(\'Unknown metadata.traceurOptions ignored: \' + unknown.join(\',\'));\n          }\n        }\n        metadata.traceurOptions = incoming || new Options();\n        return metadata;\n      },\n      defaultModuleMetadata_: function() {\n        var metadata = arguments[0] !== (void 0) ? arguments[0] : {};\n        var metadata = this.defaultMetadata_(metadata);\n        metadata.traceurOptions.script = false;\n        return metadata;\n      },\n      getSourceMap: function(url) {\n        return this.sourceMapsByURL_[url] || this.sourceMapsByOutputName_[url];\n      },\n      load: function(name) {\n        var referrerName = arguments[1] !== (void 0) ? arguments[1] : this.loader_.baseURL;\n        var address = arguments[2];\n        var metadata = arguments[3] !== (void 0) ? arguments[3] : {};\n        metadata = this.defaultMetadata_(metadata);\n        var codeUnit = this.getOrCreateCodeUnit_(name, referrerName, address, metadata);\n        this.load_(codeUnit);\n        return codeUnit.promise.then(function() {\n          return codeUnit;\n        });\n      },\n      load_: function(codeUnit) {\n        var $__8 = this;\n        if (codeUnit.state === ERROR) {\n          return codeUnit;\n        }\n        if (codeUnit.state === TRANSFORMED) {\n          this.handleCodeUnitLoaded(codeUnit);\n        } else {\n          if (codeUnit.state !== NOT_STARTED)\n            return codeUnit;\n          codeUnit.state = LOADING;\n          codeUnit.address = this.loader_.locate(codeUnit);\n          this.loader_.fetch(codeUnit).then(function(text) {\n            codeUnit.source = text;\n            return codeUnit;\n          }).then(function(load) {\n            return $__8.loader_.translate(load);\n          }).then(function(source) {\n            codeUnit.source = source;\n            codeUnit.state = LOADED;\n            $__8.handleCodeUnitLoaded(codeUnit);\n            return codeUnit;\n          }).catch(function(err) {\n            try {\n              codeUnit.state = ERROR;\n              codeUnit.error = err;\n              $__8.handleCodeUnitLoadError(codeUnit);\n            } catch (ex) {\n              console.error(\'Internal Error \' + (ex.stack || ex));\n            }\n          });\n        }\n        return codeUnit;\n      },\n      module: function(code, referrerName, address, metadata) {\n        var codeUnit = new EvalCodeUnit(this.loaderCompiler, code, \'module\', null, referrerName, address);\n        codeUnit.metadata = this.defaultMetadata_(metadata);\n        this.cache.set({}, codeUnit);\n        this.handleCodeUnitLoaded(codeUnit);\n        return codeUnit.promise;\n      },\n      define: function(normalizedName, code, address, metadata) {\n        var codeUnit = new EvalCodeUnit(this.loaderCompiler, code, \'module\', normalizedName, null, address);\n        var key = this.getKey(normalizedName, \'module\');\n        codeUnit.metadata = this.defaultMetadata_(metadata);\n        this.cache.set(key, codeUnit);\n        this.handleCodeUnitLoaded(codeUnit);\n        return codeUnit.promise;\n      },\n      script: function(code, name, referrerName, address, metadata) {\n        var normalizedName = this.loader_.normalize(name || \'\', referrerName, address);\n        var codeUnit = new EvalCodeUnit(this.loaderCompiler, code, \'script\', normalizedName, referrerName, address);\n        var key = {};\n        if (name)\n          key = this.getKey(normalizedName, \'script\');\n        codeUnit.metadata = this.defaultMetadata_(metadata);\n        this.cache.set(key, codeUnit);\n        this.handleCodeUnitLoaded(codeUnit);\n        return codeUnit.promise;\n      },\n      getKey: function(url, type) {\n        var combined = type + \':\' + url;\n        if (combined in this.urlToKey) {\n          return this.urlToKey[combined];\n        }\n        return this.urlToKey[combined] = {};\n      },\n      getCodeUnit_: function(normalizedName, type) {\n        var key = this.getKey(normalizedName, type);\n        var codeUnit = this.cache.get(key);\n        return {\n          key: key,\n          codeUnit: codeUnit\n        };\n      },\n      getOrCreateCodeUnit_: function(name, referrerName, address, metadata) {\n        var normalizedName = this.loader_.normalize(name, referrerName, address);\n        var type = \'module\';\n        if (metadata && metadata.traceurOptions && metadata.traceurOptions.script)\n          type = \'script\';\n        var $__9 = this.getCodeUnit_(normalizedName, type),\n            key = $__9.key,\n            codeUnit = $__9.codeUnit;\n        if (!codeUnit) {\n          assert(metadata && metadata.traceurOptions);\n          var module = this.loader_.get(normalizedName);\n          if (module) {\n            codeUnit = new PreCompiledCodeUnit(this.loaderCompiler, normalizedName, name, referrerName, address, module);\n            codeUnit.type = \'module\';\n          } else {\n            codeUnit = new LoadCodeUnit(this.loaderCompiler, normalizedName, name, referrerName, address);\n            codeUnit.type = type;\n          }\n          codeUnit.metadata = {\n            traceurOptions: metadata.traceurOptions,\n            outputName: metadata.outputName,\n            rootModule: metadata.rootModule\n          };\n          this.cache.set(key, codeUnit);\n        }\n        return codeUnit;\n      },\n      areAll: function(state) {\n        return mapToValues(this.cache).every(function(codeUnit) {\n          return codeUnit.state >= state;\n        });\n      },\n      getCodeUnitForModuleSpecifier: function(name, referrerName) {\n        var normalizedName = this.loader_.normalize(name, referrerName);\n        return this.getCodeUnit_(normalizedName, \'module\').codeUnit;\n      },\n      getExportsListForModuleSpecifier: function(name, referrer) {\n        var codeUnit = this.getCodeUnitForModuleSpecifier(name, referrer);\n        var exportsList = codeUnit.metadata.moduleSymbol;\n        if (!exportsList) {\n          if (codeUnit.result) {\n            exportsList = new ExportsList(codeUnit.normalizedName);\n            exportsList.addExportsFromModule(codeUnit.result);\n          } else {\n            throw new Error(("InternalError: " + name + " is not a module, required by " + referrer));\n          }\n        }\n        return exportsList;\n      },\n      handleCodeUnitLoaded: function(codeUnit) {\n        var $__8 = this;\n        var referrerName = codeUnit.normalizedName;\n        try {\n          var moduleSpecifiers = codeUnit.getModuleSpecifiers();\n          codeUnit.state = PARSED;\n          if (!moduleSpecifiers) {\n            this.abortAll(("No module specifiers in " + referrerName));\n            return;\n          }\n          codeUnit.dependencies = moduleSpecifiers.map(function(name) {\n            return $__8.getOrCreateCodeUnit_(name, referrerName, null, $__8.defaultModuleMetadata_(codeUnit.metadata));\n          });\n        } catch (error) {\n          this.rejectOneAndAll(codeUnit, error);\n          return;\n        }\n        codeUnit.dependencies.forEach(function(dependency) {\n          $__8.load_(dependency);\n        });\n        if (this.areAll(PARSED)) {\n          try {\n            if (codeUnit.type === \'module\')\n              this.analyze();\n            this.transform();\n            this.evaluate();\n          } catch (error) {\n            this.rejectOneAndAll(codeUnit, error);\n          }\n        }\n      },\n      rejectOneAndAll: function(codeUnit, error) {\n        codeUnit.state.ERROR;\n        codeUnit.error = error;\n        codeUnit.reject(error);\n        this.abortAll(error);\n      },\n      handleCodeUnitLoadError: function(codeUnit) {\n        var message = codeUnit.error ? String(codeUnit.error) + \'\\n\' : ("Failed to load \'" + codeUnit.address + "\'.\\n");\n        message += codeUnit.nameTrace() + this.loader_.nameTrace(codeUnit);\n        this.rejectOneAndAll(codeUnit, new Error(message));\n      },\n      abortAll: function(errorMessage) {\n        this.cache.forEach(function(codeUnit) {\n          if (codeUnit.state !== ERROR)\n            codeUnit.reject(errorMessage);\n        });\n      },\n      analyze: function() {\n        this.loaderCompiler.analyzeDependencies(mapToValues(this.cache), this);\n      },\n      transform: function() {\n        this.transformDependencies_(mapToValues(this.cache));\n      },\n      transformDependencies_: function(dependencies, dependentName) {\n        for (var i = 0; i < dependencies.length; i++) {\n          var codeUnit = dependencies[i];\n          if (codeUnit.state >= TRANSFORMED) {\n            continue;\n          }\n          if (codeUnit.state === TRANSFORMING) {\n            var cir = codeUnit.normalizedName;\n            var cle = dependentName;\n            this.rejectOneAndAll(codeUnit, new Error(("Unsupported circular dependency between " + cir + " and " + cle)));\n            return;\n          }\n          codeUnit.state = TRANSFORMING;\n          try {\n            this.transformCodeUnit_(codeUnit);\n          } catch (error) {\n            this.rejectOneAndAll(codeUnit, error);\n            return;\n          }\n        }\n      },\n      transformCodeUnit_: function(codeUnit) {\n        this.transformDependencies_(codeUnit.dependencies, codeUnit.normalizedName);\n        if (codeUnit.state === ERROR)\n          return;\n        this.loaderCompiler.transform(codeUnit);\n        codeUnit.state = TRANSFORMED;\n        this.loaderCompiler.write(codeUnit);\n        var info = codeUnit.metadata.compiler.sourceMapInfo;\n        if (info) {\n          this.sourceMapsByURL_[info.url] = info.map;\n          this.sourceMapsByOutputName_[info.outputName] = info.map;\n        }\n        this.loader_.instantiate(codeUnit);\n      },\n      orderDependencies: function() {\n        var visited = new Map();\n        var ordered = [];\n        function orderCodeUnits(codeUnit) {\n          if (visited.has(codeUnit)) {\n            return;\n          }\n          visited.set(codeUnit, true);\n          codeUnit.dependencies.forEach(orderCodeUnits);\n          ordered.push(codeUnit);\n        }\n        this.cache.forEach(orderCodeUnits);\n        return ordered;\n      },\n      evaluate: function() {\n        var dependencies = this.orderDependencies();\n        for (var i = 0; i < dependencies.length; i++) {\n          var codeUnit = dependencies[i];\n          if (codeUnit.state >= COMPLETE) {\n            continue;\n          }\n          var result = void 0;\n          try {\n            result = codeUnit.evaluate();\n          } catch (ex) {\n            this.rejectOneAndAll(codeUnit, ex);\n            return;\n          }\n          codeUnit.result = result;\n          codeUnit.source = null;\n        }\n        for (var i = 0; i < dependencies.length; i++) {\n          var codeUnit = dependencies[i];\n          if (codeUnit.state >= COMPLETE) {\n            continue;\n          }\n          codeUnit.state = COMPLETE;\n          codeUnit.resolve(codeUnit.result);\n        }\n      }\n    }, {});\n  }();\n  var internals = {\n    CodeUnit: CodeUnit,\n    EvalCodeUnit: EvalCodeUnit,\n    LoadCodeUnit: LoadCodeUnit,\n    LoaderCompiler: LoaderCompiler\n  };\n  return {\n    get InternalLoader() {\n      return InternalLoader;\n    },\n    get internals() {\n      return internals;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/loader/Loader.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/loader/Loader.js";\n  var InternalLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./InternalLoader.js", "traceur@0.0.111/src/loader/Loader.js")).InternalLoader;\n  function throwAbstractMethod() {\n    throw new Error(\'Unimplemented Loader function, see extended class\');\n  }\n  var Loader = function() {\n    function Loader(loaderCompiler) {\n      this.internalLoader_ = new InternalLoader(this, loaderCompiler);\n      this.loaderCompiler_ = loaderCompiler;\n    }\n    return ($traceurRuntime.createClass)(Loader, {\n      import: function(name) {\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = $__3.metadata;\n        var $__2 = this;\n        return this.internalLoader_.load(name, referrerName, address, metadata).then(function(codeUnit) {\n          return $__2.get(codeUnit.normalizedName);\n        });\n      },\n      module: function(source) {\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = $__3.metadata;\n        return this.internalLoader_.module(source, referrerName, address, metadata);\n      },\n      define: function(normalizedName, source) {\n        var $__3 = arguments[2] !== (void 0) ? arguments[2] : {},\n            address = $__3.address,\n            metadata = $__3.metadata;\n        return this.internalLoader_.define(normalizedName, source, address, metadata);\n      },\n      get: function(normalizedName) {\n        throwAbstractMethod();\n      },\n      set: function(normalizedName, module) {\n        throwAbstractMethod();\n      },\n      normalize: function(name, referrerName, referrerAddress) {\n        throwAbstractMethod();\n      },\n      locate: function(load) {\n        throwAbstractMethod();\n      },\n      fetch: function(load) {\n        throwAbstractMethod();\n      },\n      translate: function(load) {\n        throwAbstractMethod();\n      },\n      instantiate: function(load) {\n        throwAbstractMethod();\n      }\n    }, {});\n  }();\n  return {\n    get throwAbstractMethod() {\n      return throwAbstractMethod;\n    },\n    get Loader() {\n      return Loader;\n    },\n    get LoaderCompiler() {\n      return LoaderCompiler;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/loader/version.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/loader/version.js";\n  var version = \'0.0.111\';\n  return {get version() {\n      return version;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/loader/TraceurLoader.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/loader/TraceurLoader.js";\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../util/url.js", "traceur@0.0.111/src/loader/TraceurLoader.js")),\n      isAbsolute = $__5.isAbsolute,\n      resolveUrl = $__5.resolveUrl;\n  var Loader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Loader.js", "traceur@0.0.111/src/loader/TraceurLoader.js")).Loader;\n  var LoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./LoaderCompiler.js", "traceur@0.0.111/src/loader/TraceurLoader.js")).LoaderCompiler;\n  var Options = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../Options.js", "traceur@0.0.111/src/loader/TraceurLoader.js")).Options;\n  var systemjs = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./system-map.js", "traceur@0.0.111/src/loader/TraceurLoader.js")).systemjs;\n  var webLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./webLoader.js", "traceur@0.0.111/src/loader/TraceurLoader.js")).webLoader;\n  var version = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./version.js", "traceur@0.0.111/src/loader/TraceurLoader.js")).version;\n  var WebPageTranscoder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../WebPageTranscoder.js", "traceur@0.0.111/src/loader/TraceurLoader.js")).WebPageTranscoder;\n  var uniqueNameCount = 0;\n  var TraceurLoader = function($__super) {\n    function TraceurLoader(fileLoader, baseURL) {\n      var loaderCompiler = arguments[2] !== (void 0) ? arguments[2] : new LoaderCompiler();\n      $traceurRuntime.superConstructor(TraceurLoader).call(this, loaderCompiler);\n      this.fileLoader_ = fileLoader;\n      this.baseURL_ = baseURL && String(baseURL);\n      this.moduleStore_ = $traceurRuntime.ModuleStore;\n    }\n    return ($traceurRuntime.createClass)(TraceurLoader, {\n      get baseURL() {\n        return this.baseURL_;\n      },\n      set baseURL(value) {\n        this.baseURL_ = String(value);\n      },\n      get: function(normalizedName) {\n        return this.moduleStore_.get(normalizedName);\n      },\n      set: function(normalizedName, module) {\n        this.moduleStore_.set(normalizedName, module);\n      },\n      normalize: function(name, referrerName, referrerAddress) {\n        var normalizedName = this.moduleStore_.normalize(name, referrerName, referrerAddress);\n        if (typeof systemjs !== \'undefined\' && System.map)\n          return systemjs.applyMap(System.map, normalizedName, referrerName);\n        return normalizedName;\n      },\n      locate: function(load) {\n        load.metadata.traceurOptions = load.metadata.traceurOptions || {};\n        var url = load.normalizedName;\n        var options = load.metadata.traceurOptions;\n        var baseURL = load.metadata && load.metadata.baseURL;\n        baseURL = baseURL || this.baseURL;\n        var referrer = options && options.referrer;\n        if (referrer) {\n          var minChars = Math.min(referrer.length, baseURL.length);\n          var commonChars = 0;\n          for (var i = 0; i < minChars; i++) {\n            var aChar = referrer[referrer.length - 1 - i];\n            if (aChar === baseURL[baseURL.length - 1 - i])\n              commonChars++;\n            else\n              break;\n          }\n          if (commonChars) {\n            var packageName = referrer.slice(0, -commonChars);\n            var rootDirectory = baseURL.slice(0, -commonChars);\n            if (url.indexOf(packageName) === 0) {\n              url = url.replace(packageName, rootDirectory);\n            }\n          }\n        }\n        if (!isAbsolute(url)) {\n          if (baseURL) {\n            load.metadata.baseURL = baseURL;\n            url = resolveUrl(baseURL, url);\n          }\n        }\n        return url;\n      },\n      sourceName: function(load) {\n        var options = load.metadata.traceurOptions;\n        var sourceName = load.address;\n        if (options.sourceMaps) {\n          var sourceRoot = this.baseURL;\n          if (sourceName) {\n            if (sourceRoot && sourceName.indexOf(sourceRoot) === 0) {\n              sourceName = sourceName.substring(sourceRoot.length);\n            }\n          } else {\n            sourceName = this.baseURL + String(uniqueNameCount++);\n          }\n        }\n        return sourceName;\n      },\n      nameTrace: function(load) {\n        var trace = \'\';\n        if (load.metadata.locateMap) {\n          trace += this.locateMapTrace(load);\n        }\n        var base = load.metadata.baseURL || this.baseURL;\n        if (base) {\n          trace += this.baseURLTrace(base);\n        } else {\n          trace += \'No baseURL\\n\';\n        }\n        return trace;\n      },\n      locateMapTrace: function(load) {\n        var map = load.metadata.locateMap;\n        return ("locate found \\\'" + map.pattern + "\\\' -> \\\'" + map.replacement + "\\\'\\n");\n      },\n      baseURLTrace: function(base) {\n        return \'locate resolved against base \\\'\' + base + \'\\\'\\n\';\n      },\n      fetch: function(load) {\n        var $__2 = this;\n        return new Promise(function(resolve, reject) {\n          if (!load)\n            reject(new TypeError(\'fetch requires argument object\'));\n          else if (!load.address || typeof load.address !== \'string\')\n            reject(new TypeError(\'fetch({address}) missing required string.\'));\n          else\n            $__2.fileLoader_.load(load.address, resolve, reject);\n        });\n      },\n      translate: function(load) {\n        return load.source;\n      },\n      instantiate: function($__3) {\n        var $__4 = $__3,\n            name = $__4.name,\n            metadata = $__4.metadata,\n            address = $__4.address,\n            source = $__4.source,\n            sourceMap = $__4.sourceMap;\n        return new Promise(function(resolve, reject) {\n          resolve(undefined);\n        });\n      },\n      bundledModule: function(name) {\n        return this.moduleStore_.bundleStore[name];\n      },\n      importAll: function(names) {\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = $__3.metadata;\n        var $__2 = this;\n        return Promise.all(names.map(function(name) {\n          return $__2.import(name, {\n            referrerName: referrerName,\n            address: address,\n            metadata: metadata\n          });\n        }));\n      },\n      loadAsScript: function(name) {\n        var $__4;\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = ($__4 = $__3.metadata) === void 0 ? {} : $__4;\n        metadata.traceurOptions = metadata.traceurOptions || {};\n        metadata.traceurOptions.script = true;\n        return this.internalLoader_.load(name, referrerName, address, metadata).then(function(load) {\n          return load.result;\n        });\n      },\n      loadAsScriptAll: function(names) {\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = $__3.metadata;\n        var $__2 = this;\n        return Promise.all(names.map(function(name) {\n          return $__2.loadAsScript(name, {\n            referrerName: referrerName,\n            address: address,\n            metadata: metadata\n          });\n        }));\n      },\n      script: function(source) {\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            name = $__3.name,\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = $__3.metadata;\n        return this.internalLoader_.script(source, name, referrerName, address, metadata);\n      },\n      semVerRegExp_: function() {\n        return /^(\\d+)\\.(\\d+)\\.(\\d+)(?:-([0-9A-Za-z-]+(?:\\.[0-9A-Za-z-]+)*))?(?:\\+[0-9A-Za-z-]+)?$/;\n      },\n      semverMap: function(normalizedName) {\n        var slash = normalizedName.indexOf(\'/\');\n        if (slash < 0) {\n          slash = normalizedName.length;\n        }\n        var versionPart = normalizedName.slice(0, slash);\n        var at = versionPart.indexOf(\'@\');\n        if (at !== -1) {\n          var semver = versionPart.slice(at + 1);\n          var m = this.semVerRegExp_().exec(semver);\n          if (m) {\n            var major = m[1];\n            var minor = m[2];\n            var packageName = versionPart.slice(0, at);\n            var map = Object.create(null);\n            map[packageName] = versionPart;\n            map[packageName + \'@\' + major] = versionPart;\n            map[packageName + \'@\' + major + \'.\' + minor] = versionPart;\n            return map;\n          }\n          throw new Error(\'semverMap found no matching semver regexp in \' + semver);\n        }\n        throw new Error(\'semverMap expected name@semver, got \' + versionPart + \' \' + normalizedName);\n      },\n      get version() {\n        return version;\n      },\n      getSourceMap: function(filename) {\n        return this.internalLoader_.getSourceMap(filename);\n      },\n      register: function(normalizedName, deps, factoryFunction) {\n        $traceurRuntime.ModuleStore.register(normalizedName, deps, factoryFunction);\n      },\n      registerModule: function(normalizedName, deps, factoryFunction) {\n        $traceurRuntime.ModuleStore.registerModule(normalizedName, deps, factoryFunction);\n      },\n      dirname: function(filename) {\n        var lastSlash = filename.lastIndexOf(\'/\');\n        if (lastSlash === -1)\n          return \'.\';\n        if (lastSlash === 0)\n          return \'/\';\n        return filename.slice(0, lastSlash);\n      }\n    }, {}, $__super);\n  }(Loader);\n  var BrowserTraceurLoader = function($__super) {\n    function BrowserTraceurLoader() {\n      $traceurRuntime.superConstructor(BrowserTraceurLoader).call(this, webLoader, window.location.href, new LoaderCompiler());\n    }\n    return ($traceurRuntime.createClass)(BrowserTraceurLoader, {loadScriptTypeModule: function() {\n        var traceurOptions = arguments[0] !== (void 0) ? arguments[0] : new Options();\n        new traceur.WebPageTranscoder(document.location.href, traceurOptions).run();\n      }}, {}, $__super);\n  }(TraceurLoader);\n  return {\n    get TraceurLoader() {\n      return TraceurLoader;\n    },\n    get BrowserTraceurLoader() {\n      return BrowserTraceurLoader;\n    }\n  };\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/node/NodeLoaderCompiler.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/node/NodeLoaderCompiler.js";\n  var LoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../loader/LoaderCompiler.js", "traceur@0.0.111/src/node/NodeLoaderCompiler.js")).LoaderCompiler;\n  var NodeLoaderCompiler = function($__super) {\n    function NodeLoaderCompiler() {\n      $traceurRuntime.superConstructor(NodeLoaderCompiler).call(this);\n      this.sourceMapsInMemory_ = false;\n    }\n    return ($traceurRuntime.createClass)(NodeLoaderCompiler, {\n      evaluateCodeUnit: function(codeUnit) {\n        var runInThisContext = require(\'vm\').runInThisContext;\n        var semver = require(\'semver\');\n        var content = codeUnit.metadata.transcoded;\n        var filename = codeUnit.address || codeUnit.normalizedName;\n        if (codeUnit.metadata.traceurOptions.sourceMaps === \'memory\') {\n          this.enableMemorySourceMaps_();\n        }\n        var options;\n        if (semver.gte(process.version, \'0.12.0\')) {\n          options = {filename: filename};\n        } else {\n          options = filename;\n        }\n        var result = runInThisContext(content, options);\n        codeUnit.metadata.transformedTree = null;\n        return result;\n      },\n      enableMemorySourceMaps_: function() {\n        if (this.sourceMapsInMemory_) {\n          return;\n        }\n        require(\'source-map-support\').install({retrieveSourceMap: function(url) {\n            try {\n              var map = System.getSourceMap(url);\n              if (map) {\n                return {\n                  url: url,\n                  map: map\n                };\n              }\n            } catch (ex) {\n              console.error(\'retrieveSourceMap FAILED \', ex);\n            }\n          }});\n        this.sourceMapsInMemory_ = true;\n      }\n    }, {}, $__super);\n  }(LoaderCompiler);\n  return {get NodeLoaderCompiler() {\n      return NodeLoaderCompiler;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/loader/InlineLoaderCompiler.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/loader/InlineLoaderCompiler.js";\n  var LoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./LoaderCompiler.js", "traceur@0.0.111/src/loader/InlineLoaderCompiler.js")).LoaderCompiler;\n  var Script = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../syntax/trees/ParseTrees.js", "traceur@0.0.111/src/loader/InlineLoaderCompiler.js")).Script;\n  var InlineLoaderCompiler = function($__super) {\n    function InlineLoaderCompiler(elements) {\n      $traceurRuntime.superConstructor(InlineLoaderCompiler).call(this);\n      this.elements = elements;\n    }\n    return ($traceurRuntime.createClass)(InlineLoaderCompiler, {\n      write: function() {},\n      evaluateCodeUnit: function(codeUnit) {\n        var $__1;\n        var tree = codeUnit.metadata.transformedTree;\n        ($__1 = this.elements).push.apply($__1, $traceurRuntime.spread(tree.scriptItemList));\n      },\n      toTree: function() {\n        return new Script(null, this.elements, null);\n      }\n    }, {}, $__super);\n  }(LoaderCompiler);\n  return {get InlineLoaderCompiler() {\n      return InlineLoaderCompiler;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/loader/NodeTraceurLoader.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/loader/NodeTraceurLoader.js";\n  var TraceurLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TraceurLoader.js", "traceur@0.0.111/src/loader/NodeTraceurLoader.js")).TraceurLoader;\n  var NodeLoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../node/NodeLoaderCompiler.js", "traceur@0.0.111/src/loader/NodeTraceurLoader.js")).NodeLoaderCompiler;\n  var NodeTraceurLoader = function($__super) {\n    function NodeTraceurLoader() {\n      var path = require(\'path\');\n      var fileloader = require(\'../node/nodeLoader.js\');\n      var url = (path.resolve(\'./\') + \'/\').replace(/\\\\/g, \'/\');\n      $traceurRuntime.superConstructor(NodeTraceurLoader).call(this, fileloader, url, new NodeLoaderCompiler());\n      this.traceurMap_ = null;\n    }\n    return ($traceurRuntime.createClass)(NodeTraceurLoader, {getSourceMap: function(filename) {\n        var map = $traceurRuntime.superGet(this, NodeTraceurLoader.prototype, "getSourceMap").call(this, filename);\n        if (!map && filename.replace(/\\\\/g, \'/\').endsWith(\'/bin/traceur.js\')) {\n          if (!this.traceurMap_) {\n            var fs = require(\'fs\');\n            this.traceurMap_ = fs.readFileSync(filename + \'.map\', \'utf8\');\n          }\n          map = this.traceurMap_;\n        }\n        return map;\n      }}, {}, $__super);\n  }(TraceurLoader);\n  return {get NodeTraceurLoader() {\n      return NodeTraceurLoader;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/loader/loader-imports.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/loader/loader-imports.js";\n  var Loader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Loader.js", "traceur@0.0.111/src/loader/loader-imports.js")).Loader;\n  var LoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./LoaderCompiler.js", "traceur@0.0.111/src/loader/loader-imports.js")).LoaderCompiler;\n  var BrowserTraceurLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TraceurLoader.js", "traceur@0.0.111/src/loader/loader-imports.js")).BrowserTraceurLoader;\n  var NodeLoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../node/NodeLoaderCompiler.js", "traceur@0.0.111/src/loader/loader-imports.js")).NodeLoaderCompiler;\n  var InlineLoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./InlineLoaderCompiler.js", "traceur@0.0.111/src/loader/loader-imports.js")).InlineLoaderCompiler;\n  var NodeTraceurLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./NodeTraceurLoader.js", "traceur@0.0.111/src/loader/loader-imports.js")).NodeTraceurLoader;\n  var TraceurLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./TraceurLoader.js", "traceur@0.0.111/src/loader/loader-imports.js")).TraceurLoader;\n  var loader = {\n    BrowserTraceurLoader: BrowserTraceurLoader,\n    InlineLoaderCompiler: InlineLoaderCompiler,\n    Loader: Loader,\n    LoaderCompiler: LoaderCompiler,\n    NodeLoaderCompiler: NodeLoaderCompiler,\n    NodeTraceurLoader: NodeTraceurLoader,\n    TraceurLoader: TraceurLoader\n  };\n  return {get loader() {\n      return loader;\n    }};\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/traceur.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/traceur.js";\n  var $__traceur_64_0_46_0_46_111_47_src_47_util_45_imports_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./util-imports.js", "traceur@0.0.111/src/traceur.js"));\n  var $__traceur_64_0_46_0_46_111_47_src_47_compiler_45_imports_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./compiler-imports.js", "traceur@0.0.111/src/traceur.js"));\n  var $__traceur_64_0_46_0_46_111_47_src_47_loader_47_loader_45_imports_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./loader/loader-imports.js", "traceur@0.0.111/src/traceur.js"));\n  return $traceurRuntime.exportStar({}, $__traceur_64_0_46_0_46_111_47_src_47_util_45_imports_46_js__, $__traceur_64_0_46_0_46_111_47_src_47_compiler_45_imports_46_js__, $__traceur_64_0_46_0_46_111_47_src_47_loader_47_loader_45_imports_46_js__);\n});\n$traceurRuntime.registerModule("traceur@0.0.111/src/traceur-import.js", [], function() {\n  "use strict";\n  var __moduleName = "traceur@0.0.111/src/traceur-import.js";\n  var traceur = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./traceur.js", "traceur@0.0.111/src/traceur-import.js"));\n  Reflect.global.traceur = traceur;\n  $traceurRuntime.ModuleStore.set(\'traceur@\', traceur);\n  return {};\n});\n$traceurRuntime.getModule("traceur@0.0.111/src/traceur-import.js" + \'\');\n//# sourceMappingURL=traceur.js.map\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = traceur;\n\n//# sourceURL=webpack:///./node_modules/traceur/bin/traceur.js?./node_modules/exports-loader?traceur')}}]);