(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{"./node_modules/glsl-parser/direct.js":function(module,exports,__webpack_require__){eval('var parse = __webpack_require__("./node_modules/glsl-parser/lib/index.js")\r\n\r\nmodule.exports = parseArray\r\n\r\nfunction parseArray(tokens) {\r\n  var parser = parse()\r\n\r\n  for (var i = 0; i < tokens.length; i++) {\r\n    parser(tokens[i])\r\n  }\r\n\r\n  return parser(null)\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/glsl-parser/direct.js?')},"./node_modules/glsl-parser/lib/expr.js":function(module,exports){eval("var state\r\n  , token\r\n  , tokens\r\n  , idx\r\n\r\nvar original_symbol = {\r\n    nud: function() { return this.children && this.children.length ? this : fail('unexpected')() }\r\n  , led: fail('missing operator')\r\n}\r\n\r\nvar symbol_table = {}\r\n\r\nfunction itself() {\r\n  return this\r\n}\r\n\r\nsymbol('(ident)').nud = itself\r\nsymbol('(keyword)').nud = itself\r\nsymbol('(builtin)').nud = itself\r\nsymbol('(literal)').nud = itself\r\nsymbol('(end)')\r\n\r\nsymbol(':')\r\nsymbol(';')\r\nsymbol(',')\r\nsymbol(')')\r\nsymbol(']')\r\nsymbol('}')\r\n\r\ninfixr('&&', 30)\r\ninfixr('||', 30)\r\ninfix('|', 43)\r\ninfix('^', 44)\r\ninfix('&', 45)\r\ninfix('==', 46)\r\ninfix('!=', 46)\r\ninfix('<', 47)\r\ninfix('<=', 47)\r\ninfix('>', 47)\r\ninfix('>=', 47)\r\ninfix('>>', 48)\r\ninfix('<<', 48)\r\ninfix('+', 50)\r\ninfix('-', 50)\r\ninfix('*', 60)\r\ninfix('/', 60)\r\ninfix('%', 60)\r\ninfix('?', 20, function(left) {\r\n  this.children = [left, expression(0), (advance(':'), expression(0))]\r\n  this.type = 'ternary'\r\n  return this\r\n})\r\ninfix('.', 80, function(left) {\r\n  token.type = 'literal'\r\n  state.fake(token)\r\n  this.children = [left, token]\r\n  advance()\r\n  return this\r\n})\r\ninfix('[', 80, function(left) {\r\n  this.children = [left, expression(0)]\r\n  this.type = 'binary'\r\n  advance(']')\r\n  return this\r\n})\r\ninfix('(', 80, function(left) {\r\n  this.children = [left]\r\n  this.type = 'call'\r\n\r\n  if(token.data !== ')') while(1) {\r\n    this.children.push(expression(0))\r\n    if(token.data !== ',') break\r\n    advance(',')\r\n  }\r\n  advance(')')\r\n  return this\r\n})\r\n\r\nprefix('-')\r\nprefix('+')\r\nprefix('!')\r\nprefix('~')\r\nprefix('defined')\r\nprefix('(', function() {\r\n  this.type = 'group'\r\n  this.children = [expression(0)]\r\n  advance(')')\r\n  return this\r\n})\r\nprefix('++')\r\nprefix('--')\r\nsuffix('++')\r\nsuffix('--')\r\n\r\nassignment('=')\r\nassignment('+=')\r\nassignment('-=')\r\nassignment('*=')\r\nassignment('/=')\r\nassignment('%=')\r\nassignment('&=')\r\nassignment('|=')\r\nassignment('^=')\r\nassignment('>>=')\r\nassignment('<<=')\r\n\r\nmodule.exports = function(incoming_state, incoming_tokens) {\r\n  state = incoming_state\r\n  tokens = incoming_tokens\r\n  idx = 0\r\n  var result\r\n\r\n  if(!tokens.length) return\r\n\r\n  advance()\r\n  result = expression(0)\r\n  result.parent = state[0]\r\n  emit(result)\r\n\r\n  if(idx < tokens.length) {\r\n    throw new Error('did not use all tokens')\r\n  }\r\n\r\n  result.parent.children = [result]\r\n\r\n  function emit(node) {\r\n    state.unshift(node, false)\r\n    for(var i = 0, len = node.children.length; i < len; ++i) {\r\n      emit(node.children[i])\r\n    }\r\n    state.shift()\r\n  }\r\n\r\n}\r\n\r\nfunction symbol(id, binding_power) {\r\n  var sym = symbol_table[id]\r\n  binding_power = binding_power || 0\r\n  if(sym) {\r\n    if(binding_power > sym.lbp) {\r\n      sym.lbp = binding_power\r\n    }\r\n  } else {\r\n    sym = Object.create(original_symbol)\r\n    sym.id = id\r\n    sym.lbp = binding_power\r\n    symbol_table[id] = sym\r\n  }\r\n  return sym\r\n}\r\n\r\nfunction expression(rbp) {\r\n  var left, t = token\r\n  advance()\r\n\r\n  left = t.nud()\r\n  while(rbp < token.lbp) {\r\n    t = token\r\n    advance()\r\n    left = t.led(left)\r\n  }\r\n  return left\r\n}\r\n\r\nfunction infix(id, bp, led) {\r\n  var sym = symbol(id, bp)\r\n  sym.led = led || function(left) {\r\n    this.children = [left, expression(bp)]\r\n    this.type = 'binary'\r\n    return this\r\n  }\r\n}\r\n\r\nfunction infixr(id, bp, led) {\r\n  var sym = symbol(id, bp)\r\n  sym.led = led || function(left) {\r\n    this.children = [left, expression(bp - 1)]\r\n    this.type = 'binary'\r\n    return this\r\n  }\r\n  return sym\r\n}\r\n\r\nfunction prefix(id, nud) {\r\n  var sym = symbol(id)\r\n  sym.nud = nud || function() {\r\n    this.children = [expression(70)]\r\n    this.type = 'unary'\r\n    return this\r\n  }\r\n  return sym\r\n}\r\n\r\nfunction suffix(id) {\r\n  var sym = symbol(id, 150)\r\n  sym.led = function(left) {\r\n    this.children = [left]\r\n    this.type = 'suffix'\r\n    return this\r\n  }\r\n}\r\n\r\nfunction assignment(id) {\r\n  return infixr(id, 10, function(left) {\r\n    this.children = [left, expression(9)]\r\n    this.assignment = true\r\n    this.type = 'assign'\r\n    return this\r\n  })\r\n}\r\n\r\nfunction advance(id) {\r\n  var next\r\n    , value\r\n    , type\r\n    , output\r\n\r\n  if(id && token.data !== id) {\r\n    return state.unexpected('expected `'+ id + '`, got `'+token.data+'`')\r\n  }\r\n\r\n  if(idx >= tokens.length) {\r\n    token = symbol_table['(end)']\r\n    return\r\n  }\r\n\r\n  next = tokens[idx++]\r\n  value = next.data\r\n  type = next.type\r\n\r\n  if(type === 'ident') {\r\n    output = state.scope.find(value) || state.create_node()\r\n    type = output.type\r\n  } else if(type === 'builtin') {\r\n    output = symbol_table['(builtin)']\r\n  } else if(type === 'keyword') {\r\n    output = symbol_table['(keyword)']\r\n  } else if(type === 'operator') {\r\n    output = symbol_table[value]\r\n    if(!output) {\r\n      return state.unexpected('unknown operator `'+value+'`')\r\n    }\r\n  } else if(type === 'float' || type === 'integer') {\r\n    type = 'literal'\r\n    output = symbol_table['(literal)']\r\n  } else {\r\n    return state.unexpected('unexpected token.')\r\n  }\r\n\r\n  if(output) {\r\n    if(!output.nud) { output.nud = itself }\r\n    if(!output.children) { output.children = [] }\r\n  }\r\n\r\n  output = Object.create(output)\r\n  output.token = next\r\n  output.type = type\r\n  if(!output.data) output.data = value\r\n\r\n  return token = output\r\n}\r\n\r\nfunction fail(message) {\r\n  return function() { return state.unexpected(message) }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/glsl-parser/lib/expr.js?")},"./node_modules/glsl-parser/lib/index.js":function(module,exports,__webpack_require__){eval("module.exports = parser\r\n\r\nvar full_parse_expr = __webpack_require__(\"./node_modules/glsl-parser/lib/expr.js\")\r\n  , Scope = __webpack_require__(\"./node_modules/glsl-parser/lib/scope.js\")\r\n\r\n// singleton!\r\nvar Advance = new Object\r\n\r\nvar DEBUG = false\r\n\r\nvar _ = 0\r\n  , IDENT = _++\r\n  , STMT = _++\r\n  , STMTLIST = _++\r\n  , STRUCT = _++\r\n  , FUNCTION = _++\r\n  , FUNCTIONARGS = _++\r\n  , DECL = _++\r\n  , DECLLIST = _++\r\n  , FORLOOP = _++\r\n  , WHILELOOP = _++\r\n  , IF = _++\r\n  , EXPR = _++\r\n  , PRECISION = _++\r\n  , COMMENT = _++\r\n  , PREPROCESSOR = _++\r\n  , KEYWORD = _++\r\n  , KEYWORD_OR_IDENT = _++\r\n  , RETURN = _++\r\n  , BREAK = _++\r\n  , CONTINUE = _++\r\n  , DISCARD = _++\r\n  , DOWHILELOOP = _++\r\n  , PLACEHOLDER = _++\r\n  , QUANTIFIER = _++\r\n\r\nvar DECL_ALLOW_ASSIGN = 0x1\r\n  , DECL_ALLOW_COMMA = 0x2\r\n  , DECL_REQUIRE_NAME = 0x4\r\n  , DECL_ALLOW_INVARIANT = 0x8\r\n  , DECL_ALLOW_STORAGE = 0x10\r\n  , DECL_NO_INOUT = 0x20\r\n  , DECL_ALLOW_STRUCT = 0x40\r\n  , DECL_STATEMENT = 0xFF\r\n  , DECL_FUNCTION = DECL_STATEMENT & ~(DECL_ALLOW_ASSIGN | DECL_ALLOW_COMMA | DECL_NO_INOUT | DECL_ALLOW_INVARIANT | DECL_REQUIRE_NAME)\r\n  , DECL_STRUCT = DECL_STATEMENT & ~(DECL_ALLOW_ASSIGN | DECL_ALLOW_INVARIANT | DECL_ALLOW_STORAGE | DECL_ALLOW_STRUCT)\r\n\r\nvar QUALIFIERS = ['const', 'attribute', 'uniform', 'varying']\r\n\r\nvar NO_ASSIGN_ALLOWED = false\r\n  , NO_COMMA_ALLOWED = false\r\n\r\n// map of tokens to stmt types\r\nvar token_map = {\r\n    'block-comment': COMMENT\r\n  , 'line-comment': COMMENT\r\n  , 'preprocessor': PREPROCESSOR\r\n}\r\n\r\n// map of stmt types to human\r\nvar stmt_type = _ = [\r\n    'ident'\r\n  , 'stmt'\r\n  , 'stmtlist'\r\n  , 'struct'\r\n  , 'function'\r\n  , 'functionargs'\r\n  , 'decl'\r\n  , 'decllist'\r\n  , 'forloop'\r\n  , 'whileloop'\r\n  , 'if'\r\n  , 'expr'\r\n  , 'precision'\r\n  , 'comment'\r\n  , 'preprocessor'\r\n  , 'keyword'\r\n  , 'keyword_or_ident'\r\n  , 'return'\r\n  , 'break'\r\n  , 'continue'\r\n  , 'discard'\r\n  , 'do-while'\r\n  , 'placeholder'\r\n  , 'quantifier'\r\n]\r\n\r\nfunction parser() {\r\n  var stmtlist = n(STMTLIST)\r\n    , stmt = n(STMT)\r\n    , decllist = n(DECLLIST)\r\n    , precision = n(PRECISION)\r\n    , ident = n(IDENT)\r\n    , keyword_or_ident = n(KEYWORD_OR_IDENT)\r\n    , fn = n(FUNCTION)\r\n    , fnargs = n(FUNCTIONARGS)\r\n    , forstmt = n(FORLOOP)\r\n    , ifstmt = n(IF)\r\n    , whilestmt = n(WHILELOOP)\r\n    , returnstmt = n(RETURN)\r\n    , dowhilestmt = n(DOWHILELOOP)\r\n    , quantifier = n(QUANTIFIER)\r\n\r\n  var parse_struct\r\n    , parse_precision\r\n    , parse_quantifier\r\n    , parse_forloop\r\n    , parse_if\r\n    , parse_return\r\n    , parse_whileloop\r\n    , parse_dowhileloop\r\n    , parse_function\r\n    , parse_function_args\r\n\r\n  var check = arguments.length ? [].slice.call(arguments) : []\r\n    , complete = false\r\n    , ended = false\r\n    , depth = 0\r\n    , state = []\r\n    , nodes = []\r\n    , tokens = []\r\n    , whitespace = []\r\n    , errored = false\r\n    , program\r\n    , token\r\n    , node\r\n\r\n  // setup state\r\n  state.shift = special_shift\r\n  state.unshift = special_unshift\r\n  state.fake = special_fake\r\n  state.unexpected = unexpected\r\n  state.scope = new Scope(state)\r\n  state.create_node = function() {\r\n    var n = mknode(IDENT, token)\r\n    n.parent = reader.program\r\n    return n\r\n  }\r\n\r\n  setup_stative_parsers()\r\n\r\n  // setup root node\r\n  node = stmtlist()\r\n  node.expecting = '(eof)'\r\n  node.mode = STMTLIST\r\n  node.token = {type: '(program)', data: '(program)'}\r\n  program = node\r\n\r\n  reader.program = program\r\n  reader.scope = function(scope) {\r\n    if(arguments.length === 1) {\r\n      state.scope = scope\r\n    }\r\n    return state.scope\r\n  }\r\n\r\n  state.unshift(node)\r\n  return reader\r\n\r\n  function reader(data) {\r\n    if (data === null) {\r\n      return end(), program\r\n    }\r\n\r\n    nodes = []\r\n    write(data)\r\n    return nodes\r\n  }\r\n\r\n  // stream functions ---------------------------------------------\r\n\r\n  function write(input) {\r\n    if(input.type === 'whitespace' || input.type === 'line-comment' || input.type === 'block-comment') {\r\n\r\n      whitespace.push(input)\r\n      return\r\n    }\r\n    tokens.push(input)\r\n    token = token || tokens[0]\r\n\r\n    if(token && whitespace.length) {\r\n      token.preceding = token.preceding || []\r\n      token.preceding = token.preceding.concat(whitespace)\r\n      whitespace = []\r\n    }\r\n\r\n    while(take()) switch(state[0].mode) {\r\n      case STMT: parse_stmt(); break\r\n      case STMTLIST: parse_stmtlist(); break\r\n      case DECL: parse_decl(); break\r\n      case DECLLIST: parse_decllist(); break\r\n      case EXPR: parse_expr(); break\r\n      case STRUCT: parse_struct(true, true); break\r\n      case PRECISION: parse_precision(); break\r\n      case IDENT: parse_ident(); break\r\n      case KEYWORD: parse_keyword(); break\r\n      case KEYWORD_OR_IDENT: parse_keyword_or_ident(); break\r\n      case FUNCTION: parse_function(); break\r\n      case FUNCTIONARGS: parse_function_args(); break\r\n      case FORLOOP: parse_forloop(); break\r\n      case WHILELOOP: parse_whileloop(); break\r\n      case DOWHILELOOP: parse_dowhileloop(); break\r\n      case RETURN: parse_return(); break\r\n      case IF: parse_if(); break\r\n      case QUANTIFIER: parse_quantifier(); break\r\n    }\r\n  }\r\n\r\n  function end(tokens) {\r\n    if(arguments.length) {\r\n      write(tokens)\r\n    }\r\n\r\n    if(state.length > 1) {\r\n      unexpected('unexpected EOF')\r\n      return\r\n    }\r\n\r\n    complete = true\r\n  }\r\n\r\n  function take() {\r\n    if(errored || !state.length)\r\n      return false\r\n\r\n    return (token = tokens[0])\r\n  }\r\n\r\n  // ----- state manipulation --------\r\n\r\n  function special_fake(x) {\r\n    state.unshift(x)\r\n    state.shift()\r\n  }\r\n\r\n  function special_unshift(_node, add_child) {\r\n    _node.parent = state[0]\r\n\r\n    var ret = [].unshift.call(this, _node)\r\n\r\n    add_child = add_child === undefined ? true : add_child\r\n\r\n    if(DEBUG) {\r\n      var pad = ''\r\n      for(var i = 0, len = this.length - 1; i < len; ++i) {\r\n        pad += ' |'\r\n      }\r\n      console.log(pad, '\\\\'+_node.type, _node.token.data)\r\n    }\r\n\r\n    if(add_child && node !== _node) node.children.push(_node)\r\n    node = _node\r\n\r\n    return ret\r\n  }\r\n\r\n  function special_shift() {\r\n    var _node = [].shift.call(this)\r\n      , okay = check[this.length]\r\n      , emit = false\r\n\r\n    if(DEBUG) {\r\n      var pad = ''\r\n      for(var i = 0, len = this.length; i < len; ++i) {\r\n        pad += ' |'\r\n      }\r\n      console.log(pad, '/'+_node.type)\r\n    }\r\n\r\n    if(check.length) {\r\n      if(typeof check[0] === 'function') {\r\n        emit = check[0](_node)\r\n      } else if(okay !== undefined) {\r\n        emit = okay.test ? okay.test(_node.type) : okay === _node.type\r\n      }\r\n    } else {\r\n      emit = true\r\n    }\r\n\r\n    if(emit && !errored) nodes.push(_node)\r\n\r\n    node = _node.parent\r\n    return _node\r\n  }\r\n\r\n  // parse states ---------------\r\n\r\n  function parse_stmtlist() {\r\n    // determine the type of the statement\r\n    // and then start parsing\r\n    return stative(\r\n      function() { state.scope.enter(); return Advance }\r\n    , normal_mode\r\n    )()\r\n\r\n    function normal_mode() {\r\n      if(token.data === state[0].expecting) {\r\n        return state.scope.exit(), state.shift()\r\n      }\r\n      switch(token.type) {\r\n        case 'preprocessor':\r\n          state.fake(adhoc())\r\n          tokens.shift()\r\n        return\r\n        default:\r\n          state.unshift(stmt())\r\n        return\r\n      }\r\n    }\r\n  }\r\n\r\n  function parse_stmt() {\r\n    if(state[0].brace) {\r\n      if(token.data !== '}') {\r\n        return unexpected('expected `}`, got '+token.data)\r\n      }\r\n      state[0].brace = false\r\n      return tokens.shift(), state.shift()\r\n    }\r\n    switch(token.type) {\r\n      case 'eof': return got_eof()\r\n      case 'keyword':\r\n        switch(token.data) {\r\n          case 'for': return state.unshift(forstmt());\r\n          case 'if': return state.unshift(ifstmt());\r\n          case 'while': return state.unshift(whilestmt());\r\n          case 'do': return state.unshift(dowhilestmt());\r\n          case 'break': return state.fake(mknode(BREAK, token)), tokens.shift()\r\n          case 'continue': return state.fake(mknode(CONTINUE, token)), tokens.shift()\r\n          case 'discard': return state.fake(mknode(DISCARD, token)), tokens.shift()\r\n          case 'return': return state.unshift(returnstmt());\r\n          case 'precision': return state.unshift(precision());\r\n        }\r\n        return state.unshift(decl(DECL_STATEMENT))\r\n      case 'ident':\r\n        var lookup\r\n        if(lookup = state.scope.find(token.data)) {\r\n          if(lookup.parent.type === 'struct') {\r\n            // this is strictly untrue, you could have an\r\n            // expr that starts with a struct constructor.\r\n            //      ... sigh\r\n            return state.unshift(decl(DECL_STATEMENT))\r\n          }\r\n          return state.unshift(expr(';'))\r\n        }\r\n      case 'operator':\r\n        if(token.data === '{') {\r\n          state[0].brace = true\r\n          var n = stmtlist()\r\n          n.expecting = '}'\r\n          return tokens.shift(), state.unshift(n)\r\n        }\r\n        if(token.data === ';') {\r\n          return tokens.shift(), state.shift()\r\n        }\r\n      default: return state.unshift(expr(';'))\r\n    }\r\n  }\r\n\r\n  function got_eof() {\r\n    if (ended) errored = true\r\n    ended = true\r\n    return state.shift()\r\n  }\r\n\r\n  function parse_decl() {\r\n    var stmt = state[0]\r\n\r\n    return stative(\r\n      invariant_or_not,\r\n      storage_or_not,\r\n      parameter_or_not,\r\n      precision_or_not,\r\n      struct_or_type,\r\n      maybe_name,\r\n      maybe_lparen,     // lparen means we're a function\r\n      is_decllist,\r\n      done\r\n    )()\r\n\r\n    function invariant_or_not() {\r\n      if(token.data === 'invariant') {\r\n        if(stmt.flags & DECL_ALLOW_INVARIANT) {\r\n          state.unshift(keyword())\r\n          return Advance\r\n        } else {\r\n          return unexpected('`invariant` is not allowed here')\r\n        }\r\n      } else {\r\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\r\n        return Advance\r\n      }\r\n    }\r\n\r\n    function storage_or_not() {\r\n      if(is_storage(token)) {\r\n        if(stmt.flags & DECL_ALLOW_STORAGE) {\r\n          state.unshift(keyword())\r\n          return Advance\r\n        } else {\r\n          return unexpected('storage is not allowed here')\r\n        }\r\n      } else {\r\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\r\n        return Advance\r\n      }\r\n    }\r\n\r\n    function parameter_or_not() {\r\n      if(is_parameter(token)) {\r\n        if(!(stmt.flags & DECL_NO_INOUT)) {\r\n          state.unshift(keyword())\r\n          return Advance\r\n        } else {\r\n          return unexpected('parameter is not allowed here')\r\n        }\r\n      } else {\r\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\r\n        return Advance\r\n      }\r\n    }\r\n\r\n    function precision_or_not() {\r\n      if(is_precision(token)) {\r\n        state.unshift(keyword())\r\n        return Advance\r\n      } else {\r\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\r\n        return Advance\r\n      }\r\n    }\r\n\r\n    function struct_or_type() {\r\n      if(token.data === 'struct') {\r\n        if(!(stmt.flags & DECL_ALLOW_STRUCT)) {\r\n          return unexpected('cannot nest structs')\r\n        }\r\n        state.unshift(struct())\r\n        return Advance\r\n      }\r\n\r\n      if(token.type === 'keyword') {\r\n        state.unshift(keyword())\r\n        return Advance\r\n      }\r\n\r\n      var lookup = state.scope.find(token.data)\r\n\r\n      if(lookup) {\r\n        state.fake(Object.create(lookup))\r\n        tokens.shift()\r\n        return Advance\r\n      }\r\n      return unexpected('expected user defined type, struct or keyword, got '+token.data)\r\n    }\r\n\r\n    function maybe_name() {\r\n      if(token.data === ',' && !(stmt.flags & DECL_ALLOW_COMMA)) {\r\n        return state.shift()\r\n      }\r\n\r\n      if(token.data === '[') {\r\n        // oh lord.\r\n        state.unshift(quantifier())\r\n        return\r\n      }\r\n\r\n      if(token.data === ')') return state.shift()\r\n\r\n      if(token.data === ';') {\r\n        return stmt.stage + 3\r\n      }\r\n\r\n      if(token.type !== 'ident' && token.type !== 'builtin') {\r\n        return unexpected('expected identifier, got '+token.data)\r\n      }\r\n\r\n      stmt.collected_name = tokens.shift()\r\n      return Advance\r\n    }\r\n\r\n    function maybe_lparen() {\r\n      if(token.data === '(') {\r\n        tokens.unshift(stmt.collected_name)\r\n        delete stmt.collected_name\r\n        state.unshift(fn())\r\n        return stmt.stage + 2\r\n      }\r\n      return Advance\r\n    }\r\n\r\n    function is_decllist() {\r\n      tokens.unshift(stmt.collected_name)\r\n      delete stmt.collected_name\r\n      state.unshift(decllist())\r\n      return Advance\r\n    }\r\n\r\n    function done() {\r\n      return state.shift()\r\n    }\r\n  }\r\n\r\n  function parse_decllist() {\r\n    // grab ident\r\n\r\n    if(token.type === 'ident' || token.type === 'builtin') {\r\n      var name = token.data\r\n      state.unshift(ident())\r\n      state.scope.define(name)\r\n      return\r\n    }\r\n\r\n    if(token.type === 'operator') {\r\n\r\n      if(token.data === ',') {\r\n        // multi-decl!\r\n        if(!(state[1].flags & DECL_ALLOW_COMMA)) {\r\n          return state.shift()\r\n        }\r\n\r\n        return tokens.shift()\r\n      } else if(token.data === '=') {\r\n        if(!(state[1].flags & DECL_ALLOW_ASSIGN)) return unexpected('`=` is not allowed here.')\r\n\r\n        tokens.shift()\r\n\r\n        state.unshift(expr(',', ';'))\r\n        return\r\n      } else if(token.data === '[') {\r\n        state.unshift(quantifier())\r\n        return\r\n      }\r\n    }\r\n    return state.shift()\r\n  }\r\n\r\n  function parse_keyword_or_ident() {\r\n    if(token.type === 'keyword') {\r\n      state[0].type = 'keyword'\r\n      state[0].mode = KEYWORD\r\n      return\r\n    }\r\n\r\n    if(token.type === 'ident') {\r\n      state[0].type = 'ident'\r\n      state[0].mode = IDENT\r\n      return\r\n    }\r\n\r\n    return unexpected('expected keyword or user-defined name, got '+token.data)\r\n  }\r\n\r\n  function parse_keyword() {\r\n    if(token.type !== 'keyword') {\r\n      return unexpected('expected keyword, got '+token.data)\r\n    }\r\n\r\n    return state.shift(), tokens.shift()\r\n  }\r\n\r\n  function parse_ident() {\r\n    if(token.type !== 'ident' && token.type !== 'builtin') {\r\n      return unexpected('expected user-defined name, got '+token.data)\r\n    }\r\n\r\n    state[0].data = token.data\r\n    return state.shift(), tokens.shift()\r\n  }\r\n\r\n\r\n  function parse_expr() {\r\n    var expecting = state[0].expecting\r\n\r\n    state[0].tokens = state[0].tokens || []\r\n\r\n    if(state[0].parenlevel === undefined) {\r\n      state[0].parenlevel = 0\r\n      state[0].bracelevel = 0\r\n    }\r\n    if(state[0].parenlevel < 1 && expecting.indexOf(token.data) > -1) {\r\n      return parseexpr(state[0].tokens)\r\n    }\r\n    if(token.data === '(') {\r\n      ++state[0].parenlevel\r\n    } else if(token.data === ')') {\r\n      --state[0].parenlevel\r\n    }\r\n\r\n    switch(token.data) {\r\n      case '{': ++state[0].bracelevel; break\r\n      case '}': --state[0].bracelevel; break\r\n      case '(': ++state[0].parenlevel; break\r\n      case ')': --state[0].parenlevel; break\r\n    }\r\n\r\n    if(state[0].parenlevel < 0) return unexpected('unexpected `)`')\r\n    if(state[0].bracelevel < 0) return unexpected('unexpected `}`')\r\n\r\n    state[0].tokens.push(tokens.shift())\r\n    return\r\n\r\n    function parseexpr(tokens) {\r\n      try {\r\n        full_parse_expr(state, tokens)\r\n      } catch(err) {\r\n        errored = true\r\n        throw err\r\n      }\r\n\r\n      return state.shift()\r\n    }\r\n  }\r\n\r\n  // node types ---------------\r\n\r\n  function n(type) {\r\n    // this is a function factory that suffices for most kinds of expressions and statements\r\n    return function() {\r\n      return mknode(type, token)\r\n    }\r\n  }\r\n\r\n  function adhoc() {\r\n    return mknode(token_map[token.type], token, node)\r\n  }\r\n\r\n  function decl(flags) {\r\n    var _ = mknode(DECL, token, node)\r\n    _.flags = flags\r\n\r\n    return _\r\n  }\r\n\r\n  function struct(allow_assign, allow_comma) {\r\n    var _ = mknode(STRUCT, token, node)\r\n    _.allow_assign = allow_assign === undefined ? true : allow_assign\r\n    _.allow_comma = allow_comma === undefined ? true : allow_comma\r\n    return _\r\n  }\r\n\r\n  function expr() {\r\n    var n = mknode(EXPR, token, node)\r\n\r\n    n.expecting = [].slice.call(arguments)\r\n    return n\r\n  }\r\n\r\n  function keyword(default_value) {\r\n    var t = token\r\n    if(default_value) {\r\n      t = {'type': '(implied)', data: '(default)', position: t.position}\r\n    }\r\n    return mknode(KEYWORD, t, node)\r\n  }\r\n\r\n  // utils ----------------------------\r\n\r\n  function unexpected(str) {\r\n    errored = true\r\n    throw new Error(\r\n      (str || 'unexpected '+state) +\r\n      ' at line '+state[0].token.line\r\n    )\r\n  }\r\n\r\n  function assert(type, data) {\r\n    return 1,\r\n      assert_null_string_or_array(type, token.type) &&\r\n      assert_null_string_or_array(data, token.data)\r\n  }\r\n\r\n  function assert_null_string_or_array(x, y) {\r\n    switch(typeof x) {\r\n      case 'string': if(y !== x) {\r\n        unexpected('expected `'+x+'`, got '+y+'\\n'+token.data);\r\n      } return !errored\r\n\r\n      case 'object': if(x && x.indexOf(y) === -1) {\r\n        unexpected('expected one of `'+x.join('`, `')+'`, got '+y);\r\n      } return !errored\r\n    }\r\n    return true\r\n  }\r\n\r\n  // stative ----------------------------\r\n\r\n  function stative() {\r\n    var steps = [].slice.call(arguments)\r\n      , step\r\n      , result\r\n\r\n    return function() {\r\n      var current = state[0]\r\n\r\n      current.stage || (current.stage = 0)\r\n\r\n      step = steps[current.stage]\r\n      if(!step) return unexpected('parser in undefined state!')\r\n\r\n      result = step()\r\n\r\n      if(result === Advance) return ++current.stage\r\n      if(result === undefined) return\r\n      current.stage = result\r\n    }\r\n  }\r\n\r\n  function advance(op, t) {\r\n    t = t || 'operator'\r\n    return function() {\r\n      if(!assert(t, op)) return\r\n\r\n      var last = tokens.shift()\r\n        , children = state[0].children\r\n        , last_node = children[children.length - 1]\r\n\r\n      if(last_node && last_node.token && last.preceding) {\r\n        last_node.token.succeeding = last_node.token.succeeding || []\r\n        last_node.token.succeeding = last_node.token.succeeding.concat(last.preceding)\r\n      }\r\n      return Advance\r\n    }\r\n  }\r\n\r\n  function advance_expr(until) {\r\n    return function() {\r\n      state.unshift(expr(until))\r\n      return Advance\r\n    }\r\n  }\r\n\r\n  function advance_ident(declare) {\r\n    return declare ? function() {\r\n      var name = token.data\r\n      return assert('ident') && (state.unshift(ident()), state.scope.define(name), Advance)\r\n    } :  function() {\r\n      if(!assert('ident')) return\r\n\r\n      var s = Object.create(state.scope.find(token.data))\r\n      s.token = token\r\n\r\n      return (tokens.shift(), Advance)\r\n    }\r\n  }\r\n\r\n  function advance_stmtlist() {\r\n    return function() {\r\n      var n = stmtlist()\r\n      n.expecting = '}'\r\n      return state.unshift(n), Advance\r\n    }\r\n  }\r\n\r\n  function maybe_stmtlist(skip) {\r\n    return function() {\r\n      var current = state[0].stage\r\n      if(token.data !== '{') { return state.unshift(stmt()), current + skip }\r\n      return tokens.shift(), Advance\r\n    }\r\n  }\r\n\r\n  function popstmt() {\r\n    return function() { return state.shift(), state.shift() }\r\n  }\r\n\r\n\r\n  function setup_stative_parsers() {\r\n\r\n    // could also be\r\n    // struct { } decllist\r\n    parse_struct =\r\n        stative(\r\n          advance('struct', 'keyword')\r\n        , function() {\r\n            if(token.data === '{') {\r\n              state.fake(mknode(IDENT, {data:'', position: token.position, type:'ident'}))\r\n              return Advance\r\n            }\r\n\r\n            return advance_ident(true)()\r\n          }\r\n        , function() { state.scope.enter(); return Advance }\r\n        , advance('{')\r\n        , function() {\r\n            if(token.type === 'preprocessor') {\r\n              state.fake(adhoc())\r\n              tokens.shift()\r\n              return\r\n            }\r\n            if(token.data === '}') {\r\n              state.scope.exit()\r\n              tokens.shift()\r\n              return state.shift()\r\n            }\r\n            if(token.data === ';') { tokens.shift(); return }\r\n            state.unshift(decl(DECL_STRUCT))\r\n          }\r\n        )\r\n\r\n    parse_precision =\r\n        stative(\r\n          function() { return tokens.shift(), Advance }\r\n        , function() {\r\n            return assert(\r\n            'keyword', ['lowp', 'mediump', 'highp']\r\n            ) && (state.unshift(keyword()), Advance)\r\n          }\r\n        , function() { return (state.unshift(keyword()), Advance) }\r\n        , function() { return state.shift() }\r\n        )\r\n\r\n    parse_quantifier =\r\n        stative(\r\n          advance('[')\r\n        , advance_expr(']')\r\n        , advance(']')\r\n        , function() { return state.shift() }\r\n        )\r\n\r\n    parse_forloop =\r\n        stative(\r\n          advance('for', 'keyword')\r\n        , advance('(')\r\n        , function() {\r\n            var lookup\r\n            if(token.type === 'ident') {\r\n              if(!(lookup = state.scope.find(token.data))) {\r\n                lookup = state.create_node()\r\n              }\r\n\r\n              if(lookup.parent.type === 'struct') {\r\n                return state.unshift(decl(DECL_STATEMENT)), Advance\r\n              }\r\n            } else if(token.type === 'builtin' || token.type === 'keyword') {\r\n              return state.unshift(decl(DECL_STATEMENT)), Advance\r\n            }\r\n            return advance_expr(';')()\r\n          }\r\n        , advance(';')\r\n        , advance_expr(';')\r\n        , advance(';')\r\n        , advance_expr(')')\r\n        , advance(')')\r\n        , maybe_stmtlist(3)\r\n        , advance_stmtlist()\r\n        , advance('}')\r\n        , popstmt()\r\n        )\r\n\r\n    parse_if =\r\n        stative(\r\n          advance('if', 'keyword')\r\n        , advance('(')\r\n        , advance_expr(')')\r\n        , advance(')')\r\n        , maybe_stmtlist(3)\r\n        , advance_stmtlist()\r\n        , advance('}')\r\n        , function() {\r\n            if(token.data === 'else') {\r\n              return tokens.shift(), state.unshift(stmt()), Advance\r\n            }\r\n            return popstmt()()\r\n          }\r\n        , popstmt()\r\n        )\r\n\r\n    parse_return =\r\n        stative(\r\n          advance('return', 'keyword')\r\n        , function() {\r\n            if(token.data === ';') return Advance\r\n            return state.unshift(expr(';')), Advance\r\n          }\r\n        , function() { tokens.shift(), popstmt()() }\r\n        )\r\n\r\n    parse_whileloop =\r\n        stative(\r\n          advance('while', 'keyword')\r\n        , advance('(')\r\n        , advance_expr(')')\r\n        , advance(')')\r\n        , maybe_stmtlist(3)\r\n        , advance_stmtlist()\r\n        , advance('}')\r\n        , popstmt()\r\n        )\r\n\r\n    parse_dowhileloop =\r\n      stative(\r\n        advance('do', 'keyword')\r\n      , maybe_stmtlist(3)\r\n      , advance_stmtlist()\r\n      , advance('}')\r\n      , advance('while', 'keyword')\r\n      , advance('(')\r\n      , advance_expr(')')\r\n      , advance(')')\r\n      , popstmt()\r\n      )\r\n\r\n    parse_function =\r\n      stative(\r\n        function() {\r\n          for(var i = 1, len = state.length; i < len; ++i) if(state[i].mode === FUNCTION) {\r\n            return unexpected('function definition is not allowed within another function')\r\n          }\r\n\r\n          return Advance\r\n        }\r\n      , function() {\r\n          if(!assert(\"ident\")) return\r\n\r\n          var name = token.data\r\n            , lookup = state.scope.find(name)\r\n\r\n          state.unshift(ident())\r\n          state.scope.define(name)\r\n\r\n          state.scope.enter(lookup ? lookup.scope : null)\r\n          return Advance\r\n        }\r\n      , advance('(')\r\n      , function() { return state.unshift(fnargs()), Advance }\r\n      , advance(')')\r\n      , function() {\r\n          // forward decl\r\n          if(token.data === ';') {\r\n            return state.scope.exit(), state.shift(), state.shift()\r\n          }\r\n          return Advance\r\n        }\r\n      , advance('{')\r\n      , advance_stmtlist()\r\n      , advance('}')\r\n      , function() { state.scope.exit(); return Advance }\r\n      , function() { return state.shift(), state.shift(), state.shift() }\r\n      )\r\n\r\n    parse_function_args =\r\n      stative(\r\n        function() {\r\n          if(token.data === 'void') { state.fake(keyword()); tokens.shift(); return Advance }\r\n          if(token.data === ')') { state.shift(); return }\r\n          if(token.data === 'struct') {\r\n            state.unshift(struct(NO_ASSIGN_ALLOWED, NO_COMMA_ALLOWED))\r\n            return Advance\r\n          }\r\n          state.unshift(decl(DECL_FUNCTION))\r\n          return Advance\r\n        }\r\n      , function() {\r\n          if(token.data === ',') { tokens.shift(); return 0 }\r\n          if(token.data === ')') { state.shift(); return }\r\n          unexpected('expected one of `,` or `)`, got '+token.data)\r\n        }\r\n      )\r\n  }\r\n}\r\n\r\nfunction mknode(mode, sourcetoken) {\r\n  return {\r\n      mode: mode\r\n    , token: sourcetoken\r\n    , children: []\r\n    , type: stmt_type[mode]\r\n    , id: (Math.random() * 0xFFFFFFFF).toString(16)\r\n  }\r\n}\r\n\r\nfunction is_storage(token) {\r\n  return token.data === 'const' ||\r\n         token.data === 'attribute' ||\r\n         token.data === 'uniform' ||\r\n         token.data === 'varying'\r\n}\r\n\r\nfunction is_parameter(token) {\r\n  return token.data === 'in' ||\r\n         token.data === 'inout' ||\r\n         token.data === 'out'\r\n}\r\n\r\nfunction is_precision(token) {\r\n  return token.data === 'highp' ||\r\n         token.data === 'mediump' ||\r\n         token.data === 'lowp'\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/glsl-parser/lib/index.js?")},"./node_modules/glsl-parser/lib/scope.js":function(module,exports){eval("module.exports = scope\r\n\r\nfunction scope(state) {\r\n  if(this.constructor !== scope)\r\n    return new scope(state)\r\n\r\n  this.state = state\r\n  this.scopes = []\r\n  this.current = null\r\n}\r\n\r\nvar cons = scope\r\n  , proto = cons.prototype\r\n\r\nproto.enter = function(s) {\r\n  this.scopes.push(\r\n    this.current = this.state[0].scope = s || {}\r\n  )\r\n}\r\n\r\nproto.exit = function() {\r\n  this.scopes.pop()\r\n  this.current = this.scopes[this.scopes.length - 1]\r\n}\r\n\r\nproto.define = function(str) {\r\n  this.current[str] = this.state[0]\r\n}\r\n\r\nproto.find = function(name, fail) {\r\n  for(var i = this.scopes.length - 1; i > -1; --i) {\r\n    if(this.scopes[i].hasOwnProperty(name)) {\r\n      return this.scopes[i][name]\r\n    }\r\n  }\r\n\r\n  return null\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/glsl-parser/lib/scope.js?")},"./node_modules/glsl-tokenizer/index.js":function(module,exports,__webpack_require__){eval("module.exports = tokenize\r\n\r\nvar literals100 = __webpack_require__(\"./node_modules/glsl-tokenizer/lib/literals.js\")\r\n  , operators = __webpack_require__(\"./node_modules/glsl-tokenizer/lib/operators.js\")\r\n  , builtins100 = __webpack_require__(\"./node_modules/glsl-tokenizer/lib/builtins.js\")\r\n  , literals300es = __webpack_require__(\"./node_modules/glsl-tokenizer/lib/literals-300es.js\")\r\n  , builtins300es = __webpack_require__(\"./node_modules/glsl-tokenizer/lib/builtins-300es.js\")\r\n\r\nvar NORMAL = 999          // <-- never emitted\r\n  , TOKEN = 9999          // <-- never emitted\r\n  , BLOCK_COMMENT = 0\r\n  , LINE_COMMENT = 1\r\n  , PREPROCESSOR = 2\r\n  , OPERATOR = 3\r\n  , INTEGER = 4\r\n  , FLOAT = 5\r\n  , IDENT = 6\r\n  , BUILTIN = 7\r\n  , KEYWORD = 8\r\n  , WHITESPACE = 9\r\n  , EOF = 10\r\n  , HEX = 11\r\n\r\nvar map = [\r\n    'block-comment'\r\n  , 'line-comment'\r\n  , 'preprocessor'\r\n  , 'operator'\r\n  , 'integer'\r\n  , 'float'\r\n  , 'ident'\r\n  , 'builtin'\r\n  , 'keyword'\r\n  , 'whitespace'\r\n  , 'eof'\r\n  , 'integer'\r\n]\r\n\r\nfunction tokenize(opt) {\r\n  var i = 0\r\n    , total = 0\r\n    , mode = NORMAL\r\n    , c\r\n    , last\r\n    , content = []\r\n    , tokens = []\r\n    , token_idx = 0\r\n    , token_offs = 0\r\n    , line = 1\r\n    , col = 0\r\n    , start = 0\r\n    , isnum = false\r\n    , isoperator = false\r\n    , input = ''\r\n    , len\r\n\r\n  opt = opt || {}\r\n  var allBuiltins = builtins100\r\n  var allLiterals = literals100\r\n  if (opt.version === '300 es') {\r\n    allBuiltins = builtins300es\r\n    allLiterals = literals300es\r\n  }\r\n\r\n  // cache by name\r\n  var builtinsDict = {}, literalsDict = {}\r\n  for (var i = 0; i < allBuiltins.length; i++) {\r\n    builtinsDict[allBuiltins[i]] = true\r\n  }\r\n  for (var i = 0; i < allLiterals.length; i++) {\r\n    literalsDict[allLiterals[i]] = true\r\n  }\r\n\r\n  return function(data) {\r\n    tokens = []\r\n    if (data !== null) return write(data)\r\n    return end()\r\n  }\r\n\r\n  function token(data) {\r\n    if (data.length) {\r\n      tokens.push({\r\n        type: map[mode]\r\n      , data: data\r\n      , position: start\r\n      , line: line\r\n      , column: col\r\n      })\r\n    }\r\n  }\r\n\r\n  function write(chunk) {\r\n    i = 0\r\n\r\n    if (chunk.toString) chunk = chunk.toString()\r\n\r\n    input += chunk.replace(/\\r\\n/g, '\\n')\r\n    len = input.length\r\n\r\n\r\n    var last\r\n\r\n    while(c = input[i], i < len) {\r\n      last = i\r\n\r\n      switch(mode) {\r\n        case BLOCK_COMMENT: i = block_comment(); break\r\n        case LINE_COMMENT: i = line_comment(); break\r\n        case PREPROCESSOR: i = preprocessor(); break\r\n        case OPERATOR: i = operator(); break\r\n        case INTEGER: i = integer(); break\r\n        case HEX: i = hex(); break\r\n        case FLOAT: i = decimal(); break\r\n        case TOKEN: i = readtoken(); break\r\n        case WHITESPACE: i = whitespace(); break\r\n        case NORMAL: i = normal(); break\r\n      }\r\n\r\n      if(last !== i) {\r\n        switch(input[last]) {\r\n          case '\\n': col = 0; ++line; break\r\n          default: ++col; break\r\n        }\r\n      }\r\n    }\r\n\r\n    total += i\r\n    input = input.slice(i)\r\n    return tokens\r\n  }\r\n\r\n  function end(chunk) {\r\n    if(content.length) {\r\n      token(content.join(''))\r\n    }\r\n\r\n    mode = EOF\r\n    token('(eof)')\r\n    return tokens\r\n  }\r\n\r\n  function normal() {\r\n    content = content.length ? [] : content\r\n\r\n    if(last === '/' && c === '*') {\r\n      start = total + i - 1\r\n      mode = BLOCK_COMMENT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(last === '/' && c === '/') {\r\n      start = total + i - 1\r\n      mode = LINE_COMMENT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(c === '#') {\r\n      mode = PREPROCESSOR\r\n      start = total + i\r\n      return i\r\n    }\r\n\r\n    if(/\\s/.test(c)) {\r\n      mode = WHITESPACE\r\n      start = total + i\r\n      return i\r\n    }\r\n\r\n    isnum = /\\d/.test(c)\r\n    isoperator = /[^\\w_]/.test(c)\r\n\r\n    start = total + i\r\n    mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN\r\n    return i\r\n  }\r\n\r\n  function whitespace() {\r\n    if(/[^\\s]/g.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function preprocessor() {\r\n    if((c === '\\r' || c === '\\n') && last !== '\\\\') {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function line_comment() {\r\n    return preprocessor()\r\n  }\r\n\r\n  function block_comment() {\r\n    if(c === '/' && last === '*') {\r\n      content.push(c)\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i + 1\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function operator() {\r\n    if(last === '.' && /\\d/.test(c)) {\r\n      mode = FLOAT\r\n      return i\r\n    }\r\n\r\n    if(last === '/' && c === '*') {\r\n      mode = BLOCK_COMMENT\r\n      return i\r\n    }\r\n\r\n    if(last === '/' && c === '/') {\r\n      mode = LINE_COMMENT\r\n      return i\r\n    }\r\n\r\n    if(c === '.' && content.length) {\r\n      while(determine_operator(content));\r\n\r\n      mode = FLOAT\r\n      return i\r\n    }\r\n\r\n    if(c === ';' || c === ')' || c === '(') {\r\n      if(content.length) while(determine_operator(content));\r\n      token(c)\r\n      mode = NORMAL\r\n      return i + 1\r\n    }\r\n\r\n    var is_composite_operator = content.length === 2 && c !== '='\r\n    if(/[\\w_\\d\\s]/.test(c) || is_composite_operator) {\r\n      while(determine_operator(content));\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function determine_operator(buf) {\r\n    var j = 0\r\n      , idx\r\n      , res\r\n\r\n    do {\r\n      idx = operators.indexOf(buf.slice(0, buf.length + j).join(''))\r\n      res = operators[idx]\r\n\r\n      if(idx === -1) {\r\n        if(j-- + buf.length > 0) continue\r\n        res = buf.slice(0, 1).join('')\r\n      }\r\n\r\n      token(res)\r\n\r\n      start += res.length\r\n      content = content.slice(res.length)\r\n      return content.length\r\n    } while(1)\r\n  }\r\n\r\n  function hex() {\r\n    if(/[^a-fA-F0-9]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function integer() {\r\n    if(c === '.') {\r\n      content.push(c)\r\n      mode = FLOAT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[eE]/.test(c)) {\r\n      content.push(c)\r\n      mode = FLOAT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(c === 'x' && content.length === 1 && content[0] === '0') {\r\n      mode = HEX\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[^\\d]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function decimal() {\r\n    if(c === 'f') {\r\n      content.push(c)\r\n      last = c\r\n      i += 1\r\n    }\r\n\r\n    if(/[eE]/.test(c)) {\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if ((c === '-' || c === '+') && /[eE]/.test(last)) {\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[^\\d]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function readtoken() {\r\n    if(/[^\\d\\w_]/.test(c)) {\r\n      var contentstr = content.join('')\r\n      if(literalsDict[contentstr]) {\r\n        mode = KEYWORD\r\n      } else if(builtinsDict[contentstr]) {\r\n        mode = BUILTIN\r\n      } else {\r\n        mode = IDENT\r\n      }\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/glsl-tokenizer/index.js?")},"./node_modules/glsl-tokenizer/lib/builtins-300es.js":function(module,exports,__webpack_require__){eval("// 300es builtins/reserved words that were previously valid in v100\r\nvar v100 = __webpack_require__(\"./node_modules/glsl-tokenizer/lib/builtins.js\")\r\n\r\n// The texture2D|Cube functions have been removed\r\n// And the gl_ features are updated\r\nv100 = v100.slice().filter(function (b) {\r\n  return !/^(gl\\_|texture)/.test(b)\r\n})\r\n\r\nmodule.exports = v100.concat([\r\n  // the updated gl_ constants\r\n    'gl_VertexID'\r\n  , 'gl_InstanceID'\r\n  , 'gl_Position'\r\n  , 'gl_PointSize'\r\n  , 'gl_FragCoord'\r\n  , 'gl_FrontFacing'\r\n  , 'gl_FragDepth'\r\n  , 'gl_PointCoord'\r\n  , 'gl_MaxVertexAttribs'\r\n  , 'gl_MaxVertexUniformVectors'\r\n  , 'gl_MaxVertexOutputVectors'\r\n  , 'gl_MaxFragmentInputVectors'\r\n  , 'gl_MaxVertexTextureImageUnits'\r\n  , 'gl_MaxCombinedTextureImageUnits'\r\n  , 'gl_MaxTextureImageUnits'\r\n  , 'gl_MaxFragmentUniformVectors'\r\n  , 'gl_MaxDrawBuffers'\r\n  , 'gl_MinProgramTexelOffset'\r\n  , 'gl_MaxProgramTexelOffset'\r\n  , 'gl_DepthRangeParameters'\r\n  , 'gl_DepthRange'\r\n\r\n  // other builtins\r\n  , 'trunc'\r\n  , 'round'\r\n  , 'roundEven'\r\n  , 'isnan'\r\n  , 'isinf'\r\n  , 'floatBitsToInt'\r\n  , 'floatBitsToUint'\r\n  , 'intBitsToFloat'\r\n  , 'uintBitsToFloat'\r\n  , 'packSnorm2x16'\r\n  , 'unpackSnorm2x16'\r\n  , 'packUnorm2x16'\r\n  , 'unpackUnorm2x16'\r\n  , 'packHalf2x16'\r\n  , 'unpackHalf2x16'\r\n  , 'outerProduct'\r\n  , 'transpose'\r\n  , 'determinant'\r\n  , 'inverse'\r\n  , 'texture'\r\n  , 'textureSize'\r\n  , 'textureProj'\r\n  , 'textureLod'\r\n  , 'textureOffset'\r\n  , 'texelFetch'\r\n  , 'texelFetchOffset'\r\n  , 'textureProjOffset'\r\n  , 'textureLodOffset'\r\n  , 'textureProjLod'\r\n  , 'textureProjLodOffset'\r\n  , 'textureGrad'\r\n  , 'textureGradOffset'\r\n  , 'textureProjGrad'\r\n  , 'textureProjGradOffset'\r\n])\r\n\n\n//# sourceURL=webpack:///./node_modules/glsl-tokenizer/lib/builtins-300es.js?")},"./node_modules/glsl-tokenizer/lib/builtins.js":function(module,exports){eval("module.exports = [\r\n  // Keep this list sorted\r\n  'abs'\r\n  , 'acos'\r\n  , 'all'\r\n  , 'any'\r\n  , 'asin'\r\n  , 'atan'\r\n  , 'ceil'\r\n  , 'clamp'\r\n  , 'cos'\r\n  , 'cross'\r\n  , 'dFdx'\r\n  , 'dFdy'\r\n  , 'degrees'\r\n  , 'distance'\r\n  , 'dot'\r\n  , 'equal'\r\n  , 'exp'\r\n  , 'exp2'\r\n  , 'faceforward'\r\n  , 'floor'\r\n  , 'fract'\r\n  , 'gl_BackColor'\r\n  , 'gl_BackLightModelProduct'\r\n  , 'gl_BackLightProduct'\r\n  , 'gl_BackMaterial'\r\n  , 'gl_BackSecondaryColor'\r\n  , 'gl_ClipPlane'\r\n  , 'gl_ClipVertex'\r\n  , 'gl_Color'\r\n  , 'gl_DepthRange'\r\n  , 'gl_DepthRangeParameters'\r\n  , 'gl_EyePlaneQ'\r\n  , 'gl_EyePlaneR'\r\n  , 'gl_EyePlaneS'\r\n  , 'gl_EyePlaneT'\r\n  , 'gl_Fog'\r\n  , 'gl_FogCoord'\r\n  , 'gl_FogFragCoord'\r\n  , 'gl_FogParameters'\r\n  , 'gl_FragColor'\r\n  , 'gl_FragCoord'\r\n  , 'gl_FragData'\r\n  , 'gl_FragDepth'\r\n  , 'gl_FragDepthEXT'\r\n  , 'gl_FrontColor'\r\n  , 'gl_FrontFacing'\r\n  , 'gl_FrontLightModelProduct'\r\n  , 'gl_FrontLightProduct'\r\n  , 'gl_FrontMaterial'\r\n  , 'gl_FrontSecondaryColor'\r\n  , 'gl_LightModel'\r\n  , 'gl_LightModelParameters'\r\n  , 'gl_LightModelProducts'\r\n  , 'gl_LightProducts'\r\n  , 'gl_LightSource'\r\n  , 'gl_LightSourceParameters'\r\n  , 'gl_MaterialParameters'\r\n  , 'gl_MaxClipPlanes'\r\n  , 'gl_MaxCombinedTextureImageUnits'\r\n  , 'gl_MaxDrawBuffers'\r\n  , 'gl_MaxFragmentUniformComponents'\r\n  , 'gl_MaxLights'\r\n  , 'gl_MaxTextureCoords'\r\n  , 'gl_MaxTextureImageUnits'\r\n  , 'gl_MaxTextureUnits'\r\n  , 'gl_MaxVaryingFloats'\r\n  , 'gl_MaxVertexAttribs'\r\n  , 'gl_MaxVertexTextureImageUnits'\r\n  , 'gl_MaxVertexUniformComponents'\r\n  , 'gl_ModelViewMatrix'\r\n  , 'gl_ModelViewMatrixInverse'\r\n  , 'gl_ModelViewMatrixInverseTranspose'\r\n  , 'gl_ModelViewMatrixTranspose'\r\n  , 'gl_ModelViewProjectionMatrix'\r\n  , 'gl_ModelViewProjectionMatrixInverse'\r\n  , 'gl_ModelViewProjectionMatrixInverseTranspose'\r\n  , 'gl_ModelViewProjectionMatrixTranspose'\r\n  , 'gl_MultiTexCoord0'\r\n  , 'gl_MultiTexCoord1'\r\n  , 'gl_MultiTexCoord2'\r\n  , 'gl_MultiTexCoord3'\r\n  , 'gl_MultiTexCoord4'\r\n  , 'gl_MultiTexCoord5'\r\n  , 'gl_MultiTexCoord6'\r\n  , 'gl_MultiTexCoord7'\r\n  , 'gl_Normal'\r\n  , 'gl_NormalMatrix'\r\n  , 'gl_NormalScale'\r\n  , 'gl_ObjectPlaneQ'\r\n  , 'gl_ObjectPlaneR'\r\n  , 'gl_ObjectPlaneS'\r\n  , 'gl_ObjectPlaneT'\r\n  , 'gl_Point'\r\n  , 'gl_PointCoord'\r\n  , 'gl_PointParameters'\r\n  , 'gl_PointSize'\r\n  , 'gl_Position'\r\n  , 'gl_ProjectionMatrix'\r\n  , 'gl_ProjectionMatrixInverse'\r\n  , 'gl_ProjectionMatrixInverseTranspose'\r\n  , 'gl_ProjectionMatrixTranspose'\r\n  , 'gl_SecondaryColor'\r\n  , 'gl_TexCoord'\r\n  , 'gl_TextureEnvColor'\r\n  , 'gl_TextureMatrix'\r\n  , 'gl_TextureMatrixInverse'\r\n  , 'gl_TextureMatrixInverseTranspose'\r\n  , 'gl_TextureMatrixTranspose'\r\n  , 'gl_Vertex'\r\n  , 'greaterThan'\r\n  , 'greaterThanEqual'\r\n  , 'inversesqrt'\r\n  , 'length'\r\n  , 'lessThan'\r\n  , 'lessThanEqual'\r\n  , 'log'\r\n  , 'log2'\r\n  , 'matrixCompMult'\r\n  , 'max'\r\n  , 'min'\r\n  , 'mix'\r\n  , 'mod'\r\n  , 'normalize'\r\n  , 'not'\r\n  , 'notEqual'\r\n  , 'pow'\r\n  , 'radians'\r\n  , 'reflect'\r\n  , 'refract'\r\n  , 'sign'\r\n  , 'sin'\r\n  , 'smoothstep'\r\n  , 'sqrt'\r\n  , 'step'\r\n  , 'tan'\r\n  , 'texture2D'\r\n  , 'texture2DLod'\r\n  , 'texture2DProj'\r\n  , 'texture2DProjLod'\r\n  , 'textureCube'\r\n  , 'textureCubeLod'\r\n  , 'texture2DLodEXT'\r\n  , 'texture2DProjLodEXT'\r\n  , 'textureCubeLodEXT'\r\n  , 'texture2DGradEXT'\r\n  , 'texture2DProjGradEXT'\r\n  , 'textureCubeGradEXT'\r\n]\r\n\n\n//# sourceURL=webpack:///./node_modules/glsl-tokenizer/lib/builtins.js?")},"./node_modules/glsl-tokenizer/lib/literals-300es.js":function(module,exports,__webpack_require__){eval("var v100 = __webpack_require__(\"./node_modules/glsl-tokenizer/lib/literals.js\")\r\n\r\nmodule.exports = v100.slice().concat([\r\n   'layout'\r\n  , 'centroid'\r\n  , 'smooth'\r\n  , 'case'\r\n  , 'mat2x2'\r\n  , 'mat2x3'\r\n  , 'mat2x4'\r\n  , 'mat3x2'\r\n  , 'mat3x3'\r\n  , 'mat3x4'\r\n  , 'mat4x2'\r\n  , 'mat4x3'\r\n  , 'mat4x4'\r\n  , 'uvec2'\r\n  , 'uvec3'\r\n  , 'uvec4'\r\n  , 'samplerCubeShadow'\r\n  , 'sampler2DArray'\r\n  , 'sampler2DArrayShadow'\r\n  , 'isampler2D'\r\n  , 'isampler3D'\r\n  , 'isamplerCube'\r\n  , 'isampler2DArray'\r\n  , 'usampler2D'\r\n  , 'usampler3D'\r\n  , 'usamplerCube'\r\n  , 'usampler2DArray'\r\n  , 'coherent'\r\n  , 'restrict'\r\n  , 'readonly'\r\n  , 'writeonly'\r\n  , 'resource'\r\n  , 'atomic_uint'\r\n  , 'noperspective'\r\n  , 'patch'\r\n  , 'sample'\r\n  , 'subroutine'\r\n  , 'common'\r\n  , 'partition'\r\n  , 'active'\r\n  , 'filter'\r\n  , 'image1D'\r\n  , 'image2D'\r\n  , 'image3D'\r\n  , 'imageCube'\r\n  , 'iimage1D'\r\n  , 'iimage2D'\r\n  , 'iimage3D'\r\n  , 'iimageCube'\r\n  , 'uimage1D'\r\n  , 'uimage2D'\r\n  , 'uimage3D'\r\n  , 'uimageCube'\r\n  , 'image1DArray'\r\n  , 'image2DArray'\r\n  , 'iimage1DArray'\r\n  , 'iimage2DArray'\r\n  , 'uimage1DArray'\r\n  , 'uimage2DArray'\r\n  , 'image1DShadow'\r\n  , 'image2DShadow'\r\n  , 'image1DArrayShadow'\r\n  , 'image2DArrayShadow'\r\n  , 'imageBuffer'\r\n  , 'iimageBuffer'\r\n  , 'uimageBuffer'\r\n  , 'sampler1DArray'\r\n  , 'sampler1DArrayShadow'\r\n  , 'isampler1D'\r\n  , 'isampler1DArray'\r\n  , 'usampler1D'\r\n  , 'usampler1DArray'\r\n  , 'isampler2DRect'\r\n  , 'usampler2DRect'\r\n  , 'samplerBuffer'\r\n  , 'isamplerBuffer'\r\n  , 'usamplerBuffer'\r\n  , 'sampler2DMS'\r\n  , 'isampler2DMS'\r\n  , 'usampler2DMS'\r\n  , 'sampler2DMSArray'\r\n  , 'isampler2DMSArray'\r\n  , 'usampler2DMSArray'\r\n])\r\n\n\n//# sourceURL=webpack:///./node_modules/glsl-tokenizer/lib/literals-300es.js?")},"./node_modules/glsl-tokenizer/lib/literals.js":function(module,exports){eval("module.exports = [\r\n  // current\r\n    'precision'\r\n  , 'highp'\r\n  , 'mediump'\r\n  , 'lowp'\r\n  , 'attribute'\r\n  , 'const'\r\n  , 'uniform'\r\n  , 'varying'\r\n  , 'break'\r\n  , 'continue'\r\n  , 'do'\r\n  , 'for'\r\n  , 'while'\r\n  , 'if'\r\n  , 'else'\r\n  , 'in'\r\n  , 'out'\r\n  , 'inout'\r\n  , 'float'\r\n  , 'int'\r\n  , 'uint'\r\n  , 'void'\r\n  , 'bool'\r\n  , 'true'\r\n  , 'false'\r\n  , 'discard'\r\n  , 'return'\r\n  , 'mat2'\r\n  , 'mat3'\r\n  , 'mat4'\r\n  , 'vec2'\r\n  , 'vec3'\r\n  , 'vec4'\r\n  , 'ivec2'\r\n  , 'ivec3'\r\n  , 'ivec4'\r\n  , 'bvec2'\r\n  , 'bvec3'\r\n  , 'bvec4'\r\n  , 'sampler1D'\r\n  , 'sampler2D'\r\n  , 'sampler3D'\r\n  , 'samplerCube'\r\n  , 'sampler1DShadow'\r\n  , 'sampler2DShadow'\r\n  , 'struct'\r\n\r\n  // future\r\n  , 'asm'\r\n  , 'class'\r\n  , 'union'\r\n  , 'enum'\r\n  , 'typedef'\r\n  , 'template'\r\n  , 'this'\r\n  , 'packed'\r\n  , 'goto'\r\n  , 'switch'\r\n  , 'default'\r\n  , 'inline'\r\n  , 'noinline'\r\n  , 'volatile'\r\n  , 'public'\r\n  , 'static'\r\n  , 'extern'\r\n  , 'external'\r\n  , 'interface'\r\n  , 'long'\r\n  , 'short'\r\n  , 'double'\r\n  , 'half'\r\n  , 'fixed'\r\n  , 'unsigned'\r\n  , 'input'\r\n  , 'output'\r\n  , 'hvec2'\r\n  , 'hvec3'\r\n  , 'hvec4'\r\n  , 'dvec2'\r\n  , 'dvec3'\r\n  , 'dvec4'\r\n  , 'fvec2'\r\n  , 'fvec3'\r\n  , 'fvec4'\r\n  , 'sampler2DRect'\r\n  , 'sampler3DRect'\r\n  , 'sampler2DRectShadow'\r\n  , 'sizeof'\r\n  , 'cast'\r\n  , 'namespace'\r\n  , 'using'\r\n]\r\n\n\n//# sourceURL=webpack:///./node_modules/glsl-tokenizer/lib/literals.js?")},"./node_modules/glsl-tokenizer/lib/operators.js":function(module,exports){eval("module.exports = [\r\n    '<<='\r\n  , '>>='\r\n  , '++'\r\n  , '--'\r\n  , '<<'\r\n  , '>>'\r\n  , '<='\r\n  , '>='\r\n  , '=='\r\n  , '!='\r\n  , '&&'\r\n  , '||'\r\n  , '+='\r\n  , '-='\r\n  , '*='\r\n  , '/='\r\n  , '%='\r\n  , '&='\r\n  , '^^'\r\n  , '^='\r\n  , '|='\r\n  , '('\r\n  , ')'\r\n  , '['\r\n  , ']'\r\n  , '.'\r\n  , '!'\r\n  , '~'\r\n  , '*'\r\n  , '/'\r\n  , '%'\r\n  , '+'\r\n  , '-'\r\n  , '<'\r\n  , '>'\r\n  , '&'\r\n  , '^'\r\n  , '|'\r\n  , '?'\r\n  , ':'\r\n  , '='\r\n  , ','\r\n  , ';'\r\n  , '{'\r\n  , '}'\r\n]\r\n\n\n//# sourceURL=webpack:///./node_modules/glsl-tokenizer/lib/operators.js?")},"./node_modules/glsl-tokenizer/string.js":function(module,exports,__webpack_require__){eval('var tokenize = __webpack_require__("./node_modules/glsl-tokenizer/index.js")\r\n\r\nmodule.exports = tokenizeString\r\n\r\nfunction tokenizeString(str, opt) {\r\n  var generator = tokenize(opt)\r\n  var tokens = []\r\n\r\n  tokens = tokens.concat(generator(str))\r\n  tokens = tokens.concat(generator(null))\r\n\r\n  return tokens\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/glsl-tokenizer/string.js?')}}]);