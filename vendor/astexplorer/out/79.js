(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{"./node_modules/pbkit/core/parser/proto.js":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.parseConstant = exports.parse = void 0;\nconst recursive_descent_parser_1 = __webpack_require__("./node_modules/pbkit/core/parser/recursive-descent-parser.js");\nfunction parse(text) {\n    const parser = (0, recursive_descent_parser_1.createRecursiveDescentParser)(text);\n    const statements = acceptStatements(parser, [\n        acceptSyntax,\n        acceptImport,\n        acceptPackage,\n        acceptOption,\n        acceptMessage,\n        acceptEnum,\n        acceptExtend,\n        acceptService,\n        acceptEmpty,\n    ]);\n    const ast = { statements };\n    return { ast, parser };\n}\nexports.parse = parse;\nfunction parseConstant(text) {\n    const parser = (0, recursive_descent_parser_1.createRecursiveDescentParser)(text);\n    const constant = expectConstant(parser);\n    return { ast: constant, parser };\n}\nexports.parseConstant = parseConstant;\nfunction mergeSpans(spans) {\n    let start = Infinity;\n    let end = -Infinity;\n    for (let i = 0; i < spans.length; ++i) {\n        if (spans[i] == null)\n            continue;\n        const span = Array.isArray(spans[i])\n            ? mergeSpans(spans[i])\n            : spans[i];\n        start = Math.min(start, span.start);\n        end = Math.max(end, span.end);\n    }\n    return { start, end };\n}\nfunction acceptPatternAndThen(pattern, then) {\n    return function accept(parser) {\n        const token = parser.accept(pattern);\n        if (!token)\n            return;\n        return then(token);\n    };\n}\nfunction choice(acceptFns) {\n    return function accept(parser) {\n        for (const acceptFn of acceptFns) {\n            const node = acceptFn(parser);\n            if (node)\n                return node;\n        }\n    };\n}\nfunction many(parser, acceptFn) {\n    const nodes = [];\n    let node;\n    while (node = acceptFn(parser))\n        nodes.push(node);\n    return nodes;\n}\nfunction acceptComplexSequence(parser, expectFnSeq, escapePattern) {\n    const result = {};\n    let partial = false;\n    let hasNewline = false;\n    let recoveryPoint;\n    for (const [key, expectFn] of expectFnSeq) {\n        const loc = parser.loc;\n        hasNewline = skipWsAndComments2(parser);\n        if (hasNewline && !recoveryPoint) {\n            recoveryPoint = { loc: parser.loc, result: { ...result } };\n        }\n        try {\n            result[key] = expectFn(parser);\n        }\n        catch {\n            parser.loc = loc;\n            partial = true;\n            if (escapePattern && parser.try(escapePattern))\n                break;\n        }\n    }\n    if (partial && recoveryPoint) {\n        parser.loc = recoveryPoint.loc;\n        return { partial, result: recoveryPoint.result };\n    }\n    return { partial, result };\n}\nfunction acceptStatements(parser, acceptStatementFns) {\n    const statements = [];\n    statements: while (true) {\n        const { commentGroups, trailingNewline } = skipWsAndSweepComments(parser);\n        let leadingComments;\n        let leadingDetachedComments;\n        if (trailingNewline) {\n            leadingComments = [];\n            leadingDetachedComments = commentGroups;\n        }\n        else {\n            if (commentGroups.length < 1) {\n                leadingComments = [];\n                leadingDetachedComments = [];\n            }\n            else {\n                leadingComments = [commentGroups.pop()];\n                leadingDetachedComments = commentGroups;\n            }\n        }\n        for (const acceptStatementFn of acceptStatementFns) {\n            const statement = acceptStatementFn(parser, leadingComments, leadingDetachedComments);\n            if (statement) {\n                statements.push(statement);\n                continue statements;\n            }\n        }\n        break;\n    }\n    return statements;\n}\nconst whitespacePattern = /^\\s+/;\nconst whitespaceWithoutNewlinePattern = /^[ \\f\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/;\nconst newlinePattern = /^\\r?\\n/;\nconst multilineCommentPattern = /^\\/\\*(?:.|\\r?\\n)*?\\*\\//;\nconst singlelineCommentPattern = /^\\/\\/.*(?:\\r?\\n|$)/;\nconst intLitPattern = /^0(?:x[0-9a-f]+|[0-7]*)|^[1-9]\\d*/i;\nconst floatLitPattern = /^\\d+\\.\\d*(?:e[-+]?\\d+)?|^\\d+e[-+]?\\d+|^\\.\\d+(?:e[-+]?\\d+)?|^inf|^nan/i;\nconst boolLitPattern = /^true|^false/;\nconst strLitPattern = /^\'(?:\\\\x[0-9a-f]{2}|\\\\[0-7]{3}|\\\\[0-7]|\\\\[abfnrtv\\\\\\?\'"]|[^\'\\0\\n\\\\])*\'|^"(?:\\\\x[0-9a-f]{2}|\\\\[0-7]{3}|\\\\[0-7]|\\\\[abfnrtv\\\\\\?\'"]|[^"\\0\\n\\\\])*"/i;\nconst identPattern = /^[a-z_][a-z0-9_]*/i;\nconst messageBodyStatementKeywordPattern = /^(?:enum|message|extend|extensions|group|option|oneof|map|reserved)\\b/;\nconst acceptDot = acceptPatternAndThen(".", (dot) => ({ type: "dot", ...dot }));\nconst acceptComma = acceptPatternAndThen(",", (comma) => ({ type: "comma", ...comma }));\nconst acceptSemi = acceptPatternAndThen(";", (semi) => ({ type: "semi", ...semi }));\nfunction expectSemi(parser) {\n    const semi = acceptSemi(parser);\n    if (semi)\n        return semi;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [";"]);\n}\nconst acceptIdent = acceptPatternAndThen(identPattern, (ident) => ({ type: "ident", ...ident }));\nfunction acceptSpecialToken(parser, type, pattern = identPattern) {\n    const token = parser.accept(pattern);\n    if (!token)\n        return;\n    return { type, ...token };\n}\nfunction acceptKeyword(parser, pattern = identPattern) {\n    return acceptSpecialToken(parser, "keyword", pattern);\n}\nfunction acceptCommentGroup(parser) {\n    const loc = parser.loc;\n    const comments = [];\n    while (true) {\n        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);\n        if (whitespace)\n            continue;\n        const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);\n        if (multilineComment) {\n            comments.push(multilineComment);\n            continue;\n        }\n        const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);\n        if (singlelineComment) {\n            comments.push(singlelineComment);\n            continue;\n        }\n        break;\n    }\n    if (comments.length < 1) {\n        parser.loc = loc;\n        return;\n    }\n    return {\n        ...mergeSpans(comments),\n        type: "comment-group",\n        comments,\n    };\n}\nfunction acceptTrailingComments(parser) {\n    const loc = parser.loc;\n    const comments = [];\n    while (true) {\n        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);\n        if (whitespace)\n            continue;\n        const newline = parser.accept(newlinePattern);\n        if (newline)\n            break;\n        const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);\n        if (multilineComment) {\n            comments.push(multilineComment);\n            continue;\n        }\n        const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);\n        if (singlelineComment) {\n            comments.push(singlelineComment);\n            break;\n        }\n        break;\n    }\n    if (comments.length < 1) {\n        parser.loc = loc;\n        return [];\n    }\n    return [{\n            ...mergeSpans(comments),\n            type: "comment-group",\n            comments,\n        }];\n}\nfunction skipWsAndSweepComments(parser) {\n    const commentGroups = [];\n    let trailingNewline = false;\n    parser.accept(whitespacePattern);\n    while (true) {\n        const commentGroup = acceptCommentGroup(parser);\n        if (commentGroup) {\n            commentGroups.push(commentGroup);\n            trailingNewline = false;\n            continue;\n        }\n        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);\n        if (whitespace)\n            continue;\n        const newline = parser.accept(newlinePattern);\n        if (newline) {\n            trailingNewline = true;\n            continue;\n        }\n        break;\n    }\n    return {\n        commentGroups,\n        trailingNewline,\n    };\n}\nfunction skipWsAndComments(parser) {\n    while (true) {\n        const whitespace = parser.accept(whitespacePattern);\n        if (whitespace)\n            continue;\n        const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);\n        if (multilineComment)\n            continue;\n        const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);\n        if (singlelineComment)\n            continue;\n        break;\n    }\n    return;\n}\nfunction skipWsAndComments2(parser) {\n    let hasNewline = false;\n    while (true) {\n        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);\n        if (whitespace)\n            continue;\n        const newline = parser.accept(newlinePattern);\n        if (newline) {\n            hasNewline = true;\n            continue;\n        }\n        const multilineComment = acceptSpecialToken(parser, "multiline-comment", multilineCommentPattern);\n        if (multilineComment)\n            continue;\n        const singlelineComment = acceptSpecialToken(parser, "singleline-comment", singlelineCommentPattern);\n        if (singlelineComment) {\n            hasNewline = true;\n            continue;\n        }\n        break;\n    }\n    return hasNewline;\n}\nfunction acceptFullIdent(parser) {\n    const identOrDots = many(parser, choice([\n        acceptDot,\n        acceptIdent,\n    ]));\n    if (identOrDots.length < 1)\n        return;\n    return {\n        ...mergeSpans(identOrDots),\n        type: "full-ident",\n        identOrDots,\n    };\n}\nfunction expectFullIdent(parser) {\n    const fullIdent = acceptFullIdent(parser);\n    if (fullIdent)\n        return fullIdent;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [".", identPattern]);\n}\nfunction acceptType(parser) {\n    const identOrDots = many(parser, choice([\n        acceptDot,\n        acceptIdent,\n    ]));\n    if (identOrDots.length < 1)\n        return;\n    return {\n        ...mergeSpans(identOrDots),\n        type: "type",\n        identOrDots,\n    };\n}\nfunction expectType(parser) {\n    const type = acceptType(parser);\n    if (type)\n        return type;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [".", identPattern]);\n}\nfunction acceptIntLit(parser) {\n    const intLit = parser.accept(intLitPattern);\n    if (!intLit)\n        return;\n    return { type: "int-lit", ...intLit };\n}\nfunction expectIntLit(parser) {\n    const intLit = acceptIntLit(parser);\n    if (intLit)\n        return intLit;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [intLitPattern]);\n}\nfunction acceptSignedIntLit(parser) {\n    var _a;\n    const loc = parser.loc;\n    const sign = (_a = parser.accept("-")) !== null && _a !== void 0 ? _a : parser.accept("+");\n    const intLit = acceptIntLit(parser);\n    if (!intLit) {\n        parser.loc = loc;\n        return;\n    }\n    return {\n        ...mergeSpans([sign, intLit]),\n        type: "signed-int-lit",\n        sign,\n        value: intLit,\n    };\n}\nfunction expectSignedIntLit(parser) {\n    const signedIntLit = acceptSignedIntLit(parser);\n    if (signedIntLit)\n        return signedIntLit;\n    throw new recursive_descent_parser_1.SyntaxError(parser, ["-", intLitPattern]);\n}\nfunction acceptFloatLit(parser) {\n    const floatLit = parser.accept(floatLitPattern);\n    if (!floatLit)\n        return;\n    return { type: "float-lit", ...floatLit };\n}\nfunction acceptSignedFloatLit(parser) {\n    var _a;\n    const loc = parser.loc;\n    const sign = (_a = parser.accept("-")) !== null && _a !== void 0 ? _a : parser.accept("+");\n    const floatLit = acceptFloatLit(parser);\n    if (!floatLit) {\n        parser.loc = loc;\n        return;\n    }\n    return {\n        ...mergeSpans([sign, floatLit]),\n        type: "signed-float-lit",\n        sign,\n        value: floatLit,\n    };\n}\nfunction acceptBoolLit(parser) {\n    const boolLit = parser.accept(boolLitPattern);\n    if (!boolLit)\n        return;\n    return { type: "bool-lit", ...boolLit };\n}\nfunction acceptStrLit(parser) {\n    const strLit = parser.accept(strLitPattern);\n    if (!strLit)\n        return;\n    const tokens = [strLit];\n    while (true) {\n        skipWsAndComments(parser);\n        const strLit = parser.accept(strLitPattern);\n        if (!strLit)\n            break;\n        tokens.push(strLit);\n    }\n    return { ...mergeSpans(tokens), type: "str-lit", tokens };\n}\nfunction expectStrLit(parser) {\n    const strLit = acceptStrLit(parser);\n    if (strLit)\n        return strLit;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [strLitPattern]);\n}\n// https://github.com/protocolbuffers/protobuf/blob/c2148566c7/src/google/protobuf/compiler/parser.cc#L1429-L1452\nfunction acceptAggregate(parser) {\n    const parenthesisOpen = parser.accept("{");\n    if (!parenthesisOpen)\n        return;\n    let character = parenthesisOpen;\n    let depth = 1;\n    while (character = parser.expect(/^(?:\\s|\\S)/)) {\n        switch (character.text) {\n            case "{":\n                ++depth;\n                break;\n            case "}":\n                --depth;\n                break;\n        }\n        if (depth === 0) {\n            break;\n        }\n    }\n    return {\n        ...mergeSpans([parenthesisOpen, character]),\n        type: "aggregate",\n    };\n}\nfunction acceptConstant(parser) {\n    var _a, _b, _c, _d, _e;\n    return (_e = (_d = (_c = (_b = (_a = acceptSignedFloatLit(parser)) !== null && _a !== void 0 ? _a : acceptSignedIntLit(parser)) !== null && _b !== void 0 ? _b : acceptStrLit(parser)) !== null && _c !== void 0 ? _c : acceptBoolLit(parser)) !== null && _d !== void 0 ? _d : acceptFullIdent(parser)) !== null && _e !== void 0 ? _e : acceptAggregate(parser);\n}\nfunction expectConstant(parser) {\n    const constant = acceptConstant(parser);\n    if (constant)\n        return constant;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [\n        identPattern,\n        "-",\n        "+",\n        intLitPattern,\n        strLitPattern,\n        boolLitPattern,\n    ]);\n}\nfunction acceptOptionNameSegment(parser) {\n    const bracketOpen = parser.accept("(");\n    const name = acceptFullIdent(parser);\n    if (!name) {\n        if (bracketOpen)\n            throw new recursive_descent_parser_1.SyntaxError(parser, [identPattern]);\n        return;\n    }\n    const bracketClose = parser[bracketOpen ? "expect" : "accept"](")");\n    return {\n        ...mergeSpans([bracketOpen, name, bracketClose]),\n        type: "option-name-segment",\n        bracketOpen,\n        name,\n        bracketClose,\n    };\n}\nfunction acceptOptionName(parser) {\n    const optionNameSegmentOrDots = many(parser, choice([\n        acceptDot,\n        acceptOptionNameSegment,\n    ]));\n    if (optionNameSegmentOrDots.length < 1)\n        return;\n    return {\n        ...mergeSpans(optionNameSegmentOrDots),\n        type: "option-name",\n        optionNameSegmentOrDots,\n    };\n}\nfunction expectOptionName(parser) {\n    const optionName = acceptOptionName(parser);\n    if (optionName)\n        return optionName;\n    throw new recursive_descent_parser_1.SyntaxError(parser, ["(", identPattern]);\n}\nfunction acceptSyntax(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "syntax");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const eq = parser.expect("=");\n    skipWsAndComments(parser);\n    const quoteOpen = parser.expect(/^[\'"]/);\n    const syntax = parser.expect(/^[^\'"]+/);\n    const quoteClose = parser.expect(/^[\'"]/);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "syntax",\n        keyword,\n        eq,\n        quoteOpen,\n        syntax,\n        quoteClose,\n        semi,\n    };\n}\nfunction acceptImport(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "import");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const weakOrPublic = parser.accept(/^weak|^public/);\n    skipWsAndComments(parser);\n    const strLit = expectStrLit(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "import",\n        keyword,\n        weakOrPublic,\n        strLit,\n        semi,\n    };\n}\nfunction acceptPackage(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "package");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const fullIdent = expectFullIdent(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "package",\n        keyword,\n        fullIdent,\n        semi,\n    };\n}\nfunction acceptOption(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, /^option\\b/);\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const optionName = expectOptionName(parser);\n    skipWsAndComments(parser);\n    const eq = parser.expect("=");\n    skipWsAndComments(parser);\n    const constant = expectConstant(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "option",\n        keyword,\n        optionName,\n        eq,\n        constant,\n        semi,\n    };\n}\nfunction acceptEmpty(parser, leadingComments, leadingDetachedComments) {\n    const semi = acceptSemi(parser);\n    if (!semi)\n        return;\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "empty",\n        semi,\n    };\n}\nfunction acceptFieldOption(parser) {\n    const optionName = acceptOptionName(parser);\n    if (!optionName)\n        return;\n    skipWsAndComments(parser);\n    const eq = parser.expect("=");\n    skipWsAndComments(parser);\n    const constant = expectConstant(parser);\n    return {\n        ...mergeSpans([optionName, constant]),\n        type: "field-option",\n        optionName,\n        eq,\n        constant,\n    };\n}\nfunction acceptFieldOptions(parser) {\n    const bracketOpen = parser.accept("[");\n    if (!bracketOpen)\n        return;\n    const fieldOptionOrCommas = many(parser, choice([\n        skipWsAndComments,\n        acceptComma,\n        acceptFieldOption,\n    ]));\n    const bracketClose = parser.expect("]");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: "field-options",\n        bracketOpen,\n        fieldOptionOrCommas,\n        bracketClose,\n    };\n}\nfunction acceptEnumField(parser, leadingComments, leadingDetachedComments) {\n    const fieldName = parser.accept(identPattern);\n    if (!fieldName)\n        return;\n    skipWsAndComments(parser);\n    const eq = parser.expect("=");\n    skipWsAndComments(parser);\n    const fieldNumber = expectSignedIntLit(parser);\n    skipWsAndComments(parser);\n    const fieldOptions = acceptFieldOptions(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            fieldName,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "enum-field",\n        fieldName,\n        eq,\n        fieldNumber,\n        fieldOptions,\n        semi,\n    };\n}\nfunction expectEnumBody(parser) {\n    const bracketOpen = parser.expect("{");\n    const statements = acceptStatements(parser, [\n        acceptOption,\n        acceptReserved,\n        acceptEnumField,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect("}");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: "enum-body",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction acceptEnum(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "enum");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const enumName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const enumBody = expectEnumBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            enumBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "enum",\n        keyword,\n        enumName,\n        enumBody,\n    };\n}\nfunction acceptField(parser, leadingComments, leadingDetachedComments) {\n    const loc = parser.loc;\n    const fieldLabel = acceptKeyword(parser, /^required|^optional|^repeated/);\n    skipWsAndComments(parser);\n    const fieldType = acceptType(parser);\n    if (!fieldType) {\n        parser.loc = loc;\n        return;\n    }\n    const rest = acceptComplexSequence(parser, [\n        ["fieldName", (parser) => parser.expect(identPattern)],\n        ["eq", (parser) => parser.expect("=")],\n        ["fieldNumber", expectIntLit],\n        ["fieldOptions", acceptFieldOptions],\n        ["semi", expectSemi],\n    ], messageBodyStatementKeywordPattern);\n    const trailingComments = rest.result.semi\n        ? acceptTrailingComments(parser)\n        : [];\n    const type = rest.partial ? "malformed-field" : "field";\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            fieldLabel,\n            fieldType,\n            rest.result.semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: type,\n        fieldLabel,\n        fieldType,\n        ...rest.result,\n    };\n}\nfunction acceptOneofField(parser, leadingComments, leadingDetachedComments) {\n    const fieldType = acceptType(parser);\n    if (!fieldType)\n        return;\n    skipWsAndComments(parser);\n    const fieldName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const eq = parser.expect("=");\n    skipWsAndComments(parser);\n    const fieldNumber = expectIntLit(parser);\n    skipWsAndComments(parser);\n    const fieldOptions = acceptFieldOptions(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            fieldType,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "oneof-field",\n        fieldType,\n        fieldName,\n        eq,\n        fieldNumber,\n        fieldOptions,\n        semi,\n    };\n}\nfunction acceptMapField(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "map");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const typeBracketOpen = parser.expect("<");\n    skipWsAndComments(parser);\n    const keyType = expectType(parser);\n    skipWsAndComments(parser);\n    const typeSep = parser.expect(",");\n    skipWsAndComments(parser);\n    const valueType = expectType(parser);\n    skipWsAndComments(parser);\n    const typeBracketClose = parser.expect(">");\n    skipWsAndComments(parser);\n    const mapName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const eq = parser.expect("=");\n    skipWsAndComments(parser);\n    const fieldNumber = expectIntLit(parser);\n    skipWsAndComments(parser);\n    const fieldOptions = acceptFieldOptions(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "map-field",\n        keyword,\n        typeBracketOpen,\n        keyType,\n        typeSep,\n        valueType,\n        typeBracketClose,\n        mapName,\n        eq,\n        fieldNumber,\n        fieldOptions,\n        semi,\n    };\n}\nfunction expectOneofBody(parser) {\n    const bracketOpen = parser.expect("{");\n    const statements = acceptStatements(parser, [\n        acceptOneofGroup,\n        acceptOption,\n        acceptOneofField,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect("}");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: "oneof-body",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction acceptOneof(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "oneof");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const oneofName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const oneofBody = expectOneofBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            oneofBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "oneof",\n        keyword,\n        oneofName,\n        oneofBody,\n    };\n}\nconst acceptMax = acceptPatternAndThen("max", (max) => ({ type: "max", ...max }));\nfunction acceptRange(parser) {\n    var _a;\n    const rangeStart = acceptIntLit(parser);\n    if (!rangeStart)\n        return;\n    skipWsAndComments(parser);\n    const to = acceptKeyword(parser, "to");\n    if (!to) {\n        return {\n            start: rangeStart.start,\n            end: rangeStart.end,\n            type: "range",\n            rangeStart,\n        };\n    }\n    skipWsAndComments(parser);\n    const rangeEnd = (_a = acceptIntLit(parser)) !== null && _a !== void 0 ? _a : acceptMax(parser);\n    if (!rangeEnd)\n        throw new recursive_descent_parser_1.SyntaxError(parser, [intLitPattern, "max"]);\n    return {\n        ...mergeSpans([rangeStart, rangeEnd]),\n        type: "range",\n        rangeStart,\n        to,\n        rangeEnd,\n    };\n}\nfunction expectRanges(parser) {\n    const rangeOrCommas = many(parser, choice([\n        skipWsAndComments,\n        acceptComma,\n        acceptRange,\n    ]));\n    return {\n        ...mergeSpans(rangeOrCommas),\n        type: "ranges",\n        rangeOrCommas,\n    };\n}\nfunction acceptExtensions(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "extensions");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const ranges = expectRanges(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "extensions",\n        keyword,\n        ranges,\n        semi,\n    };\n}\nfunction expectFieldNames(parser) {\n    const strLitOrCommas = many(parser, choice([\n        skipWsAndComments,\n        acceptComma,\n        acceptStrLit,\n    ]));\n    return {\n        ...mergeSpans(strLitOrCommas),\n        type: "field-names",\n        strLitOrCommas,\n    };\n}\nfunction acceptReserved(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "reserved");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const reserved = parser.try(intLitPattern)\n        ? expectRanges(parser)\n        : expectFieldNames(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "reserved",\n        keyword,\n        reserved,\n        semi,\n    };\n}\nfunction expectExtendBody(parser) {\n    const bracketOpen = parser.expect("{");\n    const statements = acceptStatements(parser, [\n        acceptGroup,\n        acceptField,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect("}");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: "extend-body",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction acceptExtend(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "extend");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const messageType = expectType(parser);\n    skipWsAndComments(parser);\n    const extendBody = expectExtendBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            extendBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "extend",\n        keyword,\n        messageType,\n        extendBody,\n    };\n}\nfunction acceptGroup(parser, leadingComments, leadingDetachedComments) {\n    const loc = parser.loc;\n    const groupLabel = acceptKeyword(parser, /^required|^optional|^repeated/);\n    if (!groupLabel) {\n        parser.loc = loc;\n        return;\n    }\n    skipWsAndComments(parser);\n    const keyword = acceptKeyword(parser, "group");\n    if (!keyword) {\n        parser.loc = loc;\n        return;\n    }\n    skipWsAndComments(parser);\n    const groupName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const eq = parser.expect("=");\n    skipWsAndComments(parser);\n    const fieldNumber = expectIntLit(parser);\n    skipWsAndComments(parser);\n    const messageBody = expectMessageBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            groupLabel,\n            messageBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "group",\n        groupLabel,\n        keyword,\n        groupName,\n        eq,\n        fieldNumber,\n        messageBody,\n    };\n}\nfunction acceptOneofGroup(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "group");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const groupName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const eq = parser.expect("=");\n    skipWsAndComments(parser);\n    const fieldNumber = expectIntLit(parser);\n    skipWsAndComments(parser);\n    const messageBody = expectMessageBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            messageBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "oneof-group",\n        keyword,\n        groupName,\n        eq,\n        fieldNumber,\n        messageBody,\n    };\n}\nfunction expectMessageBody(parser) {\n    const bracketOpen = parser.expect("{");\n    const statements = acceptStatements(parser, [\n        acceptGroup,\n        acceptEnum,\n        acceptMessage,\n        acceptExtend,\n        acceptExtensions,\n        acceptOption,\n        acceptOneof,\n        acceptMapField,\n        acceptReserved,\n        acceptField,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect("}");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: "message-body",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction acceptMessage(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "message");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const messageName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const messageBody = expectMessageBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            messageBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "message",\n        keyword,\n        messageName,\n        messageBody,\n    };\n}\nfunction expectRpcType(parser) {\n    const bracketOpen = parser.expect("(");\n    skipWsAndComments(parser);\n    const stream = acceptKeyword(parser, "stream");\n    skipWsAndComments(parser);\n    const messageType = expectType(parser);\n    skipWsAndComments(parser);\n    const bracketClose = parser.expect(")");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        bracketOpen,\n        stream,\n        messageType,\n        bracketClose,\n    };\n}\nfunction acceptRpc(parser, leadingComments, leadingDetachedComments) {\n    var _a;\n    const keyword = acceptKeyword(parser, "rpc");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const rpcName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const reqType = expectRpcType(parser);\n    skipWsAndComments(parser);\n    const returns = parser.expect("returns");\n    skipWsAndComments(parser);\n    const resType = expectRpcType(parser);\n    skipWsAndComments(parser);\n    const semiOrRpcBody = (_a = acceptSemi(parser)) !== null && _a !== void 0 ? _a : expectRpcBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semiOrRpcBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "rpc",\n        keyword,\n        rpcName,\n        reqType,\n        returns,\n        resType,\n        semiOrRpcBody,\n    };\n}\nfunction expectRpcBody(parser) {\n    const bracketOpen = parser.expect("{");\n    const statements = acceptStatements(parser, [\n        acceptOption,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect("}");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: "rpc-body",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction expectServiceBody(parser) {\n    const bracketOpen = parser.expect("{");\n    const statements = acceptStatements(parser, [\n        acceptOption,\n        acceptRpc,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect("}");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: "service-body",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction acceptService(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, "service");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const serviceName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const serviceBody = expectServiceBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            serviceBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: "service",\n        keyword,\n        serviceName,\n        serviceBody,\n    };\n}\n\n\n//# sourceURL=webpack:///./node_modules/pbkit/core/parser/proto.js?')},"./node_modules/pbkit/core/parser/recursive-descent-parser.js":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.SyntaxError = exports.createRecursiveDescentParser = exports.eof = void 0;\nexports.eof = Symbol("<EOF>");\nfunction createRecursiveDescentParser(input, config) {\n    const debug = !!(config === null || config === void 0 ? void 0 : config.debug);\n    let cnt = 0;\n    const lines = input.split("\\n");\n    const parser = {\n        input,\n        loc: 0,\n        offsetToColRow: (offset) => offsetToColRow(lines, offset),\n        getAroundText: (loc, length, window) => getAroundText(lines, loc, length, window),\n        try(pattern) {\n            const loc = parser.loc;\n            try {\n                return parser.accept(pattern);\n            }\n            finally {\n                parser.loc = loc;\n            }\n        },\n        accept(pattern) {\n            cnt++;\n            if (cnt > input.length * 5)\n                throw `infinite loop`;\n            if (pattern === exports.eof)\n                return acceptEof();\n            if (typeof pattern === "string")\n                return acceptString(pattern);\n            return acceptRegex(pattern);\n        },\n        expect(acceptPattern, expectedPatterns, mistakePatterns) {\n            const result = parser.accept(acceptPattern);\n            const _expectedPatterns = (expectedPatterns\n                ? [acceptPattern, ...expectedPatterns]\n                : [acceptPattern]);\n            if (result == null) {\n                throw new SyntaxError(parser, _expectedPatterns, mistakePatterns);\n            }\n            else {\n                return result;\n            }\n        },\n    };\n    function acceptEof() {\n        if (parser.loc < input.length)\n            return;\n        return { start: parser.loc, end: parser.loc, text: "" };\n    }\n    function acceptString(pattern) {\n        const start = parser.loc;\n        const end = start + pattern.length;\n        const text = input.slice(start, end);\n        if (text !== pattern)\n            return;\n        parser.loc = end;\n        debug && console.log(text);\n        return { start, end, text };\n    }\n    function acceptRegex(pattern) {\n        pattern.lastIndex = 0;\n        const execArray = pattern.exec(input.substr(parser.loc));\n        if (execArray == null)\n            return;\n        const text = execArray[0];\n        const start = parser.loc + execArray.index;\n        const end = start + text.length;\n        parser.loc = end;\n        debug && console.log(text);\n        return { start, end, text };\n    }\n    return parser;\n}\nexports.createRecursiveDescentParser = createRecursiveDescentParser;\nclass SyntaxError extends Error {\n    constructor(parser, expectedPatterns, mistakePatterns = []) {\n        super();\n        this.parser = parser;\n        this.expectedPatterns = expectedPatterns;\n        this.mistakePatterns = mistakePatterns;\n        const colRow = this.colRow;\n        const got = this.got;\n        const length = got === exports.eof ? 1 : got.length;\n        const expectedPatternsText = expectedPatterns.map(patternToString).join(" or ");\n        this.message = (`at line ${colRow.row + 1}, column ${colRow.col + 1}:\\n\\n` +\n            `expected ${expectedPatternsText}, got ${patternToString(got)}\\n\\n` +\n            parser.getAroundText(parser.loc, length));\n    }\n    get got() {\n        const parser = this.parser;\n        for (const mistakePattern of this.mistakePatterns) {\n            const token = parser.try(mistakePattern);\n            if (token)\n                return token.text;\n        }\n        return parser.input.charAt(parser.loc) || exports.eof;\n    }\n    get colRow() {\n        return this.parser.offsetToColRow(this.parser.loc);\n    }\n}\nexports.SyntaxError = SyntaxError;\nfunction patternToString(pattern) {\n    if (pattern === exports.eof)\n        return "<EOF>";\n    if (typeof pattern === "string")\n        return JSON.stringify(pattern);\n    return pattern.toString();\n}\nfunction offsetToColRow(lines, offset) {\n    let col = offset;\n    let row = 0;\n    for (const line of lines) {\n        const len = line.length + 1;\n        if (len < col) {\n            col -= len;\n            row++;\n            continue;\n        }\n        return { col, row };\n    }\n    return { col: 0, row };\n}\nfunction getAroundText(lines, loc, length = 1, window = 5) {\n    const colRow = offsetToColRow(lines, loc);\n    const headCount = Math.min(1, (window >> 1) + (window % 2));\n    const tailCount = window >> 1;\n    const headStart = Math.max(0, colRow.row - headCount - 1);\n    const headEnd = colRow.row + 1;\n    const tailStart = colRow.row + 1;\n    const tailEnd = colRow.row + tailCount + 1;\n    const heads = lines.slice(headStart, headEnd);\n    const tails = lines.slice(tailStart, tailEnd);\n    const lineNumberDigitCount = tailEnd.toString().length;\n    const headTexts = heads.map((line, index) => {\n        const lineNumber = index + headStart + 1;\n        const lineNumberText = lineNumber.toString().padStart(lineNumberDigitCount + 1);\n        return lineNumberText + " | " + line;\n    }).join("\\n");\n    const tailTexts = tails.map((line, index) => {\n        const lineNumber = index + tailStart + 1;\n        const lineNumberText = lineNumber.toString().padStart(lineNumberDigitCount + 1);\n        return lineNumberText + " | " + line;\n    }).join("\\n");\n    return [\n        headTexts,\n        (new Array(lineNumberDigitCount + 1 + 1)).join(" ") + " | " +\n            (new Array(colRow.col + 1)).join(" ") +\n            (new Array(length + 1)).join("^"),\n        tailTexts,\n    ].join("\\n");\n}\n\n\n//# sourceURL=webpack:///./node_modules/pbkit/core/parser/recursive-descent-parser.js?')}}]);