(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{"./node_modules/@babel/runtime/helpers/construct.js":function(module,exports,__webpack_require__){eval('var setPrototypeOf = __webpack_require__("./node_modules/@babel/runtime/helpers/setPrototypeOf.js");\n\nvar isNativeReflectConstruct = __webpack_require__("./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/construct.js?')},"./node_modules/@babel/runtime/helpers/isNativeFunction.js":function(module,exports){eval('function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf("[native code]") !== -1;\n}\n\nmodule.exports = _isNativeFunction;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/isNativeFunction.js?')},"./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":function(module,exports){eval('function _isNativeReflectConstruct() {\n  if (typeof Reflect === "undefined" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === "function") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nmodule.exports = _isNativeReflectConstruct;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js?')},"./node_modules/@babel/runtime/helpers/toArray.js":function(module,exports,__webpack_require__){eval('var arrayWithHoles = __webpack_require__("./node_modules/@babel/runtime/helpers/arrayWithHoles.js");\n\nvar iterableToArray = __webpack_require__("./node_modules/@babel/runtime/helpers/iterableToArray.js");\n\nvar unsupportedIterableToArray = __webpack_require__("./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");\n\nvar nonIterableRest = __webpack_require__("./node_modules/@babel/runtime/helpers/nonIterableRest.js");\n\nfunction _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}\n\nmodule.exports = _toArray;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/toArray.js?')},"./node_modules/@babel/runtime/helpers/wrapNativeSuper.js":function(module,exports,__webpack_require__){eval('var getPrototypeOf = __webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js");\n\nvar setPrototypeOf = __webpack_require__("./node_modules/@babel/runtime/helpers/setPrototypeOf.js");\n\nvar isNativeFunction = __webpack_require__("./node_modules/@babel/runtime/helpers/isNativeFunction.js");\n\nvar construct = __webpack_require__("./node_modules/@babel/runtime/helpers/construct.js");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === "function" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== "function") {\n      throw new TypeError("Super expression must either be null or a function");\n    }\n\n    if (typeof _cache !== "undefined") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/wrapNativeSuper.js?')},"./node_modules/webidl2/index.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nObject.defineProperty(exports, "parse", {\n  enumerable: true,\n  get: function get() {\n    return _webidl.parse;\n  }\n});\nObject.defineProperty(exports, "write", {\n  enumerable: true,\n  get: function get() {\n    return _writer.write;\n  }\n});\nObject.defineProperty(exports, "validate", {\n  enumerable: true,\n  get: function get() {\n    return _validator.validate;\n  }\n});\nObject.defineProperty(exports, "WebIDLParseError", {\n  enumerable: true,\n  get: function get() {\n    return _tokeniser.WebIDLParseError;\n  }\n});\n\nvar _webidl = __webpack_require__("./node_modules/webidl2/lib/webidl2.js");\n\nvar _writer = __webpack_require__("./node_modules/webidl2/lib/writer.js");\n\nvar _validator = __webpack_require__("./node_modules/webidl2/lib/validator.js");\n\nvar _tokeniser = __webpack_require__("./node_modules/webidl2/lib/tokeniser.js");\n\n//# sourceURL=webpack:///./node_modules/webidl2/index.js?')},"./node_modules/webidl2/lib/error.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.syntaxError = syntaxError;\nexports.validationError = validationError;\n\n/**\n * @param {string} text\n */\nfunction lastLine(text) {\n  var splitted = text.split("\\n");\n  return splitted[splitted.length - 1];\n}\n/**\n * @typedef {object} WebIDL2ErrorOptions\n * @property {"error" | "warning"} [level]\n * @property {Function} [autofix]\n *\n * @param {string} message error message\n * @param {"Syntax" | "Validation"} kind error type\n * @param {WebIDL2ErrorOptions} [options]\n */\n\n\nfunction error(source, position, current, message, kind) {\n  var _ref = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {},\n      _ref$level = _ref.level,\n      level = _ref$level === void 0 ? "error" : _ref$level,\n      autofix = _ref.autofix,\n      ruleName = _ref.ruleName;\n\n  /**\n   * @param {number} count\n   */\n  function sliceTokens(count) {\n    return count > 0 ? source.slice(position, position + count) : source.slice(Math.max(position + count, 0), position);\n  }\n\n  function tokensToText(inputs) {\n    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        precedes = _ref2.precedes;\n\n    var text = inputs.map(function (t) {\n      return t.trivia + t.value;\n    }).join("");\n    var nextToken = source[position];\n\n    if (nextToken.type === "eof") {\n      return text;\n    }\n\n    if (precedes) {\n      return text + nextToken.trivia;\n    }\n\n    return text.slice(nextToken.trivia.length);\n  }\n\n  var maxTokens = 5; // arbitrary but works well enough\n\n  var line = source[position].type !== "eof" ? source[position].line : source.length > 1 ? source[position - 1].line : 1;\n  var precedingLastLine = lastLine(tokensToText(sliceTokens(-maxTokens), {\n    precedes: true\n  }));\n  var subsequentTokens = sliceTokens(maxTokens);\n  var subsequentText = tokensToText(subsequentTokens);\n  var subsequentFirstLine = subsequentText.split("\\n")[0];\n  var spaced = " ".repeat(precedingLastLine.length) + "^";\n  var sourceContext = precedingLastLine + subsequentFirstLine + "\\n" + spaced;\n  var contextType = kind === "Syntax" ? "since" : "inside";\n  var inSourceName = source.name ? " in ".concat(source.name) : "";\n  var grammaticalContext = current && current.name ? ", ".concat(contextType, " `").concat(current.partial ? "partial " : "").concat(current.type, " ").concat(current.name, "`") : "";\n  var context = "".concat(kind, " error at line ").concat(line).concat(inSourceName).concat(grammaticalContext, ":\\n").concat(sourceContext);\n  return {\n    message: "".concat(context, " ").concat(message),\n    bareMessage: message,\n    context: context,\n    line: line,\n    sourceName: source.name,\n    level: level,\n    ruleName: ruleName,\n    autofix: autofix,\n    input: subsequentText,\n    tokens: subsequentTokens\n  };\n}\n/**\n * @param {string} message error message\n */\n\n\nfunction syntaxError(source, position, current, message) {\n  return error(source, position, current, message, "Syntax");\n}\n/**\n * @param {string} message error message\n * @param {WebIDL2ErrorOptions} [options]\n */\n\n\nfunction validationError(token, current, ruleName, message) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  options.ruleName = ruleName;\n  return error(current.source, token.index, current, message, "Validation", options);\n}\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/error.js?')},"./node_modules/webidl2/lib/productions/argument.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Argument = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/toConsumableArray.js"));\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _default = __webpack_require__("./node_modules/webidl2/lib/productions/default.js");\n\nvar _extendedAttributes = __webpack_require__("./node_modules/webidl2/lib/productions/extended-attributes.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nvar _tokeniser = __webpack_require__("./node_modules/webidl2/lib/tokeniser.js");\n\nvar _error = __webpack_require__("./node_modules/webidl2/lib/error.js");\n\nvar _helpers2 = __webpack_require__("./node_modules/webidl2/lib/validators/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Argument = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Argument, _Base);\n\n  var _super = _createSuper(Argument);\n\n  function Argument() {\n    (0, _classCallCheck2.default)(this, Argument);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Argument, [{\n    key: "validate",\n\n    /**\n     * @param {import("../validator.js").Definitions} defs\n     */\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      var result, message, _message, _message2;\n\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.idlType.validate(defs), "t0", 1);\n\n            case 1:\n              result = (0, _helpers2.idlTypeIncludesDictionary)(this.idlType, defs, {\n                useNullableInner: true\n              });\n\n              if (!result) {\n                _context.next = 20;\n                break;\n              }\n\n              if (!this.idlType.nullable) {\n                _context.next = 9;\n                break;\n              }\n\n              message = "Dictionary arguments cannot be nullable.";\n              _context.next = 7;\n              return (0, _error.validationError)(this.tokens.name, this, "no-nullable-dict-arg", message);\n\n            case 7:\n              _context.next = 20;\n              break;\n\n            case 9:\n              if (this.optional) {\n                _context.next = 16;\n                break;\n              }\n\n              if (!(this.parent && !(0, _helpers2.dictionaryIncludesRequiredField)(result.dictionary, defs) && isLastRequiredArgument(this))) {\n                _context.next = 14;\n                break;\n              }\n\n              _message = "Dictionary argument must be optional if it has no required fields";\n              _context.next = 14;\n              return (0, _error.validationError)(this.tokens.name, this, "dict-arg-optional", _message, {\n                autofix: autofixDictionaryArgumentOptionality(this)\n              });\n\n            case 14:\n              _context.next = 20;\n              break;\n\n            case 16:\n              if (this.default) {\n                _context.next = 20;\n                break;\n              }\n\n              _message2 = "Optional dictionary arguments must have a default value of `{}`.";\n              _context.next = 20;\n              return (0, _error.validationError)(this.tokens.name, this, "dict-arg-default", _message2, {\n                autofix: autofixOptionalDictionaryDefaultValue(this)\n              });\n\n            case 20:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this);\n    })\n  }, {\n    key: "type",\n    get: function get() {\n      return "argument";\n    }\n  }, {\n    key: "optional",\n    get: function get() {\n      return !!this.tokens.optional;\n    }\n  }, {\n    key: "variadic",\n    get: function get() {\n      return !!this.tokens.variadic;\n    }\n  }, {\n    key: "name",\n    get: function get() {\n      return (0, _helpers.unescape)(this.tokens.name.value);\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      var start_position = tokeniser.position;\n      /** @type {Base["tokens"]} */\n\n      var tokens = {};\n      var ret = (0, _helpers.autoParenter)(new Argument({\n        source: tokeniser.source,\n        tokens: tokens\n      }));\n      ret.extAttrs = _extendedAttributes.ExtendedAttributes.parse(tokeniser);\n      tokens.optional = tokeniser.consume("optional");\n      ret.idlType = (0, _helpers.type_with_extended_attributes)(tokeniser, "argument-type");\n\n      if (!ret.idlType) {\n        return tokeniser.unconsume(start_position);\n      }\n\n      if (!tokens.optional) {\n        tokens.variadic = tokeniser.consume("...");\n      }\n\n      tokens.name = tokeniser.consume.apply(tokeniser, ["identifier"].concat((0, _toConsumableArray2.default)(_tokeniser.argumentNameKeywords)));\n\n      if (!tokens.name) {\n        return tokeniser.unconsume(start_position);\n      }\n\n      ret.default = tokens.optional ? _default.Default.parse(tokeniser) : null;\n      return ret.this;\n    }\n  }]);\n  return Argument;\n}(_base.Base);\n/**\n * @param {Argument} arg\n */\n\n\nexports.Argument = Argument;\n\nfunction isLastRequiredArgument(arg) {\n  var list = arg.parent.arguments || arg.parent.list;\n  var index = list.indexOf(arg);\n  var requiredExists = list.slice(index + 1).some(function (a) {\n    return !a.optional;\n  });\n  return !requiredExists;\n}\n/**\n * @param {Argument} arg\n */\n\n\nfunction autofixDictionaryArgumentOptionality(arg) {\n  return function () {\n    var firstToken = (0, _helpers.getFirstToken)(arg.idlType);\n    arg.tokens.optional = {\n      type: "optional",\n      value: "optional",\n      trivia: firstToken.trivia\n    };\n    firstToken.trivia = " ";\n    autofixOptionalDictionaryDefaultValue(arg)();\n  };\n}\n/**\n * @param {Argument} arg\n */\n\n\nfunction autofixOptionalDictionaryDefaultValue(arg) {\n  return function () {\n    arg.default = _default.Default.parse(new _tokeniser.Tokeniser(" = {}"));\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/argument.js?')},"./node_modules/webidl2/lib/productions/array-base.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.ArrayBase = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/wrapNativeSuper.js"));\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n// @ts-check\nvar ArrayBase = /*#__PURE__*/function (_Array) {\n  (0, _inherits2.default)(ArrayBase, _Array);\n\n  var _super = _createSuper(ArrayBase);\n\n  function ArrayBase(_ref) {\n    var _this;\n\n    var source = _ref.source,\n        tokens = _ref.tokens;\n    (0, _classCallCheck2.default)(this, ArrayBase);\n    _this = _super.call(this);\n    Object.defineProperties((0, _assertThisInitialized2.default)(_this), {\n      source: {\n        value: source\n      },\n      tokens: {\n        value: tokens\n      },\n      parent: {\n        value: null,\n        writable: true\n      }\n    });\n    return _this;\n  }\n\n  return ArrayBase;\n}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Array));\n\nexports.ArrayBase = ArrayBase;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/array-base.js?')},"./node_modules/webidl2/lib/productions/attribute.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Attribute = void 0;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Attribute = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Attribute, _Base);\n\n  var _super = _createSuper(Attribute);\n\n  function Attribute() {\n    (0, _classCallCheck2.default)(this, Attribute);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Attribute, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.idlType.validate(defs), "t0", 1);\n\n            case 1:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this);\n    })\n  }, {\n    key: "type",\n    get: function get() {\n      return "attribute";\n    }\n  }, {\n    key: "special",\n    get: function get() {\n      if (!this.tokens.special) {\n        return "";\n      }\n\n      return this.tokens.special.value;\n    }\n  }, {\n    key: "readonly",\n    get: function get() {\n      return !!this.tokens.readonly;\n    }\n  }, {\n    key: "name",\n    get: function get() {\n      return (0, _helpers.unescape)(this.tokens.name.value);\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser.js").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          special = _ref.special,\n          _ref$noInherit = _ref.noInherit,\n          noInherit = _ref$noInherit === void 0 ? false : _ref$noInherit,\n          _ref$readonly = _ref.readonly,\n          readonly = _ref$readonly === void 0 ? false : _ref$readonly;\n\n      var start_position = tokeniser.position;\n      var tokens = {\n        special: special\n      };\n      var ret = (0, _helpers.autoParenter)(new Attribute({\n        source: tokeniser.source,\n        tokens: tokens\n      }));\n\n      if (!special && !noInherit) {\n        tokens.special = tokeniser.consume("inherit");\n      }\n\n      if (ret.special === "inherit" && tokeniser.probe("readonly")) {\n        tokeniser.error("Inherited attributes cannot be read-only");\n      }\n\n      tokens.readonly = tokeniser.consume("readonly");\n\n      if (readonly && !tokens.readonly && tokeniser.probe("attribute")) {\n        tokeniser.error("Attributes must be readonly in this context");\n      }\n\n      tokens.base = tokeniser.consume("attribute");\n\n      if (!tokens.base) {\n        tokeniser.unconsume(start_position);\n        return;\n      }\n\n      ret.idlType = (0, _helpers.type_with_extended_attributes)(tokeniser, "attribute-type") || tokeniser.error("Attribute lacks a type");\n\n      switch (ret.idlType.generic) {\n        case "sequence":\n        case "record":\n          tokeniser.error("Attributes cannot accept ".concat(ret.idlType.generic, " types"));\n      }\n\n      tokens.name = tokeniser.consume("identifier", "async", "required") || tokeniser.error("Attribute lacks a name");\n      tokens.termination = tokeniser.consume(";") || tokeniser.error("Unterminated attribute, expected `;`");\n      return ret.this;\n    }\n  }]);\n  return Attribute;\n}(_base.Base);\n\nexports.Attribute = Attribute;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/attribute.js?')},"./node_modules/webidl2/lib/productions/base.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Base = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/slicedToArray.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\n// @ts-check\nvar Base = /*#__PURE__*/function () {\n  /**\n   * @param {object} initializer\n   * @param {Base["source"]} initializer.source\n   * @param {Base["tokens"]} initializer.tokens\n   */\n  function Base(_ref) {\n    var source = _ref.source,\n        tokens = _ref.tokens;\n    (0, _classCallCheck2.default)(this, Base);\n    Object.defineProperties(this, {\n      source: {\n        value: source\n      },\n      tokens: {\n        value: tokens\n      },\n      parent: {\n        value: null,\n        writable: true\n      },\n      this: {\n        value: this\n      } // useful when escaping from proxy\n\n    });\n  }\n\n  (0, _createClass2.default)(Base, [{\n    key: "toJSON",\n    value: function toJSON() {\n      var json = {\n        type: undefined,\n        name: undefined,\n        inheritance: undefined\n      };\n      var proto = this;\n\n      while (proto !== Object.prototype) {\n        var descMap = Object.getOwnPropertyDescriptors(proto);\n\n        for (var _i = 0, _Object$entries = Object.entries(descMap); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i], 2),\n              key = _Object$entries$_i[0],\n              value = _Object$entries$_i[1];\n\n          if (value.enumerable || value.get) {\n            // @ts-ignore - allow indexing here\n            json[key] = this[key];\n          }\n        }\n\n        proto = Object.getPrototypeOf(proto);\n      }\n\n      return json;\n    }\n  }]);\n  return Base;\n}();\n\nexports.Base = Base;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/base.js?')},"./node_modules/webidl2/lib/productions/callback-interface.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.CallbackInterface = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _container = __webpack_require__("./node_modules/webidl2/lib/productions/container.js");\n\nvar _operation = __webpack_require__("./node_modules/webidl2/lib/productions/operation.js");\n\nvar _constant = __webpack_require__("./node_modules/webidl2/lib/productions/constant.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar CallbackInterface = /*#__PURE__*/function (_Container) {\n  (0, _inherits2.default)(CallbackInterface, _Container);\n\n  var _super = _createSuper(CallbackInterface);\n\n  function CallbackInterface() {\n    (0, _classCallCheck2.default)(this, CallbackInterface);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(CallbackInterface, [{\n    key: "type",\n    get: function get() {\n      return "callback interface";\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser, callback) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref$partial = _ref.partial,\n          partial = _ref$partial === void 0 ? null : _ref$partial;\n\n      var tokens = {\n        callback: callback\n      };\n      tokens.base = tokeniser.consume("interface");\n\n      if (!tokens.base) {\n        return;\n      }\n\n      return _container.Container.parse(tokeniser, new CallbackInterface({\n        source: tokeniser.source,\n        tokens: tokens\n      }), {\n        type: "callback interface",\n        inheritable: !partial,\n        allowedMembers: [[_constant.Constant.parse], [_operation.Operation.parse, {\n          regular: true\n        }]]\n      });\n    }\n  }]);\n  return CallbackInterface;\n}(_container.Container);\n\nexports.CallbackInterface = CallbackInterface;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/callback-interface.js?')},"./node_modules/webidl2/lib/productions/callback.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.CallbackFunction = void 0;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar CallbackFunction = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(CallbackFunction, _Base);\n\n  var _super = _createSuper(CallbackFunction);\n\n  function CallbackFunction() {\n    (0, _classCallCheck2.default)(this, CallbackFunction);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(CallbackFunction, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.idlType.validate(defs), "t0", 1);\n\n            case 1:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this);\n    })\n  }, {\n    key: "type",\n    get: function get() {\n      return "callback";\n    }\n  }, {\n    key: "name",\n    get: function get() {\n      return (0, _helpers.unescape)(this.tokens.name.value);\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser.js").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser, base) {\n      var tokens = {\n        base: base\n      };\n      var ret = (0, _helpers.autoParenter)(new CallbackFunction({\n        source: tokeniser.source,\n        tokens: tokens\n      }));\n      tokens.name = tokeniser.consume("identifier") || tokeniser.error("Callback lacks a name");\n      tokeniser.current = ret.this;\n      tokens.assign = tokeniser.consume("=") || tokeniser.error("Callback lacks an assignment");\n      ret.idlType = (0, _helpers.return_type)(tokeniser) || tokeniser.error("Callback lacks a return type");\n      tokens.open = tokeniser.consume("(") || tokeniser.error("Callback lacks parentheses for arguments");\n      ret.arguments = (0, _helpers.argument_list)(tokeniser);\n      tokens.close = tokeniser.consume(")") || tokeniser.error("Unterminated callback");\n      tokens.termination = tokeniser.consume(";") || tokeniser.error("Unterminated callback, expected `;`");\n      return ret.this;\n    }\n  }]);\n  return CallbackFunction;\n}(_base.Base);\n\nexports.CallbackFunction = CallbackFunction;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/callback.js?')},"./node_modules/webidl2/lib/productions/constant.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Constant = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _type = __webpack_require__("./node_modules/webidl2/lib/productions/type.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Constant = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Constant, _Base);\n\n  var _super = _createSuper(Constant);\n\n  function Constant() {\n    (0, _classCallCheck2.default)(this, Constant);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Constant, [{\n    key: "type",\n    get: function get() {\n      return "const";\n    }\n  }, {\n    key: "name",\n    get: function get() {\n      return (0, _helpers.unescape)(this.tokens.name.value);\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      return (0, _helpers.const_data)(this.tokens.value);\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser.js").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      /** @type {Base["tokens"]} */\n      var tokens = {};\n      tokens.base = tokeniser.consume("const");\n\n      if (!tokens.base) {\n        return;\n      }\n\n      var idlType = (0, _helpers.primitive_type)(tokeniser);\n\n      if (!idlType) {\n        var base = tokeniser.consume("identifier") || tokeniser.error("Const lacks a type");\n        idlType = new _type.Type({\n          source: tokeniser.source,\n          tokens: {\n            base: base\n          }\n        });\n      }\n\n      if (tokeniser.probe("?")) {\n        tokeniser.error("Unexpected nullable constant type");\n      }\n\n      idlType.type = "const-type";\n      tokens.name = tokeniser.consume("identifier") || tokeniser.error("Const lacks a name");\n      tokens.assign = tokeniser.consume("=") || tokeniser.error("Const lacks value assignment");\n      tokens.value = (0, _helpers.const_value)(tokeniser) || tokeniser.error("Const lacks a value");\n      tokens.termination = tokeniser.consume(";") || tokeniser.error("Unterminated const, expected `;`");\n      var ret = new Constant({\n        source: tokeniser.source,\n        tokens: tokens\n      });\n      (0, _helpers.autoParenter)(ret).idlType = idlType;\n      return ret;\n    }\n  }]);\n  return Constant;\n}(_base.Base);\n\nexports.Constant = Constant;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/constant.js?')},"./node_modules/webidl2/lib/productions/constructor.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Constructor = void 0;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Constructor = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Constructor, _Base);\n\n  var _super = _createSuper(Constructor);\n\n  function Constructor() {\n    (0, _classCallCheck2.default)(this, Constructor);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Constructor, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      var _iterator, _step, argument;\n\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.idlType) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.delegateYield(this.idlType.validate(defs), "t0", 2);\n\n            case 2:\n              _iterator = _createForOfIteratorHelper(this.arguments);\n              _context.prev = 3;\n\n              _iterator.s();\n\n            case 5:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 10;\n                break;\n              }\n\n              argument = _step.value;\n              return _context.delegateYield(argument.validate(defs), "t1", 8);\n\n            case 8:\n              _context.next = 5;\n              break;\n\n            case 10:\n              _context.next = 15;\n              break;\n\n            case 12:\n              _context.prev = 12;\n              _context.t2 = _context["catch"](3);\n\n              _iterator.e(_context.t2);\n\n            case 15:\n              _context.prev = 15;\n\n              _iterator.f();\n\n              return _context.finish(15);\n\n            case 18:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this, [[3, 12, 15, 18]]);\n    })\n  }, {\n    key: "type",\n    get: function get() {\n      return "constructor";\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      var base = tokeniser.consume("constructor");\n\n      if (!base) {\n        return;\n      }\n      /** @type {Base["tokens"]} */\n\n\n      var tokens = {\n        base: base\n      };\n      tokens.open = tokeniser.consume("(") || tokeniser.error("No argument list in constructor");\n      var args = (0, _helpers.argument_list)(tokeniser);\n      tokens.close = tokeniser.consume(")") || tokeniser.error("Unterminated constructor");\n      tokens.termination = tokeniser.consume(";") || tokeniser.error("No semicolon after constructor");\n      var ret = new Constructor({\n        source: tokeniser.source,\n        tokens: tokens\n      });\n      (0, _helpers.autoParenter)(ret).arguments = args;\n      return ret;\n    }\n  }]);\n  return Constructor;\n}(_base.Base);\n\nexports.Constructor = Constructor;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/constructor.js?')},"./node_modules/webidl2/lib/productions/container.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Container = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/toConsumableArray.js"));\n\nvar _toArray2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/toArray.js"));\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _extendedAttributes = __webpack_require__("./node_modules/webidl2/lib/productions/extended-attributes.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * @param {import("../tokeniser.js").Tokeniser} tokeniser\n */\nfunction inheritance(tokeniser) {\n  var colon = tokeniser.consume(":");\n\n  if (!colon) {\n    return {};\n  }\n\n  var inheritance = tokeniser.consume("identifier") || tokeniser.error("Inheritance lacks a type");\n  return {\n    colon: colon,\n    inheritance: inheritance\n  };\n}\n\nvar Container = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Container, _Base);\n\n  var _super = _createSuper(Container);\n\n  function Container() {\n    (0, _classCallCheck2.default)(this, Container);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Container, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      var _iterator, _step, member;\n\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator = _createForOfIteratorHelper(this.members);\n              _context.prev = 1;\n\n              _iterator.s();\n\n            case 3:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 9;\n                break;\n              }\n\n              member = _step.value;\n\n              if (!member.validate) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.delegateYield(member.validate(defs), "t0", 7);\n\n            case 7:\n              _context.next = 3;\n              break;\n\n            case 9:\n              _context.next = 14;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t1 = _context["catch"](1);\n\n              _iterator.e(_context.t1);\n\n            case 14:\n              _context.prev = 14;\n\n              _iterator.f();\n\n              return _context.finish(14);\n\n            case 17:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this, [[1, 11, 14, 17]]);\n    })\n  }, {\n    key: "partial",\n    get: function get() {\n      return !!this.tokens.partial;\n    }\n  }, {\n    key: "name",\n    get: function get() {\n      return (0, _helpers.unescape)(this.tokens.name.value);\n    }\n  }, {\n    key: "inheritance",\n    get: function get() {\n      if (!this.tokens.inheritance) {\n        return null;\n      }\n\n      return (0, _helpers.unescape)(this.tokens.inheritance.value);\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @template T\n     * @param {import("../tokeniser.js").Tokeniser} tokeniser\n     * @param {T} instance\n     * @param {*} args\n     */\n    value: function parse(tokeniser, instance, _ref) {\n      var type = _ref.type,\n          inheritable = _ref.inheritable,\n          allowedMembers = _ref.allowedMembers;\n      var _instance = instance,\n          tokens = _instance.tokens;\n      tokens.name = tokeniser.consume("identifier") || tokeniser.error("Missing name in ".concat(instance.type));\n      tokeniser.current = instance;\n      instance = (0, _helpers.autoParenter)(instance);\n\n      if (inheritable) {\n        Object.assign(tokens, inheritance(tokeniser));\n      }\n\n      tokens.open = tokeniser.consume("{") || tokeniser.error("Bodyless ".concat(type));\n      instance.members = [];\n\n      while (true) {\n        tokens.close = tokeniser.consume("}");\n\n        if (tokens.close) {\n          tokens.termination = tokeniser.consume(";") || tokeniser.error("Missing semicolon after ".concat(type));\n          return instance.this;\n        }\n\n        var ea = _extendedAttributes.ExtendedAttributes.parse(tokeniser);\n\n        var mem = void 0;\n\n        var _iterator2 = _createForOfIteratorHelper(allowedMembers),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = (0, _toArray2.default)(_step2.value),\n                parser = _step2$value[0],\n                args = _step2$value.slice(1);\n\n            mem = (0, _helpers.autoParenter)(parser.apply(void 0, [tokeniser].concat((0, _toConsumableArray2.default)(args))));\n\n            if (mem) {\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (!mem) {\n          tokeniser.error("Unknown member");\n        }\n\n        mem.extAttrs = ea;\n        instance.members.push(mem.this);\n      }\n    }\n  }]);\n  return Container;\n}(_base.Base);\n\nexports.Container = Container;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/container.js?')},"./node_modules/webidl2/lib/productions/default.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Default = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Default, _Base);\n\n  var _super = _createSuper(Default);\n\n  (0, _createClass2.default)(Default, null, [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      var assign = tokeniser.consume("=");\n\n      if (!assign) {\n        return null;\n      }\n\n      var def = (0, _helpers.const_value)(tokeniser) || tokeniser.consume("string", "null", "[", "{") || tokeniser.error("No value for default");\n      var expression = [def];\n\n      if (def.type === "[") {\n        var close = tokeniser.consume("]") || tokeniser.error("Default sequence value must be empty");\n        expression.push(close);\n      } else if (def.type === "{") {\n        var _close = tokeniser.consume("}") || tokeniser.error("Default dictionary value must be empty");\n\n        expression.push(_close);\n      }\n\n      return new Default({\n        source: tokeniser.source,\n        tokens: {\n          assign: assign\n        },\n        expression: expression\n      });\n    }\n  }]);\n\n  function Default(_ref) {\n    var _this;\n\n    var source = _ref.source,\n        tokens = _ref.tokens,\n        expression = _ref.expression;\n    (0, _classCallCheck2.default)(this, Default);\n    _this = _super.call(this, {\n      source: source,\n      tokens: tokens\n    });\n    expression.parent = (0, _assertThisInitialized2.default)(_this);\n    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "expression", {\n      value: expression\n    });\n    return _this;\n  }\n\n  (0, _createClass2.default)(Default, [{\n    key: "type",\n    get: function get() {\n      return (0, _helpers.const_data)(this.expression[0]).type;\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      return (0, _helpers.const_data)(this.expression[0]).value;\n    }\n  }, {\n    key: "negative",\n    get: function get() {\n      return (0, _helpers.const_data)(this.expression[0]).negative;\n    }\n  }]);\n  return Default;\n}(_base.Base);\n\nexports.Default = Default;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/default.js?')},"./node_modules/webidl2/lib/productions/dictionary.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Dictionary = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _container = __webpack_require__("./node_modules/webidl2/lib/productions/container.js");\n\nvar _field = __webpack_require__("./node_modules/webidl2/lib/productions/field.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Dictionary = /*#__PURE__*/function (_Container) {\n  (0, _inherits2.default)(Dictionary, _Container);\n\n  var _super = _createSuper(Dictionary);\n\n  function Dictionary() {\n    (0, _classCallCheck2.default)(this, Dictionary);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Dictionary, [{\n    key: "type",\n    get: function get() {\n      return "dictionary";\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     * @param {object} [options]\n     * @param {import("../tokeniser.js").Token} [options.partial]\n     */\n    value: function parse(tokeniser) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          partial = _ref.partial;\n\n      var tokens = {\n        partial: partial\n      };\n      tokens.base = tokeniser.consume("dictionary");\n\n      if (!tokens.base) {\n        return;\n      }\n\n      return _container.Container.parse(tokeniser, new Dictionary({\n        source: tokeniser.source,\n        tokens: tokens\n      }), {\n        type: "dictionary",\n        inheritable: !partial,\n        allowedMembers: [[_field.Field.parse]]\n      });\n    }\n  }]);\n  return Dictionary;\n}(_container.Container);\n\nexports.Dictionary = Dictionary;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/dictionary.js?')},"./node_modules/webidl2/lib/productions/enum.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Enum = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _get2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/get.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nvar _token = __webpack_require__("./node_modules/webidl2/lib/productions/token.js");\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar EnumValue = /*#__PURE__*/function (_Token) {\n  (0, _inherits2.default)(EnumValue, _Token);\n\n  var _super = _createSuper(EnumValue);\n\n  function EnumValue() {\n    (0, _classCallCheck2.default)(this, EnumValue);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(EnumValue, [{\n    key: "type",\n    get: function get() {\n      return "enum-value";\n    }\n  }, {\n    key: "value",\n    get: function get() {\n      return (0, _get2.default)((0, _getPrototypeOf2.default)(EnumValue.prototype), "value", this).slice(1, -1);\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      var value = tokeniser.consume("string");\n\n      if (value) {\n        return new EnumValue({\n          source: tokeniser.source,\n          tokens: {\n            value: value\n          }\n        });\n      }\n    }\n  }]);\n  return EnumValue;\n}(_token.Token);\n\nvar Enum = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Enum, _Base);\n\n  var _super2 = _createSuper(Enum);\n\n  function Enum() {\n    (0, _classCallCheck2.default)(this, Enum);\n    return _super2.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Enum, [{\n    key: "type",\n    get: function get() {\n      return "enum";\n    }\n  }, {\n    key: "name",\n    get: function get() {\n      return (0, _helpers.unescape)(this.tokens.name.value);\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      /** @type {Base["tokens"]} */\n      var tokens = {};\n      tokens.base = tokeniser.consume("enum");\n\n      if (!tokens.base) {\n        return;\n      }\n\n      tokens.name = tokeniser.consume("identifier") || tokeniser.error("No name for enum");\n      var ret = (0, _helpers.autoParenter)(new Enum({\n        source: tokeniser.source,\n        tokens: tokens\n      }));\n      tokeniser.current = ret.this;\n      tokens.open = tokeniser.consume("{") || tokeniser.error("Bodyless enum");\n      ret.values = (0, _helpers.list)(tokeniser, {\n        parser: EnumValue.parse,\n        allowDangler: true,\n        listName: "enumeration"\n      });\n\n      if (tokeniser.probe("string")) {\n        tokeniser.error("No comma between enum values");\n      }\n\n      tokens.close = tokeniser.consume("}") || tokeniser.error("Unexpected value in enum");\n\n      if (!ret.values.length) {\n        tokeniser.error("No value in enum");\n      }\n\n      tokens.termination = tokeniser.consume(";") || tokeniser.error("No semicolon after enum");\n      return ret.this;\n    }\n  }]);\n  return Enum;\n}(_base.Base);\n\nexports.Enum = Enum;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/enum.js?')},"./node_modules/webidl2/lib/productions/extended-attributes.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.ExtendedAttributes = exports.SimpleExtendedAttribute = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/toConsumableArray.js"));\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _arrayBase = __webpack_require__("./node_modules/webidl2/lib/productions/array-base.js");\n\nvar _token = __webpack_require__("./node_modules/webidl2/lib/productions/token.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nvar _error = __webpack_require__("./node_modules/webidl2/lib/error.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n * @param {string} tokenName\n */\nfunction tokens(tokeniser, tokenName) {\n  return (0, _helpers.list)(tokeniser, {\n    parser: _token.Token.parser(tokeniser, tokenName),\n    listName: tokenName + " list"\n  });\n}\n\nvar extAttrValueSyntax = ["identifier", "decimal", "integer", "string"];\n/**\n * This will allow a set of extended attribute values to be parsed.\n * @param {import("../tokeniser").Tokeniser} tokeniser\n */\n\nfunction extAttrListItems(tokeniser) {\n  var _iterator = _createForOfIteratorHelper(extAttrValueSyntax),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var syntax = _step.value;\n      var toks = tokens(tokeniser, syntax);\n\n      if (toks.length) {\n        return toks;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  tokeniser.error("Expected identifiers, strings, decimals, or integers but none found");\n}\n\nvar ExtendedAttributeParameters = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(ExtendedAttributeParameters, _Base);\n\n  var _super = _createSuper(ExtendedAttributeParameters);\n\n  function ExtendedAttributeParameters() {\n    (0, _classCallCheck2.default)(this, ExtendedAttributeParameters);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(ExtendedAttributeParameters, [{\n    key: "rhsIsList",\n    get: function get() {\n      return this.tokens.assign && !this.tokens.secondaryName;\n    }\n  }, {\n    key: "rhsType",\n    get: function get() {\n      if (this.rhsIsList) {\n        return this.list[0].tokens.value.type + "-list";\n      }\n\n      if (this.tokens.secondaryName) {\n        return this.tokens.secondaryName.type;\n      }\n\n      return null;\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      var tokens = {\n        assign: tokeniser.consume("=")\n      };\n      var ret = (0, _helpers.autoParenter)(new ExtendedAttributeParameters({\n        source: tokeniser.source,\n        tokens: tokens\n      }));\n\n      if (tokens.assign) {\n        tokens.secondaryName = tokeniser.consume.apply(tokeniser, extAttrValueSyntax);\n      }\n\n      tokens.open = tokeniser.consume("(");\n\n      if (tokens.open) {\n        ret.list = ret.rhsIsList ? // [Exposed=(Window,Worker)]\n        extAttrListItems(tokeniser) : // [NamedConstructor=Audio(DOMString src)] or [Constructor(DOMString str)]\n        (0, _helpers.argument_list)(tokeniser);\n        tokens.close = tokeniser.consume(")") || tokeniser.error("Unexpected token in extended attribute argument list");\n      } else if (ret.hasRhs && !tokens.secondaryName) {\n        tokeniser.error("No right hand side to extended attribute assignment");\n      }\n\n      return ret.this;\n    }\n  }]);\n  return ExtendedAttributeParameters;\n}(_base.Base);\n\nvar SimpleExtendedAttribute = /*#__PURE__*/function (_Base2) {\n  (0, _inherits2.default)(SimpleExtendedAttribute, _Base2);\n\n  var _super2 = _createSuper(SimpleExtendedAttribute);\n\n  (0, _createClass2.default)(SimpleExtendedAttribute, null, [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      var name = tokeniser.consume("identifier");\n\n      if (name) {\n        return new SimpleExtendedAttribute({\n          source: tokeniser.source,\n          tokens: {\n            name: name\n          },\n          params: ExtendedAttributeParameters.parse(tokeniser)\n        });\n      }\n    }\n  }]);\n\n  function SimpleExtendedAttribute(_ref) {\n    var _this;\n\n    var source = _ref.source,\n        tokens = _ref.tokens,\n        params = _ref.params;\n    (0, _classCallCheck2.default)(this, SimpleExtendedAttribute);\n    _this = _super2.call(this, {\n      source: source,\n      tokens: tokens\n    });\n    params.parent = (0, _assertThisInitialized2.default)(_this);\n    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "params", {\n      value: params\n    });\n    return _this;\n  }\n\n  (0, _createClass2.default)(SimpleExtendedAttribute, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      var message, _iterator2, _step2, arg;\n\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.name === "NoInterfaceObject")) {\n                _context.next = 4;\n                break;\n              }\n\n              message = "`[NoInterfaceObject]` extended attribute is an undesirable feature that may be removed from Web IDL in the future. Refer to the [relevant upstream PR](https://github.com/heycam/webidl/pull/609) for more information.";\n              _context.next = 4;\n              return (0, _error.validationError)(this.tokens.name, this, "no-nointerfaceobject", message, {\n                level: "warning"\n              });\n\n            case 4:\n              _iterator2 = _createForOfIteratorHelper(this.arguments);\n              _context.prev = 5;\n\n              _iterator2.s();\n\n            case 7:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 12;\n                break;\n              }\n\n              arg = _step2.value;\n              return _context.delegateYield(arg.validate(defs), "t0", 10);\n\n            case 10:\n              _context.next = 7;\n              break;\n\n            case 12:\n              _context.next = 17;\n              break;\n\n            case 14:\n              _context.prev = 14;\n              _context.t1 = _context["catch"](5);\n\n              _iterator2.e(_context.t1);\n\n            case 17:\n              _context.prev = 17;\n\n              _iterator2.f();\n\n              return _context.finish(17);\n\n            case 20:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this, [[5, 14, 17, 20]]);\n    })\n  }, {\n    key: "type",\n    get: function get() {\n      return "extended-attribute";\n    }\n  }, {\n    key: "name",\n    get: function get() {\n      return this.tokens.name.value;\n    }\n  }, {\n    key: "rhs",\n    get: function get() {\n      var _this$params = this.params,\n          type = _this$params.rhsType,\n          tokens = _this$params.tokens,\n          list = _this$params.list;\n\n      if (!type) {\n        return null;\n      }\n\n      var value = this.params.rhsIsList ? list : (0, _helpers.unescape)(tokens.secondaryName.value);\n      return {\n        type: type,\n        value: value\n      };\n    }\n  }, {\n    key: "arguments",\n    get: function get() {\n      var _this$params2 = this.params,\n          rhsIsList = _this$params2.rhsIsList,\n          list = _this$params2.list;\n\n      if (!list || rhsIsList) {\n        return [];\n      }\n\n      return list;\n    }\n  }]);\n  return SimpleExtendedAttribute;\n}(_base.Base); // Note: we parse something simpler than the official syntax. It\'s all that ever\n// seems to be used\n\n\nexports.SimpleExtendedAttribute = SimpleExtendedAttribute;\n\nvar ExtendedAttributes = /*#__PURE__*/function (_ArrayBase) {\n  (0, _inherits2.default)(ExtendedAttributes, _ArrayBase);\n\n  var _super3 = _createSuper(ExtendedAttributes);\n\n  function ExtendedAttributes() {\n    (0, _classCallCheck2.default)(this, ExtendedAttributes);\n    return _super3.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(ExtendedAttributes, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      var _iterator3, _step3, extAttr;\n\n      return _regenerator.default.wrap(function validate$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _iterator3 = _createForOfIteratorHelper(this);\n              _context2.prev = 1;\n\n              _iterator3.s();\n\n            case 3:\n              if ((_step3 = _iterator3.n()).done) {\n                _context2.next = 8;\n                break;\n              }\n\n              extAttr = _step3.value;\n              return _context2.delegateYield(extAttr.validate(defs), "t0", 6);\n\n            case 6:\n              _context2.next = 3;\n              break;\n\n            case 8:\n              _context2.next = 13;\n              break;\n\n            case 10:\n              _context2.prev = 10;\n              _context2.t1 = _context2["catch"](1);\n\n              _iterator3.e(_context2.t1);\n\n            case 13:\n              _context2.prev = 13;\n\n              _iterator3.f();\n\n              return _context2.finish(13);\n\n            case 16:\n            case "end":\n              return _context2.stop();\n          }\n        }\n      }, validate, this, [[1, 10, 13, 16]]);\n    })\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      var tokens = {};\n      tokens.open = tokeniser.consume("[");\n      if (!tokens.open) return new ExtendedAttributes({});\n      var ret = new ExtendedAttributes({\n        source: tokeniser.source,\n        tokens: tokens\n      });\n      ret.push.apply(ret, (0, _toConsumableArray2.default)((0, _helpers.list)(tokeniser, {\n        parser: SimpleExtendedAttribute.parse,\n        listName: "extended attribute"\n      })));\n      tokens.close = tokeniser.consume("]") || tokeniser.error("Unexpected closing token of extended attribute");\n\n      if (!ret.length) {\n        tokeniser.error("Found an empty extended attribute");\n      }\n\n      if (tokeniser.probe("[")) {\n        tokeniser.error("Illegal double extended attribute lists, consider merging them");\n      }\n\n      return ret;\n    }\n  }]);\n  return ExtendedAttributes;\n}(_arrayBase.ArrayBase);\n\nexports.ExtendedAttributes = ExtendedAttributes;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/extended-attributes.js?')},"./node_modules/webidl2/lib/productions/field.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Field = void 0;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nvar _extendedAttributes = __webpack_require__("./node_modules/webidl2/lib/productions/extended-attributes.js");\n\nvar _default = __webpack_require__("./node_modules/webidl2/lib/productions/default.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Field = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Field, _Base);\n\n  var _super = _createSuper(Field);\n\n  function Field() {\n    (0, _classCallCheck2.default)(this, Field);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Field, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.idlType.validate(defs), "t0", 1);\n\n            case 1:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this);\n    })\n  }, {\n    key: "type",\n    get: function get() {\n      return "field";\n    }\n  }, {\n    key: "name",\n    get: function get() {\n      return (0, _helpers.unescape)(this.tokens.name.value);\n    }\n  }, {\n    key: "required",\n    get: function get() {\n      return !!this.tokens.required;\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      /** @type {Base["tokens"]} */\n      var tokens = {};\n      var ret = (0, _helpers.autoParenter)(new Field({\n        source: tokeniser.source,\n        tokens: tokens\n      }));\n      ret.extAttrs = _extendedAttributes.ExtendedAttributes.parse(tokeniser);\n      tokens.required = tokeniser.consume("required");\n      ret.idlType = (0, _helpers.type_with_extended_attributes)(tokeniser, "dictionary-type") || tokeniser.error("Dictionary member lacks a type");\n      tokens.name = tokeniser.consume("identifier") || tokeniser.error("Dictionary member lacks a name");\n      ret.default = _default.Default.parse(tokeniser);\n      if (tokens.required && ret.default) tokeniser.error("Required member must not have a default");\n      tokens.termination = tokeniser.consume(";") || tokeniser.error("Unterminated dictionary member, expected `;`");\n      return ret.this;\n    }\n  }]);\n  return Field;\n}(_base.Base);\n\nexports.Field = Field;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/field.js?')},"./node_modules/webidl2/lib/productions/helpers.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.unescape = unescape;\nexports.list = list;\nexports.const_value = const_value;\nexports.const_data = const_data;\nexports.primitive_type = primitive_type;\nexports.argument_list = argument_list;\nexports.type_with_extended_attributes = type_with_extended_attributes;\nexports.return_type = return_type;\nexports.stringifier = stringifier;\nexports.getLastIndentation = getLastIndentation;\nexports.getMemberIndentation = getMemberIndentation;\nexports.autofixAddExposedWindow = autofixAddExposedWindow;\nexports.getFirstToken = getFirstToken;\nexports.findLastIndex = findLastIndex;\nexports.autoParenter = autoParenter;\n\nvar _type = __webpack_require__("./node_modules/webidl2/lib/productions/type.js");\n\nvar _argument = __webpack_require__("./node_modules/webidl2/lib/productions/argument.js");\n\nvar _extendedAttributes = __webpack_require__("./node_modules/webidl2/lib/productions/extended-attributes.js");\n\nvar _operation = __webpack_require__("./node_modules/webidl2/lib/productions/operation.js");\n\nvar _attribute = __webpack_require__("./node_modules/webidl2/lib/productions/attribute.js");\n\nvar _tokeniser = __webpack_require__("./node_modules/webidl2/lib/tokeniser.js");\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @param {string} identifier\n */\nfunction unescape(identifier) {\n  return identifier.startsWith(\'_\') ? identifier.slice(1) : identifier;\n}\n/**\n * Parses comma-separated list\n * @param {import("../tokeniser").Tokeniser} tokeniser\n * @param {object} args\n * @param {Function} args.parser parser function for each item\n * @param {boolean} [args.allowDangler] whether to allow dangling comma\n * @param {string} [args.listName] the name to be shown on error messages\n */\n\n\nfunction list(tokeniser, _ref) {\n  var parser = _ref.parser,\n      allowDangler = _ref.allowDangler,\n      _ref$listName = _ref.listName,\n      listName = _ref$listName === void 0 ? "list" : _ref$listName;\n  var first = parser(tokeniser);\n\n  if (!first) {\n    return [];\n  }\n\n  first.tokens.separator = tokeniser.consume(",");\n  var items = [first];\n\n  while (first.tokens.separator) {\n    var item = parser(tokeniser);\n\n    if (!item) {\n      if (!allowDangler) {\n        tokeniser.error("Trailing comma in ".concat(listName));\n      }\n\n      break;\n    }\n\n    item.tokens.separator = tokeniser.consume(",");\n    items.push(item);\n    if (!item.tokens.separator) break;\n  }\n\n  return items;\n}\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n */\n\n\nfunction const_value(tokeniser) {\n  return tokeniser.consume("true", "false", "Infinity", "-Infinity", "NaN", "decimal", "integer");\n}\n/**\n * @param {object} token\n * @param {string} token.type\n * @param {string} token.value\n */\n\n\nfunction const_data(_ref2) {\n  var type = _ref2.type,\n      value = _ref2.value;\n\n  switch (type) {\n    case "true":\n    case "false":\n      return {\n        type: "boolean",\n        value: type === "true"\n      };\n\n    case "Infinity":\n    case "-Infinity":\n      return {\n        type: "Infinity",\n        negative: type.startsWith("-")\n      };\n\n    case "[":\n      return {\n        type: "sequence",\n        value: []\n      };\n\n    case "{":\n      return {\n        type: "dictionary"\n      };\n\n    case "decimal":\n    case "integer":\n      return {\n        type: "number",\n        value: value\n      };\n\n    case "string":\n      return {\n        type: "string",\n        value: value.slice(1, -1)\n      };\n\n    default:\n      return {\n        type: type\n      };\n  }\n}\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n */\n\n\nfunction primitive_type(tokeniser) {\n  function integer_type() {\n    var prefix = tokeniser.consume("unsigned");\n    var base = tokeniser.consume("short", "long");\n\n    if (base) {\n      var postfix = tokeniser.consume("long");\n      return new _type.Type({\n        source: source,\n        tokens: {\n          prefix: prefix,\n          base: base,\n          postfix: postfix\n        }\n      });\n    }\n\n    if (prefix) tokeniser.error("Failed to parse integer type");\n  }\n\n  function decimal_type() {\n    var prefix = tokeniser.consume("unrestricted");\n    var base = tokeniser.consume("float", "double");\n\n    if (base) {\n      return new _type.Type({\n        source: source,\n        tokens: {\n          prefix: prefix,\n          base: base\n        }\n      });\n    }\n\n    if (prefix) tokeniser.error("Failed to parse float type");\n  }\n\n  var source = tokeniser.source;\n  var num_type = integer_type(tokeniser) || decimal_type(tokeniser);\n  if (num_type) return num_type;\n  var base = tokeniser.consume("boolean", "byte", "octet");\n\n  if (base) {\n    return new _type.Type({\n      source: source,\n      tokens: {\n        base: base\n      }\n    });\n  }\n}\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n */\n\n\nfunction argument_list(tokeniser) {\n  return list(tokeniser, {\n    parser: _argument.Argument.parse,\n    listName: "arguments list"\n  });\n}\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n * @param {string} typeName\n */\n\n\nfunction type_with_extended_attributes(tokeniser, typeName) {\n  var extAttrs = _extendedAttributes.ExtendedAttributes.parse(tokeniser);\n\n  var ret = _type.Type.parse(tokeniser, typeName);\n\n  if (ret) autoParenter(ret).extAttrs = extAttrs;\n  return ret;\n}\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n * @param {string} typeName\n */\n\n\nfunction return_type(tokeniser, typeName) {\n  var typ = _type.Type.parse(tokeniser, typeName || "return-type");\n\n  if (typ) {\n    return typ;\n  }\n\n  var voidToken = tokeniser.consume("void");\n\n  if (voidToken) {\n    var ret = new _type.Type({\n      source: tokeniser.source,\n      tokens: {\n        base: voidToken\n      }\n    });\n    ret.type = "return-type";\n    return ret;\n  }\n}\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n */\n\n\nfunction stringifier(tokeniser) {\n  var special = tokeniser.consume("stringifier");\n  if (!special) return;\n  var member = _attribute.Attribute.parse(tokeniser, {\n    special: special\n  }) || _operation.Operation.parse(tokeniser, {\n    special: special\n  }) || tokeniser.error("Unterminated stringifier");\n  return member;\n}\n/**\n * @param {string} str\n */\n\n\nfunction getLastIndentation(str) {\n  var lines = str.split("\\n"); // the first line visually binds to the preceding token\n\n  if (lines.length) {\n    var match = lines[lines.length - 1].match(/^\\s+/);\n\n    if (match) {\n      return match[0];\n    }\n  }\n\n  return "";\n}\n/**\n * @param {string} parentTrivia\n */\n\n\nfunction getMemberIndentation(parentTrivia) {\n  var indentation = getLastIndentation(parentTrivia);\n  var indentCh = indentation.includes("\\t") ? "\\t" : "  ";\n  return indentation + indentCh;\n}\n/**\n * @param {object} def\n * @param {import("./extended-attributes.js").ExtendedAttributes} def.extAttrs\n */\n\n\nfunction autofixAddExposedWindow(def) {\n  return function () {\n    if (def.extAttrs.length) {\n      var tokeniser = new _tokeniser.Tokeniser("Exposed=Window,");\n\n      var exposed = _extendedAttributes.SimpleExtendedAttribute.parse(tokeniser);\n\n      exposed.tokens.separator = tokeniser.consume(",");\n      var existing = def.extAttrs[0];\n\n      if (!/^\\s/.test(existing.tokens.name.trivia)) {\n        existing.tokens.name.trivia = " ".concat(existing.tokens.name.trivia);\n      }\n\n      def.extAttrs.unshift(exposed);\n    } else {\n      autoParenter(def).extAttrs = _extendedAttributes.ExtendedAttributes.parse(new _tokeniser.Tokeniser("[Exposed=Window]"));\n      var trivia = def.tokens.base.trivia;\n      def.extAttrs.tokens.open.trivia = trivia;\n      def.tokens.base.trivia = "\\n".concat(getLastIndentation(trivia));\n    }\n  };\n}\n/**\n * Get the first syntax token for the given IDL object.\n * @param {*} data\n */\n\n\nfunction getFirstToken(data) {\n  if (data.extAttrs.length) {\n    return data.extAttrs.tokens.open;\n  }\n\n  if (data.type === "operation" && !data.special) {\n    return getFirstToken(data.idlType);\n  }\n\n  var tokens = Object.values(data.tokens).sort(function (x, y) {\n    return x.index - y.index;\n  });\n  return tokens[0];\n}\n/**\n * @template T\n * @param {T[]} array\n * @param {(item: T) => boolean} predicate\n */\n\n\nfunction findLastIndex(array, predicate) {\n  var index = array.slice().reverse().findIndex(predicate);\n\n  if (index === -1) {\n    return index;\n  }\n\n  return array.length - index - 1;\n}\n/**\n * Returns a proxy that auto-assign `parent` field.\n * @template T\n * @param {T} data\n * @param {*} [parent] The object that will be assigned to `parent`.\n *                     If absent, it will be `data` by default.\n * @return {T}\n */\n\n\nfunction autoParenter(data, parent) {\n  if (!parent) {\n    // Defaults to `data` unless specified otherwise.\n    parent = data;\n  }\n\n  if (!data) {\n    // This allows `autoParenter(undefined)` which again allows\n    // `autoParenter(parse())` where the function may return nothing.\n    return data;\n  }\n\n  return new Proxy(data, {\n    get: function get(target, p) {\n      var value = target[p];\n\n      if (Array.isArray(value)) {\n        // Wraps the array so that any added items will also automatically\n        // get their `parent` values.\n        return autoParenter(value, target);\n      }\n\n      return value;\n    },\n    set: function set(target, p, value) {\n      target[p] = value;\n\n      if (!value) {\n        return true;\n      } else if (Array.isArray(value)) {\n        // Assigning an array will add `parent` to its items.\n        var _iterator = _createForOfIteratorHelper(value),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var item = _step.value;\n\n            if (typeof item.parent !== "undefined") {\n              item.parent = parent;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else if (typeof value.parent !== "undefined") {\n        value.parent = parent;\n      }\n\n      return true;\n    }\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/helpers.js?')},"./node_modules/webidl2/lib/productions/includes.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Includes = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Includes = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Includes, _Base);\n\n  var _super = _createSuper(Includes);\n\n  function Includes() {\n    (0, _classCallCheck2.default)(this, Includes);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Includes, [{\n    key: "type",\n    get: function get() {\n      return "includes";\n    }\n  }, {\n    key: "target",\n    get: function get() {\n      return (0, _helpers.unescape)(this.tokens.target.value);\n    }\n  }, {\n    key: "includes",\n    get: function get() {\n      return (0, _helpers.unescape)(this.tokens.mixin.value);\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      var target = tokeniser.consume("identifier");\n\n      if (!target) {\n        return;\n      }\n\n      var tokens = {\n        target: target\n      };\n      tokens.includes = tokeniser.consume("includes");\n\n      if (!tokens.includes) {\n        tokeniser.unconsume(target.index);\n        return;\n      }\n\n      tokens.mixin = tokeniser.consume("identifier") || tokeniser.error("Incomplete includes statement");\n      tokens.termination = tokeniser.consume(";") || tokeniser.error("No terminating ; for includes statement");\n      return new Includes({\n        source: tokeniser.source,\n        tokens: tokens\n      });\n    }\n  }]);\n  return Includes;\n}(_base.Base);\n\nexports.Includes = Includes;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/includes.js?')},"./node_modules/webidl2/lib/productions/interface.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Interface = void 0;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _get2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/get.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _container = __webpack_require__("./node_modules/webidl2/lib/productions/container.js");\n\nvar _attribute = __webpack_require__("./node_modules/webidl2/lib/productions/attribute.js");\n\nvar _operation = __webpack_require__("./node_modules/webidl2/lib/productions/operation.js");\n\nvar _constant = __webpack_require__("./node_modules/webidl2/lib/productions/constant.js");\n\nvar _iterable = __webpack_require__("./node_modules/webidl2/lib/productions/iterable.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nvar _error = __webpack_require__("./node_modules/webidl2/lib/error.js");\n\nvar _interface = __webpack_require__("./node_modules/webidl2/lib/validators/interface.js");\n\nvar _constructor2 = __webpack_require__("./node_modules/webidl2/lib/productions/constructor.js");\n\nvar _tokeniser = __webpack_require__("./node_modules/webidl2/lib/tokeniser.js");\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n */\nfunction static_member(tokeniser) {\n  var special = tokeniser.consume("static");\n  if (!special) return;\n  var member = _attribute.Attribute.parse(tokeniser, {\n    special: special\n  }) || _operation.Operation.parse(tokeniser, {\n    special: special\n  }) || tokeniser.error("No body in static member");\n  return member;\n}\n\nvar Interface = /*#__PURE__*/function (_Container) {\n  (0, _inherits2.default)(Interface, _Container);\n\n  var _super = _createSuper(Interface);\n\n  function Interface() {\n    (0, _classCallCheck2.default)(this, Interface);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Interface, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      var message, oldConstructors, _iterator, _step, _constructor, _message3, isGlobal, namedConstructors, _iterator2, _step2, named, _message, constructors, _iterator3, _step3, _named, _message2;\n\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.extAttrs.validate(defs), "t0", 1);\n\n            case 1:\n              if (!(!this.partial && this.extAttrs.every(function (extAttr) {\n                return extAttr.name !== "Exposed";\n              }) && this.extAttrs.every(function (extAttr) {\n                return extAttr.name !== "NoInterfaceObject";\n              }))) {\n                _context.next = 5;\n                break;\n              }\n\n              message = "Interfaces must have `[Exposed]` extended attribute. To fix, add, for example, `[Exposed=Window]`. Please also consider carefully if your interface should also be exposed in a Worker scope. Refer to the [WebIDL spec section on Exposed](https://heycam.github.io/webidl/#Exposed) for more information.";\n              _context.next = 5;\n              return (0, _error.validationError)(this.tokens.name, this, "require-exposed", message, {\n                autofix: (0, _helpers.autofixAddExposedWindow)(this)\n              });\n\n            case 5:\n              oldConstructors = this.extAttrs.filter(function (extAttr) {\n                return extAttr.name === "Constructor";\n              });\n              _iterator = _createForOfIteratorHelper(oldConstructors);\n              _context.prev = 7;\n\n              _iterator.s();\n\n            case 9:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 16;\n                break;\n              }\n\n              _constructor = _step.value;\n              _message3 = "Constructors should now be represented as a `constructor()` operation on the interface instead of `[Constructor]` extended attribute. Refer to the [WebIDL spec section on constructor operations](https://heycam.github.io/webidl/#idl-constructors) for more information.";\n              _context.next = 14;\n              return (0, _error.validationError)(_constructor.tokens.name, this, "constructor-member", _message3, {\n                autofix: autofixConstructor(this, _constructor)\n              });\n\n            case 14:\n              _context.next = 9;\n              break;\n\n            case 16:\n              _context.next = 21;\n              break;\n\n            case 18:\n              _context.prev = 18;\n              _context.t1 = _context["catch"](7);\n\n              _iterator.e(_context.t1);\n\n            case 21:\n              _context.prev = 21;\n\n              _iterator.f();\n\n              return _context.finish(21);\n\n            case 24:\n              isGlobal = this.extAttrs.some(function (extAttr) {\n                return extAttr.name === "Global";\n              });\n\n              if (!isGlobal) {\n                _context.next = 64;\n                break;\n              }\n\n              namedConstructors = this.extAttrs.filter(function (extAttr) {\n                return extAttr.name === "NamedConstructor";\n              });\n              _iterator2 = _createForOfIteratorHelper(namedConstructors);\n              _context.prev = 28;\n\n              _iterator2.s();\n\n            case 30:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 37;\n                break;\n              }\n\n              named = _step2.value;\n              _message = "Interfaces marked as `[Global]` cannot have named constructors.";\n              _context.next = 35;\n              return (0, _error.validationError)(named.tokens.name, this, "no-constructible-global", _message);\n\n            case 35:\n              _context.next = 30;\n              break;\n\n            case 37:\n              _context.next = 42;\n              break;\n\n            case 39:\n              _context.prev = 39;\n              _context.t2 = _context["catch"](28);\n\n              _iterator2.e(_context.t2);\n\n            case 42:\n              _context.prev = 42;\n\n              _iterator2.f();\n\n              return _context.finish(42);\n\n            case 45:\n              constructors = this.members.filter(function (member) {\n                return member.type === "constructor";\n              });\n              _iterator3 = _createForOfIteratorHelper(constructors);\n              _context.prev = 47;\n\n              _iterator3.s();\n\n            case 49:\n              if ((_step3 = _iterator3.n()).done) {\n                _context.next = 56;\n                break;\n              }\n\n              _named = _step3.value;\n              _message2 = "Interfaces marked as `[Global]` cannot have constructors.";\n              _context.next = 54;\n              return (0, _error.validationError)(_named.tokens.base, this, "no-constructible-global", _message2);\n\n            case 54:\n              _context.next = 49;\n              break;\n\n            case 56:\n              _context.next = 61;\n              break;\n\n            case 58:\n              _context.prev = 58;\n              _context.t3 = _context["catch"](47);\n\n              _iterator3.e(_context.t3);\n\n            case 61:\n              _context.prev = 61;\n\n              _iterator3.f();\n\n              return _context.finish(61);\n\n            case 64:\n              return _context.delegateYield((0, _get2.default)((0, _getPrototypeOf2.default)(Interface.prototype), "validate", this).call(this, defs), "t4", 65);\n\n            case 65:\n              if (this.partial) {\n                _context.next = 67;\n                break;\n              }\n\n              return _context.delegateYield((0, _interface.checkInterfaceMemberDuplication)(defs, this), "t5", 67);\n\n            case 67:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this, [[7, 18, 21, 24], [28, 39, 42, 45], [47, 58, 61, 64]]);\n    })\n  }, {\n    key: "type",\n    get: function get() {\n      return "interface";\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser, base) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref$partial = _ref.partial,\n          partial = _ref$partial === void 0 ? null : _ref$partial;\n\n      var tokens = {\n        partial: partial,\n        base: base\n      };\n      return _container.Container.parse(tokeniser, new Interface({\n        source: tokeniser.source,\n        tokens: tokens\n      }), {\n        type: "interface",\n        inheritable: !partial,\n        allowedMembers: [[_constant.Constant.parse], [_constructor2.Constructor.parse], [static_member], [_helpers.stringifier], [_iterable.IterableLike.parse], [_attribute.Attribute.parse], [_operation.Operation.parse]]\n      });\n    }\n  }]);\n  return Interface;\n}(_container.Container);\n\nexports.Interface = Interface;\n\nfunction autofixConstructor(interfaceDef, constructorExtAttr) {\n  interfaceDef = (0, _helpers.autoParenter)(interfaceDef);\n  return function () {\n    var indentation = (0, _helpers.getLastIndentation)(interfaceDef.extAttrs.tokens.open.trivia);\n    var memberIndent = interfaceDef.members.length ? (0, _helpers.getLastIndentation)((0, _helpers.getFirstToken)(interfaceDef.members[0]).trivia) : (0, _helpers.getMemberIndentation)(indentation);\n\n    var constructorOp = _constructor2.Constructor.parse(new _tokeniser.Tokeniser("\\n".concat(memberIndent, "constructor();")));\n\n    constructorOp.extAttrs = [];\n    (0, _helpers.autoParenter)(constructorOp).arguments = constructorExtAttr.arguments;\n    var existingIndex = (0, _helpers.findLastIndex)(interfaceDef.members, function (m) {\n      return m.type === "constructor";\n    });\n    interfaceDef.members.splice(existingIndex + 1, 0, constructorOp);\n    var close = interfaceDef.tokens.close;\n\n    if (!close.trivia.includes("\\n")) {\n      close.trivia += "\\n".concat(indentation);\n    }\n\n    var _interfaceDef = interfaceDef,\n        extAttrs = _interfaceDef.extAttrs;\n    var index = extAttrs.indexOf(constructorExtAttr);\n    var removed = extAttrs.splice(index, 1);\n\n    if (!extAttrs.length) {\n      extAttrs.tokens.open = extAttrs.tokens.close = undefined;\n    } else if (extAttrs.length === index) {\n      extAttrs[index - 1].tokens.separator = undefined;\n    } else if (!extAttrs[index].tokens.name.trivia.trim()) {\n      extAttrs[index].tokens.name.trivia = removed[0].tokens.name.trivia;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/interface.js?')},"./node_modules/webidl2/lib/productions/iterable.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.IterableLike = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar IterableLike = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(IterableLike, _Base);\n\n  var _super = _createSuper(IterableLike);\n\n  function IterableLike() {\n    (0, _classCallCheck2.default)(this, IterableLike);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(IterableLike, [{\n    key: "type",\n    get: function get() {\n      return this.tokens.base.value;\n    }\n  }, {\n    key: "readonly",\n    get: function get() {\n      return !!this.tokens.readonly;\n    }\n  }, {\n    key: "async",\n    get: function get() {\n      return !!this.tokens.async;\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser.js").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      var start_position = tokeniser.position;\n      var tokens = {};\n      var ret = (0, _helpers.autoParenter)(new IterableLike({\n        source: tokeniser.source,\n        tokens: tokens\n      }));\n      tokens.readonly = tokeniser.consume("readonly");\n\n      if (!tokens.readonly) {\n        tokens.async = tokeniser.consume("async");\n      }\n\n      tokens.base = tokens.readonly ? tokeniser.consume("maplike", "setlike") : tokens.async ? tokeniser.consume("iterable") : tokeniser.consume("iterable", "maplike", "setlike");\n\n      if (!tokens.base) {\n        tokeniser.unconsume(start_position);\n        return;\n      }\n\n      var type = ret.type;\n      var secondTypeRequired = type === "maplike" || ret.async;\n      var secondTypeAllowed = secondTypeRequired || type === "iterable";\n      tokens.open = tokeniser.consume("<") || tokeniser.error("Missing less-than sign `<` in ".concat(type, " declaration"));\n      var first = (0, _helpers.type_with_extended_attributes)(tokeniser) || tokeniser.error("Missing a type argument in ".concat(type, " declaration"));\n      ret.idlType = [first];\n\n      if (secondTypeAllowed) {\n        first.tokens.separator = tokeniser.consume(",");\n\n        if (first.tokens.separator) {\n          ret.idlType.push((0, _helpers.type_with_extended_attributes)(tokeniser));\n        } else if (secondTypeRequired) {\n          tokeniser.error("Missing second type argument in ".concat(type, " declaration"));\n        }\n      }\n\n      tokens.close = tokeniser.consume(">") || tokeniser.error("Missing greater-than sign `>` in ".concat(type, " declaration"));\n      tokens.termination = tokeniser.consume(";") || tokeniser.error("Missing semicolon after ".concat(type, " declaration"));\n      return ret.this;\n    }\n  }]);\n  return IterableLike;\n}(_base.Base);\n\nexports.IterableLike = IterableLike;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/iterable.js?')},"./node_modules/webidl2/lib/productions/mixin.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Mixin = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _container = __webpack_require__("./node_modules/webidl2/lib/productions/container.js");\n\nvar _constant = __webpack_require__("./node_modules/webidl2/lib/productions/constant.js");\n\nvar _attribute = __webpack_require__("./node_modules/webidl2/lib/productions/attribute.js");\n\nvar _operation = __webpack_require__("./node_modules/webidl2/lib/productions/operation.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Mixin = /*#__PURE__*/function (_Container) {\n  (0, _inherits2.default)(Mixin, _Container);\n\n  var _super = _createSuper(Mixin);\n\n  function Mixin() {\n    (0, _classCallCheck2.default)(this, Mixin);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Mixin, [{\n    key: "type",\n    get: function get() {\n      return "interface mixin";\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @typedef {import("../tokeniser.js").Token} Token\n     *\n     * @param {import("../tokeniser.js").Tokeniser} tokeniser\n     * @param {Token} base\n     * @param {object} [options]\n     * @param {Token} [options.partial]\n     */\n    value: function parse(tokeniser, base) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          partial = _ref.partial;\n\n      var tokens = {\n        partial: partial,\n        base: base\n      };\n      tokens.mixin = tokeniser.consume("mixin");\n\n      if (!tokens.mixin) {\n        return;\n      }\n\n      return _container.Container.parse(tokeniser, new Mixin({\n        source: tokeniser.source,\n        tokens: tokens\n      }), {\n        type: "interface mixin",\n        allowedMembers: [[_constant.Constant.parse], [_helpers.stringifier], [_attribute.Attribute.parse, {\n          noInherit: true\n        }], [_operation.Operation.parse, {\n          regular: true\n        }]]\n      });\n    }\n  }]);\n  return Mixin;\n}(_container.Container);\n\nexports.Mixin = Mixin;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/mixin.js?')},"./node_modules/webidl2/lib/productions/namespace.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Namespace = void 0;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _get2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/get.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _container = __webpack_require__("./node_modules/webidl2/lib/productions/container.js");\n\nvar _attribute = __webpack_require__("./node_modules/webidl2/lib/productions/attribute.js");\n\nvar _operation = __webpack_require__("./node_modules/webidl2/lib/productions/operation.js");\n\nvar _error = __webpack_require__("./node_modules/webidl2/lib/error.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Namespace = /*#__PURE__*/function (_Container) {\n  (0, _inherits2.default)(Namespace, _Container);\n\n  var _super = _createSuper(Namespace);\n\n  function Namespace() {\n    (0, _classCallCheck2.default)(this, Namespace);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Namespace, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      var message;\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!this.partial && this.extAttrs.every(function (extAttr) {\n                return extAttr.name !== "Exposed";\n              }))) {\n                _context.next = 4;\n                break;\n              }\n\n              message = "Namespaces must have [Exposed] extended attribute. To fix, add, for example, [Exposed=Window]. Please also consider carefully if your namespace should also be exposed in a Worker scope. Refer to the [WebIDL spec section on Exposed](https://heycam.github.io/webidl/#Exposed) for more information.";\n              _context.next = 4;\n              return (0, _error.validationError)(this.tokens.name, this, "require-exposed", message, {\n                autofix: (0, _helpers.autofixAddExposedWindow)(this)\n              });\n\n            case 4:\n              return _context.delegateYield((0, _get2.default)((0, _getPrototypeOf2.default)(Namespace.prototype), "validate", this).call(this, defs), "t0", 5);\n\n            case 5:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this);\n    })\n  }, {\n    key: "type",\n    get: function get() {\n      return "namespace";\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     * @param {object} [options]\n     * @param {import("../tokeniser.js").Token} [options.partial]\n     */\n    value: function parse(tokeniser) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          partial = _ref.partial;\n\n      var tokens = {\n        partial: partial\n      };\n      tokens.base = tokeniser.consume("namespace");\n\n      if (!tokens.base) {\n        return;\n      }\n\n      return _container.Container.parse(tokeniser, new Namespace({\n        source: tokeniser.source,\n        tokens: tokens\n      }), {\n        type: "namespace",\n        allowedMembers: [[_attribute.Attribute.parse, {\n          noInherit: true,\n          readonly: true\n        }], [_operation.Operation.parse, {\n          regular: true\n        }]]\n      });\n    }\n  }]);\n  return Namespace;\n}(_container.Container);\n\nexports.Namespace = Namespace;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/namespace.js?')},"./node_modules/webidl2/lib/productions/operation.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Operation = void 0;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nvar _error = __webpack_require__("./node_modules/webidl2/lib/error.js");\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Operation = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Operation, _Base);\n\n  var _super = _createSuper(Operation);\n\n  function Operation() {\n    (0, _classCallCheck2.default)(this, Operation);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Operation, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      var message, _iterator, _step, argument;\n\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!this.name && ["", "static"].includes(this.special))) {\n                _context.next = 4;\n                break;\n              }\n\n              message = "Regular or static operations must have both a return type and an identifier.";\n              _context.next = 4;\n              return (0, _error.validationError)(this.tokens.open, this, "incomplete-op", message);\n\n            case 4:\n              if (!this.idlType) {\n                _context.next = 6;\n                break;\n              }\n\n              return _context.delegateYield(this.idlType.validate(defs), "t0", 6);\n\n            case 6:\n              _iterator = _createForOfIteratorHelper(this.arguments);\n              _context.prev = 7;\n\n              _iterator.s();\n\n            case 9:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 14;\n                break;\n              }\n\n              argument = _step.value;\n              return _context.delegateYield(argument.validate(defs), "t1", 12);\n\n            case 12:\n              _context.next = 9;\n              break;\n\n            case 14:\n              _context.next = 19;\n              break;\n\n            case 16:\n              _context.prev = 16;\n              _context.t2 = _context["catch"](7);\n\n              _iterator.e(_context.t2);\n\n            case 19:\n              _context.prev = 19;\n\n              _iterator.f();\n\n              return _context.finish(19);\n\n            case 22:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this, [[7, 16, 19, 22]]);\n    })\n  }, {\n    key: "type",\n    get: function get() {\n      return "operation";\n    }\n  }, {\n    key: "name",\n    get: function get() {\n      var name = this.tokens.name;\n\n      if (!name) {\n        return "";\n      }\n\n      return (0, _helpers.unescape)(name.value);\n    }\n  }, {\n    key: "special",\n    get: function get() {\n      if (!this.tokens.special) {\n        return "";\n      }\n\n      return this.tokens.special.value;\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @typedef {import("../tokeniser.js").Token} Token\n     *\n     * @param {import("../tokeniser.js").Tokeniser} tokeniser\n     * @param {object} [options]\n     * @param {Token} [options.special]\n     * @param {Token} [options.regular]\n     */\n    value: function parse(tokeniser) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          special = _ref.special,\n          regular = _ref.regular;\n\n      var tokens = {\n        special: special\n      };\n      var ret = (0, _helpers.autoParenter)(new Operation({\n        source: tokeniser.source,\n        tokens: tokens\n      }));\n\n      if (special && special.value === "stringifier") {\n        tokens.termination = tokeniser.consume(";");\n\n        if (tokens.termination) {\n          ret.arguments = [];\n          return ret;\n        }\n      }\n\n      if (!special && !regular) {\n        tokens.special = tokeniser.consume("getter", "setter", "deleter");\n      }\n\n      ret.idlType = (0, _helpers.return_type)(tokeniser) || tokeniser.error("Missing return type");\n      tokens.name = tokeniser.consume("identifier", "includes");\n      tokens.open = tokeniser.consume("(") || tokeniser.error("Invalid operation");\n      ret.arguments = (0, _helpers.argument_list)(tokeniser);\n      tokens.close = tokeniser.consume(")") || tokeniser.error("Unterminated operation");\n      tokens.termination = tokeniser.consume(";") || tokeniser.error("Unterminated operation, expected `;`");\n      return ret.this;\n    }\n  }]);\n  return Operation;\n}(_base.Base);\n\nexports.Operation = Operation;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/operation.js?')},"./node_modules/webidl2/lib/productions/token.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Token = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Token = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Token, _Base);\n\n  var _super = _createSuper(Token);\n\n  function Token() {\n    (0, _classCallCheck2.default)(this, Token);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Token, [{\n    key: "value",\n    get: function get() {\n      return (0, _helpers.unescape)(this.tokens.value.value);\n    }\n  }], [{\n    key: "parser",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     * @param {string} type\n     */\n    value: function parser(tokeniser, type) {\n      return function () {\n        var value = tokeniser.consume(type);\n\n        if (value) {\n          return new Token({\n            source: tokeniser.source,\n            tokens: {\n              value: value\n            }\n          });\n        }\n      };\n    }\n  }]);\n  return Token;\n}(_base.Base);\n\nexports.Token = Token;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/token.js?')},"./node_modules/webidl2/lib/productions/type.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Type = void 0;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/toConsumableArray.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nvar _tokeniser = __webpack_require__("./node_modules/webidl2/lib/tokeniser.js");\n\nvar _error = __webpack_require__("./node_modules/webidl2/lib/error.js");\n\nvar _helpers2 = __webpack_require__("./node_modules/webidl2/lib/validators/helpers.js");\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n * @param {string} typeName\n */\nfunction generic_type(tokeniser, typeName) {\n  var base = tokeniser.consume("FrozenArray", "Promise", "sequence", "record");\n\n  if (!base) {\n    return;\n  }\n\n  var ret = (0, _helpers.autoParenter)(new Type({\n    source: tokeniser.source,\n    tokens: {\n      base: base\n    }\n  }));\n  ret.tokens.open = tokeniser.consume("<") || tokeniser.error("No opening bracket after ".concat(base.type));\n\n  switch (base.type) {\n    case "Promise":\n      {\n        if (tokeniser.probe("[")) tokeniser.error("Promise type cannot have extended attribute");\n        var subtype = (0, _helpers.return_type)(tokeniser, typeName) || tokeniser.error("Missing Promise subtype");\n        ret.subtype.push(subtype);\n        break;\n      }\n\n    case "sequence":\n    case "FrozenArray":\n      {\n        var _subtype = (0, _helpers.type_with_extended_attributes)(tokeniser, typeName) || tokeniser.error("Missing ".concat(base.type, " subtype"));\n\n        ret.subtype.push(_subtype);\n        break;\n      }\n\n    case "record":\n      {\n        if (tokeniser.probe("[")) tokeniser.error("Record key cannot have extended attribute");\n        var keyType = tokeniser.consume.apply(tokeniser, (0, _toConsumableArray2.default)(_tokeniser.stringTypes)) || tokeniser.error("Record key must be one of: ".concat(_tokeniser.stringTypes.join(", ")));\n        var keyIdlType = new Type({\n          source: tokeniser.source,\n          tokens: {\n            base: keyType\n          }\n        });\n        keyIdlType.tokens.separator = tokeniser.consume(",") || tokeniser.error("Missing comma after record key type");\n        keyIdlType.type = typeName;\n        var valueType = (0, _helpers.type_with_extended_attributes)(tokeniser, typeName) || tokeniser.error("Error parsing generic type record");\n        ret.subtype.push(keyIdlType, valueType);\n        break;\n      }\n  }\n\n  if (!ret.idlType) tokeniser.error("Error parsing generic type ".concat(base.type));\n  ret.tokens.close = tokeniser.consume(">") || tokeniser.error("Missing closing bracket after ".concat(base.type));\n  return ret.this;\n}\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n */\n\n\nfunction type_suffix(tokeniser, obj) {\n  var nullable = tokeniser.consume("?");\n\n  if (nullable) {\n    obj.tokens.nullable = nullable;\n  }\n\n  if (tokeniser.probe("?")) tokeniser.error("Can\'t nullable more than once");\n}\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n * @param {string} typeName\n */\n\n\nfunction single_type(tokeniser, typeName) {\n  var ret = generic_type(tokeniser, typeName) || (0, _helpers.primitive_type)(tokeniser);\n\n  if (!ret) {\n    var base = tokeniser.consume.apply(tokeniser, ["identifier"].concat((0, _toConsumableArray2.default)(_tokeniser.stringTypes), (0, _toConsumableArray2.default)(_tokeniser.typeNameKeywords)));\n\n    if (!base) {\n      return;\n    }\n\n    ret = new Type({\n      source: tokeniser.source,\n      tokens: {\n        base: base\n      }\n    });\n    if (tokeniser.probe("<")) tokeniser.error("Unsupported generic type ".concat(base.value));\n  }\n\n  if (ret.generic === "Promise" && tokeniser.probe("?")) {\n    tokeniser.error("Promise type cannot be nullable");\n  }\n\n  ret.type = typeName || null;\n  type_suffix(tokeniser, ret);\n  if (ret.nullable && ret.idlType === "any") tokeniser.error("Type `any` cannot be made nullable");\n  return ret;\n}\n/**\n * @param {import("../tokeniser").Tokeniser} tokeniser\n * @param {string} type\n */\n\n\nfunction union_type(tokeniser, type) {\n  var tokens = {};\n  tokens.open = tokeniser.consume("(");\n  if (!tokens.open) return;\n  var ret = (0, _helpers.autoParenter)(new Type({\n    source: tokeniser.source,\n    tokens: tokens\n  }));\n  ret.type = type || null;\n\n  while (true) {\n    var typ = (0, _helpers.type_with_extended_attributes)(tokeniser) || tokeniser.error("No type after open parenthesis or \'or\' in union type");\n    if (typ.idlType === "any") tokeniser.error("Type `any` cannot be included in a union type");\n    if (typ.generic === "Promise") tokeniser.error("Type `Promise` cannot be included in a union type");\n    ret.subtype.push(typ);\n    var or = tokeniser.consume("or");\n\n    if (or) {\n      typ.tokens.separator = or;\n    } else break;\n  }\n\n  if (ret.idlType.length < 2) {\n    tokeniser.error("At least two types are expected in a union type but found less");\n  }\n\n  tokens.close = tokeniser.consume(")") || tokeniser.error("Unterminated union type");\n  type_suffix(tokeniser, ret);\n  return ret.this;\n}\n\nvar Type = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Type, _Base);\n\n  var _super = _createSuper(Type);\n\n  (0, _createClass2.default)(Type, null, [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     * @param {string} typeName\n     */\n    value: function parse(tokeniser, typeName) {\n      return single_type(tokeniser, typeName) || union_type(tokeniser, typeName);\n    }\n  }]);\n\n  function Type(_ref) {\n    var _this;\n\n    var source = _ref.source,\n        tokens = _ref.tokens;\n    (0, _classCallCheck2.default)(this, Type);\n    _this = _super.call(this, {\n      source: source,\n      tokens: tokens\n    });\n    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "subtype", {\n      value: [],\n      writable: true\n    });\n    _this.extAttrs = [];\n    return _this;\n  }\n\n  (0, _createClass2.default)(Type, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      var typedef, target, _ref2, reference, targetToken, message, _iterator, _step, subtype;\n\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              /*\n               * If a union is nullable, its subunions cannot include a dictionary\n               * If not, subunions may include dictionaries if each union is not nullable\n               */\n              typedef = !this.union && defs.unique.get(this.idlType);\n              target = this.union ? this : typedef && typedef.type === "typedef" ? typedef.idlType : undefined;\n\n              if (!(target && this.nullable)) {\n                _context.next = 11;\n                break;\n              }\n\n              // do not allow any dictionary\n              _ref2 = (0, _helpers2.idlTypeIncludesDictionary)(target, defs) || {}, reference = _ref2.reference;\n\n              if (!reference) {\n                _context.next = 9;\n                break;\n              }\n\n              targetToken = (this.union ? reference : this).tokens.base;\n              message = "Nullable union cannot include a dictionary type";\n              _context.next = 9;\n              return (0, _error.validationError)(targetToken, this, "no-nullable-union-dict", message);\n\n            case 9:\n              _context.next = 27;\n              break;\n\n            case 11:\n              // allow some dictionary\n              _iterator = _createForOfIteratorHelper(this.subtype);\n              _context.prev = 12;\n\n              _iterator.s();\n\n            case 14:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 19;\n                break;\n              }\n\n              subtype = _step.value;\n              return _context.delegateYield(subtype.validate(defs), "t0", 17);\n\n            case 17:\n              _context.next = 14;\n              break;\n\n            case 19:\n              _context.next = 24;\n              break;\n\n            case 21:\n              _context.prev = 21;\n              _context.t1 = _context["catch"](12);\n\n              _iterator.e(_context.t1);\n\n            case 24:\n              _context.prev = 24;\n\n              _iterator.f();\n\n              return _context.finish(24);\n\n            case 27:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this, [[12, 21, 24, 27]]);\n    })\n  }, {\n    key: "generic",\n    get: function get() {\n      if (this.subtype.length && this.tokens.base) {\n        return this.tokens.base.value;\n      }\n\n      return "";\n    }\n  }, {\n    key: "nullable",\n    get: function get() {\n      return Boolean(this.tokens.nullable);\n    }\n  }, {\n    key: "union",\n    get: function get() {\n      return Boolean(this.subtype.length) && !this.tokens.base;\n    }\n  }, {\n    key: "idlType",\n    get: function get() {\n      if (this.subtype.length) {\n        return this.subtype;\n      } // Adding prefixes/postfixes for "unrestricted float", etc.\n\n\n      var name = [this.tokens.prefix, this.tokens.base, this.tokens.postfix].filter(function (t) {\n        return t;\n      }).map(function (t) {\n        return t.value;\n      }).join(" ");\n      return (0, _helpers.unescape)(name);\n    }\n  }]);\n  return Type;\n}(_base.Base);\n\nexports.Type = Type;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/type.js?')},"./node_modules/webidl2/lib/productions/typedef.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Typedef = void 0;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _base = __webpack_require__("./node_modules/webidl2/lib/productions/base.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Typedef = /*#__PURE__*/function (_Base) {\n  (0, _inherits2.default)(Typedef, _Base);\n\n  var _super = _createSuper(Typedef);\n\n  function Typedef() {\n    (0, _classCallCheck2.default)(this, Typedef);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Typedef, [{\n    key: "validate",\n    value: /*#__PURE__*/_regenerator.default.mark(function validate(defs) {\n      return _regenerator.default.wrap(function validate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.idlType.validate(defs), "t0", 1);\n\n            case 1:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, validate, this);\n    })\n  }, {\n    key: "type",\n    get: function get() {\n      return "typedef";\n    }\n  }, {\n    key: "name",\n    get: function get() {\n      return (0, _helpers.unescape)(this.tokens.name.value);\n    }\n  }], [{\n    key: "parse",\n\n    /**\n     * @param {import("../tokeniser").Tokeniser} tokeniser\n     */\n    value: function parse(tokeniser) {\n      /** @type {Base["tokens"]} */\n      var tokens = {};\n      var ret = (0, _helpers.autoParenter)(new Typedef({\n        source: tokeniser.source,\n        tokens: tokens\n      }));\n      tokens.base = tokeniser.consume("typedef");\n\n      if (!tokens.base) {\n        return;\n      }\n\n      ret.idlType = (0, _helpers.type_with_extended_attributes)(tokeniser, "typedef-type") || tokeniser.error("Typedef lacks a type");\n      tokens.name = tokeniser.consume("identifier") || tokeniser.error("Typedef lacks a name");\n      tokeniser.current = ret.this;\n      tokens.termination = tokeniser.consume(";") || tokeniser.error("Unterminated typedef, expected `;`");\n      return ret.this;\n    }\n  }]);\n  return Typedef;\n}(_base.Base);\n\nexports.Typedef = Typedef;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/productions/typedef.js?')},"./node_modules/webidl2/lib/tokeniser.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.WebIDLParseError = exports.Tokeniser = exports.argumentNameKeywords = exports.stringTypes = exports.typeNameKeywords = void 0;\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/inherits.js"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/getPrototypeOf.js"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/wrapNativeSuper.js"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"));\n\nvar _error = __webpack_require__("./node_modules/webidl2/lib/error.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\nfunction _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// These regular expressions use the sticky flag so they will only match at\n// the current location (ie. the offset of lastIndex).\nvar tokenRe = {\n  // This expression uses a lookahead assertion to catch false matches\n  // against integers early.\n  "decimal": new RegExp("-?(?=[0-9]*\\\\.|[0-9]+[eE])(([0-9]+\\\\.[0-9]*|[0-9]*\\\\.[0-9]+)([Ee][-+]?[0-9]+)?|[0-9]+[Ee][-+]?[0-9]+)", "y"),\n  "integer": new RegExp("-?(0([Xx][0-9A-Fa-f]+|[0-7]*)|[1-9][0-9]*)", "y"),\n  "identifier": new RegExp("[_-]?[A-Za-z][0-9A-Z_a-z-]*", "y"),\n  "string": new RegExp("\\"[^\\"]*\\"", "y"),\n  "whitespace": new RegExp("[\\\\t\\\\n\\\\r ]+", "y"),\n  "comment": new RegExp("((\\\\/(\\\\/.*|\\\\*([^*]|\\\\*[^/])*\\\\*\\\\/)[\\\\t\\\\n\\\\r ]*)+)", "y"),\n  "other": new RegExp("[^\\\\t\\\\n\\\\r 0-9A-Za-z]", "y")\n};\nvar typeNameKeywords = ["ArrayBuffer", "DataView", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray", "Float32Array", "Float64Array", "any", "object", "symbol"];\nexports.typeNameKeywords = typeNameKeywords;\nvar stringTypes = ["ByteString", "DOMString", "USVString"];\nexports.stringTypes = stringTypes;\nvar argumentNameKeywords = ["async", "attribute", "callback", "const", "constructor", "deleter", "dictionary", "enum", "getter", "includes", "inherit", "interface", "iterable", "maplike", "namespace", "partial", "required", "setlike", "setter", "static", "stringifier", "typedef", "unrestricted"];\nexports.argumentNameKeywords = argumentNameKeywords;\nvar nonRegexTerminals = ["-Infinity", "FrozenArray", "Infinity", "NaN", "Promise", "boolean", "byte", "double", "false", "float", "long", "mixin", "null", "octet", "optional", "or", "readonly", "record", "sequence", "short", "true", "unsigned", "void"].concat(argumentNameKeywords, stringTypes, typeNameKeywords);\nvar punctuations = ["(", ")", ",", "...", ":", ";", "<", "=", ">", "?", "[", "]", "{", "}"];\nvar reserved = [// "constructor" is now a keyword\n"_constructor", "toString", "_toString"];\n/**\n * @typedef {ArrayItemType<ReturnType<typeof tokenise>>} Token\n * @param {string} str\n */\n\nfunction tokenise(str) {\n  var tokens = [];\n  var lastCharIndex = 0;\n  var trivia = "";\n  var line = 1;\n  var index = 0;\n\n  while (lastCharIndex < str.length) {\n    var nextChar = str.charAt(lastCharIndex);\n    var result = -1;\n\n    if (/[\\t\\n\\r ]/.test(nextChar)) {\n      result = attemptTokenMatch("whitespace", {\n        noFlushTrivia: true\n      });\n    } else if (nextChar === \'/\') {\n      result = attemptTokenMatch("comment", {\n        noFlushTrivia: true\n      });\n    }\n\n    if (result !== -1) {\n      var currentTrivia = tokens.pop().value;\n      line += (currentTrivia.match(/\\n/g) || []).length;\n      trivia += currentTrivia;\n      index -= 1;\n    } else if (/[-0-9.A-Z_a-z]/.test(nextChar)) {\n      result = attemptTokenMatch("decimal");\n\n      if (result === -1) {\n        result = attemptTokenMatch("integer");\n      }\n\n      if (result === -1) {\n        result = attemptTokenMatch("identifier");\n        var lastIndex = tokens.length - 1;\n        var token = tokens[lastIndex];\n\n        if (result !== -1) {\n          if (reserved.includes(token.value)) {\n            var message = "".concat((0, _helpers.unescape)(token.value), " is a reserved identifier and must not be used.");\n            throw new WebIDLParseError((0, _error.syntaxError)(tokens, lastIndex, null, message));\n          } else if (nonRegexTerminals.includes(token.value)) {\n            token.type = token.value;\n          }\n        }\n      }\n    } else if (nextChar === \'"\') {\n      result = attemptTokenMatch("string");\n    }\n\n    var _iterator = _createForOfIteratorHelper(punctuations),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var punctuation = _step.value;\n\n        if (str.startsWith(punctuation, lastCharIndex)) {\n          tokens.push({\n            type: punctuation,\n            value: punctuation,\n            trivia: trivia,\n            line: line,\n            index: index\n          });\n          trivia = "";\n          lastCharIndex += punctuation.length;\n          result = lastCharIndex;\n          break;\n        }\n      } // other as the last try\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (result === -1) {\n      result = attemptTokenMatch("other");\n    }\n\n    if (result === -1) {\n      throw new Error("Token stream not progressing");\n    }\n\n    lastCharIndex = result;\n    index += 1;\n  } // remaining trivia as eof\n\n\n  tokens.push({\n    type: "eof",\n    value: "",\n    trivia: trivia\n  });\n  return tokens;\n  /**\n   * @param {keyof typeof tokenRe} type\n   * @param {object} options\n   * @param {boolean} [options.noFlushTrivia]\n   */\n\n  function attemptTokenMatch(type) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        noFlushTrivia = _ref.noFlushTrivia;\n\n    var re = tokenRe[type];\n    re.lastIndex = lastCharIndex;\n    var result = re.exec(str);\n\n    if (result) {\n      tokens.push({\n        type: type,\n        value: result[0],\n        trivia: trivia,\n        line: line,\n        index: index\n      });\n\n      if (!noFlushTrivia) {\n        trivia = "";\n      }\n\n      return re.lastIndex;\n    }\n\n    return -1;\n  }\n}\n\nvar Tokeniser = /*#__PURE__*/function () {\n  /**\n   * @param {string} idl\n   */\n  function Tokeniser(idl) {\n    (0, _classCallCheck2.default)(this, Tokeniser);\n    this.source = tokenise(idl);\n    this.position = 0;\n  }\n  /**\n   * @param {string} message\n   * @return {never}\n   */\n\n\n  (0, _createClass2.default)(Tokeniser, [{\n    key: "error",\n    value: function error(message) {\n      throw new WebIDLParseError((0, _error.syntaxError)(this.source, this.position, this.current, message));\n    }\n    /**\n     * @param {string} type\n     */\n\n  }, {\n    key: "probe",\n    value: function probe(type) {\n      return this.source.length > this.position && this.source[this.position].type === type;\n    }\n    /**\n     * @param  {...string} candidates\n     */\n\n  }, {\n    key: "consume",\n    value: function consume() {\n      for (var _len = arguments.length, candidates = new Array(_len), _key = 0; _key < _len; _key++) {\n        candidates[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _candidates = candidates; _i < _candidates.length; _i++) {\n        var type = _candidates[_i];\n        if (!this.probe(type)) continue;\n        var token = this.source[this.position];\n        this.position++;\n        return token;\n      }\n    }\n    /**\n     * @param {number} position\n     */\n\n  }, {\n    key: "unconsume",\n    value: function unconsume(position) {\n      this.position = position;\n    }\n  }]);\n  return Tokeniser;\n}();\n\nexports.Tokeniser = Tokeniser;\n\nvar WebIDLParseError = /*#__PURE__*/function (_Error) {\n  (0, _inherits2.default)(WebIDLParseError, _Error);\n\n  var _super = _createSuper(WebIDLParseError);\n\n  /**\n   * @param {object} options\n   * @param {string} options.message\n   * @param {string} options.bareMessage\n   * @param {string} options.context\n   * @param {number} options.line\n   * @param {*} options.sourceName\n   * @param {string} options.input\n   * @param {*[]} options.tokens\n   */\n  function WebIDLParseError(_ref2) {\n    var _this;\n\n    var message = _ref2.message,\n        bareMessage = _ref2.bareMessage,\n        context = _ref2.context,\n        line = _ref2.line,\n        sourceName = _ref2.sourceName,\n        input = _ref2.input,\n        tokens = _ref2.tokens;\n    (0, _classCallCheck2.default)(this, WebIDLParseError);\n    _this = _super.call(this, message);\n    _this.name = "WebIDLParseError"; // not to be mangled\n\n    _this.bareMessage = bareMessage;\n    _this.context = context;\n    _this.line = line;\n    _this.sourceName = sourceName;\n    _this.input = input;\n    _this.tokens = tokens;\n    return _this;\n  }\n\n  return WebIDLParseError;\n}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));\n\nexports.WebIDLParseError = WebIDLParseError;\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/tokeniser.js?')},"./node_modules/webidl2/lib/validator.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.validate = validate;\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/toConsumableArray.js"));\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _error = __webpack_require__("./node_modules/webidl2/lib/error.js");\n\nvar _marked = /*#__PURE__*/_regenerator.default.mark(checkDuplicatedNames),\n    _marked2 = /*#__PURE__*/_regenerator.default.mark(validateIterable);\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction getMixinMap(all, unique) {\n  var map = new Map();\n  var includes = all.filter(function (def) {\n    return def.type === "includes";\n  });\n\n  var _iterator = _createForOfIteratorHelper(includes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var include = _step.value;\n      var mixin = unique.get(include.includes);\n\n      if (!mixin) {\n        continue;\n      }\n\n      var array = map.get(include.target);\n\n      if (array) {\n        array.push(mixin);\n      } else {\n        map.set(include.target, [mixin]);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return map;\n}\n/**\n * @typedef {ReturnType<typeof groupDefinitions>} Definitions\n */\n\n\nfunction groupDefinitions(all) {\n  var unique = new Map();\n  var duplicates = new Set();\n  var partials = new Map();\n\n  var _iterator2 = _createForOfIteratorHelper(all),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var def = _step2.value;\n\n      if (def.partial) {\n        var array = partials.get(def.name);\n\n        if (array) {\n          array.push(def);\n        } else {\n          partials.set(def.name, [def]);\n        }\n\n        continue;\n      }\n\n      if (!def.name) {\n        continue;\n      }\n\n      if (!unique.has(def.name)) {\n        unique.set(def.name, def);\n      } else {\n        duplicates.add(def);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return {\n    all: all,\n    unique: unique,\n    partials: partials,\n    duplicates: duplicates,\n    mixinMap: getMixinMap(all, unique),\n    cache: {\n      typedefIncludesDictionary: new WeakMap(),\n      dictionaryIncludesRequiredField: new WeakMap()\n    }\n  };\n}\n\nfunction checkDuplicatedNames(_ref) {\n  var unique, duplicates, _iterator3, _step3, dup, name, message;\n\n  return _regenerator.default.wrap(function checkDuplicatedNames$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          unique = _ref.unique, duplicates = _ref.duplicates;\n          _iterator3 = _createForOfIteratorHelper(duplicates);\n          _context.prev = 2;\n\n          _iterator3.s();\n\n        case 4:\n          if ((_step3 = _iterator3.n()).done) {\n            _context.next = 12;\n            break;\n          }\n\n          dup = _step3.value;\n          name = dup.name;\n          message = "The name \\"".concat(name, "\\" of type \\"").concat(unique.get(name).type, "\\" was already seen");\n          _context.next = 10;\n          return (0, _error.validationError)(dup.tokens.name, dup, "no-duplicate", message);\n\n        case 10:\n          _context.next = 4;\n          break;\n\n        case 12:\n          _context.next = 17;\n          break;\n\n        case 14:\n          _context.prev = 14;\n          _context.t0 = _context["catch"](2);\n\n          _iterator3.e(_context.t0);\n\n        case 17:\n          _context.prev = 17;\n\n          _iterator3.f();\n\n          return _context.finish(17);\n\n        case 20:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[2, 14, 17, 20]]);\n}\n\nfunction validateIterable(ast) {\n  var defs, _iterator4, _step4, def;\n\n  return _regenerator.default.wrap(function validateIterable$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          defs = groupDefinitions(ast);\n          _iterator4 = _createForOfIteratorHelper(defs.all);\n          _context2.prev = 2;\n\n          _iterator4.s();\n\n        case 4:\n          if ((_step4 = _iterator4.n()).done) {\n            _context2.next = 10;\n            break;\n          }\n\n          def = _step4.value;\n\n          if (!def.validate) {\n            _context2.next = 8;\n            break;\n          }\n\n          return _context2.delegateYield(def.validate(defs), "t0", 8);\n\n        case 8:\n          _context2.next = 4;\n          break;\n\n        case 10:\n          _context2.next = 15;\n          break;\n\n        case 12:\n          _context2.prev = 12;\n          _context2.t1 = _context2["catch"](2);\n\n          _iterator4.e(_context2.t1);\n\n        case 15:\n          _context2.prev = 15;\n\n          _iterator4.f();\n\n          return _context2.finish(15);\n\n        case 18:\n          return _context2.delegateYield(checkDuplicatedNames(defs), "t2", 19);\n\n        case 19:\n        case "end":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[2, 12, 15, 18]]);\n} // Remove this once all of our support targets expose `.flat()` by default\n\n\nfunction flatten(array) {\n  var _ref2;\n\n  if (array.flat) {\n    return array.flat();\n  }\n\n  return (_ref2 = []).concat.apply(_ref2, (0, _toConsumableArray2.default)(array));\n}\n/**\n * @param {*} ast AST or array of ASTs\n */\n\n\nfunction validate(ast) {\n  return (0, _toConsumableArray2.default)(validateIterable(flatten(ast)));\n}\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/validator.js?')},"./node_modules/webidl2/lib/validators/helpers.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.idlTypeIncludesDictionary = idlTypeIncludesDictionary;\nexports.dictionaryIncludesRequiredField = dictionaryIncludesRequiredField;\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// @ts-check\n\n/**\n * @typedef {import("../productions/dictionary.js").Dictionary} Dictionary\n *\n * @param {*} idlType\n * @param {import("../validator.js").Definitions} defs\n * @param {object} [options]\n * @param {boolean} [options.useNullableInner] use when the input idlType is nullable and you want to use its inner type\n * @return {{ reference: *, dictionary: Dictionary }} the type reference that ultimately includes dictionary.\n */\nfunction idlTypeIncludesDictionary(idlType, defs) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      useNullableInner = _ref.useNullableInner;\n\n  if (!idlType.union) {\n    var def = defs.unique.get(idlType.idlType);\n\n    if (!def) {\n      return;\n    }\n\n    if (def.type === "typedef") {\n      var typedefIncludesDictionary = defs.cache.typedefIncludesDictionary;\n\n      if (typedefIncludesDictionary.has(def)) {\n        // Note that this also halts when it met indeterminate state\n        // to prevent infinite recursion\n        return typedefIncludesDictionary.get(def);\n      }\n\n      defs.cache.typedefIncludesDictionary.set(def, undefined); // indeterminate state\n\n      var result = idlTypeIncludesDictionary(def.idlType, defs);\n      defs.cache.typedefIncludesDictionary.set(def, result);\n\n      if (result) {\n        return {\n          reference: idlType,\n          dictionary: result.dictionary\n        };\n      }\n    }\n\n    if (def.type === "dictionary" && (useNullableInner || !idlType.nullable)) {\n      return {\n        reference: idlType,\n        dictionary: def\n      };\n    }\n  }\n\n  var _iterator = _createForOfIteratorHelper(idlType.subtype),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var subtype = _step.value;\n\n      var _result = idlTypeIncludesDictionary(subtype, defs);\n\n      if (_result) {\n        if (subtype.union) {\n          return _result;\n        }\n\n        return {\n          reference: subtype,\n          dictionary: _result.dictionary\n        };\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n/**\n * @param {*} dict dictionary type\n * @param {import("../validator.js").Definitions} defs\n * @return {boolean}\n */\n\n\nfunction dictionaryIncludesRequiredField(dict, defs) {\n  if (defs.cache.dictionaryIncludesRequiredField.has(dict)) {\n    return defs.cache.dictionaryIncludesRequiredField.get(dict);\n  }\n\n  defs.cache.dictionaryIncludesRequiredField.set(dict, undefined); // indeterminate\n\n  if (dict.inheritance) {\n    var superdict = defs.unique.get(dict.inheritance);\n\n    if (!superdict) {\n      return true;\n    }\n\n    if (dictionaryIncludesRequiredField(superdict, defs)) {\n      return true;\n    }\n  }\n\n  var result = dict.members.some(function (field) {\n    return field.required;\n  });\n  defs.cache.dictionaryIncludesRequiredField.set(dict, result);\n  return result;\n}\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/validators/helpers.js?')},"./node_modules/webidl2/lib/validators/interface.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.checkInterfaceMemberDuplication = checkInterfaceMemberDuplication;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/regenerator/index.js"));\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/toConsumableArray.js"));\n\nvar _error = __webpack_require__("./node_modules/webidl2/lib/error.js");\n\nvar _marked2 = /*#__PURE__*/_regenerator.default.mark(checkInterfaceMemberDuplication);\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction checkInterfaceMemberDuplication(defs, i) {\n  var _marked, opNames, partials, mixins, _i, _arr, ext, additions, _iterator, _step, addition, forEachExtension, getOperations;\n\n  return _regenerator.default.wrap(function checkInterfaceMemberDuplication$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          getOperations = function _getOperations(i) {\n            return i.members.filter(function (_ref) {\n              var type = _ref.type;\n              return type === "operation";\n            });\n          };\n\n          forEachExtension = function _forEachExtension(additions, existings, ext, base) {\n            var _iterator2, _step2, _addition, name, message;\n\n            return _regenerator.default.wrap(function forEachExtension$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _iterator2 = _createForOfIteratorHelper(additions);\n                    _context.prev = 1;\n\n                    _iterator2.s();\n\n                  case 3:\n                    if ((_step2 = _iterator2.n()).done) {\n                      _context.next = 12;\n                      break;\n                    }\n\n                    _addition = _step2.value;\n                    name = _addition.name;\n\n                    if (!(name && existings.has(name))) {\n                      _context.next = 10;\n                      break;\n                    }\n\n                    message = "The operation \\"".concat(name, "\\" has already been defined for the base interface \\"").concat(base.name, "\\" either in itself or in a mixin");\n                    _context.next = 10;\n                    return (0, _error.validationError)(_addition.tokens.name, ext, "no-cross-overload", message);\n\n                  case 10:\n                    _context.next = 3;\n                    break;\n\n                  case 12:\n                    _context.next = 17;\n                    break;\n\n                  case 14:\n                    _context.prev = 14;\n                    _context.t0 = _context["catch"](1);\n\n                    _iterator2.e(_context.t0);\n\n                  case 17:\n                    _context.prev = 17;\n\n                    _iterator2.f();\n\n                    return _context.finish(17);\n\n                  case 20:\n                  case "end":\n                    return _context.stop();\n                }\n              }\n            }, _marked, null, [[1, 14, 17, 20]]);\n          };\n\n          _marked = /*#__PURE__*/_regenerator.default.mark(forEachExtension);\n          opNames = new Set(getOperations(i).map(function (op) {\n            return op.name;\n          }));\n          partials = defs.partials.get(i.name) || [];\n          mixins = defs.mixinMap.get(i.name) || [];\n          _i = 0, _arr = [].concat((0, _toConsumableArray2.default)(partials), (0, _toConsumableArray2.default)(mixins));\n\n        case 7:\n          if (!(_i < _arr.length)) {\n            _context2.next = 16;\n            break;\n          }\n\n          ext = _arr[_i];\n          additions = getOperations(ext);\n          return _context2.delegateYield(forEachExtension(additions, opNames, ext, i), "t0", 11);\n\n        case 11:\n          _iterator = _createForOfIteratorHelper(additions);\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              addition = _step.value;\n              opNames.add(addition.name);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n        case 13:\n          _i++;\n          _context2.next = 7;\n          break;\n\n        case 16:\n        case "end":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/validators/interface.js?')},"./node_modules/webidl2/lib/webidl2.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.parse = parse;\n\nvar _tokeniser = __webpack_require__("./node_modules/webidl2/lib/tokeniser.js");\n\nvar _enum = __webpack_require__("./node_modules/webidl2/lib/productions/enum.js");\n\nvar _includes = __webpack_require__("./node_modules/webidl2/lib/productions/includes.js");\n\nvar _extendedAttributes = __webpack_require__("./node_modules/webidl2/lib/productions/extended-attributes.js");\n\nvar _typedef = __webpack_require__("./node_modules/webidl2/lib/productions/typedef.js");\n\nvar _callback = __webpack_require__("./node_modules/webidl2/lib/productions/callback.js");\n\nvar _interface = __webpack_require__("./node_modules/webidl2/lib/productions/interface.js");\n\nvar _mixin = __webpack_require__("./node_modules/webidl2/lib/productions/mixin.js");\n\nvar _dictionary = __webpack_require__("./node_modules/webidl2/lib/productions/dictionary.js");\n\nvar _namespace = __webpack_require__("./node_modules/webidl2/lib/productions/namespace.js");\n\nvar _callbackInterface = __webpack_require__("./node_modules/webidl2/lib/productions/callback-interface.js");\n\nvar _helpers = __webpack_require__("./node_modules/webidl2/lib/productions/helpers.js");\n\n/**\n * @param {Tokeniser} tokeniser\n * @param {object} options\n * @param {boolean} [options.concrete]\n */\nfunction parseByTokens(tokeniser, options) {\n  var source = tokeniser.source;\n\n  function error(str) {\n    tokeniser.error(str);\n  }\n\n  function consume() {\n    return tokeniser.consume.apply(tokeniser, arguments);\n  }\n\n  function callback() {\n    var callback = consume("callback");\n    if (!callback) return;\n\n    if (tokeniser.probe("interface")) {\n      return _callbackInterface.CallbackInterface.parse(tokeniser, callback);\n    }\n\n    return _callback.CallbackFunction.parse(tokeniser, callback);\n  }\n\n  function interface_(opts) {\n    var base = consume("interface");\n    if (!base) return;\n    var ret = _mixin.Mixin.parse(tokeniser, base, opts) || _interface.Interface.parse(tokeniser, base, opts) || error("Interface has no proper body");\n    return ret;\n  }\n\n  function partial() {\n    var partial = consume("partial");\n    if (!partial) return;\n    return _dictionary.Dictionary.parse(tokeniser, {\n      partial: partial\n    }) || interface_({\n      partial: partial\n    }) || _namespace.Namespace.parse(tokeniser, {\n      partial: partial\n    }) || error("Partial doesn\'t apply to anything");\n  }\n\n  function definition() {\n    return callback() || interface_() || partial() || _dictionary.Dictionary.parse(tokeniser) || _enum.Enum.parse(tokeniser) || _typedef.Typedef.parse(tokeniser) || _includes.Includes.parse(tokeniser) || _namespace.Namespace.parse(tokeniser);\n  }\n\n  function definitions() {\n    if (!source.length) return [];\n    var defs = [];\n\n    while (true) {\n      var ea = _extendedAttributes.ExtendedAttributes.parse(tokeniser);\n\n      var def = definition();\n\n      if (!def) {\n        if (ea.length) error("Stray extended attributes");\n        break;\n      }\n\n      (0, _helpers.autoParenter)(def).extAttrs = ea;\n      defs.push(def);\n    }\n\n    var eof = consume("eof");\n\n    if (options.concrete) {\n      defs.push(eof);\n    }\n\n    return defs;\n  }\n\n  var res = definitions();\n  if (tokeniser.position < source.length) error("Unrecognised tokens");\n  return res;\n}\n/**\n * @param {string} str\n * @param {object} [options]\n * @param {*} [options.sourceName]\n * @param {boolean} [options.concrete]\n */\n\n\nfunction parse(str) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var tokeniser = new _tokeniser.Tokeniser(str);\n\n  if (typeof options.sourceName !== "undefined") {\n    tokeniser.source.name = options.sourceName;\n  }\n\n  return parseByTokens(tokeniser, options);\n}\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/webidl2.js?')},"./node_modules/webidl2/lib/writer.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _interopRequireDefault = __webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.write = write;\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__("./node_modules/@babel/runtime/helpers/toConsumableArray.js"));\n\nfunction noop(arg) {\n  return arg;\n}\n\nvar templates = {\n  wrap: function wrap(items) {\n    return items.join("");\n  },\n  trivia: noop,\n  name: noop,\n  reference: noop,\n  type: noop,\n  generic: noop,\n  nameless: noop,\n  inheritance: noop,\n  definition: noop,\n  extendedAttribute: noop,\n  extendedAttributeReference: noop\n};\n\nfunction write(ast) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$templates = _ref.templates,\n      ts = _ref$templates === void 0 ? templates : _ref$templates;\n\n  ts = Object.assign({}, templates, ts);\n\n  function reference(raw, _ref2) {\n    var unescaped = _ref2.unescaped,\n        context = _ref2.context;\n\n    if (!unescaped) {\n      unescaped = raw.startsWith("_") ? raw.slice(1) : raw;\n    }\n\n    return ts.reference(raw, unescaped, context);\n  }\n\n  function token(t) {\n    var wrapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\n    if (!t) {\n      return "";\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    var value = wrapper.apply(void 0, [t.value].concat(args));\n    return ts.wrap([ts.trivia(t.trivia), value]);\n  }\n\n  function reference_token(t, context) {\n    return token(t, reference, {\n      context: context\n    });\n  }\n\n  function name_token(t, arg) {\n    return token(t, ts.name, arg);\n  }\n\n  function type_body(it) {\n    if (it.union || it.generic) {\n      return ts.wrap([token(it.tokens.base, ts.generic), token(it.tokens.open)].concat((0, _toConsumableArray2.default)(it.subtype.map(type)), [token(it.tokens.close)]));\n    }\n\n    var firstToken = it.tokens.prefix || it.tokens.base;\n    var prefix = it.tokens.prefix ? [it.tokens.prefix.value, ts.trivia(it.tokens.base.trivia)] : [];\n    var ref = reference(ts.wrap([].concat(prefix, [it.tokens.base.value, token(it.tokens.postfix)])), {\n      unescaped: it.idlType,\n      context: it\n    });\n    return ts.wrap([ts.trivia(firstToken.trivia), ref]);\n  }\n\n  function type(it) {\n    return ts.wrap([extended_attributes(it.extAttrs), type_body(it), token(it.tokens.nullable), token(it.tokens.separator)]);\n  }\n\n  function default_(def) {\n    if (!def) {\n      return "";\n    }\n\n    return ts.wrap([token(def.tokens.assign)].concat((0, _toConsumableArray2.default)(def.expression.map(function (t) {\n      return token(t);\n    }))));\n  }\n\n  function argument(arg) {\n    return ts.wrap([extended_attributes(arg.extAttrs), token(arg.tokens.optional), ts.type(type(arg.idlType)), token(arg.tokens.variadic), name_token(arg.tokens.name, {\n      data: arg\n    }), default_(arg.default), token(arg.tokens.separator)]);\n  }\n\n  function extended_attribute_listitem(str) {\n    return ts.wrap([token(str.tokens.value), token(str.tokens.separator)]);\n  }\n\n  function identifier(id, context) {\n    return ts.wrap([reference_token(id.tokens.value, context), token(id.tokens.separator)]);\n  }\n\n  function make_ext_at(it) {\n    var rhsType = it.params.rhsType;\n    return ts.wrap([ts.trivia(it.tokens.name.trivia), ts.extendedAttribute(ts.wrap([ts.extendedAttributeReference(it.name), token(it.params.tokens.assign), reference_token(it.params.tokens.secondaryName, it), token(it.params.tokens.open)].concat((0, _toConsumableArray2.default)(!it.params.list ? [] : it.params.list.map(rhsType === "identifier-list" ? function (id) {\n      return identifier(id, it);\n    } : rhsType && rhsType.endsWith("-list") ? extended_attribute_listitem : argument)), [token(it.params.tokens.close)]))), token(it.tokens.separator)]);\n  }\n\n  function extended_attributes(eats) {\n    if (!eats.length) return "";\n    return ts.wrap([token(eats.tokens.open)].concat((0, _toConsumableArray2.default)(eats.map(make_ext_at)), [token(eats.tokens.close)]));\n  }\n\n  function operation(it, parent) {\n    var body = it.idlType ? [ts.type(type(it.idlType)), name_token(it.tokens.name, {\n      data: it,\n      parent: parent\n    }), token(it.tokens.open), ts.wrap(it.arguments.map(argument)), token(it.tokens.close)] : [];\n    return ts.definition(ts.wrap([extended_attributes(it.extAttrs), it.tokens.name ? token(it.tokens.special) : token(it.tokens.special, ts.nameless, {\n      data: it,\n      parent: parent\n    })].concat(body, [token(it.tokens.termination)])), {\n      data: it,\n      parent: parent\n    });\n  }\n\n  function attribute(it, parent) {\n    return ts.definition(ts.wrap([extended_attributes(it.extAttrs), token(it.tokens.special), token(it.tokens.readonly), token(it.tokens.base), ts.type(type(it.idlType)), name_token(it.tokens.name, {\n      data: it,\n      parent: parent\n    }), token(it.tokens.termination)]), {\n      data: it,\n      parent: parent\n    });\n  }\n\n  function constructor(it, parent) {\n    return ts.definition(ts.wrap([extended_attributes(it.extAttrs), token(it.tokens.base, ts.nameless, {\n      data: it,\n      parent: parent\n    }), token(it.tokens.open), ts.wrap(it.arguments.map(argument)), token(it.tokens.close), token(it.tokens.termination)]), {\n      data: it,\n      parent: parent\n    });\n  }\n\n  function inheritance(inh) {\n    if (!inh.tokens.inheritance) {\n      return "";\n    }\n\n    return ts.wrap([token(inh.tokens.colon), ts.trivia(inh.tokens.inheritance.trivia), ts.inheritance(reference(inh.tokens.inheritance.value, {\n      context: inh\n    }))]);\n  }\n\n  function container(it) {\n    return ts.definition(ts.wrap([extended_attributes(it.extAttrs), token(it.tokens.callback), token(it.tokens.partial), token(it.tokens.base), token(it.tokens.mixin), name_token(it.tokens.name, {\n      data: it\n    }), inheritance(it), token(it.tokens.open), iterate(it.members, it), token(it.tokens.close), token(it.tokens.termination)]), {\n      data: it\n    });\n  }\n\n  function field(it, parent) {\n    return ts.definition(ts.wrap([extended_attributes(it.extAttrs), token(it.tokens.required), ts.type(type(it.idlType)), name_token(it.tokens.name, {\n      data: it,\n      parent: parent\n    }), default_(it.default), token(it.tokens.termination)]), {\n      data: it,\n      parent: parent\n    });\n  }\n\n  function const_(it, parent) {\n    return ts.definition(ts.wrap([extended_attributes(it.extAttrs), token(it.tokens.base), ts.type(type(it.idlType)), name_token(it.tokens.name, {\n      data: it,\n      parent: parent\n    }), token(it.tokens.assign), token(it.tokens.value), token(it.tokens.termination)]), {\n      data: it,\n      parent: parent\n    });\n  }\n\n  function typedef(it) {\n    return ts.definition(ts.wrap([extended_attributes(it.extAttrs), token(it.tokens.base), ts.type(type(it.idlType)), name_token(it.tokens.name, {\n      data: it\n    }), token(it.tokens.termination)]), {\n      data: it\n    });\n  }\n\n  function includes(it) {\n    return ts.definition(ts.wrap([extended_attributes(it.extAttrs), reference_token(it.tokens.target, it), token(it.tokens.includes), reference_token(it.tokens.mixin, it), token(it.tokens.termination)]), {\n      data: it\n    });\n  }\n\n  function callback(it) {\n    return ts.definition(ts.wrap([extended_attributes(it.extAttrs), token(it.tokens.base), name_token(it.tokens.name, {\n      data: it\n    }), token(it.tokens.assign), ts.type(type(it.idlType)), token(it.tokens.open)].concat((0, _toConsumableArray2.default)(it.arguments.map(argument)), [token(it.tokens.close), token(it.tokens.termination)])), {\n      data: it\n    });\n  }\n\n  function enum_(it) {\n    return ts.definition(ts.wrap([extended_attributes(it.extAttrs), token(it.tokens.base), name_token(it.tokens.name, {\n      data: it\n    }), token(it.tokens.open), iterate(it.values, it), token(it.tokens.close), token(it.tokens.termination)]), {\n      data: it\n    });\n  }\n\n  function enum_value(v, parent) {\n    return ts.wrap([ts.trivia(v.tokens.value.trivia), ts.definition(ts.wrap([\'"\', ts.name(v.value, {\n      data: v,\n      parent: parent\n    }), \'"\']), {\n      data: v,\n      parent: parent\n    }), token(v.tokens.separator)]);\n  }\n\n  function iterable_like(it, parent) {\n    return ts.definition(ts.wrap([extended_attributes(it.extAttrs), token(it.tokens.readonly), token(it.tokens.async), token(it.tokens.base, ts.generic), token(it.tokens.open), ts.wrap(it.idlType.map(type)), token(it.tokens.close), token(it.tokens.termination)]), {\n      data: it,\n      parent: parent\n    });\n  }\n\n  function eof(it) {\n    return ts.trivia(it.trivia);\n  }\n\n  var table = {\n    interface: container,\n    "interface mixin": container,\n    namespace: container,\n    operation: operation,\n    attribute: attribute,\n    constructor: constructor,\n    dictionary: container,\n    field: field,\n    const: const_,\n    typedef: typedef,\n    includes: includes,\n    callback: callback,\n    enum: enum_,\n    "enum-value": enum_value,\n    iterable: iterable_like,\n    maplike: iterable_like,\n    setlike: iterable_like,\n    "callback interface": container,\n    eof: eof\n  };\n\n  function dispatch(it, parent) {\n    var dispatcher = table[it.type];\n\n    if (!dispatcher) {\n      throw new Error("Type \\"".concat(it.type, "\\" is unsupported"));\n    }\n\n    return table[it.type](it, parent);\n  }\n\n  function iterate(things, parent) {\n    if (!things) return;\n    var results = things.map(function (thing) {\n      return dispatch(thing, parent);\n    });\n    return ts.wrap(results);\n  }\n\n  return iterate(ast);\n}\n\n//# sourceURL=webpack:///./node_modules/webidl2/lib/writer.js?')}}]);